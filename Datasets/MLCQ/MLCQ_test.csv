,code,smell
447,"    public synchronized void setNotificationRegistration(final String token) {
        // Get the NotificationRegistrationManager from the platform
        ConnectedDevicesNotificationRegistrationManager registrationManager = mPlatform.getNotificationRegistrationManager();

        // Create a NotificationRegistration obect to store all notification information
        ConnectedDevicesNotificationRegistration registration = new ConnectedDevicesNotificationRegistration();
        registration.setType(ConnectedDevicesNotificationType.FCM);
        registration.setToken(token);
        registration.setAppId(Secrets.FCM_SENDER_ID);
        registration.setAppDisplayName(""GraphNotificationsSample"");

        Log.i(TAG, ""Completing the RomeNotificationReceiver operation with token: "" + token);

        // For each prepared account, register for notifications
        for (final Account account : mAccounts) {
            registrationManager.registerForAccountAsync(account.getAccount(), registration)
                    .whenCompleteAsync((Boolean success, Throwable throwable) -> {
                        if (throwable != null) {
                            Log.e(TAG, ""Exception encountered in registerForAccountAsync"", throwable);
                        } else if (!success) {
                            Log.e(TAG, ""Failed to register account "" + account.getAccount().getId() + "" for cloud notifications!"");
                        } else {
                            Log.i(TAG, ""Successfully registered account "" + account.getAccount().getId() + "" for cloud notifications"");
                        }
                    });
        }

        // The two cases of receiving a new notification token are:
        // 1. A notification registration is asked for and now it is available. In this case there is a pending promise that was made
        //    at the time of requesting the information. It now needs to be completed.
        // 2. The account is already registered but for whatever reason the registration changes (GCM/FCM gives the app a new token)
        //
        // In order to most cleanly handle both cases set the new notification information and then trigger a re registration of all accounts
        // that are in good standing.
        RomeNotificationReceiver.setNotificationRegistration(registration);

        // For all the accounts which have been prepared successfully, perform SDK registration
        for (Account account : mAccounts) {
            if (account.getRegistrationState() == AccountRegistrationState.IN_APP_CACHE_AND_SDK_CACHE) {
                account.registerAccountWithSdkAsync();
            }
        }
    }
",feature envy
421,"    NativeKeyHolder(P11Key p11Key, long keyID, Session keySession,
            boolean extractKeyInfo, boolean isTokenObject) {
        this.p11Key = p11Key;
        this.keyID = keyID;
        this.refCount = -1;
        byte[] ki = null;
        if (isTokenObject) {
            this.ref = null;
        } else {
            this.ref = new SessionKeyRef(p11Key, keyID, keySession);

            // Try extracting key info, if any error, disable it
            Token token = p11Key.token;
            if (extractKeyInfo) {
                try {
                    if (p11Key.sensitive && nativeKeyWrapperKeyID == 0) {
                        synchronized(NativeKeyHolder.class) {
                            // Create a global wrapping/unwrapping key
                            CK_ATTRIBUTE[] wrappingAttributes = token.getAttributes
                                (O_GENERATE, CKO_SECRET_KEY, CKK_AES, new CK_ATTRIBUTE[] {
                                    new CK_ATTRIBUTE(CKA_CLASS, CKO_SECRET_KEY),
                                    new CK_ATTRIBUTE(CKA_VALUE_LEN, 256 >> 3),
                                });
                            Session wrappingSession = null;
                            try {
                                wrappingSession = token.getObjSession();
                                nativeKeyWrapperKeyID = token.p11.C_GenerateKey
                                    (wrappingSession.id(),
                                    new CK_MECHANISM(CKM_AES_KEY_GEN),
                                    wrappingAttributes);
                                byte[] iv = new byte[16];
                                JCAUtil.getSecureRandom().nextBytes(iv);
                                nativeKeyWrapperMechanism = new CK_MECHANISM
                                    (CKM_AES_CBC_PAD, iv);
                            } catch (PKCS11Exception e) {
                                // best effort
                            } finally {
                                token.releaseSession(wrappingSession);
                            }
                        }
                    }
                    Session opSession = null;
                    try {
                        opSession = token.getOpSession();
                        ki = p11Key.token.p11.getNativeKeyInfo(opSession.id(),
                            keyID, nativeKeyWrapperKeyID, nativeKeyWrapperMechanism);
                    } catch (PKCS11Exception e) {
                        // best effort
                    } finally {
                        token.releaseSession(opSession);
                    }
                } catch (PKCS11Exception e) {
                    // best effort
                }
            }
        }
        this.nativeKeyInfo = ((ki == null || ki.length == 0)? null : ki);
    }
",long method
303,"        public int specialStateTransition(int s, IntStream _input) throws NoViableAltException {
            TokenStream input = (TokenStream)_input;
        	int _s = s;
            switch ( s ) {
                    case 0 : 
                        int LA60_0 = input.LA(1);

                         
                        int index60_0 = input.index();
                        input.rewind();
                        s = -1;
                        if ( (LA60_0==RULE_ID) ) {s = 1;}

                        else if ( (LA60_0==14) ) {s = 2;}

                        else if ( (LA60_0==39) && (synpred33_InternalXbaseWithAnnotations())) {s = 3;}

                        else if ( ((LA60_0>=RULE_STRING && LA60_0<=RULE_DECIMAL)||(LA60_0>=18 && LA60_0<=19)||LA60_0==26||(LA60_0>=42 && LA60_0<=43)||LA60_0==48||LA60_0==55||LA60_0==59||LA60_0==61||(LA60_0>=65 && LA60_0<=67)||(LA60_0>=70 && LA60_0<=82)||LA60_0==84) ) {s = 4;}

                         
                        input.seek(index60_0);
                        if ( s>=0 ) return s;
                        break;
                    case 1 : 
                        int LA60_1 = input.LA(1);

                         
                        int index60_1 = input.index();
                        input.rewind();
                        s = -1;
                        if ( (synpred33_InternalXbaseWithAnnotations()) ) {s = 3;}

                        else if ( (true) ) {s = 4;}

                         
                        input.seek(index60_1);
                        if ( s>=0 ) return s;
                        break;
                    case 2 : 
                        int LA60_2 = input.LA(1);

                         
                        int index60_2 = input.index();
                        input.rewind();
                        s = -1;
                        if ( (synpred33_InternalXbaseWithAnnotations()) ) {s = 3;}

                        else if ( (true) ) {s = 4;}

                         
                        input.seek(index60_2);
                        if ( s>=0 ) return s;
                        break;
            }
            if (state.backtracking>0) {state.failed=true; return -1;}
            NoViableAltException nvae =
                new NoViableAltException(getDescription(), 60, _s, input);
            error(nvae);
            throw nvae;
        }
",long method
1072,"    public int next()
    {
      final int startNode = _startNode;
      if (_startNode == NULL) {
        return NULL;
      }

      int node = _currentNode;

      int expType;
      final int nodeType = _nodeType;

      if (nodeType != DTM.ELEMENT_NODE)
      {
        do
        {
          node++;
	  expType = _exptype2(node);

          if (NULL == expType || _parent2(node) < startNode && startNode != node) {
            _currentNode = NULL;
            return END;
          }
        }
        while (expType != nodeType);
      }
      // %OPT% If the start node is root (e.g. in the case of //node),
      // we can save the isDescendant() check, because all nodes are
      // descendants of root.
      else if (startNode == DTMDefaultBase.ROOTNODE)
      {
	do
	{
	  node++;
	  expType = _exptype2(node);

	  if (NULL == expType) {
	    _currentNode = NULL;
	    return END;
	  }
	} while (expType < DTM.NTYPES
	        || m_extendedTypes[expType].getNodeType() != DTM.ELEMENT_NODE);
      }
      else
      {
        do
        {
          node++;
	  expType = _exptype2(node);

          if (NULL == expType || _parent2(node) < startNode && startNode != node) {
            _currentNode = NULL;
            return END;
          }
        }
        while (expType < DTM.NTYPES
	       || m_extendedTypes[expType].getNodeType() != DTM.ELEMENT_NODE);
      }

      _currentNode = node;
      return returnNode(makeNodeHandle(node));
    }
",long method
373,"@Document
public class Customer extends AbstractDocument {

	private String firstname, lastname;

	@Field(""email"")
	@Indexed(unique = true)
	private EmailAddress emailAddress;
	private Set<Address> addresses = new HashSet<Address>();

	/**
	 * Creates a new {@link Customer} from the given firstname and lastname.
	 * 
	 * @param firstname must not be {@literal null} or empty.
	 * @param lastname must not be {@literal null} or empty.
	 */
	public Customer(String firstname, String lastname) {

		Assert.hasText(firstname);
		Assert.hasText(lastname);

		this.firstname = firstname;
		this.lastname = lastname;
	}

	protected Customer() {

	}

	/**
	 * Adds the given {@link Address} to the {@link Customer}.
	 * 
	 * @param address must not be {@literal null}.
	 */
	public void add(Address address) {

		Assert.notNull(address);
		this.addresses.add(address);
	}

	/**
	 * Returns the firstname of the {@link Customer}.
	 * 
	 * @return
	 */
	public String getFirstname() {
		return firstname;
	}

	/**
	 * Returns the lastname of the {@link Customer}.
	 * 
	 * @return
	 */
	public String getLastname() {
		return lastname;
	}

	/**
	 * Sets the lastname of the {@link Customer}.
	 * 
	 * @param lastname
	 */
	public void setLastname(String lastname) {
		this.lastname = lastname;
	}

	/**
	 * Returns the {@link EmailAddress} of the {@link Customer}.
	 * 
	 * @return
	 */
	public EmailAddress getEmailAddress() {
		return emailAddress;
	}

	/**
	 * Sets the {@link Customer}'s {@link EmailAddress}.
	 * 
	 * @param emailAddress must not be {@literal null}.
	 */
	public void setEmailAddress(EmailAddress emailAddress) {
		this.emailAddress = emailAddress;
	}

	/**
	 * Return the {@link Customer}'s addresses.
	 * 
	 * @return
	 */
	public Set<Address> getAddresses() {
		return Collections.unmodifiableSet(addresses);
	}
}
",data class
166,"@Singleton
public class StandardComponentInitializer {

  public static final String NAVIGATE_TO_FILE = ""navigateToFile"";
  public static final String FULL_TEXT_SEARCH = ""fullTextSearch"";
  public static final String PREVIEW_IMAGE = ""previewImage"";
  public static final String FIND_ACTION = ""findAction"";
  public static final String FORMAT = ""format"";
  public static final String SAVE = ""save"";
  public static final String COPY = ""copy"";
  public static final String CUT = ""cut"";
  public static final String PASTE = ""paste"";
  public static final String UNDO = ""undo"";
  public static final String REDO = ""redo"";
  public static final String SWITCH_LEFT_TAB = ""switchLeftTab"";
  public static final String SWITCH_RIGHT_TAB = ""switchRightTab"";
  public static final String OPEN_RECENT_FILES = ""openRecentFiles"";
  public static final String DELETE_ITEM = ""deleteItem"";
  public static final String NEW_FILE = ""newFile"";
  public static final String CREATE_PROJECT = ""createProject"";
  public static final String IMPORT_PROJECT = ""importProject"";
  public static final String CLOSE_ACTIVE_EDITOR = ""closeActiveEditor"";
  public static final String SIGNATURE_HELP = ""signatureHelp"";
  public static final String SOFT_WRAP = ""softWrap"";
  public static final String RENAME = ""renameResource"";
  public static final String SHOW_REFERENCE = ""showReference"";
  public static final String SHOW_COMMANDS_PALETTE = ""showCommandsPalette"";
  public static final String NEW_TERMINAL = ""newTerminal"";
  public static final String OPEN_IN_TERMINAL = ""openInTerminal"";
  public static final String PROJECT_EXPLORER_DISPLAYING_MODE = ""projectExplorerDisplayingMode"";
  public static final String COMMAND_EXPLORER_DISPLAYING_MODE = ""commandExplorerDisplayingMode"";
  public static final String FIND_RESULT_DISPLAYING_MODE = ""findResultDisplayingMode"";
  public static final String EVENT_LOGS_DISPLAYING_MODE = ""eventLogsDisplayingMode"";
  public static final String EDITOR_DISPLAYING_MODE = ""editorDisplayingMode"";
  public static final String TERMINAL_DISPLAYING_MODE = ""terminalDisplayingMode"";
  public static final String REVEAL_RESOURCE = ""revealResourceInProjectTree"";
  public static final String COLLAPSE_ALL = ""collapseAll"";

  public interface ParserResource extends ClientBundle {
    @Source(""org/eclipse/che/ide/blank.svg"")
    SVGResource samplesCategoryBlank();
  }

  @Inject private EditorRegistry editorRegistry;

  @Inject private FileTypeRegistry fileTypeRegistry;

  @Inject private Resources resources;

  @Inject private KeyBindingAgent keyBinding;

  @Inject private ActionManager actionManager;

  @Inject private SaveAction saveAction;

  @Inject private SaveAllAction saveAllAction;

  @Inject private ShowPreferencesAction showPreferencesAction;

  @Inject private PreviewImageAction previewImageAction;

  @Inject private FindActionAction findActionAction;

  @Inject private NavigateToFileAction navigateToFileAction;

  @Inject @MainToolbar private ToolbarPresenter toolbarPresenter;

  @Inject private CutResourceAction cutResourceAction;

  @Inject private CopyResourceAction copyResourceAction;

  @Inject private PasteResourceAction pasteResourceAction;

  @Inject private DeleteResourceAction deleteResourceAction;

  @Inject private RenameItemAction renameItemAction;

  @Inject private SplitVerticallyAction splitVerticallyAction;

  @Inject private SplitHorizontallyAction splitHorizontallyAction;

  @Inject private CloseAction closeAction;

  @Inject private CloseAllAction closeAllAction;

  @Inject private CloseOtherAction closeOtherAction;

  @Inject private CloseAllExceptPinnedAction closeAllExceptPinnedAction;

  @Inject private ReopenClosedFileAction reopenClosedFileAction;

  @Inject private PinEditorTabAction pinEditorTabAction;

  @Inject private GoIntoAction goIntoAction;

  @Inject private EditFileAction editFileAction;

  @Inject private OpenFileAction openFileAction;

  @Inject private ShowHiddenFilesAction showHiddenFilesAction;

  @Inject private FormatterAction formatterAction;

  @Inject private UndoAction undoAction;

  @Inject private RedoAction redoAction;

  @Inject private UploadFileAction uploadFileAction;

  @Inject private UploadFolderAction uploadFolderAction;

  @Inject private DownloadProjectAction downloadProjectAction;

  @Inject private DownloadWsAction downloadWsAction;

  @Inject private DownloadResourceAction downloadResourceAction;

  @Inject private ImportProjectAction importProjectAction;

  @Inject private CreateProjectAction createProjectAction;

  @Inject private ConvertFolderToProjectAction convertFolderToProjectAction;

  @Inject private FullTextSearchAction fullTextSearchAction;

  @Inject private NewFolderAction newFolderAction;

  @Inject private NewFileAction newFileAction;

  @Inject private NewXmlFileAction newXmlFileAction;

  @Inject private ImageViewerProvider imageViewerProvider;

  @Inject private ProjectConfigurationAction projectConfigurationAction;

  @Inject private ExpandEditorAction expandEditorAction;

  @Inject private CompleteAction completeAction;

  @Inject private SwitchPreviousEditorAction switchPreviousEditorAction;

  @Inject private SwitchNextEditorAction switchNextEditorAction;

  @Inject private HotKeysListAction hotKeysListAction;

  @Inject private OpenRecentFilesAction openRecentFilesAction;

  @Inject private ClearRecentListAction clearRecentFilesAction;

  @Inject private CloseActiveEditorAction closeActiveEditorAction;

  @Inject private MessageLoaderResources messageLoaderResources;

  @Inject private EditorResources editorResources;

  @Inject private PopupResources popupResources;

  @Inject private ShowReferenceAction showReferenceAction;

  @Inject private RevealResourceAction revealResourceAction;

  @Inject private RefreshPathAction refreshPathAction;

  @Inject private LinkWithEditorAction linkWithEditorAction;

  @Inject private ShowToolbarAction showToolbarAction;

  @Inject private SignatureHelpAction signatureHelpAction;

  @Inject private MaximizePartAction maximizePartAction;

  @Inject private HidePartAction hidePartAction;

  @Inject private RestorePartAction restorePartAction;

  @Inject private ShowCommandsPaletteAction showCommandsPaletteAction;

  @Inject private SoftWrapAction softWrapAction;

  @Inject private StartWorkspaceAction startWorkspaceAction;

  @Inject private StopWorkspaceAction stopWorkspaceAction;

  @Inject private ShowWorkspaceStatusAction showWorkspaceStatusAction;

  @Inject private ShowRuntimeInfoAction showRuntimeInfoAction;

  @Inject private RunCommandAction runCommandAction;

  @Inject private NewTerminalAction newTerminalAction;

  @Inject private ReRunProcessAction reRunProcessAction;

  @Inject private StopProcessAction stopProcessAction;

  @Inject private CloseConsoleAction closeConsoleAction;

  @Inject private DisplayMachineOutputAction displayMachineOutputAction;

  @Inject private PreviewSSHAction previewSSHAction;

  @Inject private ShowConsoleTreeAction showConsoleTreeAction;

  @Inject private AddToFileWatcherExcludesAction addToFileWatcherExcludesAction;

  @Inject private RemoveFromFileWatcherExcludesAction removeFromFileWatcherExcludesAction;

  @Inject private DevModeSetUpAction devModeSetUpAction;

  @Inject private DevModeOffAction devModeOffAction;

  @Inject private CollapseAllAction collapseAllAction;

  @Inject private PerspectiveManager perspectiveManager;

  @Inject private CommandsExplorerDisplayingModeAction commandsExplorerDisplayingModeAction;

  @Inject private ProjectExplorerDisplayingModeAction projectExplorerDisplayingModeAction;

  @Inject private EventLogsDisplayingModeAction eventLogsDisplayingModeAction;

  @Inject private FindResultDisplayingModeAction findResultDisplayingModeAction;

  @Inject private EditorDisplayingModeAction editorDisplayingModeAction;

  @Inject private TerminalDisplayingModeAction terminalDisplayingModeAction;

  @Inject private RenameCommandAction renameCommandAction;

  @Inject private MoveCommandAction moveCommandAction;

  @Inject private OpenInTerminalAction openInTerminalAction;

  @Inject private FreeDiskSpaceStatusBarAction freeDiskSpaceStatusBarAction;

  @Inject
  @Named(""XMLFileType"")
  private FileType xmlFile;

  @Inject
  @Named(""TXTFileType"")
  private FileType txtFile;

  @Inject
  @Named(""JsonFileType"")
  private FileType jsonFile;

  @Inject
  @Named(""MDFileType"")
  private FileType mdFile;

  @Inject
  @Named(""PNGFileType"")
  private FileType pngFile;

  @Inject
  @Named(""BMPFileType"")
  private FileType bmpFile;

  @Inject
  @Named(""GIFFileType"")
  private FileType gifFile;

  @Inject
  @Named(""ICOFileType"")
  private FileType iconFile;

  @Inject
  @Named(""SVGFileType"")
  private FileType svgFile;

  @Inject
  @Named(""JPEFileType"")
  private FileType jpeFile;

  @Inject
  @Named(""JPEGFileType"")
  private FileType jpegFile;

  @Inject
  @Named(""JPGFileType"")
  private FileType jpgFile;

  @Inject private CommandEditorProvider commandEditorProvider;

  @Inject
  @Named(""CommandFileType"")
  private FileType commandFileType;

  @Inject private ProjectConfigSynchronized projectConfigSynchronized;

  @Inject private TreeResourceRevealer treeResourceRevealer; // just to work with it

  @Inject private TerminalInitializer terminalInitializer;

  /** Instantiates {@link StandardComponentInitializer} an creates standard content. */
  @Inject
  public StandardComponentInitializer(
      IconRegistry iconRegistry,
      MachineResources machineResources,
      StandardComponentInitializer.ParserResource parserResource) {
    iconRegistry.registerIcon(
        new Icon(BLANK_CATEGORY + "".samples.category.icon"", parserResource.samplesCategoryBlank()));
    iconRegistry.registerIcon(new Icon(""che.machine.icon"", machineResources.devMachine()));
    machineResources.getCss().ensureInjected();
  }

  public void initialize() {
    messageLoaderResources.Css().ensureInjected();
    editorResources.editorCss().ensureInjected();
    popupResources.popupStyle().ensureInjected();

    fileTypeRegistry.registerFileType(xmlFile);

    fileTypeRegistry.registerFileType(txtFile);

    fileTypeRegistry.registerFileType(jsonFile);

    fileTypeRegistry.registerFileType(mdFile);

    fileTypeRegistry.registerFileType(pngFile);
    editorRegistry.registerDefaultEditor(pngFile, imageViewerProvider);

    fileTypeRegistry.registerFileType(bmpFile);
    editorRegistry.registerDefaultEditor(bmpFile, imageViewerProvider);

    fileTypeRegistry.registerFileType(gifFile);
    editorRegistry.registerDefaultEditor(gifFile, imageViewerProvider);

    fileTypeRegistry.registerFileType(iconFile);
    editorRegistry.registerDefaultEditor(iconFile, imageViewerProvider);

    fileTypeRegistry.registerFileType(svgFile);
    editorRegistry.registerDefaultEditor(svgFile, imageViewerProvider);

    fileTypeRegistry.registerFileType(jpeFile);
    editorRegistry.registerDefaultEditor(jpeFile, imageViewerProvider);

    fileTypeRegistry.registerFileType(jpegFile);
    editorRegistry.registerDefaultEditor(jpegFile, imageViewerProvider);

    fileTypeRegistry.registerFileType(jpgFile);
    editorRegistry.registerDefaultEditor(jpgFile, imageViewerProvider);

    fileTypeRegistry.registerFileType(commandFileType);
    editorRegistry.registerDefaultEditor(commandFileType, commandEditorProvider);

    // Workspace (New Menu)
    DefaultActionGroup workspaceGroup =
        (DefaultActionGroup) actionManager.getAction(GROUP_WORKSPACE);

    actionManager.registerAction(IMPORT_PROJECT, importProjectAction);
    workspaceGroup.add(importProjectAction);

    actionManager.registerAction(CREATE_PROJECT, createProjectAction);
    workspaceGroup.add(createProjectAction);

    actionManager.registerAction(""downloadWsAsZipAction"", downloadWsAction);
    workspaceGroup.add(downloadWsAction);

    workspaceGroup.addSeparator();
    workspaceGroup.add(startWorkspaceAction);
    workspaceGroup.add(stopWorkspaceAction);
    workspaceGroup.add(showWorkspaceStatusAction);

    // Project (New Menu)
    DefaultActionGroup projectGroup = (DefaultActionGroup) actionManager.getAction(GROUP_PROJECT);

    DefaultActionGroup newGroup = new DefaultActionGroup(""New"", true, actionManager);
    newGroup.getTemplatePresentation().setDescription(""Create..."");
    newGroup
        .getTemplatePresentation()
        .setImageElement(new SVGImage(resources.newResource()).getElement());
    actionManager.registerAction(GROUP_FILE_NEW, newGroup);
    projectGroup.add(newGroup);

    newGroup.addSeparator();

    actionManager.registerAction(NEW_FILE, newFileAction);
    newGroup.addAction(newFileAction, Constraints.FIRST);

    actionManager.registerAction(""newFolder"", newFolderAction);
    newGroup.addAction(newFolderAction, new Constraints(AFTER, NEW_FILE));

    newGroup.addSeparator();

    actionManager.registerAction(""newXmlFile"", newXmlFileAction);
    newXmlFileAction
        .getTemplatePresentation()
        .setImageElement(new SVGImage(xmlFile.getImage()).getElement());
    newGroup.addAction(newXmlFileAction);

    actionManager.registerAction(""uploadFile"", uploadFileAction);
    projectGroup.add(uploadFileAction);

    actionManager.registerAction(""uploadFolder"", uploadFolderAction);
    projectGroup.add(uploadFolderAction);

    actionManager.registerAction(""convertFolderToProject"", convertFolderToProjectAction);
    projectGroup.add(convertFolderToProjectAction);

    actionManager.registerAction(""downloadAsZipAction"", downloadProjectAction);
    projectGroup.add(downloadProjectAction);

    actionManager.registerAction(""showHideHiddenFiles"", showHiddenFilesAction);
    projectGroup.add(showHiddenFilesAction);

    projectGroup.addSeparator();

    actionManager.registerAction(""projectConfiguration"", projectConfigurationAction);
    projectGroup.add(projectConfigurationAction);

    DefaultActionGroup saveGroup = new DefaultActionGroup(actionManager);
    actionManager.registerAction(""saveGroup"", saveGroup);
    actionManager.registerAction(SAVE, saveAction);
    saveGroup.addSeparator();
    saveGroup.add(saveAction);

    // Edit (New Menu)
    DefaultActionGroup editGroup = (DefaultActionGroup) actionManager.getAction(GROUP_EDIT);
    DefaultActionGroup recentGroup = new DefaultActionGroup(RECENT_GROUP_ID, true, actionManager);
    actionManager.registerAction(GROUP_RECENT_FILES, recentGroup);
    actionManager.registerAction(""clearRecentList"", clearRecentFilesAction);
    recentGroup.addSeparator();
    recentGroup.add(clearRecentFilesAction, LAST);
    editGroup.add(recentGroup);
    actionManager.registerAction(OPEN_RECENT_FILES, openRecentFilesAction);
    editGroup.add(openRecentFilesAction);

    actionManager.registerAction(CLOSE_ACTIVE_EDITOR, closeActiveEditorAction);
    editGroup.add(closeActiveEditorAction);

    actionManager.registerAction(FORMAT, formatterAction);
    editGroup.add(formatterAction);

    editGroup.add(saveAction);

    actionManager.registerAction(UNDO, undoAction);
    editGroup.add(undoAction);

    actionManager.registerAction(REDO, redoAction);
    editGroup.add(redoAction);

    actionManager.registerAction(SOFT_WRAP, softWrapAction);
    editGroup.add(softWrapAction);

    actionManager.registerAction(CUT, cutResourceAction);
    editGroup.add(cutResourceAction);

    actionManager.registerAction(COPY, copyResourceAction);
    editGroup.add(copyResourceAction);

    actionManager.registerAction(PASTE, pasteResourceAction);
    editGroup.add(pasteResourceAction);

    actionManager.registerAction(RENAME, renameItemAction);
    editGroup.add(renameItemAction);

    actionManager.registerAction(DELETE_ITEM, deleteResourceAction);
    editGroup.add(deleteResourceAction);

    actionManager.registerAction(FULL_TEXT_SEARCH, fullTextSearchAction);
    editGroup.add(fullTextSearchAction);

    editGroup.addSeparator();
    editGroup.add(switchPreviousEditorAction);
    editGroup.add(switchNextEditorAction);

    // Assistant (New Menu)
    DefaultActionGroup assistantGroup =
        (DefaultActionGroup) actionManager.getAction(GROUP_ASSISTANT);

    actionManager.registerAction(PREVIEW_IMAGE, previewImageAction);
    assistantGroup.add(previewImageAction);

    actionManager.registerAction(FIND_ACTION, findActionAction);
    assistantGroup.add(findActionAction);

    actionManager.registerAction(""hotKeysList"", hotKeysListAction);
    assistantGroup.add(hotKeysListAction);

    assistantGroup.addSeparator();

    // Switching of parts
    DefaultActionGroup toolWindowsGroup =
        new DefaultActionGroup(""Tool Windows"", true, actionManager);
    actionManager.registerAction(TOOL_WINDOWS_GROUP, toolWindowsGroup);

    actionManager.registerAction(
        PROJECT_EXPLORER_DISPLAYING_MODE, projectExplorerDisplayingModeAction);
    actionManager.registerAction(FIND_RESULT_DISPLAYING_MODE, findResultDisplayingModeAction);
    actionManager.registerAction(EVENT_LOGS_DISPLAYING_MODE, eventLogsDisplayingModeAction);
    actionManager.registerAction(
        COMMAND_EXPLORER_DISPLAYING_MODE, commandsExplorerDisplayingModeAction);
    actionManager.registerAction(EDITOR_DISPLAYING_MODE, editorDisplayingModeAction);
    actionManager.registerAction(TERMINAL_DISPLAYING_MODE, terminalDisplayingModeAction);
    toolWindowsGroup.add(projectExplorerDisplayingModeAction, FIRST);
    toolWindowsGroup.add(
        eventLogsDisplayingModeAction, new Constraints(AFTER, PROJECT_EXPLORER_DISPLAYING_MODE));
    toolWindowsGroup.add(
        findResultDisplayingModeAction, new Constraints(AFTER, EVENT_LOGS_DISPLAYING_MODE));
    toolWindowsGroup.add(
        commandsExplorerDisplayingModeAction, new Constraints(AFTER, FIND_RESULT_DISPLAYING_MODE));
    toolWindowsGroup.add(editorDisplayingModeAction);
    toolWindowsGroup.add(terminalDisplayingModeAction);

    assistantGroup.add(toolWindowsGroup);
    assistantGroup.addSeparator();

    actionManager.registerAction(""callCompletion"", completeAction);
    assistantGroup.add(completeAction);

    actionManager.registerAction(""downloadItemAction"", downloadResourceAction);
    actionManager.registerAction(NAVIGATE_TO_FILE, navigateToFileAction);
    assistantGroup.add(navigateToFileAction);

    assistantGroup.addSeparator();
    actionManager.registerAction(""devModeSetUpAction"", devModeSetUpAction);
    actionManager.registerAction(""devModeOffAction"", devModeOffAction);
    assistantGroup.add(devModeSetUpAction);
    assistantGroup.add(devModeOffAction);

    // Compose Profile menu
    DefaultActionGroup profileGroup = (DefaultActionGroup) actionManager.getAction(GROUP_PROFILE);
    actionManager.registerAction(""showPreferences"", showPreferencesAction);

    profileGroup.add(showPreferencesAction);

    // Compose Help menu
    DefaultActionGroup helpGroup = (DefaultActionGroup) actionManager.getAction(GROUP_HELP);
    helpGroup.addSeparator();

    // Processes panel actions
    actionManager.registerAction(""startWorkspace"", startWorkspaceAction);
    actionManager.registerAction(""stopWorkspace"", stopWorkspaceAction);
    actionManager.registerAction(""showWorkspaceStatus"", showWorkspaceStatusAction);
    actionManager.registerAction(""runCommand"", runCommandAction);
    actionManager.registerAction(""newTerminal"", newTerminalAction);

    // Compose main context menu
    DefaultActionGroup resourceOperation = new DefaultActionGroup(actionManager);
    actionManager.registerAction(""resourceOperation"", resourceOperation);
    actionManager.registerAction(""refreshPathAction"", refreshPathAction);
    actionManager.registerAction(""linkWithEditor"", linkWithEditorAction);
    actionManager.registerAction(""showToolbar"", showToolbarAction);

    resourceOperation.addSeparator();
    resourceOperation.add(previewImageAction);
    resourceOperation.add(showReferenceAction);
    resourceOperation.add(goIntoAction);
    resourceOperation.add(editFileAction);

    resourceOperation.add(saveAction);
    resourceOperation.add(cutResourceAction);
    resourceOperation.add(copyResourceAction);
    resourceOperation.add(pasteResourceAction);
    resourceOperation.add(renameItemAction);
    resourceOperation.add(deleteResourceAction);
    resourceOperation.addSeparator();
    resourceOperation.add(downloadResourceAction);
    resourceOperation.add(refreshPathAction);
    resourceOperation.add(linkWithEditorAction);
    resourceOperation.add(collapseAllAction);
    resourceOperation.addSeparator();
    resourceOperation.add(convertFolderToProjectAction);
    resourceOperation.addSeparator();
    resourceOperation.addSeparator();
    resourceOperation.add(addToFileWatcherExcludesAction);
    resourceOperation.add(removeFromFileWatcherExcludesAction);
    resourceOperation.addSeparator();

    DefaultActionGroup mainContextMenuGroup =
        (DefaultActionGroup) actionManager.getAction(GROUP_MAIN_CONTEXT_MENU);
    mainContextMenuGroup.add(newGroup, FIRST);
    mainContextMenuGroup.addSeparator();
    mainContextMenuGroup.add(resourceOperation);
    mainContextMenuGroup.add(openInTerminalAction);
    actionManager.registerAction(OPEN_IN_TERMINAL, openInTerminalAction);

    DefaultActionGroup partMenuGroup =
        (DefaultActionGroup) actionManager.getAction(GROUP_PART_MENU);
    partMenuGroup.add(maximizePartAction);
    partMenuGroup.add(hidePartAction);
    partMenuGroup.add(restorePartAction);
    partMenuGroup.add(showConsoleTreeAction);
    partMenuGroup.add(revealResourceAction);
    partMenuGroup.add(collapseAllAction);
    partMenuGroup.add(refreshPathAction);
    partMenuGroup.add(linkWithEditorAction);

    DefaultActionGroup toolbarControllerGroup =
        (DefaultActionGroup) actionManager.getAction(GROUP_TOOLBAR_CONTROLLER);
    toolbarControllerGroup.add(showToolbarAction);

    actionManager.registerAction(""expandEditor"", expandEditorAction);
    DefaultActionGroup rightMenuGroup =
        (DefaultActionGroup) actionManager.getAction(GROUP_RIGHT_MAIN_MENU);
    rightMenuGroup.add(expandEditorAction, FIRST);

    // Compose main toolbar
    DefaultActionGroup changeResourceGroup = new DefaultActionGroup(actionManager);
    actionManager.registerAction(""changeResourceGroup"", changeResourceGroup);
    actionManager.registerAction(""editFile"", editFileAction);
    actionManager.registerAction(""goInto"", goIntoAction);
    actionManager.registerAction(SHOW_REFERENCE, showReferenceAction);

    actionManager.registerAction(REVEAL_RESOURCE, revealResourceAction);
    actionManager.registerAction(COLLAPSE_ALL, collapseAllAction);

    actionManager.registerAction(""openFile"", openFileAction);
    actionManager.registerAction(SWITCH_LEFT_TAB, switchPreviousEditorAction);
    actionManager.registerAction(SWITCH_RIGHT_TAB, switchNextEditorAction);

    changeResourceGroup.add(cutResourceAction);
    changeResourceGroup.add(copyResourceAction);
    changeResourceGroup.add(pasteResourceAction);
    changeResourceGroup.add(deleteResourceAction);

    DefaultActionGroup mainToolbarGroup =
        (DefaultActionGroup) actionManager.getAction(GROUP_MAIN_TOOLBAR);
    mainToolbarGroup.add(newGroup);
    mainToolbarGroup.add(saveGroup);
    mainToolbarGroup.add(changeResourceGroup);
    toolbarPresenter.bindMainGroup(mainToolbarGroup);

    DefaultActionGroup centerToolbarGroup =
        (DefaultActionGroup) actionManager.getAction(GROUP_CENTER_TOOLBAR);
    toolbarPresenter.bindCenterGroup(centerToolbarGroup);

    DefaultActionGroup rightToolbarGroup =
        (DefaultActionGroup) actionManager.getAction(GROUP_RIGHT_TOOLBAR);
    toolbarPresenter.bindRightGroup(rightToolbarGroup);

    actionManager.registerAction(""showServers"", showRuntimeInfoAction);

    // Consoles tree context menu group
    DefaultActionGroup consolesTreeContextMenu =
        (DefaultActionGroup) actionManager.getAction(GROUP_CONSOLES_TREE_CONTEXT_MENU);
    consolesTreeContextMenu.add(showRuntimeInfoAction);
    consolesTreeContextMenu.add(newTerminalAction);
    consolesTreeContextMenu.add(reRunProcessAction);
    consolesTreeContextMenu.add(stopProcessAction);
    consolesTreeContextMenu.add(closeConsoleAction);

    actionManager.registerAction(""displayMachineOutput"", displayMachineOutputAction);
    consolesTreeContextMenu.add(displayMachineOutputAction);

    actionManager.registerAction(""previewSSH"", previewSSHAction);
    consolesTreeContextMenu.add(previewSSHAction);

    // Editor context menu group
    DefaultActionGroup editorTabContextMenu =
        (DefaultActionGroup) actionManager.getAction(GROUP_EDITOR_TAB_CONTEXT_MENU);
    editorTabContextMenu.add(closeAction);
    actionManager.registerAction(CLOSE, closeAction);
    editorTabContextMenu.add(closeAllAction);
    actionManager.registerAction(CLOSE_ALL, closeAllAction);
    editorTabContextMenu.add(closeOtherAction);
    actionManager.registerAction(CLOSE_OTHER, closeOtherAction);
    editorTabContextMenu.add(closeAllExceptPinnedAction);
    actionManager.registerAction(CLOSE_ALL_EXCEPT_PINNED, closeAllExceptPinnedAction);
    editorTabContextMenu.addSeparator();
    editorTabContextMenu.add(reopenClosedFileAction);
    actionManager.registerAction(REOPEN_CLOSED, reopenClosedFileAction);
    editorTabContextMenu.add(pinEditorTabAction);
    actionManager.registerAction(PIN_TAB, pinEditorTabAction);
    editorTabContextMenu.addSeparator();
    actionManager.registerAction(SPLIT_HORIZONTALLY, splitHorizontallyAction);
    editorTabContextMenu.add(splitHorizontallyAction);
    actionManager.registerAction(SPLIT_VERTICALLY, splitVerticallyAction);
    editorTabContextMenu.add(splitVerticallyAction);
    actionManager.registerAction(SIGNATURE_HELP, signatureHelpAction);

    actionManager.registerAction(SHOW_COMMANDS_PALETTE, showCommandsPaletteAction);
    DefaultActionGroup runGroup =
        (DefaultActionGroup) actionManager.getAction(IdeActions.GROUP_RUN);
    runGroup.add(showCommandsPaletteAction);
    runGroup.add(newTerminalAction, FIRST);
    runGroup.addSeparator();

    DefaultActionGroup editorContextMenuGroup = new DefaultActionGroup(actionManager);
    actionManager.registerAction(GROUP_EDITOR_CONTEXT_MENU, editorContextMenuGroup);

    editorContextMenuGroup.add(saveAction);
    editorContextMenuGroup.add(undoAction);
    editorContextMenuGroup.add(redoAction);
    editorContextMenuGroup.addSeparator();
    editorContextMenuGroup.add(formatterAction);
    editorContextMenuGroup.add(softWrapAction);

    editorContextMenuGroup.addSeparator();
    editorContextMenuGroup.add(fullTextSearchAction);
    editorContextMenuGroup.add(closeActiveEditorAction);

    editorContextMenuGroup.addSeparator();
    editorContextMenuGroup.add(revealResourceAction);

    DefaultActionGroup commandExplorerMenuGroup = new DefaultActionGroup(actionManager);
    actionManager.registerAction(GROUP_COMMAND_EXPLORER_CONTEXT_MENU, commandExplorerMenuGroup);

    actionManager.registerAction(""renameCommand"", renameCommandAction);
    commandExplorerMenuGroup.add(renameCommandAction);
    actionManager.registerAction(""moveCommand"", moveCommandAction);
    commandExplorerMenuGroup.add(moveCommandAction);

    DefaultActionGroup rightStatusPanelGroup =
        (DefaultActionGroup) actionManager.getAction(GROUP_RIGHT_STATUS_PANEL);
    rightStatusPanelGroup.add(freeDiskSpaceStatusBarAction);

    // Define hot-keys
    keyBinding
        .getGlobal()
        .addKey(new KeyBuilder().action().alt().charCode('n').build(), NAVIGATE_TO_FILE);
    keyBinding
        .getGlobal()
        .addKey(new KeyBuilder().action().charCode('F').build(), FULL_TEXT_SEARCH);
    keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('A').build(), FIND_ACTION);
    keyBinding.getGlobal().addKey(new KeyBuilder().alt().charCode('L').build(), FORMAT);
    keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('c').build(), COPY);
    keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('x').build(), CUT);
    keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('v').build(), PASTE);
    keyBinding.getGlobal().addKey(new KeyBuilder().shift().charCode(KeyCodeMap.F6).build(), RENAME);
    keyBinding
        .getGlobal()
        .addKey(new KeyBuilder().shift().charCode(KeyCodeMap.F7).build(), SHOW_REFERENCE);
    keyBinding
        .getGlobal()
        .addKey(new KeyBuilder().alt().charCode(KeyCodeMap.ARROW_LEFT).build(), SWITCH_LEFT_TAB);
    keyBinding
        .getGlobal()
        .addKey(new KeyBuilder().alt().charCode(KeyCodeMap.ARROW_RIGHT).build(), SWITCH_RIGHT_TAB);
    keyBinding
        .getGlobal()
        .addKey(new KeyBuilder().action().charCode('e').build(), OPEN_RECENT_FILES);
    keyBinding
        .getGlobal()
        .addKey(new KeyBuilder().charCode(KeyCodeMap.DELETE).build(), DELETE_ITEM);
    keyBinding.getGlobal().addKey(new KeyBuilder().action().alt().charCode('w').build(), SOFT_WRAP);
    keyBinding
        .getGlobal()
        .addKey(new KeyBuilder().alt().charCode(KeyCodeMap.F12).build(), NEW_TERMINAL);
    keyBinding
        .getGlobal()
        .addKey(new KeyBuilder().alt().shift().charCode(KeyCodeMap.F12).build(), OPEN_IN_TERMINAL);

    keyBinding.getGlobal().addKey(new KeyBuilder().alt().charCode('N').build(), NEW_FILE);
    keyBinding.getGlobal().addKey(new KeyBuilder().alt().charCode('x').build(), CREATE_PROJECT);
    keyBinding.getGlobal().addKey(new KeyBuilder().alt().charCode('A').build(), IMPORT_PROJECT);

    keyBinding
        .getGlobal()
        .addKey(new KeyBuilder().shift().charCode(KeyCodeMap.F10).build(), SHOW_COMMANDS_PALETTE);

    keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('s').build(), SAVE);

    keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('z').build(), UNDO);
    keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('y').build(), REDO);

    if (UserAgent.isMac()) {
      keyBinding
          .getGlobal()
          .addKey(
              new KeyBuilder().action().control().charCode('1').build(),
              PROJECT_EXPLORER_DISPLAYING_MODE);

      keyBinding
          .getGlobal()
          .addKey(
              new KeyBuilder().action().control().charCode('2').build(),
              EVENT_LOGS_DISPLAYING_MODE);

      keyBinding
          .getGlobal()
          .addKey(
              new KeyBuilder().action().control().charCode('3').build(),
              FIND_RESULT_DISPLAYING_MODE);

      keyBinding
          .getGlobal()
          .addKey(
              new KeyBuilder().action().control().charCode('4').build(),
              COMMAND_EXPLORER_DISPLAYING_MODE);

      keyBinding
          .getGlobal()
          .addKey(new KeyBuilder().action().charCode('E').build(), EDITOR_DISPLAYING_MODE);

      keyBinding
          .getGlobal()
          .addKey(new KeyBuilder().action().charCode('T').build(), TERMINAL_DISPLAYING_MODE);
    } else {
      keyBinding
          .getGlobal()
          .addKey(
              new KeyBuilder().action().alt().charCode('1').build(),
              PROJECT_EXPLORER_DISPLAYING_MODE);

      keyBinding
          .getGlobal()
          .addKey(
              new KeyBuilder().action().alt().charCode('2').build(), EVENT_LOGS_DISPLAYING_MODE);

      keyBinding
          .getGlobal()
          .addKey(
              new KeyBuilder().action().alt().charCode('3').build(), FIND_RESULT_DISPLAYING_MODE);

      keyBinding
          .getGlobal()
          .addKey(
              new KeyBuilder().action().alt().charCode('4').build(),
              COMMAND_EXPLORER_DISPLAYING_MODE);

      keyBinding
          .getGlobal()
          .addKey(new KeyBuilder().alt().charCode('E').build(), EDITOR_DISPLAYING_MODE);

      keyBinding
          .getGlobal()
          .addKey(new KeyBuilder().alt().charCode('T').build(), TERMINAL_DISPLAYING_MODE);
    }

    keyBinding
        .getGlobal()
        .addKey(new KeyBuilder().action().charCode(ARROW_DOWN).build(), REVEAL_RESOURCE);
    keyBinding
        .getGlobal()
        .addKey(new KeyBuilder().action().charCode(ARROW_UP).build(), COLLAPSE_ALL);

    if (UserAgent.isMac()) {
      keyBinding
          .getGlobal()
          .addKey(new KeyBuilder().control().charCode('w').build(), CLOSE_ACTIVE_EDITOR);
      keyBinding
          .getGlobal()
          .addKey(new KeyBuilder().control().charCode('p').build(), SIGNATURE_HELP);
    } else {
      keyBinding
          .getGlobal()
          .addKey(new KeyBuilder().alt().charCode('w').build(), CLOSE_ACTIVE_EDITOR);
      keyBinding
          .getGlobal()
          .addKey(new KeyBuilder().action().charCode('p').build(), SIGNATURE_HELP);
    }

    final Map<String, Perspective> perspectives = perspectiveManager.getPerspectives();
    if (perspectives.size()
        > 1) { // if registered perspectives will be more then 2 Main Menu -> Window
      // will appears and contains all of them as sub-menu
      final DefaultActionGroup windowMenu = new DefaultActionGroup(""Window"", true, actionManager);
      actionManager.registerAction(""Window"", windowMenu);
      final DefaultActionGroup mainMenu =
          (DefaultActionGroup) actionManager.getAction(GROUP_MAIN_MENU);
      mainMenu.add(windowMenu);
      for (Perspective perspective : perspectives.values()) {
        final BaseAction action =
            new BaseAction(perspective.getPerspectiveName()) {
              @Override
              public void actionPerformed(ActionEvent e) {
                perspectiveManager.setPerspectiveId(perspective.getPerspectiveId());
              }
            };
        actionManager.registerAction(perspective.getPerspectiveId(), action);
        windowMenu.add(action);
      }
    }
  }
}
",blob
503,"public class MainActivity extends FragmentActivity {
    private static final String TAG = ""MainActivity"";
    private static final String INAPP_PURCHASE_DATA = ""INAPP_PURCHASE_DATA"";

    static final int RPS = 0;
    static final int SETTINGS = 1;
    static final int CONTENT = 2;
    static final int FRAGMENT_COUNT = CONTENT +1;

    private Fragment[] fragments = new Fragment[FRAGMENT_COUNT];
    private MenuItem settings;
    private MenuItem challenge;
    private MenuItem share;
    private MenuItem message;
    private boolean isResumed = false;
    private boolean hasNativeLink = false;
    private CallbackManager callbackManager;
    private GameRequestDialog gameRequestDialog;

    private AccessTokenTracker accessTokenTracker;

    @Override
    public void onCreate(Bundle savedInstanceState) {

        FacebookSdk.addLoggingBehavior(LoggingBehavior.APP_EVENTS);
        FacebookSdk.setIsDebugEnabled(true);

        super.onCreate(savedInstanceState);
        accessTokenTracker = new AccessTokenTracker() {
            @Override
            protected void onCurrentAccessTokenChanged(AccessToken oldAccessToken,
                                                       AccessToken currentAccessToken) {
                if (isResumed) {
                    if (currentAccessToken == null) {
                        showFragment(RPS, false);
                    }
                }
            }
        };

        setContentView(R.layout.main);

        FragmentManager fm = getSupportFragmentManager();
        fragments[RPS] = fm.findFragmentById(R.id.rps_fragment);
        fragments[SETTINGS] = fm.findFragmentById(R.id.settings_fragment);
        fragments[CONTENT] = fm.findFragmentById(R.id.content_fragment);

        FragmentTransaction transaction = fm.beginTransaction();
        for(int i = 0; i < fragments.length; i++) {
            transaction.hide(fragments[i]);
        }
        transaction.commit();

        hasNativeLink = handleNativeLink();

        gameRequestDialog = new GameRequestDialog(this);
        callbackManager = CallbackManager.Factory.create();
        gameRequestDialog.registerCallback(
                callbackManager,
                new FacebookCallback<GameRequestDialog.Result>() {
                    @Override
                    public void onCancel() {
                        Log.d(TAG, ""Canceled"");
                    }

                    @Override
                    public void onError(FacebookException error) {
                        Log.d(TAG, String.format(""Error: %s"", error.toString()));
                    }

                    @Override
                    public void onSuccess(GameRequestDialog.Result result) {
                        Log.d(TAG, ""Success!"");
                        Log.d(TAG, ""Request id: "" + result.getRequestId());
                        Log.d(TAG, ""Recipients:"");
                        for (String recipient : result.getRequestRecipients()) {
                            Log.d(TAG, recipient);
                        }
                    }
                });
    }

    @Override
    public void onResume() {
        super.onResume();
        isResumed = true;
    }

    @Override
    public void onPause() {
        super.onPause();
        isResumed = false;
    }

    @Override
    public void onActivityResult(int requestCode, int resultCode, Intent data) {
        callbackManager.onActivityResult(requestCode, resultCode, data);
        super.onActivityResult(requestCode, resultCode, data);
        if (requestCode == RpsFragment.IN_APP_PURCHASE_RESULT) {
            String purchaseData = data.getStringExtra(INAPP_PURCHASE_DATA);

            if (resultCode == RESULT_OK) {
                RpsFragment fragment = (RpsFragment) fragments[RPS];
                try {
                    JSONObject jo = new JSONObject(purchaseData);
                    fragment.onInAppPurchaseSuccess(jo);
                }
                catch (JSONException e) {
                    Log.e(TAG, ""In app purchase invalid json."", e);
                }
            }
        }
    }

    @Override
    public void onDestroy() {
        super.onDestroy();
        accessTokenTracker.stopTracking();
    }

    @Override
    protected void onResumeFragments() {
        super.onResumeFragments();

        if (hasNativeLink) {
            showFragment(CONTENT, false);
            hasNativeLink = false;
        } else {
            showFragment(RPS, false);
        }
    }

    @Override
    public boolean onPrepareOptionsMenu(Menu menu) {
        // only add the menu when the selection fragment is showing
        if (fragments[RPS].isVisible()) {
            if (menu.size() == 0) {
                share = menu.add(R.string.share_on_facebook);
                message = menu.add(R.string.send_with_messenger);
                challenge = menu.add(R.string.challenge_friends);
                settings = menu.add(R.string.check_settings);
            }
            return true;
        } else {
            menu.clear();
            settings = null;
        }
        return false;
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        if (item.equals(settings)) {
            showFragment(SETTINGS, true);
            return true;
        } else if (item.equals(challenge)) {
            GameRequestContent newGameRequestContent = new GameRequestContent.Builder()
                    .setTitle(getString(R.string.challenge_dialog_title))
                    .setMessage(getString(R.string.challenge_dialog_message))
                    .build();

            gameRequestDialog.show(this, newGameRequestContent);

            return true;
        } else if (item.equals(share)) {
            RpsFragment fragment = (RpsFragment) fragments[RPS];
            fragment.shareUsingAutomaticDialog();
            return true;
        } else if (item.equals(message)) {
            RpsFragment fragment = (RpsFragment) fragments[RPS];
            fragment.shareUsingMessengerDialog();
            return true;
        }
        return false;
    }

    private boolean handleNativeLink() {
        if (!AccessToken.isCurrentAccessTokenActive()) {
            AccessToken.createFromNativeLinkingIntent(getIntent(),
                    FacebookSdk.getApplicationId(), new AccessToken.AccessTokenCreationCallback(){

                        @Override
                        public void onSuccess(AccessToken token) {
                            AccessToken.setCurrentAccessToken(token);
                        }

                        @Override
                        public void onError(FacebookException error) {

                        }
                    });
        }
        // See if we have a deep link in addition.
        int appLinkGesture = getAppLinkGesture(getIntent());
        if (appLinkGesture != INVALID_CHOICE) {
            ContentFragment fragment = (ContentFragment) fragments[CONTENT];
            fragment.setContentIndex(appLinkGesture);
            return true;
        }
        return false;
    }

    private int getAppLinkGesture(Intent intent) {
      Uri targetURI = AppLinks.getTargetUrlFromInboundIntent(this, intent);
      if (targetURI == null) {
        return INVALID_CHOICE;
      }
      String gesture = targetURI.getQueryParameter(""gesture"");
      if (gesture != null) {
          if (gesture.equalsIgnoreCase(getString(R.string.rock))) {
              return RpsGameUtils.ROCK;
          } else if (gesture.equalsIgnoreCase(getString(R.string.paper))) {
              return RpsGameUtils.PAPER;
          } else if (gesture.equalsIgnoreCase(getString(R.string.scissors))) {
              return RpsGameUtils.SCISSORS;
          }
      }
      return INVALID_CHOICE;
    }

    void showFragment(int fragmentIndex, boolean addToBackStack) {
        FragmentManager fm = getSupportFragmentManager();
        FragmentTransaction transaction = fm.beginTransaction();
        if (addToBackStack) {
            transaction.addToBackStack(null);
        } else {
            int backStackSize = fm.getBackStackEntryCount();
            for (int i = 0; i < backStackSize; i++) {
                fm.popBackStack();
            }
        }
        for (int i = 0; i < fragments.length; i++) {
            if (i == fragmentIndex) {
                transaction.show(fragments[i]);
            } else {
                transaction.hide(fragments[i]);
            }
        }
        transaction.commit();
    }
}
",blob
1356,"    public void afterValue( K key, V value ) throws LdapException, CursorException
    {
        checkNotClosed();
        /*
         * There is a subtle difference between after and before handling
         * with duplicate key values.  Say we have the following tuples:
         *
         * (0, 0)
         * (1, 1)
         * (1, 2)
         * (1, 3)
         * (2, 2)
         *
         * If we request an after cursor on (1, 2).  We must make sure that
         * the container cursor does not advance after the entry with key 1
         * since this would result in us skip returning (1. 3) on the call to
         * next which will incorrectly return (2, 2) instead.
         *
         * So if the value is null in the element then we don't care about
         * this obviously since we just want to advance past the duplicate key
         * values all together.  But when it is not null, then we want to
         * go right before this key instead of after it.
         */

        if ( value == null )
        {
            containerCursor.after( new Tuple<K, DupsContainer<V>>( key, null ) );
        }
        else
        {
            containerCursor.before( new Tuple<K, DupsContainer<V>>( key, null ) );
        }

        if ( containerCursor.next() )
        {
            containerTuple.setBoth( containerCursor.get() );
            DupsContainer<V> values = containerTuple.getValue();

            if ( values.isArrayTree() )
            {
                ArrayTree<V> set = values.getArrayTree();
                dupsCursor = new ArrayTreeCursor<>( set );
            }
            else
            {
                try
                {
                    BTree tree = table.getBTree( values.getBTreeRedirect() );
                    dupsCursor = new KeyBTreeCursor<>( tree, table.getValueComparator() );
                }
                catch ( IOException e )
                {
                    throw new CursorException( e );
                }
            }

            if ( value == null )
            {
                return;
            }

            // only advance the dupsCursor if we're on same key
            if ( table.getKeyComparator().compare( containerTuple.getKey(), key ) == 0 )
            {
                dupsCursor.after( value );
            }

            return;
        }

        clearValue();
        containerTuple.setKey( null );
        containerTuple.setValue( null );
    }
",long method
1349,"@Named
@RequestScoped
public class UserUpdateBean
{
    private String name;
    
    private String surname;
    
    private int age;
    
    private String userName;
    
    private String password;
    
    private @Inject @Default UserController controller;
    
    private @Inject @Default SessionTracker tracker;
    
    public UserUpdateBean()
    {
        
    }

    public String showInfo()
    {
        //Just show how can access session webbeans
        User user = this.controller.getUser(tracker.getUser().getId());
        
        setName(user.getName());
        setSurname(user.getSurname());
        setAge(user.getAge());
        setUserName(user.getUserName());
        setPassword(user.getPassword());
                
        return ""toUpdatePage"";
    }

    public String clear()
    {
        setName("""");
        setSurname("""");
        setAge(0);
        setUserName("""");
        setPassword("""");
        
        return null;
    }
    
    public String update()
    {
        this.controller.updateUserInfo(tracker.getUser().getId(), name, surname, age, userName, password);
        
        JSFUtility.addInfoMessage(""Personal information is succesfully updated."", """");
        
        return null;
    }
    
    /**
     * @return the name
     */
    public String getName()
    {
        return name;
    }

    /**
     * @param name the name to set
     */
    public void setName(String name)
    {
        this.name = name;
    }

    /**
     * @return the surname
     */
    public String getSurname()
    {
        return surname;
    }

    /**
     * @param surname the surname to set
     */
    public void setSurname(String surname)
    {
        this.surname = surname;
    }

    /**
     * @return the age
     */
    public int getAge()
    {
        return age;
    }

    /**
     * @param age the age to set
     */
    public void setAge(int age)
    {
        this.age = age;
    }

    /**
     * @return the userName
     */
    public String getUserName()
    {
        return userName;
    }

    /**
     * @param userName the userName to set
     */
    public void setUserName(String userName)
    {
        this.userName = userName;
    }

    /**
     * @return the password
     */
    public String getPassword()
    {
        return password;
    }

    /**
     * @param password the password to set
     */
    public void setPassword(String password)
    {
        this.password = password;
    }
    
    
}
",data class
201,"public class SageRuntimeException extends RuntimeException implements SageExceptable
{
  protected final int kind;


  public SageRuntimeException()
  {
    kind = UNKNOWN;
  }

  public SageRuntimeException(String message, int kind)
  {
    super(message);

    this.kind = kind;
  }

  public SageRuntimeException(Throwable cause, int kind)
  {
    super(cause);

    this.kind = kind;
  }

  public SageRuntimeException(String message, Throwable cause, int kind)
  {
    super(message, cause);

    this.kind = kind;
  }

  public int getKind()
  {
    return (kind);
  }

  public boolean isKind(int kind)
  {
    return ((this.kind & kind) != 0);
  }

  public String getMessage()
  {
    return (""kind="" + kind + ""; "" + super.getMessage());
  }
}
",data class
435,"@XmlType(name = ""remoteProcessGroup"")
public class RemoteProcessGroupDTO extends ComponentDTO {

    private String targetUri;
    private String targetUris;
    private Boolean targetSecure;

    private String name;
    private String comments;
    private String communicationsTimeout;
    private String yieldDuration;
    private String transportProtocol;
    private String localNetworkInterface;
    private String proxyHost;
    private Integer proxyPort;
    private String proxyUser;
    private String proxyPassword;

    private Collection<String> authorizationIssues;
    private Collection<String> validationErrors;
    private Boolean transmitting;

    private Integer inputPortCount;
    private Integer outputPortCount;

    private Integer activeRemoteInputPortCount;
    private Integer inactiveRemoteInputPortCount;
    private Integer activeRemoteOutputPortCount;
    private Integer inactiveRemoteOutputPortCount;

    private Date flowRefreshed;

    private RemoteProcessGroupContentsDTO contents;

    public RemoteProcessGroupDTO() {
        super();
    }

    public RemoteProcessGroupDTO(final RemoteProcessGroupDTO toCopy) {
        setId(toCopy.getId());
        setPosition(toCopy.getPosition());
        targetUri = toCopy.getTargetUri();
        name = toCopy.getName();
    }

    public void setTargetUri(final String targetUri) {
        this.targetUri = targetUri;
    }

    /**
     * @return target uri of this remote process group.
     * If target uri is not set, but uris are set, then returns the first url in the urls.
     * If neither target uri nor uris are set, then returns null.
     */
    @ApiModelProperty(
            value = ""The target URI of the remote process group."" +
                    "" If target uri is not set, but uris are set, then returns the first url in the urls."" +
                    "" If neither target uri nor uris are set, then returns null.""
    )
    public String getTargetUri() {
        if (targetUri == null || targetUri.length() == 0) {
            synchronized (this) {
                if (targetUri == null || targetUri.length() == 0) {
                    if (targetUris != null && targetUris.length() > 0) {
                        if (targetUris.indexOf(',') > -1) {
                            targetUri = targetUris.substring(0, targetUris.indexOf(','));
                        } else {
                            targetUri = targetUris;
                        }
                    }
                }
            }
        }

        return this.targetUri;
    }

    public void setTargetUris(String targetUris) {
        this.targetUris = targetUris;
    }

    /**
     * @return target uris of this remote process group
     * If targetUris was not set but target uri was set, then returns a collection containing the single uri.
     * If neither target uris nor uri were set, then returns null.
     */
    @ApiModelProperty(
            value = ""The target URI of the remote process group."" +
                    "" If target uris is not set but target uri is set,"" +
                    "" then returns a collection containing the single target uri."" +
                    "" If neither target uris nor uris are set, then returns null.""
    )
    public String getTargetUris() {
        if (targetUris == null || targetUris.length() == 0) {
            synchronized (this) {
                if (targetUris == null || targetUris.length() == 0) {
                    targetUris = targetUri;
                }
            }
        }

        return this.targetUris;
    }

    /**
     * @param name of this remote process group
     */
    @ApiModelProperty(
            value = ""The name of the remote process group.""
    )
    public void setName(final String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }

    /**
     * @return Comments for this remote process group
     */
    @ApiModelProperty(
            value = ""The comments for the remote process group.""
    )
    public String getComments() {
        return comments;
    }

    public void setComments(String comments) {
        this.comments = comments;
    }

    /**
     * @return any remote authorization issues for this remote process group
     */
    @ApiModelProperty(
            value = ""Any remote authorization issues for the remote process group.""
    )
    public Collection<String> getAuthorizationIssues() {
        return authorizationIssues;
    }

    public void setAuthorizationIssues(Collection<String> authorizationIssues) {
        this.authorizationIssues = authorizationIssues;
    }

    /**
     * @return whether or not this remote process group is actively transmitting
     */
    @ApiModelProperty(
            value = ""Whether the remote process group is actively transmitting.""
    )
    public Boolean isTransmitting() {
        return transmitting;
    }

    public void setTransmitting(Boolean transmitting) {
        this.transmitting = transmitting;
    }

    /**
     * @return whether or not the target is running securely
     */
    @ApiModelProperty(
            value = ""Whether the target is running securely.""
    )
    public Boolean isTargetSecure() {
        return targetSecure;
    }

    public void setTargetSecure(Boolean targetSecure) {
        this.targetSecure = targetSecure;
    }

    /**
     * @return the time period used for the timeout when communicating with this RemoteProcessGroup
     */
    @ApiModelProperty(
            value = ""The time period used for the timeout when communicating with the target.""
    )
    public String getCommunicationsTimeout() {
        return communicationsTimeout;
    }

    public void setCommunicationsTimeout(String communicationsTimeout) {
        this.communicationsTimeout = communicationsTimeout;
    }

    /**
     * @return when yielding, this amount of time must elapse before this remote process group is scheduled again
     */
    @ApiModelProperty(
            value = ""When yielding, this amount of time must elapse before the remote process group is scheduled again.""
    )
    public String getYieldDuration() {
        return yieldDuration;
    }

    public void setYieldDuration(String yieldDuration) {
        this.yieldDuration = yieldDuration;
    }

    /**
     * @return number of active remote input ports
     */
    @ApiModelProperty(
            value = ""The number of active remote input ports.""
    )
    public Integer getActiveRemoteInputPortCount() {
        return activeRemoteInputPortCount;
    }

    public void setActiveRemoteInputPortCount(Integer activeRemoteInputPortCount) {
        this.activeRemoteInputPortCount = activeRemoteInputPortCount;
    }

    /**
     * @return number of inactive remote input ports
     */
    @ApiModelProperty(
            value = ""The number of inactive remote input ports.""
    )
    public Integer getInactiveRemoteInputPortCount() {
        return inactiveRemoteInputPortCount;
    }

    public void setInactiveRemoteInputPortCount(Integer inactiveRemoteInputPortCount) {
        this.inactiveRemoteInputPortCount = inactiveRemoteInputPortCount;
    }

    /**
     * @return number of active remote output ports
     */
    @ApiModelProperty(
            value = ""The number of active remote output ports.""
    )
    public Integer getActiveRemoteOutputPortCount() {
        return activeRemoteOutputPortCount;
    }

    public void setActiveRemoteOutputPortCount(Integer activeRemoteOutputPortCount) {
        this.activeRemoteOutputPortCount = activeRemoteOutputPortCount;
    }

    /**
     * @return number of inactive remote output ports
     */
    @ApiModelProperty(
            value = ""The number of inactive remote output ports.""
    )
    public Integer getInactiveRemoteOutputPortCount() {
        return inactiveRemoteOutputPortCount;
    }

    public void setInactiveRemoteOutputPortCount(Integer inactiveRemoteOutputPortCount) {
        this.inactiveRemoteOutputPortCount = inactiveRemoteOutputPortCount;
    }

    /**
     * @return number of Remote Input Ports currently available in the remote NiFi instance
     */
    @ApiModelProperty(
            value = ""The number of remote input ports currently available on the target.""
    )
    public Integer getInputPortCount() {
        return inputPortCount;
    }

    public void setInputPortCount(Integer inputPortCount) {
        this.inputPortCount = inputPortCount;
    }

    /**
     * @return number of Remote Output Ports currently available in the remote NiFi instance
     */
    @ApiModelProperty(
            value = ""The number of remote output ports currently available on the target.""
    )
    public Integer getOutputPortCount() {
        return outputPortCount;
    }

    public void setOutputPortCount(Integer outputPortCount) {
        this.outputPortCount = outputPortCount;
    }

    /**
     * @return contents of this remote process group. Will contain available input/output ports
     */
    @ApiModelProperty(
            value = ""The contents of the remote process group. Will contain available input/output ports.""
    )
    public RemoteProcessGroupContentsDTO getContents() {
        return contents;
    }

    public void setContents(RemoteProcessGroupContentsDTO contents) {
        this.contents = contents;
    }

    /**
     * @return the flow for this remote group was last refreshed
     */
    @XmlJavaTypeAdapter(DateTimeAdapter.class)
    @ApiModelProperty(
            value = ""The timestamp when this remote process group was last refreshed."",
            dataType = ""string""
    )
    public Date getFlowRefreshed() {
        return flowRefreshed;
    }

    public void setFlowRefreshed(Date flowRefreshed) {
        this.flowRefreshed = flowRefreshed;
    }

    public String getTransportProtocol() {
        return transportProtocol;
    }

    public void setTransportProtocol(String transportProtocol) {
        this.transportProtocol = transportProtocol;
    }

    @ApiModelProperty(""The local network interface to send/receive data. If not specified, any local address is used. If clustered, all nodes must have an interface with this identifier."")
    public String getLocalNetworkInterface() {
        return localNetworkInterface;
    }

    public void setLocalNetworkInterface(String localNetworkInterface) {
        this.localNetworkInterface = localNetworkInterface;
    }

    @ApiModelProperty(
            ""The validation errors for the remote process group. These validation errors represent the problems with the remote process group that must be resolved before it can transmit.""
    )
    public Collection<String> getValidationErrors() {
        return validationErrors;
    }

    public void setValidationErrors(Collection<String> validationErrors) {
        this.validationErrors = validationErrors;
    }

    public String getProxyHost() {
        return proxyHost;
    }

    public void setProxyHost(String proxyHost) {
        this.proxyHost = proxyHost;
    }

    public Integer getProxyPort() {
        return proxyPort;
    }

    public void setProxyPort(Integer proxyPort) {
        this.proxyPort = proxyPort;
    }

    public String getProxyUser() {
        return proxyUser;
    }

    public void setProxyUser(String proxyUser) {
        this.proxyUser = proxyUser;
    }

    public String getProxyPassword() {
        return proxyPassword;
    }

    public void setProxyPassword(String proxyPassword) {
        this.proxyPassword = proxyPassword;
    }
}
",blob
773,"public class MultiDexConfig {

    private String name;

    public MultiDexConfig(String name) {
        this.name = name;
    }

    @Config(title = ""Whether to enable fast"", message = ""Enable atlas , true/false"", order = 0, group = ""atlas"")
    private boolean fastMultiDex = false;

    @Config(title = ""The extra first dex class list"", message = ""The custom needs to be placed in the entry class in the first dex"", order = 3, group = ""atlas"")
    private Set<String> firstDexClasses = Sets.newHashSet();
    /**
     * dex The number of subcontracting, 0 No restrictions, no two merges
     */
    @Config(title = ""dexThe number of"", message = ""0unlimited"", order = 1, group = ""atlas"")
    private int dexCount;

    public int getMainDexListCount() {
        return mainDexListCount;
    }

    public void setMainDexListCount(int mainDexListCount) {
        this.mainDexListCount = mainDexListCount;
    }

    private int mainDexListCount;

    @Config(title = ""dexSeparated rules"", message = ""a,b;c,d"", order = 2, group = ""atlas"")
    private String dexSplitRules;

    @Config(title = ""Does not enter the list of the first dex's blacklist"", message = ""a"", order = 2, group = ""atlas"")
    private Set<String> mainDexBlackList = Sets.newHashSet();

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public boolean isFastMultiDex() {
        return fastMultiDex;
    }

    public void setFastMultiDex(boolean fastMultiDex) {
        this.fastMultiDex = fastMultiDex;
    }

    public Set<String> getMainDexBlackList() {
        return mainDexBlackList;
    }

    public void setMainDexBlackList(Set<String> mainDexBlackList) {
        this.mainDexBlackList = mainDexBlackList;
    }

    public Set<String> getFirstDexClasses() {
        return firstDexClasses;
    }

    public void setFirstDexClasses(Set<String> firstDexClasses) {
        this.firstDexClasses = firstDexClasses;
    }

    public int getDexCount() {
        return dexCount;
    }

    public void setDexCount(int dexCount) {
        this.dexCount = dexCount;
    }

    public String getDexSplitRules() {
        return dexSplitRules;
    }

    public void setDexSplitRules(String dexSplitRules) {
        this.dexSplitRules = dexSplitRules;
    }
}
",data class
336,"public class WireAdminImpl implements WireAdmin, ServiceListener {

	private BundleContext m_bundleContext;

    // A Map containing a service reference associated to a producer and a List
    // of wire objects	
    private Map m_consumers = new HashMap(); /* ServiceReferences, List */
	
    private Map m_producers = new HashMap(); /* ServiceReferences, List */

	private List m_wires; // List containing the wires

	//private BindingController wireAdminListenersBindingController;

    // Filter corresponding to a consumer service
	private Filter m_consumerFilter;
    
    //  Filter corresponding to a producer service
	private Filter m_producerFilter;

    // EventManager
    private EventManager m_eventManager;

	private static int m_wireCount = 0;
    
    private AsyncMethodCaller m_asyncMethodCaller = new AsyncMethodCaller();        //m_eventDispatcher.stop();
    
    private static PrintStream m_traceout = null;
    
    private static PrintStream m_errorout = System.err;

	/**
     * Constructor with package visibility
     * 
	 * @param bundleContext the bundle context
	 */
	WireAdminImpl(BundleContext bundleContext) 
    {
		m_bundleContext = bundleContext;
        
        if(bundleContext.getProperty(""fr.imag.adele.wireadmin.trace"") != null)
        {
            String value = bundleContext.getProperty(""fr.imag.adele.wireadmin.trace"");
            if(value.equals(""true""))
            {
                m_traceout = System.out;
            }
        }
        // Create the event manager (the event manager will start its own thread)       
        m_eventManager = new EventManager(m_bundleContext);
        
		try 
        {
			m_producerFilter = m_bundleContext.createFilter(
					""(objectClass=org.osgi.service.wireadmin.Producer)"");
			m_consumerFilter = m_bundleContext.createFilter(
					""(objectClass=org.osgi.service.wireadmin.Consumer)"");
		} 
        catch (InvalidSyntaxException e) 
        {
			// never thrown since LDAP expressions are correct
		}

        // Recover persistent wires
        getPersistentWires();

        // Activate thread that does asynchronous calls to
        // the producersConnected and consummersConnected methods
        new Thread(m_asyncMethodCaller).start();

        // Gets all producers and consumers that are present at the
        // moment the wire admin is created
        try 
        {
            // Registration for events must be done first, as some service
            // can be registered during initialization
            
            m_bundleContext.addServiceListener(this,""(|""+m_producerFilter.toString()+m_consumerFilter.toString()+"")"");

            // Replacement for the two following lines which work under OSCAR, 
            // but not work under IBM's SMF
            //m_bundleContext.addServiceListener(this,m_consumerFilter.toString());
            //m_bundleContext.addServiceListener(this,m_producerFilter.toString());
            
            // Get all producers
            ServiceReference[] producerRefs = m_bundleContext.getServiceReferences(Producer.class.getName(),null);
            
            if(producerRefs!=null)
            {
                // lock the producers Map to avoid concurrent modifications due
                // to service events
                synchronized(m_producers)
                {
                    for(int i=0;i<producerRefs.length;i++)
                    {
                        ServiceReference currentRef=(ServiceReference)producerRefs[i];
                        
                        Iterator wireIt = m_wires.iterator();
                        while(wireIt.hasNext())
                        {
                            WireImpl currentWire = (WireImpl) wireIt.next();
                            if(currentWire.getProducerPID().equals(currentRef.getProperty(Constants.SERVICE_PID)))
                            {
                                currentWire.bindProducer(currentRef);
                            }
                        }
                        m_producers.put(currentRef,new ArrayList());
                    }
                }
            }

            // Get all the consumers
            ServiceReference[] consumerRefs = m_bundleContext.getServiceReferences(Consumer.class.getName(),null);
            
            if(consumerRefs!=null)
            {
                for(int i=0;i<consumerRefs.length;i++)
                {
                    // lock the consumers to avoid concurrent modifications due
                    // to service events
                    synchronized(m_consumers)
                    {
                        ServiceReference currentRef=(ServiceReference)consumerRefs[i];

                        Iterator wireIt = m_wires.iterator();
                        while(wireIt.hasNext())
                        {
                            WireImpl currentWire = (WireImpl) wireIt.next();
                            if(currentWire.getConsumerPID().equals(currentRef.getProperty(Constants.SERVICE_PID)))
                            {
                                currentWire.bindConsumer(currentRef);
                            }
                        }
                        m_consumers.put(currentRef,new ArrayList());
                    }
                }
            }
        } 
        catch (InvalidSyntaxException e) 
        {
            trace(e);
        }

        // Iterate over all the wires, when a wire is connected
        // add it to the list of wires associated to a particular
        // producer or consumer
        synchronized(m_wires)
        {
            Iterator wireIterator = m_wires.iterator();
            while(wireIterator.hasNext())
            {
                WireImpl currentWire = (WireImpl) wireIterator.next();
                if(currentWire.isConnected())
                {                
                    // p. 327 ""If both Producer and consumer services are registered
                    // with the framework, they are connected by the WireAdmin service""
                    List wires = (List) m_producers.get(currentWire.getProducerServiceRef());
                    wires.add(currentWire);
                    m_asyncMethodCaller.consumersConnected(currentWire.getProducer(),(Wire[])wires.toArray(new Wire[wires.size()]));
                    
                    wires = (List) m_consumers.get(currentWire.getConsumerServiceRef());
                    wires.add(currentWire);
                    m_asyncMethodCaller.producersConnected(currentWire.getConsumer(),(Wire[])wires.toArray(new Wire[wires.size()]));
                }            
            }
        }       
	}
    
    /**
     * Pass the service reference to the event dispatcher
     * 
     * @param ref the service reference
     */
    void setServiceReference(ServiceReference ref)
    {
        m_eventManager.setServiceReference(ref);
    }

	/**
	 * Create a new <tt>Wire</tt> object that connects a Producer
	 * service to a Consumer service.
	 *
	 * The Producer service and Consumer service do not
	 * have to be registered when the <tt>Wire</tt> object is created.
	 *
	 * <p>The <tt>Wire</tt> configuration data must be persistently stored.
	 * All <tt>Wire</tt> connections are reestablished when the
	 * <tt>WireAdmin</tt> service is registered.
	 * A <tt>Wire</tt> can be permanently removed by using the
	 * {@link #deleteWire} method.
	 *
	 * <p>The <tt>Wire</tt> object's properties must have case
	 * insensitive <tt>String</tt> objects as keys (like the Framework).
	 * However, the case of the key must be preserved.
	 * The type of the value of the property must be one of the following:
	 *
	 * <pre>
	 * type        = basetype
	 *  | vector | arrays
	 *
	 * basetype = String | Integer | Long
	 *  | Float | Double | Byte
	 *  | Short | Character
	 *  | Boolean
	 *
	 * primitive   = long | int | short
	 *  | char | byte | double | float
	 *
	 * arrays   = primitive '[]' | basetype '[]'
	 *
	 * vector   = Vector of basetype
	 * </pre>
	 *
	 * <p>The <tt>WireAdmin</tt> service must automatically add the
	 * following <tt>Wire</tt> properties:
	 * <ul>
	 * <li>
	 * {@link WireConstants#WIREADMIN_PID} set to the value of the <tt>Wire</tt> object's
	 * persistent identity (PID). This value is generated by the
	 * Wire Admin service when a <tt>Wire</tt> object is created.
	 * </li>
	 * <li>
	 * {@link WireConstants#WIREADMIN_PRODUCER_PID} set to the value of
	 * Producer service's PID.
	 * </li>
	 * <li>
	 * {@link WireConstants#WIREADMIN_CONSUMER_PID} set to the value of
	 * Consumer service's PID.
	 * </li>
	 * </ul>
	 * If the <tt>properties</tt> argument
	 * already contains any of these keys, then the supplied values
	 * are replaced with the values assigned by the Wire Admin service.
	 *
	 * <p>The Wire Admin service must broadcast a <tt>WireAdminEvent</tt> of type
	 * {@link WireAdminEvent#WIRE_CREATED}
	 * after the new <tt>Wire</tt> object becomes available from {@link #getWires}.
	 *
	 * @param producerPID The <tt>service.pid</tt> of the Producer service
	 * to be connected to the <tt>Wire</tt> object.
	 * @param consumerPID The <tt>service.pid</tt> of the Consumer service
	 * to be connected to the <tt>Wire</tt> object.
	 * @param properties The <tt>Wire</tt> object's properties. This argument may be <tt>null</tt>
	 * if the caller does not wish to define any <tt>Wire</tt> object's properties.
	 * @return The <tt>Wire</tt> object for this connection.
	 * @throws java.lang.IllegalArgumentException If
	 * <tt>properties</tt> contains case variants of the same key name.
	 */
	public Wire createWire(String producerPID, String consumerPID, Dictionary props) 
    {
        ServiceReference producerServiceRef = null;
        ServiceReference consumerServiceRef = null;

        Dictionary properties;
        
        if(props == null)
        {
        	properties = new Hashtable();
        }
        else
        {
        	//Clone the dictionary
        	properties = cloneProperties(props);
        }

        // Addition of mandatory properties
        properties.put(WireConstants.WIREADMIN_CONSUMER_PID, consumerPID);
        properties.put(WireConstants.WIREADMIN_PRODUCER_PID, producerPID);
        properties.put(WireConstants.WIREADMIN_PID, generateWirePID());

        // p.327 ""Wire objects can be created when the producer or consumer
        // service is not registered
        WireImpl wire = new WireImpl(producerPID, consumerPID, properties);

        // Initialize the wire
        wire.initialize(m_bundleContext,m_eventManager);

        // Add the wire to the list 
        synchronized(m_wires)
        {
            m_wires.add(wire);            
        }

        // p. 357 ""The Wire Admin service must broadcast a WireAdminEvent of 
        // type WireAdminEvent.WIRE_CREATED  after the new Wire object becomes 
        // available from getWires(java.lang.String).""
        m_eventManager.fireEvent(WireAdminEvent.WIRE_CREATED,wire);

        synchronized (m_producers)
        {
            Iterator producerIterator = m_producers.keySet().iterator();
            while(producerIterator.hasNext())
            {
                producerServiceRef = (ServiceReference) producerIterator.next();
                if (producerServiceRef.getProperty(Constants.SERVICE_PID).equals(producerPID)) 
                {
                    wire.bindProducer(producerServiceRef);                    
                    break;
                }
            }
        }        
        
        synchronized (m_consumers)
        {
            Iterator consumerIterator = m_consumers.keySet().iterator();
            while(consumerIterator.hasNext())
            {
                consumerServiceRef = (ServiceReference) consumerIterator.next();
                if (consumerServiceRef.getProperty(Constants.SERVICE_PID).equals(consumerPID)) 
                {
                    wire.bindConsumer(consumerServiceRef);
                    break;
                }
                
            }
        }
        
        
        // p.327 If both Producer and Consumer services are registered, they are 
        // connected by the wire admin service. 
        if(wire.isConnected())
        {
            List wires = (List) m_producers.get(producerServiceRef);
            wires.add(wire);
            m_asyncMethodCaller.consumersConnected(wire.getProducer(),(Wire[])wires.toArray(new Wire[wires.size()]));

            wires = (List) m_consumers.get(consumerServiceRef);
            wires.add(wire);
            m_asyncMethodCaller.producersConnected(wire.getConsumer(),(Wire[])wires.toArray(new Wire[wires.size()]));
        }

        // Newly created wires are immediately persisted to avoid information
        // loss in case of crashes.  (spec not clear about this)        
        persistWires();

        return wire;
    }

	/**
	 * Delete a <tt>Wire</tt> object.
	 *
	 * <p>The <tt>Wire</tt> object representing a connection between
	 * a Producer service and a Consumer service must be
	 * removed.
	 * The persistently stored configuration data for the <tt>Wire</tt> object
	 * must destroyed. The <tt>Wire</tt> object's method {@link Wire#isValid} will return <tt>false</tt>
	 * after it is deleted.
	 *
	 * <p>The Wire Admin service must broadcast a <tt>WireAdminEvent</tt> of type
	 * {@link WireAdminEvent#WIRE_DELETED}
	 * after the <tt>Wire</tt> object becomes invalid.
	 *
	 * @param wire The <tt>Wire</tt> object which is to be deleted.
	 */
	public void deleteWire(Wire wire) 
    {
        if(m_wires.contains(wire))
        {
            WireImpl wireImpl = (WireImpl) wire;
            m_wires.remove(wire);
            if(wireImpl.isConnected())
            {
                List wires = (List) m_producers.get(wireImpl.getProducerServiceRef());
                wires.remove(wireImpl);
                m_asyncMethodCaller.consumersConnected(wireImpl.getProducer(),(Wire[])wires.toArray(new Wire[wires.size()]));

                wires = (List) m_consumers.get(wireImpl.getConsumerServiceRef());
                wires.remove(wireImpl);
                m_asyncMethodCaller.producersConnected(wireImpl.getConsumer(),(Wire[])wires.toArray(new Wire[wires.size()]));
            }
            
            wireImpl.invalidate();

            // fire an event
            m_eventManager.fireEvent(WireAdminEvent.WIRE_DELETED,wireImpl);
            
            // Persist state to avoid losses in case of crashes (spec not clear about this).        
            persistWires();
        }
        else
        {
            traceln(""WireAdminImpl: Cannot delete a wire that is not managed by this service"");
        }

	}

	/**
	 * Update the properties of a <tt>Wire</tt> object.
	 *
	 * The persistently stored configuration data for the <tt>Wire</tt> object
	 * is updated with the new properties and then the Consumer and Producer
	 * services will be called at the respective {@link Consumer#producersConnected}
	 * and {@link Producer#consumersConnected} methods.
	 *
	 * <p>The Wire Admin service must broadcast a <tt>WireAdminEvent</tt> of type
	 * {@link WireAdminEvent#WIRE_UPDATED}
	 * after the updated properties are available from the <tt>Wire</tt> object.
	 *
	 * @param wire The <tt>Wire</tt> object which is to be updated.
	 * @param properties The new <tt>Wire</tt> object's properties or <tt>null</tt> if no properties are required.
	 */
	public void updateWire(Wire wire, Dictionary props) 
    {
        if(m_wires.contains(wire) == false)
        {
            traceln(""WireAdminImpl: Cannot update a wire that is not managed by this service"");
            return;
        }
        
        // Clone the dictionary
        Dictionary properties = cloneProperties(props);

        // Put again the mandatory properties, in case they are not set
        properties.put(WireConstants.WIREADMIN_CONSUMER_PID,wire.getProperties().get(WireConstants.WIREADMIN_CONSUMER_PID));
        properties.put(WireConstants.WIREADMIN_PRODUCER_PID,wire.getProperties().get(WireConstants.WIREADMIN_PRODUCER_PID));
        properties.put(WireConstants.WIREADMIN_PID,wire.getProperties().get(WireConstants.WIREADMIN_PID));
        
        WireImpl wireImpl = (WireImpl) wire;
        
        wireImpl.updateProperties(properties);
        
        // Call methods on Consumer and Producer
        if(wireImpl.isConnected())
        {
            List wires = (List) m_producers.get(wireImpl.getProducerServiceRef());
            m_asyncMethodCaller.consumersConnected(wireImpl.getProducer(),(Wire[])wires.toArray(new Wire[wires.size()]));

            wires = (List) m_consumers.get(wireImpl.getConsumerServiceRef());
            m_asyncMethodCaller.producersConnected(wireImpl.getConsumer(),(Wire[])wires.toArray(new Wire[wires.size()]));
        }

        // fire an event
        m_eventManager.fireEvent(WireAdminEvent.WIRE_UPDATED,wireImpl);
	}

	/**
	 * Return the <tt>Wire</tt> objects that match the given <tt>filter</tt>.
	 *
	 * <p>The list of available <tt>Wire</tt> objects is matched against the
	 * specified <tt>filter</tt>. <tt>Wire</tt> objects which match the
	 * <tt>filter</tt> must be returned. These <tt>Wire</tt> objects are not necessarily
	 * connected. The Wire Admin service should not return
	 * invalid <tt>Wire</tt> objects, but it is possible that a <tt>Wire</tt>
	 * object is deleted after it was placed in the list.
	 *
	 * <p>The filter matches against the <tt>Wire</tt> object's properties including
	 * {@link WireConstants#WIREADMIN_PRODUCER_PID}, {@link WireConstants#WIREADMIN_CONSUMER_PID}
	 * and {@link WireConstants#WIREADMIN_PID}.
	 *
	 * @param filter Filter string to select <tt>Wire</tt> objects
	 * or <tt>null</tt> to select all <tt>Wire</tt> objects.
	 * @return An array of <tt>Wire</tt> objects which match the <tt>filter</tt>
	 * or <tt>null</tt> if no <tt>Wire</tt> objects match the <tt>filter</tt>.
	 * @throws org.osgi.framework.InvalidSyntaxException If the specified <tt>filter</tt>
	 * has an invalid syntax.
	 * @see org.osgi.framework.Filter
	 */
	public Wire[] getWires(String filter) throws InvalidSyntaxException 
    {
		List res = null;
		if (filter == null) 
        {
            return (Wire [])m_wires.toArray(new Wire[m_wires.size()]);
		} 
        else 
        {
			Filter tempFilter = m_bundleContext.createFilter(filter);
			Iterator iter = m_wires.iterator();
			while (iter.hasNext()) 
            {
				WireImpl currentWire = (WireImpl) iter.next();
				if (tempFilter.match(currentWire.getProperties())) 
                {
					if (res == null)
                    {
						res = new ArrayList();
                    }
					res.add(currentWire);
				}
			}
		}
		if (res == null) 
        {
			return null;
		} 
        else 
        {
            return (Wire [])res.toArray(new Wire[res.size()]);
		}
	}

    /**
     * listens Producer and Consumer services changes
     * @see org.osgi.framework.ServiceListener#serviceChanged(org.osgi.framework.ServiceEvent)
     */
    public void serviceChanged(ServiceEvent e) 
    {
		ServiceReference serviceRef = e.getServiceReference();
		// A consumer service changed
		if (m_consumerFilter.match(serviceRef)) 
        {
			switch (e.getType()) 
            {
                case ServiceEvent.REGISTERED :
                    traceln(""consumer registered"");
                    
                    List wires = new ArrayList();

                    synchronized(m_consumers)
                    {
                        m_consumers.put(serviceRef,wires);
                    }
                    synchronized(m_wires)
                    {
                        Iterator wireIt = m_wires.iterator();
                        boolean called = false;
                        // Iterate over all existing wires
                        while(wireIt.hasNext())
                        {
                            WireImpl currentWire = (WireImpl) wireIt.next();

                            if(currentWire.getConsumerPID().equals(serviceRef.getProperty(Constants.SERVICE_PID)))
                            {
                                // This wire is associated to the newly arrived consumer
                                currentWire.bindConsumer(serviceRef);
                                if(currentWire.isConnected())
                                {
                                    // The wire has been connected, both producer and consumer
                                    // must be updated
                                    wires.add(currentWire);
                                    called = true;
                                    m_asyncMethodCaller.producersConnected(currentWire.getConsumer(),(Wire[])wires.toArray(new Wire[wires.size()]));
                                    List producerWires = (List) m_producers.get(currentWire.getProducerServiceRef());
                                    producerWires.add(currentWire);
                                    m_asyncMethodCaller.consumersConnected(currentWire.getProducer(),(Wire[])producerWires.toArray(new Wire[producerWires.size()]));                                    
                                }
                            }
                        }
                        if(!called)
                        {
                            // P. 329 ""If the Consumer service has no Wire objects attached when it
                            // is registered, the WireAdmin service must always call producersConnected(null)
                            m_asyncMethodCaller.producersConnected((Consumer) m_bundleContext.getService(serviceRef),null);
                        }
                    }
                    break;
                case ServiceEvent.UNREGISTERING :
                    traceln(""consumer unregistering"");
                    
                    synchronized(m_consumers)
                    {
                        m_consumers.remove(serviceRef);
                    }
                    synchronized(m_wires)
                    {
                        Iterator wireIt = m_wires.iterator();
                        while(wireIt.hasNext())
                        {
                            WireImpl currentWire = (WireImpl) wireIt.next();
                            if(currentWire.getConsumerPID().equals(serviceRef.getProperty(Constants.SERVICE_PID)))
                            {
                                // p. 328 ""When a Consumer or Producer service is unregistered
                                // from the OSGi framework, the other object in the association
                                // is informed that the Wire object is no longer valid""

                                if(currentWire.isConnected())
                                {
                                    currentWire.unbindConsumer();                               
                                    List producerWires = (List) m_producers.get(currentWire.getProducerServiceRef());
                                    producerWires.remove(currentWire);
                                    m_asyncMethodCaller.consumersConnected(currentWire.getProducer(),(Wire[])producerWires.toArray(new Wire[producerWires.size()]));
                                }
                                else
                                {
                                    currentWire.unbindConsumer();    
                                }
                            }
                        }
                    }
                    break;
                case ServiceEvent.MODIFIED :
                    // TODO Respond to consumer service modification
                    traceln(""consumer service modified"");
                    break;

            }
        }
        // Removed else to manage services which are both producers AND consumers
		if (m_producerFilter.match(serviceRef)) 
        {
            switch (e.getType()) 
            {
                case ServiceEvent.REGISTERED :
                    traceln(""producer registered"");
                    
                    List wires = new ArrayList();

                    synchronized(m_producers)
                    {
                        m_producers.put(serviceRef,wires);
                    }
                    synchronized(m_wires)
                    {
                        Iterator wireIt = m_wires.iterator();
                        boolean called = false;
                        // Iterate over all existing wires
                        while(wireIt.hasNext())
                        {
                            WireImpl currentWire = (WireImpl) wireIt.next();
                            if(currentWire.getProducerPID().equals(serviceRef.getProperty(Constants.SERVICE_PID)))
                            {
                                // This wire is associated to the newly arrived producer
                                currentWire.bindProducer(serviceRef);
                                if(currentWire.isConnected())
                                {
                                    // The wire has been connected, both producer and consumer
                                    // must be updated
                                    wires.add(currentWire);
                                    called = true;
                                    m_asyncMethodCaller.consumersConnected(currentWire.getProducer(),(Wire[])wires.toArray(new Wire[wires.size()]));
                                    List consumerWires = (List) m_consumers.get(currentWire.getConsumerServiceRef());
                                    consumerWires.add(currentWire);
                                    m_asyncMethodCaller.producersConnected(currentWire.getConsumer(),(Wire[])consumerWires.toArray(new Wire[consumerWires.size()]));                                    
                                }
                            }
                        }
                        if(!called)
                        {
                            // P. 329 ""If the Producer service has no Wire objects attached when it
                            // is registered, the WireAdmin service must always call consumersConnected(null)
                            m_asyncMethodCaller.consumersConnected((Producer) m_bundleContext.getService(serviceRef),null);
                        }
                    }
                    break;
                case ServiceEvent.UNREGISTERING :
                    traceln(""Producer unregistering"");
                    
                    synchronized(m_producers)
                    {
                        m_producers.remove(serviceRef);
                    }
                    synchronized(m_wires)
                    {
                        Iterator wireIt = m_wires.iterator();
                        while(wireIt.hasNext())
                        {
                            WireImpl currentWire = (WireImpl) wireIt.next();
                            if(currentWire.getProducerPID().equals(serviceRef.getProperty(Constants.SERVICE_PID)))
                            {
                                // p. 328 ""When a Consumer or Producer service is unregistered
                                // from the OSGi framework, the other object in the association
                                // is informed that the Wire object is no longer valid""

                                if(currentWire.isConnected())
                                {
                                    currentWire.unbindProducer();                               
                                    List consumerWires = (List) m_consumers.get(currentWire.getConsumerServiceRef());
                                    consumerWires.remove(currentWire);
                                    m_asyncMethodCaller.producersConnected(currentWire.getConsumer(),(Wire[])consumerWires.toArray(new Wire[consumerWires.size()]));
                                }
                                else
                                {
                                    currentWire.unbindProducer();    
                                }
                            }
                        }
                    }
                    break;
                case ServiceEvent.MODIFIED :
                    // TODO Respond to producer service modification
                    traceln(""producer service modified"");
                    break;
            }
        }        
    }


	/**
	 * release all references before stop
	 */
	synchronized void releaseAll() 
    {
        Iterator wireIt = m_wires.iterator();
        while(wireIt.hasNext())
        {
            WireImpl currentWire = (WireImpl) wireIt.next();
            currentWire.invalidate();
        }
        
        Iterator producerIt = m_producers.keySet().iterator();        
        while (producerIt.hasNext())
        {
            ServiceReference producerRef = (ServiceReference) producerIt.next();
            ((Producer)m_bundleContext.getService(producerRef)).consumersConnected(null);            
        }
        
        Iterator consumerIt = m_consumers.keySet().iterator();        
        while (consumerIt.hasNext())
        {
            ServiceReference consumerRef = (ServiceReference) consumerIt.next();
            ((Consumer)m_bundleContext.getService(consumerRef)).producersConnected(null);            
        }

        // Stop the thread
        m_asyncMethodCaller.stop();
        
        // Notify the event manager so that it stops its thread
        m_eventManager.stop();
        
        persistWires();

	}

    /**
     * This method generates a PID. The pid is generated from the bundle id,
     * a hash code from the current time and a counter.
     * 
     * @return a wire PID
     */
    private String generateWirePID()
    {
        Date d = new Date();
        String PID=""wire.""+m_bundleContext.getBundle().getBundleId()+d.hashCode()+m_wireCount;
        m_wireCount ++;
        
        // Maybe the counter should go above 9?
        if(m_wireCount>9)
        {
            m_wireCount = 0;
        }
        return PID;
    }
    
    /**
     * Recover persistent wires 
     *
     */
    private void getPersistentWires()
    {
        
        try
        {
            ObjectInputStream ois = new ObjectInputStream(new FileInputStream(m_bundleContext.getDataFile(""wires.ser"")));
            m_wires = (ArrayList) ois.readObject();
            ois.close();
            if(m_wires!=null)
            {
                traceln(""Deserialized ""+m_wires.size()+"" wires"");
                Iterator wireIt = m_wires.iterator();
                while(wireIt.hasNext())
                {
                    WireImpl currentWire = (WireImpl) wireIt.next();
                    currentWire.initialize(m_bundleContext,m_eventManager);     
                }
            }
            else
            {
                traceln(""Couldn't Deserialize wires"");
                m_wires = new ArrayList();
            }
        }
        catch(FileNotFoundException ex)
        {
            // do not show anything as this exception is thrown every
            // time the wire admin service is launched for the first
            // time
            m_wires = new ArrayList();
        }
        catch(Exception ex)
        {
            trace(ex);
            m_wires = new ArrayList();
        }
    }
    
    /**
     * Persist existing wires
     *
     */
    private void persistWires()
    {
        try
        {
            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(m_bundleContext.getDataFile(""wires.ser"")));
            oos.writeObject(m_wires);
            oos.close();
            traceln(""Serialized ""+m_wires.size()+"" wires"");
        }
        catch(Exception ex)
        {
            trace(ex);
        }
    }

    /**
     * print an error 
     * @param message message to error 
     */
    static void error(String message)
    {
        if (m_errorout != null) 
        {
            m_errorout.println(message);
        }
    }

	/**
	 * print a trace 
	 * @param message message to trace
	 */
	static void traceln(String message)
    {
		if (m_traceout != null) 
        {
			trace(message);
			trace(""\n"");
		}
	}

	/**
	 * print a trace 
	 * @param message message to trace
	 */
	static void trace(String message)
    {
		if (m_traceout != null) 
        {
			m_traceout.print(message);
		}
	}
	/**
	 * print a trace 
	 * @param e exception to trace
	 */
	static void trace(Exception e) 
    {
		if (m_traceout != null) 
        {
			e.printStackTrace(m_traceout);
		}
	}

	/**
	 * Clone a dictionary
	 * 
	 * @param dictionary The dictionary to clone
	 * @return a copy of the dicionary
	 */
    private Dictionary cloneProperties(Dictionary dictionary){
        Dictionary properties=new Hashtable();
        
        if (dictionary == null) {
            properties = new Hashtable();
        } else {
            Enumeration enumeration=dictionary.keys();
            while(enumeration.hasMoreElements()){
                Object key=enumeration.nextElement();
                Object value=dictionary.get(key);
                properties.put(key,value);
            }
        }
        
        return properties;
    }
	
    /**
     * This class enables calls to Producer.consumersConnected and Consumer.producersConnected
     * to be done asynchronously
     * 
     * p.333 ""The WireAdmin service can call the consumersConnected or producersConnected
     * methods during the registration of the consumer of producer service""
     *
    **/
    class AsyncMethodCaller implements Runnable
    {
        private boolean m_stop = false;

        private List m_methodCallStack = new ArrayList();

        public void run()
        {
            while (!m_stop)
            {
                Object nextTarget[] = null;

                synchronized (m_methodCallStack)
                {
                    while (m_methodCallStack.size() == 0)
                    {
                        try
                        {
                            m_methodCallStack.wait();
                        } 
                        catch (InterruptedException ex)
                        {
                            // Ignore.
                        }
                    }
                    nextTarget = (Object[]) m_methodCallStack.remove(0);
                }
                
                if(nextTarget[0] instanceof Producer)
                {
                    try
                    {
                        ((Producer)nextTarget[0]).consumersConnected((Wire[])nextTarget[1]);
                    }
                    catch(Exception ex)
                    {
                        trace(ex);
                    }
                }
                // Removed else because nextTarget can be both producer and consumer                
                if(nextTarget[0] instanceof Consumer)
                {
                    try
                    {
                        ((Consumer)nextTarget[0]).producersConnected((Wire[])nextTarget[1]);
                    }
                    catch(Exception ex)
                    {
                        trace(ex);
                    }
                }
            }
        }

        /**
         * Place a call to Consumer.producersConnected on the stack
         * 
         * @param c the consumer
         * @param wires the wires
         */
        public void producersConnected(Consumer c,Wire []wires)
        {
            synchronized (m_methodCallStack)
            {
                m_methodCallStack.add(new Object[]{c,wires});
                m_methodCallStack.notify();
            }
        }

        /**
         * Place a call to Producer.consumersConnected on the stack
         * 
         * @param p the producer
         * @param wires the wires
         */
        public void consumersConnected(Producer p,Wire []wires)
        {
            synchronized (m_methodCallStack)
            {
                m_methodCallStack.add(new Object[]{p,wires});
                m_methodCallStack.notify();
            }
        }

        /**
         * stop the dispatcher
         *
         */
        void stop()
        {
            m_stop = true;
        }
    }
}
",blob
616,"public final class PostgreSQLDatabaseFunctions {
  /**
   * Local cache for all tables currently in the database This is used to avoid multiple queries to
   * the database if there are > 1 modules in the database.
   */
  protected static Multimap<Pair<CConnection, String>, String> m_cache = HashMultimap.create();

  /**
   * You are not supposed to instantiate this class.
   */
  private PostgreSQLDatabaseFunctions() {
    // You are not supposed to instantiate this class.
  }

  /**
   * Check arguments function to wrap a set of preconditions.
   * 
   * @param provider The provider argument to check.
   * @param debuggerManager The debugger manager argument to check.
   */
  protected static void checkArguments(final AbstractSQLProvider provider,
      final DebuggerTemplateManager debuggerManager) {
    Preconditions.checkNotNull(provider, ""IE00413: Provider argument can not be null"");
    Preconditions.checkNotNull(debuggerManager,
        ""IE01227: Debugger final manager argument can final not be null"");
    Preconditions.checkArgument(debuggerManager.inSameDatabase(provider),
        ""IE00415: Debugger manager is not part of the given database"");
  }

  /**
   * Checks the existence of all necessary raw module tables.
   * 
   * @param connection The connection to the database.
   * @param databaseName The name of the database.
   * @param rawModuleId The ID of the raw module whose tables are checked.
   * @return True, if all necessary tables exist.
   */
  protected static boolean checkRawModulesTables(final CConnection connection,
      final String databaseName, final int rawModuleId) {

    Preconditions.checkNotNull(connection, ""IE02261: Connection argument can not be null"");
    Preconditions.checkNotNull(databaseName, ""IE02262: Database name argument can not be null"");
    Preconditions.checkArgument(rawModuleId > 0,
        ""Raw module id %s must be a positive integer"", rawModuleId);

    final ImmutableSet<String> rawTableNames =
        ImmutableSet.of(String.format(CTableNames.RAW_ADDRESS_COMMENTS_TABLE, rawModuleId),
            String.format(CTableNames.RAW_ADDRESS_REFERENCES_TABLE, rawModuleId),
            String.format(CTableNames.RAW_BASE_TYPES, rawModuleId),
            String.format(CTableNames.RAW_BASIC_BLOCK_INSTRUCTIONS_TABLE, rawModuleId),
            String.format(CTableNames.RAW_BASIC_BLOCKS_TABLE, rawModuleId),
            String.format(CTableNames.RAW_CALLGRAPH_TABLE, rawModuleId),
            String.format(CTableNames.RAW_CONTROL_FLOW_GRAPHS_TABLE, rawModuleId),
            String.format(CTableNames.RAW_EXPRESSION_NODES_TABLE, rawModuleId),
            String.format(CTableNames.RAW_EXPRESSION_SUBSTITUTIONS_TABLE, rawModuleId),
            String.format(CTableNames.RAW_EXPRESSION_TREE_NODES_TABLE, rawModuleId),
            String.format(CTableNames.RAW_EXPRESSION_TREES_TABLE, rawModuleId),
            String.format(CTableNames.RAW_EXPRESSION_TYPES_TABLE, rawModuleId),
            String.format(CTableNames.RAW_FUNCTIONS_TABLE, rawModuleId),
            String.format(CTableNames.RAW_INSTRUCTIONS_TABLE, rawModuleId),
            String.format(CTableNames.RAW_OPERANDS_TABLE, rawModuleId),
            String.format(CTableNames.RAW_SECTIONS, rawModuleId),
            String.format(CTableNames.RAW_EXPRESSION_TYPE_INSTANCES, rawModuleId),
            String.format(CTableNames.RAW_TYPE_INSTACES, rawModuleId),
            String.format(CTableNames.RAW_TYPES, rawModuleId));

    final Pair<CConnection, String> cacheKey = new Pair<>(connection, databaseName);

    if (PostgreSQLDatabaseFunctions.queryCache(cacheKey, rawTableNames)) {
      return true;
    } else {
      if (!PostgreSQLDatabaseFunctions.fillCache(cacheKey)) {
        return false;
      }

      return PostgreSQLDatabaseFunctions.queryCache(cacheKey, rawTableNames);
    }
  }

  /**
   * Fill the local cache of all tables which are in the database.
   * 
   * @return true if the cache could be filled.
   */
  protected static boolean fillCache(final Pair<CConnection, String> cacheKey) {
    PostgreSQLDatabaseFunctions.m_cache.clear();
    
    final String query =
      ""SELECT table_name FROM information_schema.tables  WHERE table_catalog = '""
        + cacheKey.second() + ""' "";
    try (ResultSet result = cacheKey.first().executeQuery(query, true)) {
      while (result.next()) {
        PostgreSQLDatabaseFunctions.m_cache.put(cacheKey, result.getString(1));
      }
    } catch (final SQLException exception) {
      return false;
    }

    return true;
  }

  /**
   * Returns the raw module with the given ID.
   * 
   * @param rawModuleId The ID to search for.
   * @param rawModules The raw modules to search through.
   * @return The raw module with the given ID.
   */
  protected static INaviRawModule findRawModule(final int rawModuleId,
      final List<INaviRawModule> rawModules) {
    Preconditions.checkArgument(rawModuleId > 0,
        ""Raw module id %s must be positive integer"", rawModuleId);
    Preconditions.checkNotNull(rawModules, ""IE02263: raw modules argument can not be null"");

    for (final INaviRawModule rawModule : rawModules) {
      if (rawModule.getId() == rawModuleId) {
        return rawModule;
      }
    }

    throw new IllegalStateException(""IE00160: Could not find raw module"");
  }

  /**
   * Determines the debuggers that are assigned to a project.
   * 
   * @param connection Connection to the SQL database where the information is stored.
   * @param projectId ID of the project in question.
   * @param debuggerManager Debugger manager object that belongs to the given database.
   * @return A list that contains the debugger templates assigned to the given project.
   * @throws CouldntLoadDataException Thrown if the debugger templates could not be loaded.
   */
  protected static List<DebuggerTemplate> getAssignedDebuggers(final CConnection connection,
      final int projectId, final DebuggerTemplateManager debuggerManager)
      throws CouldntLoadDataException {
    Preconditions.checkNotNull(connection, ""IE02264: Connection argument can not be null"");
    Preconditions.checkArgument(projectId > 0, ""Project id %s must be a positive integer."",
        projectId);
    Preconditions.checkNotNull(debuggerManager,
        ""IE02265: debugger manager argument can not be null"");

    final List<DebuggerTemplate> debuggerIds = new ArrayList<>();

    final String query =
        String.format(""SELECT debugger_id FROM %s WHERE project_id = %d"",
            CTableNames.PROJECT_DEBUGGERS_TABLE, projectId);

    try (ResultSet resultSet = connection.executeQuery(query, true)) {
      while (resultSet.next()) {
        debuggerIds.add(debuggerManager.findDebugger(resultSet.getInt(""debugger_id"")));
      }
    } catch (final SQLException exception) {
      throw new CouldntLoadDataException(exception);
    }

    return debuggerIds;
  }

  /**
   * Returns the number of functions in a raw module.
   * 
   * @param connection Connection to the database.
   * @param rawModuleId ID of the raw module.
   * @return The number of functions in the raw module with the given ID.
   * @throws SQLException Thrown if the number of functions could not be determined.
   */
  protected static int getRawModuleFunctionCount(final CConnection connection, final int rawModuleId)
      throws SQLException {
    Preconditions.checkNotNull(connection, ""IE02266: Connection argument can not be null"");
    Preconditions.checkArgument(rawModuleId > 0,
        ""Raw module id %s must be a positive integer"", rawModuleId);
    
    final String query = 
        ""SELECT count(*) AS fcount "" + "" FROM ex_"" + rawModuleId
            + ""_functions "" + "" WHERE address <> 0 "" + "" OR type <> 3"";
            
    try (ResultSet resultSet = connection.executeQuery(query, true)) {
      while (resultSet.next()) {
        return resultSet.getInt(""fcount"");
      }
    return 0;
    } catch (final SQLException exception) {
      throw new SQLException(""Could not load function count"");
    }
  }

  protected static ArrayList<Integer> getRawModuleIDs(final CConnection connection)
      throws SQLException {
    Preconditions.checkNotNull(connection, ""IE02267: Connection argument can not be null"");

    final ArrayList<Integer> rawModuleIDs = new ArrayList<>();
    
    try (ResultSet resultSet = connection.executeQuery(""SELECT id FROM modules"", true)) {
      while (resultSet.next()) {
        rawModuleIDs.add(resultSet.getInt(""id""));
      }
    } catch (final Exception exception) {
      return null;
    }
    return rawModuleIDs;
  }

  /**
   * Queries the local cache of table names.
   * 
   * @param cacheKey the local cache of table names.
   * @param rawTableNames the hash set of tables names for a given raw module.
   * @return true if the cache contains all of the elements in the table names hash set.
   */
  protected static boolean queryCache(final Pair<CConnection, String> cacheKey,
      final ImmutableSet<String> rawTableNames) {
    return PostgreSQLDatabaseFunctions.m_cache.get(cacheKey).containsAll(rawTableNames);
  }

  /**
   * Determines which version the current database has. Each of the checks tries to locate the one
   * database version specific thing that was changed in a version upgrade.
   *
   * @param m_connection The connection to the database.
   * @return A {@link DatabaseVersion} for further processing.
   * @throws CouldntLoadDataException if the version could not be determined.
   * @throws SQLException if the version could not be determined.
   */
  public static DatabaseVersion getDatabaseVersion(final CConnection m_connection)
      throws CouldntLoadDataException, SQLException {

    if (PostgreSQLHelpers.hasTable(m_connection, CTableNames.SECTIONS_TABLE)) {
      return new DatabaseVersion(""6.0.0"");
    }
    if (PostgreSQLHelpers.hasTable(m_connection, CTableNames.USER_TABLE)) {
      return new DatabaseVersion(""5.0.0"");
    }
    if (PostgreSQLHelpers.hasTable(m_connection, CTableNames.RAW_MODULES_TABLE)
        && PostgreSQLHelpers.hasTable(m_connection, CTableNames.MODULES_TABLE)) {
      final ArrayList<Integer> rawModuleIds = getRawModuleIDs(m_connection);
      if (rawModuleIds.isEmpty()) {
        return new DatabaseVersion(""3.0.0"");
      }
      if (PostgreSQLHelpers.hasTable(m_connection, ""ex_"" + rawModuleIds.get(0) + ""_type_structs"")) {
        return new DatabaseVersion(""4.0.0"");
      }
      return new DatabaseVersion(""3.0.0"");
    }
    return new DatabaseVersion(Constants.PROJECT_VERSION);
  }

  /**
   * Loads the modules of a database.
   * 
   * @param provider The SQL provider that provides the connection.
   * @param rawModules Previously loaded raw module objects.
   * @param debuggerManager Debugger manager object that belongs to the given database.
   * 
   * @return A list of modules that contains the modules stored in the database.
   * 
   * @throws CouldntLoadDataException Thrown if the modules could not be loaded from the database.
   */
  public static List<INaviModule> loadModules(final AbstractSQLProvider provider,
      final List<INaviRawModule> rawModules, final DebuggerTemplateManager debuggerManager)
      throws CouldntLoadDataException {
    Preconditions.checkNotNull(rawModules, ""IE02043: rawModules argument can not be null"");
    PostgreSQLDatabaseFunctions.checkArguments(provider, debuggerManager);

    final List<CModule> modules = new ArrayList<>();
    final CConnection connection = provider.getConnection();

    if (!PostgreSQLHelpers.hasTable(connection, CTableNames.MODULES_TABLE)) {
      return new ArrayList<INaviModule>(modules);
    }

    final String query =
        ""SELECT id, raw_module_id, ""
            + CTableNames.MODULES_TABLE
            + "".name, ""
            + "" md5, sha1, description, import_time, modification_date, file_base, image_base, stared, ""
            + "" initialization_state, debugger_id, "" + "" (SELECT count(*) FROM ""
            + CTableNames.FUNCTIONS_TABLE + "" "" + "" WHERE id = "" + CTableNames.FUNCTIONS_TABLE
            + "".module_id) "" + "" AS function_count, "" + "" (SELECT count(*) FROM ""
            + CTableNames.MODULE_VIEWS_TABLE + "" JOIN "" + CTableNames.VIEWS_TABLE
            + "" ON view_id = id "" + "" WHERE type = 'non-native' and module_id = ""
            + CTableNames.MODULES_TABLE + "".id) "" + "" AS view_count FROM ""
            + CTableNames.MODULES_TABLE + "" "" + "" WHERE raw_module_id IS NOT NULL ORDER BY id"";

    try (ResultSet resultSet = connection.executeQuery(query, true)) {
      while (resultSet.next()) {
        final int moduleId = resultSet.getInt(""id"");
        final String name = PostgreSQLHelpers.readString(resultSet, ""name"");
        final String md5 = PostgreSQLHelpers.readString(resultSet, ""md5"");
        final String sha1 = PostgreSQLHelpers.readString(resultSet, ""sha1"");
        final String comment = PostgreSQLHelpers.readString(resultSet, ""description"");
        final Timestamp timestamp = resultSet.getTimestamp(""import_time"");
        final Timestamp modificationDate = resultSet.getTimestamp(""modification_date"");
        int functionCount = resultSet.getInt(""function_count"");
        final int viewCount = resultSet.getInt(""view_count"");
        final IAddress imageBase = PostgreSQLHelpers.loadAddress(resultSet, ""image_base"");
        final IAddress fileBase = PostgreSQLHelpers.loadAddress(resultSet, ""file_base"");
        final int debuggerId = resultSet.getInt(""debugger_id"");
        final boolean isStared = resultSet.getBoolean(""stared"");
        final int initializationState = resultSet.getInt(""initialization_state"");

        final DebuggerTemplate description = debuggerManager.findDebugger(debuggerId);

        final int rawModuleId = resultSet.getInt(""raw_module_id"");
        final INaviRawModule rawModule =
          PostgreSQLDatabaseFunctions.findRawModule(rawModuleId, rawModules);

        if ((functionCount == 0) && (rawModule != null)) {
          functionCount = rawModule.getFunctionCount();
        }

        modules.add(new CModule(moduleId, name, comment, timestamp, modificationDate, md5, sha1,
          functionCount, viewCount, fileBase, imageBase, description, rawModule,
          initializationState, isStared, provider));
      }
    } catch (final SQLException e) {
      throw new CouldntLoadDataException(e);
    }

    return new ArrayList<INaviModule>(modules);
  }

  /**
   * Loads the projects of a database.
   * 
   * @param provider The SQL provider that provides the connection.
   * @param debuggerManager Debugger manager object that belongs to the given database.
   * 
   * @return A list of projects that contains the projects stored in the database.
   * 
   * @throws CouldntLoadDataException Thrown if the projects could not be loaded from the database.
   */
  public static List<INaviProject> loadProjects(final AbstractSQLProvider provider,
      final DebuggerTemplateManager debuggerManager) throws CouldntLoadDataException {
    PostgreSQLDatabaseFunctions.checkArguments(provider, debuggerManager);

    final CConnection connection = provider.getConnection();

    final List<INaviProject> projects = new ArrayList<>();

    if (!PostgreSQLHelpers.hasTable(connection, CTableNames.PROJECTS_TABLE)) {
      return projects;
    }
    
    String query =
          ""SELECT id, name, description, creation_date, modification_date, ""
              + "" (SELECT count(*) FROM "" + CTableNames.ADDRESS_SPACES_TABLE
              + "" WHERE project_id = "" + CTableNames.PROJECTS_TABLE + "".id) ""
              + "" AS addressspace_count FROM "" + CTableNames.PROJECTS_TABLE;
              
    try (ResultSet resultSet = connection.executeQuery(query, true)) {
      while (resultSet.next()) {
        final int projectId = resultSet.getInt(""id"");
        final String name = PostgreSQLHelpers.readString(resultSet, ""name"");
        final String description = PostgreSQLHelpers.readString(resultSet, ""description"");
        final int addressSpaceCount = resultSet.getInt(""addressspace_count"");

        final Timestamp creationDate = resultSet.getTimestamp(""creation_date"");
        final Timestamp modificationDate = resultSet.getTimestamp(""modification_date"");

        final List<DebuggerTemplate> debuggers =
            PostgreSQLDatabaseFunctions.getAssignedDebuggers(connection, projectId,
                debuggerManager);

        projects.add(new CProject(projectId, name, description == null ? """" : description,
            creationDate, modificationDate, addressSpaceCount, debuggers, provider));
      }
    } catch (final SQLException e) {
      throw new CouldntLoadDataException(e);
    }

    return new ArrayList<INaviProject>(projects);
  }

  /**
   * Loads the raw modules of a database.
   * 
   * @param provider The SQL provider that provides the connection.
   * 
   * @return A list of raw modules that contains the raw modules stored in the database.
   * 
   * @throws CouldntLoadDataException Thrown if the raw modules could not be loaded from the
   *         database.
   */
  public static final List<INaviRawModule> loadRawModules(final AbstractSQLProvider provider)
      throws CouldntLoadDataException {
    Preconditions.checkNotNull(provider, ""IE00416: Provider argument can not be null"");

    final CConnection connection = provider.getConnection();

    final List<INaviRawModule> modules = new ArrayList<INaviRawModule>();

    if (!PostgreSQLHelpers.hasTable(connection, CTableNames.RAW_MODULES_TABLE)) {
      return modules;
    }

    final String query = ""SELECT id, name FROM "" + CTableNames.RAW_MODULES_TABLE + "" ORDER BY id"";

    try (ResultSet resultSet = connection.executeQuery(query, true)) {
      while (resultSet.next()) {
        final int rawModuleId = resultSet.getInt(""id"");
        final String name = PostgreSQLHelpers.readString(resultSet, ""name"");

        final boolean isComplete =
            PostgreSQLDatabaseFunctions.checkRawModulesTables(provider.getConnection(),
                PostgreSQLHelpers.getDatabaseName(provider.getConnection()), rawModuleId);

        final int functionCount =
            isComplete ? PostgreSQLDatabaseFunctions.getRawModuleFunctionCount(connection,
                rawModuleId) : 0;

        final CRawModule module =
            new CRawModule(rawModuleId, name, functionCount, isComplete, provider);

        modules.add(module);
      }
    } catch (final SQLException e) {
      throw new CouldntLoadDataException(e);
    }

    return modules;
  }


  /**
   * Performs an update of a postgresql database with the resource passed as argument.
   * 
   * @param connection The connection to the database.
   * @param resource The resource SQL file to perform the update with.
   * @throws CouldntUpdateDatabaseException if the update fails.
   */
  private static void databaseUpdater(final CConnection connection, final String resource)
      throws CouldntUpdateDatabaseException {

    final BufferedReader input =
        new BufferedReader(new InputStreamReader(ClassLoader.getSystemResourceAsStream(resource)));

    final StringBuffer contents = new StringBuffer();
    String line = null;

    try {
      while ((line = input.readLine()) != null) {
        if (line.length() > 0 && line.charAt(0) == '#') {
          continue;
        }

        contents.append(line);
        contents.append('\n');
      }
      input.close();
    } catch (final IOException exception) {
      throw new CouldntUpdateDatabaseException(exception.toString(), 40);
    }

    try (PreparedStatement statement =
          connection.getConnection().prepareStatement(contents.toString())) {
      statement.execute();
    } catch (final SQLException exception) {
      throw new CouldntUpdateDatabaseException(exception.toString(), 41);
    }
  }


  /**
   * Updates a database to the newest version of the database. It determines the current version and
   * then updates accordingly. Supported are all versions since the postgresql move.
   * 
   * @throws CouldntUpdateDatabaseException
   */
  public static void updateDatabase(final SQLProvider provider)
      throws CouldntUpdateDatabaseException {

    try {
      if (provider.getDatabaseVersion().compareTo(new DatabaseVersion(""4.0.0"")) == 0) {
        databaseUpdater(provider.getConnection(), ""com/google/security/zynamics/binnavi/data/""
            + ""postgresql_convert_4_0_7_to_5_0_0.sql"");
        databaseUpdater(provider.getConnection(), ""com/google/security/zynamics/binnavi/data/""
            + ""postgresql_convert_5_0_0_to_5_0_1.sql"");
      } else if (provider.getDatabaseVersion().compareTo(new DatabaseVersion(""5.0.0"")) == 0) {
        databaseUpdater(provider.getConnection(), ""com/google/security/zynamics/binnavi/data/""
            + ""postgresql_convert_5_0_0_to_5_0_1.sql"");
      }
    } catch (final CouldntLoadDataException exception) {
      CUtilityFunctions.logException(exception);
    }
  }
}
",blob
1292,"@XmlType(name = ""remoteProcessGroup"")
public class RemoteProcessGroupDTO extends ComponentDTO {

    private String targetUri;
    private String targetUris;
    private Boolean targetSecure;

    private String name;
    private String comments;
    private String communicationsTimeout;
    private String yieldDuration;
    private String transportProtocol;
    private String localNetworkInterface;
    private String proxyHost;
    private Integer proxyPort;
    private String proxyUser;
    private String proxyPassword;

    private Collection<String> authorizationIssues;
    private Collection<String> validationErrors;
    private Boolean transmitting;

    private Integer inputPortCount;
    private Integer outputPortCount;

    private Integer activeRemoteInputPortCount;
    private Integer inactiveRemoteInputPortCount;
    private Integer activeRemoteOutputPortCount;
    private Integer inactiveRemoteOutputPortCount;

    private Date flowRefreshed;

    private RemoteProcessGroupContentsDTO contents;

    public RemoteProcessGroupDTO() {
        super();
    }

    public RemoteProcessGroupDTO(final RemoteProcessGroupDTO toCopy) {
        setId(toCopy.getId());
        setPosition(toCopy.getPosition());
        targetUri = toCopy.getTargetUri();
        name = toCopy.getName();
    }

    public void setTargetUri(final String targetUri) {
        this.targetUri = targetUri;
    }

    /**
     * @return target uri of this remote process group.
     * If target uri is not set, but uris are set, then returns the first url in the urls.
     * If neither target uri nor uris are set, then returns null.
     */
    @ApiModelProperty(
            value = ""The target URI of the remote process group."" +
                    "" If target uri is not set, but uris are set, then returns the first url in the urls."" +
                    "" If neither target uri nor uris are set, then returns null.""
    )
    public String getTargetUri() {
        if (targetUri == null || targetUri.length() == 0) {
            synchronized (this) {
                if (targetUri == null || targetUri.length() == 0) {
                    if (targetUris != null && targetUris.length() > 0) {
                        if (targetUris.indexOf(',') > -1) {
                            targetUri = targetUris.substring(0, targetUris.indexOf(','));
                        } else {
                            targetUri = targetUris;
                        }
                    }
                }
            }
        }

        return this.targetUri;
    }

    public void setTargetUris(String targetUris) {
        this.targetUris = targetUris;
    }

    /**
     * @return target uris of this remote process group
     * If targetUris was not set but target uri was set, then returns a collection containing the single uri.
     * If neither target uris nor uri were set, then returns null.
     */
    @ApiModelProperty(
            value = ""The target URI of the remote process group."" +
                    "" If target uris is not set but target uri is set,"" +
                    "" then returns a collection containing the single target uri."" +
                    "" If neither target uris nor uris are set, then returns null.""
    )
    public String getTargetUris() {
        if (targetUris == null || targetUris.length() == 0) {
            synchronized (this) {
                if (targetUris == null || targetUris.length() == 0) {
                    targetUris = targetUri;
                }
            }
        }

        return this.targetUris;
    }

    /**
     * @param name of this remote process group
     */
    @ApiModelProperty(
            value = ""The name of the remote process group.""
    )
    public void setName(final String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }

    /**
     * @return Comments for this remote process group
     */
    @ApiModelProperty(
            value = ""The comments for the remote process group.""
    )
    public String getComments() {
        return comments;
    }

    public void setComments(String comments) {
        this.comments = comments;
    }

    /**
     * @return any remote authorization issues for this remote process group
     */
    @ApiModelProperty(
            value = ""Any remote authorization issues for the remote process group.""
    )
    public Collection<String> getAuthorizationIssues() {
        return authorizationIssues;
    }

    public void setAuthorizationIssues(Collection<String> authorizationIssues) {
        this.authorizationIssues = authorizationIssues;
    }

    /**
     * @return whether or not this remote process group is actively transmitting
     */
    @ApiModelProperty(
            value = ""Whether the remote process group is actively transmitting.""
    )
    public Boolean isTransmitting() {
        return transmitting;
    }

    public void setTransmitting(Boolean transmitting) {
        this.transmitting = transmitting;
    }

    /**
     * @return whether or not the target is running securely
     */
    @ApiModelProperty(
            value = ""Whether the target is running securely.""
    )
    public Boolean isTargetSecure() {
        return targetSecure;
    }

    public void setTargetSecure(Boolean targetSecure) {
        this.targetSecure = targetSecure;
    }

    /**
     * @return the time period used for the timeout when communicating with this RemoteProcessGroup
     */
    @ApiModelProperty(
            value = ""The time period used for the timeout when communicating with the target.""
    )
    public String getCommunicationsTimeout() {
        return communicationsTimeout;
    }

    public void setCommunicationsTimeout(String communicationsTimeout) {
        this.communicationsTimeout = communicationsTimeout;
    }

    /**
     * @return when yielding, this amount of time must elapse before this remote process group is scheduled again
     */
    @ApiModelProperty(
            value = ""When yielding, this amount of time must elapse before the remote process group is scheduled again.""
    )
    public String getYieldDuration() {
        return yieldDuration;
    }

    public void setYieldDuration(String yieldDuration) {
        this.yieldDuration = yieldDuration;
    }

    /**
     * @return number of active remote input ports
     */
    @ApiModelProperty(
            value = ""The number of active remote input ports.""
    )
    public Integer getActiveRemoteInputPortCount() {
        return activeRemoteInputPortCount;
    }

    public void setActiveRemoteInputPortCount(Integer activeRemoteInputPortCount) {
        this.activeRemoteInputPortCount = activeRemoteInputPortCount;
    }

    /**
     * @return number of inactive remote input ports
     */
    @ApiModelProperty(
            value = ""The number of inactive remote input ports.""
    )
    public Integer getInactiveRemoteInputPortCount() {
        return inactiveRemoteInputPortCount;
    }

    public void setInactiveRemoteInputPortCount(Integer inactiveRemoteInputPortCount) {
        this.inactiveRemoteInputPortCount = inactiveRemoteInputPortCount;
    }

    /**
     * @return number of active remote output ports
     */
    @ApiModelProperty(
            value = ""The number of active remote output ports.""
    )
    public Integer getActiveRemoteOutputPortCount() {
        return activeRemoteOutputPortCount;
    }

    public void setActiveRemoteOutputPortCount(Integer activeRemoteOutputPortCount) {
        this.activeRemoteOutputPortCount = activeRemoteOutputPortCount;
    }

    /**
     * @return number of inactive remote output ports
     */
    @ApiModelProperty(
            value = ""The number of inactive remote output ports.""
    )
    public Integer getInactiveRemoteOutputPortCount() {
        return inactiveRemoteOutputPortCount;
    }

    public void setInactiveRemoteOutputPortCount(Integer inactiveRemoteOutputPortCount) {
        this.inactiveRemoteOutputPortCount = inactiveRemoteOutputPortCount;
    }

    /**
     * @return number of Remote Input Ports currently available in the remote NiFi instance
     */
    @ApiModelProperty(
            value = ""The number of remote input ports currently available on the target.""
    )
    public Integer getInputPortCount() {
        return inputPortCount;
    }

    public void setInputPortCount(Integer inputPortCount) {
        this.inputPortCount = inputPortCount;
    }

    /**
     * @return number of Remote Output Ports currently available in the remote NiFi instance
     */
    @ApiModelProperty(
            value = ""The number of remote output ports currently available on the target.""
    )
    public Integer getOutputPortCount() {
        return outputPortCount;
    }

    public void setOutputPortCount(Integer outputPortCount) {
        this.outputPortCount = outputPortCount;
    }

    /**
     * @return contents of this remote process group. Will contain available input/output ports
     */
    @ApiModelProperty(
            value = ""The contents of the remote process group. Will contain available input/output ports.""
    )
    public RemoteProcessGroupContentsDTO getContents() {
        return contents;
    }

    public void setContents(RemoteProcessGroupContentsDTO contents) {
        this.contents = contents;
    }

    /**
     * @return the flow for this remote group was last refreshed
     */
    @XmlJavaTypeAdapter(DateTimeAdapter.class)
    @ApiModelProperty(
            value = ""The timestamp when this remote process group was last refreshed."",
            dataType = ""string""
    )
    public Date getFlowRefreshed() {
        return flowRefreshed;
    }

    public void setFlowRefreshed(Date flowRefreshed) {
        this.flowRefreshed = flowRefreshed;
    }

    public String getTransportProtocol() {
        return transportProtocol;
    }

    public void setTransportProtocol(String transportProtocol) {
        this.transportProtocol = transportProtocol;
    }

    @ApiModelProperty(""The local network interface to send/receive data. If not specified, any local address is used. If clustered, all nodes must have an interface with this identifier."")
    public String getLocalNetworkInterface() {
        return localNetworkInterface;
    }

    public void setLocalNetworkInterface(String localNetworkInterface) {
        this.localNetworkInterface = localNetworkInterface;
    }

    @ApiModelProperty(
            ""The validation errors for the remote process group. These validation errors represent the problems with the remote process group that must be resolved before it can transmit.""
    )
    public Collection<String> getValidationErrors() {
        return validationErrors;
    }

    public void setValidationErrors(Collection<String> validationErrors) {
        this.validationErrors = validationErrors;
    }

    public String getProxyHost() {
        return proxyHost;
    }

    public void setProxyHost(String proxyHost) {
        this.proxyHost = proxyHost;
    }

    public Integer getProxyPort() {
        return proxyPort;
    }

    public void setProxyPort(Integer proxyPort) {
        this.proxyPort = proxyPort;
    }

    public String getProxyUser() {
        return proxyUser;
    }

    public void setProxyUser(String proxyUser) {
        this.proxyUser = proxyUser;
    }

    public String getProxyPassword() {
        return proxyPassword;
    }

    public void setProxyPassword(String proxyPassword) {
        this.proxyPassword = proxyPassword;
    }
}
",data class
894,"    public boolean matchesAllInstances(SequenceType testST) {
        Quantifier stq = sequenceType.getQuantifier();
        ItemType it = sequenceType.getItemType();
        if (stq.isSubQuantifier(testST.getQuantifier())) {
            if (it instanceof AnyItemType) {
                return true;
            } else if (it.isAtomicType() && testST.getItemType().isAtomicType()) {
                AtomicType ait = (AtomicType) it;
                AtomicType testIT = (AtomicType) testST.getItemType();
                if (BuiltinTypeRegistry.INSTANCE.isBuiltinTypeId(testIT.getTypeId())) {
                    SchemaType vType = BuiltinTypeRegistry.INSTANCE.getSchemaTypeById(testIT.getTypeId());
                    while (vType != null && vType.getTypeId() != ait.getTypeId()) {
                        vType = vType.getBaseType();
                    }
                    return vType != null;
                }
            } else if (it instanceof NodeType && testST.getItemType() instanceof NodeType) {
                NodeType nt = (NodeType) it;
                NodeKind kind = nt.getNodeKind();
                NodeType testNT = (NodeType) testST.getItemType();
                NodeKind testKind = testNT.getNodeKind();
                if (kind == NodeKind.ANY || kind == testKind) {
                    return true;
                }
            }
            return false;
        }
        return false;
    }
",long method
425,"    public static void main(String[] args) throws IOException {
        try (XSSFWorkbook wb = new XSSFWorkbook()) {
            XSSFSheet sheet = wb.createSheet(""linechart"");
            final int NUM_OF_ROWS = 3;
            final int NUM_OF_COLUMNS = 10;

            // Create a row and put some cells in it. Rows are 0 based.
            Row row;
            Cell cell;
            for (int rowIndex = 0; rowIndex < NUM_OF_ROWS; rowIndex++) {
                row = sheet.createRow((short) rowIndex);
                for (int colIndex = 0; colIndex < NUM_OF_COLUMNS; colIndex++) {
                    cell = row.createCell((short) colIndex);
                    cell.setCellValue(colIndex * (rowIndex + 1.0));
                }
            }

            XSSFDrawing drawing = sheet.createDrawingPatriarch();
            XSSFClientAnchor anchor = drawing.createAnchor(0, 0, 0, 0, 0, 5, 10, 15);

            XSSFChart chart = drawing.createChart(anchor);
            XDDFChartLegend legend = chart.getOrAddLegend();
            legend.setPosition(LegendPosition.TOP_RIGHT);

            // Use a category axis for the bottom axis.
            XDDFCategoryAxis bottomAxis = chart.createCategoryAxis(AxisPosition.BOTTOM);
            bottomAxis.setTitle(""x""); // https://stackoverflow.com/questions/32010765
            XDDFValueAxis leftAxis = chart.createValueAxis(AxisPosition.LEFT);
            leftAxis.setTitle(""f(x)"");
            leftAxis.setCrosses(AxisCrosses.AUTO_ZERO);

            XDDFDataSource<Double> xs = XDDFDataSourcesFactory.fromNumericCellRange(sheet, new CellRangeAddress(0, 0, 0, NUM_OF_COLUMNS - 1));
            XDDFNumericalDataSource<Double> ys1 = XDDFDataSourcesFactory.fromNumericCellRange(sheet, new CellRangeAddress(1, 1, 0, NUM_OF_COLUMNS - 1));
            XDDFNumericalDataSource<Double> ys2 = XDDFDataSourcesFactory.fromNumericCellRange(sheet, new CellRangeAddress(2, 2, 0, NUM_OF_COLUMNS - 1));

            XDDFLineChartData data = (XDDFLineChartData) chart.createData(ChartTypes.LINE, bottomAxis, leftAxis);
            XDDFLineChartData.Series series1 = (XDDFLineChartData.Series) data.addSeries(xs, ys1);
            series1.setTitle(""2x"", null); // https://stackoverflow.com/questions/21855842
            series1.setSmooth(false); // https://stackoverflow.com/questions/29014848
            series1.setMarkerStyle(MarkerStyle.STAR); // https://stackoverflow.com/questions/39636138
            XDDFLineChartData.Series series2 = (XDDFLineChartData.Series) data.addSeries(xs, ys2);
            series2.setTitle(""3x"", null);
            series2.setSmooth(true);
            series2.setMarkerSize((short) 6);
            series2.setMarkerStyle(MarkerStyle.TRIANGLE); // https://stackoverflow.com/questions/39636138
            chart.plot(data);

            // if your series have missing values like https://stackoverflow.com/questions/29014848
            // chart.displayBlanksAs(DisplayBlanks.GAP);

            // https://stackoverflow.com/questions/24676460
            solidLineSeries(data, 0, PresetColor.CHARTREUSE);
            solidLineSeries(data, 1, PresetColor.TURQUOISE);

            // Write the output to a file
            try (FileOutputStream fileOut = new FileOutputStream(""ooxml-line-chart.xlsx"")) {
                wb.write(fileOut);
            }
        }
    }
",long method
702,"public final class ObjectLruCache extends AbstractLruCache {

    /** The array of values */
    Object[] values = new Object[INITIAL_SIZE];

    /**
     * Create a new ObjectLruCache.
     * @param maxSize the maximum size the cache can grow to
     */
    public ObjectLruCache(int maxSize) {
        super(maxSize);
    }

    /**
     * Overridden method to return values array.
     */
    Object getValuesArray() {
        return values;
    }

    /**
     * Overridden method to allocate new values array.
     */
    void allocNewValuesArray(int newSize) {
        super.allocNewValuesArray(newSize);
        values = new Object[newSize];
    }

    /**
     * Overridden method to repopulate with key plus value at given offset.
     */
    void put(long key, Object oldvalues, int offset) {
        Object[] v = (Object[])oldvalues;
        put(key, v[offset]);
    }

    /**
     * Returns the value mapped by the given key. Also promotes this key to the most
     * recently used.
     * @return the value or null if it cannot be found
     */
    public Object get(long key) {
        int index = getIndexAndPromote(key) ;
        if (index != -1) {
            return values[index];
        }
        return null;
    }

    /**
     * Add the key/value pair to the map.
     */
    public void put(long key, Object value) {
        int index = putIndexAndPromote(key) ;
        values[index] = value;
        checkRehash();
    }
}
",data class
547,"    public void send(byte[] data, int length, InetAddress host, int port)
    throws IOException
    {
        _sendPacket.setData(data);
        _sendPacket.setLength(length);
        _sendPacket.setAddress(host);
        _sendPacket.setPort(port);
        _socket_.send(_sendPacket);
    }
",feature envy
408,"	public void run( IAction action )
	{
		if ( !preGenerate( ) )
		{
			return;
		}

		IFile file = getSelectedFile( );
		if ( file != null )
		{
			String url = file.getLocation( ).toOSString( );

			Map options = new HashMap( );
			options.put( WebViewer.RESOURCE_FOLDER_KEY,
					ReportPlugin.getDefault( )
							.getResourceFolder( file.getProject( ) ) );
			options.put( WebViewer.SERVLET_NAME_KEY, WebViewer.VIEWER_DOCUMENT );

			Object adapter = ElementAdapterManager.getAdapter( action,
					IPreviewAction.class );

			if ( adapter instanceof IPreviewAction )
			{
				IPreviewAction delegate = (IPreviewAction) adapter;

				delegate.setProperty( IPreviewConstants.REPORT_PREVIEW_OPTIONS,
						options );
				delegate.setProperty( IPreviewConstants.REPORT_FILE_PATH, url );

				delegate.run( );

				return;
			}

			try
			{
				WebViewer.display( url, options );
			}
			catch ( Exception e )
			{
				ExceptionUtil.handle( e );
				return;
			}
		}
		else
		{
			action.setEnabled( false );
		}
	}
",feature envy
1493,"public abstract class ExternalLoadBalancerDeviceManagerImpl extends AdapterBase implements ExternalLoadBalancerDeviceManager, ResourceStateAdapter {

    @Inject
    NetworkExternalLoadBalancerDao _networkExternalLBDao;
    @Inject
    ExternalLoadBalancerDeviceDao _externalLoadBalancerDeviceDao;
    @Inject
    HostDao _hostDao;
    @Inject
    DataCenterDao _dcDao;
    @Inject
    NetworkModel _networkModel;
    @Inject
    NetworkOrchestrationService _networkMgr;
    @Inject
    InlineLoadBalancerNicMapDao _inlineLoadBalancerNicMapDao;
    @Inject
    NicDao _nicDao;
    @Inject
    AgentManager _agentMgr;
    @Inject
    ResourceManager _resourceMgr;
    @Inject
    IPAddressDao _ipAddressDao;
    @Inject
    VlanDao _vlanDao;
    @Inject
    NetworkOfferingDao _networkOfferingDao;
    @Inject
    AccountDao _accountDao;
    @Inject
    PhysicalNetworkDao _physicalNetworkDao;
    @Inject
    PhysicalNetworkServiceProviderDao _physicalNetworkServiceProviderDao;
    @Inject
    AccountManager _accountMgr;
    @Inject
    UserStatisticsDao _userStatsDao;
    @Inject
    NetworkDao _networkDao;
    @Inject
    DomainRouterDao _routerDao;
    @Inject
    LoadBalancerDao _loadBalancerDao;
    @Inject
    PortForwardingRulesDao _portForwardingRulesDao;
    @Inject
    ConfigurationDao _configDao;
    @Inject
    HostDetailsDao _hostDetailDao;
    @Inject
    NetworkExternalLoadBalancerDao _networkLBDao;
    @Inject
    NetworkServiceMapDao _ntwkSrvcProviderDao;
    @Inject
    NetworkExternalFirewallDao _networkExternalFirewallDao;
    @Inject
    ExternalFirewallDeviceDao _externalFirewallDeviceDao;
    @Inject
    protected HostPodDao _podDao = null;
    @Inject
    IpAddressManager _ipAddrMgr;
    @Inject
    protected
    VirtualMachineManager _itMgr;
    @Inject
    VMInstanceDao _vmDao;
    @Inject
    VMTemplateDao _templateDao;
    @Inject
    ServiceOfferingDao _serviceOfferingDao;
    @Inject
    PhysicalNetworkServiceProviderDao _physicalProviderDao;
    @Inject
    VirtualRouterProviderDao _vrProviderDao;

    private long _defaultLbCapacity;
    private static final org.apache.log4j.Logger s_logger = Logger.getLogger(ExternalLoadBalancerDeviceManagerImpl.class);

    @Override
    @DB
    public ExternalLoadBalancerDeviceVO addExternalLoadBalancer(long physicalNetworkId, String url, String username, String password, final String deviceName,
        ServerResource resource, final boolean gslbProvider, final boolean exclusiveGslbProivider,
        final String gslbSitePublicIp, final String gslbSitePrivateIp) {

        PhysicalNetworkVO pNetwork = null;
        final NetworkDevice ntwkDevice = NetworkDevice.getNetworkDevice(deviceName);
        long zoneId;

        if ((ntwkDevice == null) || (url == null) || (username == null) || (resource == null) || (password == null)) {
            throw new InvalidParameterValueException(""Atleast one of the required parameters (url, username, password,""
                + "" server resource, zone id/physical network id) is not specified or a valid parameter."");
        }

        pNetwork = _physicalNetworkDao.findById(physicalNetworkId);
        if (pNetwork == null) {
            throw new InvalidParameterValueException(""Could not find phyical network with ID: "" + physicalNetworkId);
        }

        zoneId = pNetwork.getDataCenterId();
        PhysicalNetworkServiceProviderVO ntwkSvcProvider =
            _physicalNetworkServiceProviderDao.findByServiceProvider(pNetwork.getId(), ntwkDevice.getNetworkServiceProvder());

        ntwkSvcProvider = _physicalNetworkServiceProviderDao.findByServiceProvider(pNetwork.getId(), ntwkDevice.getNetworkServiceProvder());
        if (ntwkSvcProvider == null) {
            throw new CloudRuntimeException(""Network Service Provider: "" + ntwkDevice.getNetworkServiceProvder() + "" is not enabled in the physical network: "" +
                physicalNetworkId + ""to add this device"");
        } else if (ntwkSvcProvider.getState() == PhysicalNetworkServiceProvider.State.Shutdown) {
            throw new CloudRuntimeException(""Network Service Provider: "" + ntwkSvcProvider.getProviderName() + "" is in shutdown state in the physical network: "" +
                physicalNetworkId + ""to add this device"");
        }

        if (gslbProvider) {
            ExternalLoadBalancerDeviceVO zoneGslbProvider =
                _externalLoadBalancerDeviceDao.findGslbServiceProvider(physicalNetworkId, ntwkDevice.getNetworkServiceProvder());
            if (zoneGslbProvider != null) {
                throw new CloudRuntimeException(""There is a GSLB service provider configured in the zone alredy."");
            }
        }

        URI uri;
        try {
            uri = new URI(url);
        } catch (Exception e) {
            s_logger.debug(e);
            throw new InvalidParameterValueException(e.getMessage());
        }

        String ipAddress = uri.getHost();
        Map hostDetails = new HashMap<String, String>();
        String hostName = getExternalLoadBalancerResourceGuid(pNetwork.getId(), deviceName, ipAddress);
        hostDetails.put(""name"", hostName);
        hostDetails.put(""guid"", UUID.randomUUID().toString());
        hostDetails.put(""zoneId"", String.valueOf(pNetwork.getDataCenterId()));
        hostDetails.put(""ip"", ipAddress);
        hostDetails.put(""physicalNetworkId"", String.valueOf(pNetwork.getId()));
        hostDetails.put(""username"", username);
        hostDetails.put(""password"", password);
        hostDetails.put(""deviceName"", deviceName);

        // leave parameter validation to be part server resource configure
        Map<String, String> configParams = new HashMap<String, String>();
        UrlUtil.parseQueryParameters(uri.getQuery(), false, configParams);
        hostDetails.putAll(configParams);

        try {
            resource.configure(hostName, hostDetails);

            final Host host = _resourceMgr.addHost(zoneId, resource, Host.Type.ExternalLoadBalancer, hostDetails);
            if (host != null) {

                final boolean dedicatedUse =
                    (configParams.get(ApiConstants.LOAD_BALANCER_DEVICE_DEDICATED) != null) ? Boolean.parseBoolean(configParams.get(ApiConstants.LOAD_BALANCER_DEVICE_DEDICATED))
                        : false;
                long capacity = NumbersUtil.parseLong(configParams.get(ApiConstants.LOAD_BALANCER_DEVICE_CAPACITY), 0);
                if (capacity == 0) {
                    capacity = _defaultLbCapacity;
                }

                final long capacityFinal = capacity;
                final PhysicalNetworkVO pNetworkFinal = pNetwork;
                return Transaction.execute(new TransactionCallback<ExternalLoadBalancerDeviceVO>() {
                    @Override
                    public ExternalLoadBalancerDeviceVO doInTransaction(TransactionStatus status) {
                        ExternalLoadBalancerDeviceVO lbDeviceVO =
                            new ExternalLoadBalancerDeviceVO(host.getId(), pNetworkFinal.getId(), ntwkDevice.getNetworkServiceProvder(), deviceName, capacityFinal,
                                dedicatedUse, gslbProvider);
                        if (gslbProvider) {
                            lbDeviceVO.setGslbSitePublicIP(gslbSitePublicIp);
                            lbDeviceVO.setGslbSitePrivateIP(gslbSitePrivateIp);
                            lbDeviceVO.setExclusiveGslbProvider(exclusiveGslbProivider);
                        }
                        _externalLoadBalancerDeviceDao.persist(lbDeviceVO);
                        DetailVO hostDetail = new DetailVO(host.getId(), ApiConstants.LOAD_BALANCER_DEVICE_ID, String.valueOf(lbDeviceVO.getId()));
                        _hostDetailDao.persist(hostDetail);

                        return lbDeviceVO;
                    }
                });
            } else {
                throw new CloudRuntimeException(""Failed to add load balancer device due to internal error."");
            }
        } catch (ConfigurationException e) {
            throw new CloudRuntimeException(e.getMessage());
        }
    }

    @Override
    public boolean deleteExternalLoadBalancer(long hostId) {
        HostVO externalLoadBalancer = _hostDao.findById(hostId);
        if (externalLoadBalancer == null) {
            throw new InvalidParameterValueException(""Could not find an external load balancer with ID: "" + hostId);
        }

        DetailVO lbHostDetails = _hostDetailDao.findDetail(hostId, ApiConstants.LOAD_BALANCER_DEVICE_ID);
        long lbDeviceId = Long.parseLong(lbHostDetails.getValue());

        ExternalLoadBalancerDeviceVO lbDeviceVo = _externalLoadBalancerDeviceDao.findById(lbDeviceId);
        if (lbDeviceVo.getAllocationState() == LBDeviceAllocationState.Provider) {
            // check if cloudstack has provisioned any load balancer appliance on the device before deleting
            List<ExternalLoadBalancerDeviceVO> lbDevices = _externalLoadBalancerDeviceDao.listAll();
            if (lbDevices != null) {
                for (ExternalLoadBalancerDeviceVO lbDevice : lbDevices) {
                    if (lbDevice.getParentHostId() == hostId) {
                        throw new CloudRuntimeException(
                            ""This load balancer device can not be deleted as there are one or more load balancers applainces provisioned by cloudstack on the device."");
                    }
                }
            }
        } else {
            // check if any networks are using this load balancer device
            List<NetworkExternalLoadBalancerVO> networks = _networkLBDao.listByLoadBalancerDeviceId(lbDeviceId);
            if ((networks != null) && !networks.isEmpty()) {
                throw new CloudRuntimeException(""Delete can not be done as there are networks using this load balancer device "");
            }
        }

        try {
            // put the host in maintenance state in order for it to be deleted
            externalLoadBalancer.setResourceState(ResourceState.Maintenance);
            _hostDao.update(hostId, externalLoadBalancer);
            _resourceMgr.deleteHost(hostId, false, false);

            // delete the external load balancer entry
            _externalLoadBalancerDeviceDao.remove(lbDeviceId);

            return true;
        } catch (Exception e) {
            s_logger.debug(e);
            return false;
        }
    }

    @Override
    public List<Host> listExternalLoadBalancers(long physicalNetworkId, String deviceName) {
        List<Host> lbHosts = new ArrayList<Host>();
        NetworkDevice lbNetworkDevice = NetworkDevice.getNetworkDevice(deviceName);
        PhysicalNetworkVO pNetwork = null;

        pNetwork = _physicalNetworkDao.findById(physicalNetworkId);

        if ((pNetwork == null) || (lbNetworkDevice == null)) {
            throw new InvalidParameterValueException(""Atleast one of the required parameter physical networkId, device name is invalid."");
        }

        PhysicalNetworkServiceProviderVO ntwkSvcProvider =
            _physicalNetworkServiceProviderDao.findByServiceProvider(pNetwork.getId(), lbNetworkDevice.getNetworkServiceProvder());
        // if provider not configured in to physical network, then there can be no instances
        if (ntwkSvcProvider == null) {
            return null;
        }

        List<ExternalLoadBalancerDeviceVO> lbDevices =
            _externalLoadBalancerDeviceDao.listByPhysicalNetworkAndProvider(physicalNetworkId, ntwkSvcProvider.getProviderName());
        for (ExternalLoadBalancerDeviceVO provderInstance : lbDevices) {
            lbHosts.add(_hostDao.findById(provderInstance.getHostId()));
        }
        return lbHosts;
    }

    public ExternalLoadBalancerResponse createExternalLoadBalancerResponse(Host externalLoadBalancer) {
        Map<String, String> lbDetails = _hostDetailDao.findDetails(externalLoadBalancer.getId());
        ExternalLoadBalancerResponse response = new ExternalLoadBalancerResponse();
        response.setId(externalLoadBalancer.getUuid());
        response.setIpAddress(externalLoadBalancer.getPrivateIpAddress());
        response.setUsername(lbDetails.get(""username""));
        response.setPublicInterface(lbDetails.get(""publicInterface""));
        response.setPrivateInterface(lbDetails.get(""privateInterface""));
        response.setNumRetries(lbDetails.get(""numRetries""));
        return response;
    }

    public String getExternalLoadBalancerResourceGuid(long physicalNetworkId, String deviceName, String ip) {
        return physicalNetworkId + ""-"" + deviceName + ""-"" + ip;
    }

    @Override
    public ExternalLoadBalancerDeviceVO getExternalLoadBalancerForNetwork(Network network) {
        NetworkExternalLoadBalancerVO lbDeviceForNetwork = _networkExternalLBDao.findByNetworkId(network.getId());
        if (lbDeviceForNetwork != null) {
            long lbDeviceId = lbDeviceForNetwork.getExternalLBDeviceId();
            ExternalLoadBalancerDeviceVO lbDeviceVo = _externalLoadBalancerDeviceDao.findById(lbDeviceId);
            assert (lbDeviceVo != null);
            return lbDeviceVo;
        }
        return null;
    }

    public void setExternalLoadBalancerForNetwork(Network network, long externalLBDeviceID) {
        NetworkExternalLoadBalancerVO lbDeviceForNetwork = new NetworkExternalLoadBalancerVO(network.getId(), externalLBDeviceID);
        _networkExternalLBDao.persist(lbDeviceForNetwork);
    }

    @DB
    protected ExternalLoadBalancerDeviceVO allocateLoadBalancerForNetwork(final Network guestConfig) throws InsufficientCapacityException {
        boolean retry = true;
        boolean tryLbProvisioning = false;
        ExternalLoadBalancerDeviceVO lbDevice = null;
        long physicalNetworkId = guestConfig.getPhysicalNetworkId();
        NetworkOfferingVO offering = _networkOfferingDao.findById(guestConfig.getNetworkOfferingId());
        String provider = _ntwkSrvcProviderDao.getProviderForServiceInNetwork(guestConfig.getId(), Service.Lb);

        while (retry) {
            GlobalLock deviceMapLock = GlobalLock.getInternLock(""LoadBalancerAllocLock"");
            try {
                if (deviceMapLock.lock(120)) {
                    try {
                        final boolean dedicatedLB = offering.isDedicatedLB(); // does network offering supports a dedicated load balancer?

                        try {
                            lbDevice = Transaction.execute(new TransactionCallbackWithException<ExternalLoadBalancerDeviceVO, InsufficientCapacityException>() {
                                @Override
                                public ExternalLoadBalancerDeviceVO doInTransaction(TransactionStatus status) throws InsufficientCapacityException {
                                    // FIXME: should the device allocation be done during network implement phase or do a
                                    // lazy allocation when first rule for the network is configured??

                                    // find a load balancer device for this network as per the network offering
                                    ExternalLoadBalancerDeviceVO lbDevice = findSuitableLoadBalancerForNetwork(guestConfig, dedicatedLB);
                                    long lbDeviceId = lbDevice.getId();

                                    // persist the load balancer device id that will be used for this network. Once a network
                                    // is implemented on a LB device then later on all rules will be programmed on to same device
                                    NetworkExternalLoadBalancerVO networkLB = new NetworkExternalLoadBalancerVO(guestConfig.getId(), lbDeviceId);
                                    _networkExternalLBDao.persist(networkLB);

                                    // mark device to be either dedicated or shared use
                                    lbDevice.setAllocationState(dedicatedLB ? LBDeviceAllocationState.Dedicated : LBDeviceAllocationState.Shared);
                                    _externalLoadBalancerDeviceDao.update(lbDeviceId, lbDevice);
                                    return lbDevice;
                                }
                            });

                            // allocated load balancer for the network, so skip retry
                            tryLbProvisioning = false;
                            retry = false;
                        } catch (InsufficientCapacityException exception) {
                            // if already attempted to provision load balancer then throw out of capacity exception,
                            if (tryLbProvisioning) {
                                retry = false;
                                // TODO: throwing warning instead of error for now as its possible another provider can service this network
                                s_logger.warn(""There are no load balancer device with the capacity for implementing this network"");
                                throw exception;
                            } else {
                                tryLbProvisioning = true; // if possible provision a LB appliance in to the physical network
                            }
                        }
                    } finally {
                        deviceMapLock.unlock();
                    }
                }
            } finally {
                deviceMapLock.releaseRef();
            }

            // there are no LB devices or there is no free capacity on the devices in the physical network so provision a new LB appliance
            if (tryLbProvisioning) {
                // check if LB appliance can be dynamically provisioned
                List<ExternalLoadBalancerDeviceVO> providerLbDevices =
                    _externalLoadBalancerDeviceDao.listByProviderAndDeviceAllocationState(physicalNetworkId, provider, LBDeviceAllocationState.Provider);
                if ((providerLbDevices != null) && (!providerLbDevices.isEmpty())) {
                    for (ExternalLoadBalancerDeviceVO lbProviderDevice : providerLbDevices) {
                        if (lbProviderDevice.getState() == LBDeviceState.Enabled) {
                            // acquire a private IP from the data center which will be used as management IP of provisioned LB appliance,
                            DataCenterIpAddressVO dcPrivateIp = _dcDao.allocatePrivateIpAddress(guestConfig.getDataCenterId(), lbProviderDevice.getUuid());
                            if (dcPrivateIp == null) {
                                throw new InsufficientNetworkCapacityException(""failed to acquire a priavate IP in the zone "" + guestConfig.getDataCenterId() +
                                    "" needed for management IP of the load balancer appliance"", DataCenter.class, guestConfig.getDataCenterId());
                            }
                            Pod pod = _podDao.findById(dcPrivateIp.getPodId());
                            String lbIP = dcPrivateIp.getIpAddress();
                            String netmask = NetUtils.getCidrNetmask(pod.getCidrSize());
                            String gateway = pod.getGateway();

                            // send CreateLoadBalancerApplianceCommand to the host capable of provisioning
                            CreateLoadBalancerApplianceCommand lbProvisionCmd = new CreateLoadBalancerApplianceCommand(lbIP, netmask, gateway);
                            CreateLoadBalancerApplianceAnswer createLbAnswer = null;
                            try {
                                createLbAnswer = (CreateLoadBalancerApplianceAnswer)_agentMgr.easySend(lbProviderDevice.getHostId(), lbProvisionCmd);
                                if (createLbAnswer == null || !createLbAnswer.getResult()) {
                                    s_logger.error(""Could not provision load balancer instance on the load balancer device "" + lbProviderDevice.getId());
                                    continue;
                                }
                            } catch (Exception agentException) {
                                s_logger.error(""Could not provision load balancer instance on the load balancer device "" + lbProviderDevice.getId() + "" due to "" +
                                    agentException.getMessage());
                                continue;
                            }

                            String username = createLbAnswer.getUsername();
                            String password = createLbAnswer.getPassword();
                            String publicIf = createLbAnswer.getPublicInterface();
                            String privateIf = createLbAnswer.getPrivateInterface();

                            // we have provisioned load balancer so add the appliance as cloudstack provisioned external load balancer
                            String dedicatedLb = offering.isDedicatedLB() ? ""true"" : ""false"";
                            String capacity = Long.toString(lbProviderDevice.getCapacity());

                            // acquire a public IP to associate with lb appliance (used as subnet IP to make the appliance part of private network)
                            PublicIp publicIp =
                                _ipAddrMgr.assignPublicIpAddress(guestConfig.getDataCenterId(), null, _accountMgr.getSystemAccount(), VlanType.VirtualNetwork, null,
                                    null, false, false);
                            String publicIPNetmask = publicIp.getVlanNetmask();
                            String publicIPgateway = publicIp.getVlanGateway();
                            String publicIP = publicIp.getAddress().toString();
                            String publicIPVlanTag="""";
                            try {
                                publicIPVlanTag = BroadcastDomainType.getValue(publicIp.getVlanTag());
                            } catch (URISyntaxException e) {
                                s_logger.error(""Failed to parse public ip vlan tag"" + e.getMessage());
                            }

                            String url =
                                ""https://"" + lbIP + ""?publicinterface="" + publicIf + ""&privateinterface="" + privateIf + ""&lbdevicededicated="" + dedicatedLb +
                                    ""&cloudmanaged=true"" + ""&publicip="" + publicIP + ""&publicipnetmask="" + publicIPNetmask + ""&lbdevicecapacity="" + capacity +
                                    ""&publicipvlan="" + publicIPVlanTag + ""&publicipgateway="" + publicIPgateway;
                            ExternalLoadBalancerDeviceVO lbAppliance = null;
                            try {
                                lbAppliance =
                                    addExternalLoadBalancer(physicalNetworkId, url, username, password, createLbAnswer.getDeviceName(),
                                        createLbAnswer.getServerResource(), false, false, null, null);
                            } catch (Exception e) {
                                s_logger.error(""Failed to add load balancer appliance in to cloudstack due to "" + e.getMessage() +
                                    "". So provisioned load balancer appliance will be destroyed."");
                            }

                            if (lbAppliance != null) {
                                // mark the load balancer as cloudstack managed and set parent host id on which lb appliance is provisioned
                                ExternalLoadBalancerDeviceVO managedLb = _externalLoadBalancerDeviceDao.findById(lbAppliance.getId());
                                managedLb.setIsManagedDevice(true);
                                managedLb.setParentHostId(lbProviderDevice.getHostId());
                                _externalLoadBalancerDeviceDao.update(lbAppliance.getId(), managedLb);
                            } else {
                                // failed to add the provisioned load balancer into cloudstack so destroy the appliance
                                DestroyLoadBalancerApplianceCommand lbDeleteCmd = new DestroyLoadBalancerApplianceCommand(lbIP);
                                DestroyLoadBalancerApplianceAnswer answer = null;
                                try {
                                    answer = (DestroyLoadBalancerApplianceAnswer)_agentMgr.easySend(lbProviderDevice.getHostId(), lbDeleteCmd);
                                    if (answer == null || !answer.getResult()) {
                                        s_logger.warn(""Failed to destroy load balancer appliance created"");
                                    } else {
                                        // release the public & private IP back to dc pool, as the load balancer appliance is now destroyed
                                        _dcDao.releasePrivateIpAddress(lbIP, guestConfig.getDataCenterId(), null);
                                        _ipAddrMgr.disassociatePublicIpAddress(publicIp.getId(), _accountMgr.getSystemUser().getId(), _accountMgr.getSystemAccount());
                                    }
                                } catch (Exception e) {
                                    s_logger.warn(""Failed to destroy load balancer appliance created for the network"" + guestConfig.getId() + "" due to "" + e.getMessage());
                                }
                            }
                        }
                    }
                }
            }
        }

        return lbDevice;
    }

    @Override
    public ExternalLoadBalancerDeviceVO findSuitableLoadBalancerForNetwork(Network network, boolean dedicatedLb) throws InsufficientCapacityException {
        long physicalNetworkId = network.getPhysicalNetworkId();
        List<ExternalLoadBalancerDeviceVO> lbDevices = null;
        String provider = _ntwkSrvcProviderDao.getProviderForServiceInNetwork(network.getId(), Service.Lb);
        assert (provider != null);

        if (dedicatedLb) {
            lbDevices = _externalLoadBalancerDeviceDao.listByProviderAndDeviceAllocationState(physicalNetworkId, provider, LBDeviceAllocationState.Free);
            if (lbDevices != null && !lbDevices.isEmpty()) {
                // return first device that is free, fully configured and meant for dedicated use
                for (ExternalLoadBalancerDeviceVO lbdevice : lbDevices) {
                    if (lbdevice.getState() == LBDeviceState.Enabled && lbdevice.getIsDedicatedDevice()) {
                        return lbdevice;
                    }
                }
            }
        } else {
            // get the LB devices that are already allocated for shared use
            lbDevices = _externalLoadBalancerDeviceDao.listByProviderAndDeviceAllocationState(physicalNetworkId, provider, LBDeviceAllocationState.Shared);

            if (lbDevices != null) {

                ExternalLoadBalancerDeviceVO maxFreeCapacityLbdevice = null;
                long maxFreeCapacity = 0;

                // loop through the LB device in the physical network and pick the one with maximum free capacity
                for (ExternalLoadBalancerDeviceVO lbdevice : lbDevices) {

                    // skip if device is not enabled
                    if (lbdevice.getState() != LBDeviceState.Enabled) {
                        continue;
                    }

                    // get the used capacity from the list of guest networks that are mapped to this load balancer
                    List<NetworkExternalLoadBalancerVO> mappedNetworks = _networkExternalLBDao.listByLoadBalancerDeviceId(lbdevice.getId());
                    long usedCapacity = ((mappedNetworks == null) || (mappedNetworks.isEmpty())) ? 0 : mappedNetworks.size();

                    // get the configured capacity for this device
                    long fullCapacity = lbdevice.getCapacity();
                    if (fullCapacity == 0) {
                        fullCapacity = _defaultLbCapacity; // if capacity not configured then use the default
                    }

                    long freeCapacity = fullCapacity - usedCapacity;
                    if (freeCapacity > 0) {
                        if (maxFreeCapacityLbdevice == null) {
                            maxFreeCapacityLbdevice = lbdevice;
                            maxFreeCapacity = freeCapacity;
                        } else if (freeCapacity > maxFreeCapacity) {
                            maxFreeCapacityLbdevice = lbdevice;
                            maxFreeCapacity = freeCapacity;
                        }
                    }
                }

                // return the device with maximum free capacity and is meant for shared use
                if (maxFreeCapacityLbdevice != null) {
                    return maxFreeCapacityLbdevice;
                }
            }

            // if we are here then there are no existing LB devices in shared use or the devices in shared use has no
// free capacity left
            // so allocate a new load balancer configured for shared use from the pool of free LB devices
            lbDevices = _externalLoadBalancerDeviceDao.listByProviderAndDeviceAllocationState(physicalNetworkId, provider, LBDeviceAllocationState.Free);
            if (lbDevices != null && !lbDevices.isEmpty()) {
                for (ExternalLoadBalancerDeviceVO lbdevice : lbDevices) {
                    if (lbdevice.getState() == LBDeviceState.Enabled && !lbdevice.getIsDedicatedDevice()) {
                        return lbdevice;
                    }
                }
            }
        }

        // there are no devices which capacity
        throw new InsufficientNetworkCapacityException(""Unable to find a load balancing provider with sufficient capcity "" + "" to implement the network"", Network.class,
            network.getId());
    }

    @DB
    protected boolean freeLoadBalancerForNetwork(final Network guestConfig) {
        GlobalLock deviceMapLock = GlobalLock.getInternLock(""LoadBalancerAllocLock"");

        try {
            if (deviceMapLock.lock(120)) {
                ExternalLoadBalancerDeviceVO lbDevice = Transaction.execute(new TransactionCallback<ExternalLoadBalancerDeviceVO>() {
                    @Override
                    public ExternalLoadBalancerDeviceVO doInTransaction(TransactionStatus status) {
                        // since network is shutdown remove the network mapping to the load balancer device
                        NetworkExternalLoadBalancerVO networkLBDevice = _networkExternalLBDao.findByNetworkId(guestConfig.getId());
                        long lbDeviceId = networkLBDevice.getExternalLBDeviceId();
                        _networkExternalLBDao.remove(networkLBDevice.getId());

                        List<NetworkExternalLoadBalancerVO> ntwksMapped = _networkExternalLBDao.listByLoadBalancerDeviceId(networkLBDevice.getExternalLBDeviceId());
                        ExternalLoadBalancerDeviceVO lbDevice = _externalLoadBalancerDeviceDao.findById(lbDeviceId);
                        boolean lbInUse = !(ntwksMapped == null || ntwksMapped.isEmpty());
                        boolean lbCloudManaged = lbDevice.getIsManagedDevice();

                        if (!lbInUse && !lbCloudManaged) {
                            // this is the last network mapped to the load balancer device so set device allocation state to be free
                            lbDevice.setAllocationState(LBDeviceAllocationState.Free);
                            _externalLoadBalancerDeviceDao.update(lbDevice.getId(), lbDevice);
                        }

                        // commit the changes before sending agent command to destroy cloudstack managed LB
                        if (!lbInUse && lbCloudManaged) {
                            return lbDevice;
                        } else {
                            return null;
                        }
                    }
                });

                if (lbDevice != null) {
                    // send DestroyLoadBalancerApplianceCommand to the host where load balancer appliance is provisioned
                    Host lbHost = _hostDao.findById(lbDevice.getHostId());
                    String lbIP = lbHost.getPrivateIpAddress();
                    DestroyLoadBalancerApplianceCommand lbDeleteCmd = new DestroyLoadBalancerApplianceCommand(lbIP);
                    DestroyLoadBalancerApplianceAnswer answer = null;
                    try {
                        answer = (DestroyLoadBalancerApplianceAnswer)_agentMgr.easySend(lbDevice.getParentHostId(), lbDeleteCmd);
                        if (answer == null || !answer.getResult()) {
                            s_logger.warn(""Failed to destoy load balancer appliance used by the network""
                                    + guestConfig.getId() + "" due to "" + answer == null ? ""communication error with agent""
                                    : answer.getDetails());
                        }
                    } catch (Exception e) {
                        s_logger.warn(""Failed to destroy load balancer appliance used by the network"" + guestConfig.getId() + "" due to "" + e.getMessage());
                    }

                    if (s_logger.isDebugEnabled()) {
                        s_logger.debug(""Successfully destroyed load balancer appliance used for the network"" + guestConfig.getId());
                    }
                    deviceMapLock.unlock();

                    // remove the provisioned load balancer appliance from cloudstack
                    deleteExternalLoadBalancer(lbHost.getId());

                    // release the private IP back to dc pool, as the load balancer appliance is now destroyed
                    _dcDao.releasePrivateIpAddress(lbHost.getPrivateIpAddress(), guestConfig.getDataCenterId(), null);

                    // release the public IP allocated for this LB appliance
                    DetailVO publicIpDetail = _hostDetailDao.findDetail(lbHost.getId(), ""publicip"");
                    IPAddressVO ipVo = _ipAddressDao.findByIpAndDcId(guestConfig.getDataCenterId(), publicIpDetail.toString());
                    _ipAddrMgr.disassociatePublicIpAddress(ipVo.getId(), _accountMgr.getSystemUser().getId(), _accountMgr.getSystemAccount());
                } else {
                    deviceMapLock.unlock();
                }

                return true;
            } else {
                s_logger.error(""Failed to release load balancer device for the network"" + guestConfig.getId() + ""as failed to acquire lock "");
                return false;
            }
        } catch (Exception exception) {
            s_logger.error(""Failed to release load balancer device for the network"" + guestConfig.getId() + "" due to "" + exception.getMessage());
        } finally {
            deviceMapLock.releaseRef();
        }

        return false;
    }

    private void applyStaticNatRuleForInlineLBRule(DataCenterVO zone, Network network, boolean revoked, String publicIp, String privateIp)
        throws ResourceUnavailableException {
        List<StaticNat> staticNats = new ArrayList<StaticNat>();
        IPAddressVO ipVO = _ipAddressDao.listByDcIdIpAddress(zone.getId(), publicIp).get(0);
        StaticNatImpl staticNat = new StaticNatImpl(ipVO.getAllocatedToAccountId(), ipVO.getAllocatedInDomainId(), network.getId(), ipVO.getId(), privateIp, revoked);
        staticNats.add(staticNat);
        StaticNatServiceProvider element = _networkMgr.getStaticNatProviderForNetwork(network);
        element.applyStaticNats(network, staticNats);
    }

    private enum MappingState {
        Create, Remove, Unchanged,
    };

    private class MappingNic {
        private Nic nic;
        private MappingState state;

        public Nic getNic() {
            return nic;
        }

        public void setNic(Nic nic) {
            this.nic = nic;
        }

        public MappingState getState() {
            return state;
        }

        public void setState(MappingState state) {
            this.state = state;
        }
    };

    private MappingNic getLoadBalancingIpNic(DataCenterVO zone, Network network, long sourceIpId, boolean revoked, String existedGuestIp)
        throws ResourceUnavailableException {
        String srcIp = _networkModel.getIp(sourceIpId).getAddress().addr();
        InlineLoadBalancerNicMapVO mapping = _inlineLoadBalancerNicMapDao.findByPublicIpAddress(srcIp);
        Nic loadBalancingIpNic = null;
        MappingNic nic = new MappingNic();
        nic.setState(MappingState.Unchanged);
        if (!revoked) {
            if (mapping == null) {
                // Acquire a new guest IP address and save it as the load balancing IP address
                String loadBalancingIpAddress = existedGuestIp;

                if (loadBalancingIpAddress == null) {
                    if (network.getGuestType() == Network.GuestType.Isolated) {
                        loadBalancingIpAddress = _ipAddrMgr.acquireGuestIpAddress(network, null);
                    } else if (network.getGuestType() == Network.GuestType.Shared) {
                        try {
                            PublicIp directIp =
                                _ipAddrMgr.assignPublicIpAddress(network.getDataCenterId(), null, _accountDao.findById(network.getAccountId()), VlanType.DirectAttached,
                                    network.getId(), null, true, false);
                            loadBalancingIpAddress = directIp.getAddress().addr();
                        } catch (InsufficientCapacityException capException) {
                            String msg = ""Ran out of guest IP addresses from the shared network."";
                            s_logger.error(msg);
                            throw new ResourceUnavailableException(msg, DataCenter.class, network.getDataCenterId());
                        }
                    }
                }

                if (loadBalancingIpAddress == null) {
                    String msg = ""Ran out of guest IP addresses."";
                    s_logger.error(msg);
                    throw new ResourceUnavailableException(msg, DataCenter.class, network.getDataCenterId());
                }

                // If a NIC doesn't exist for the load balancing IP address, create one
                loadBalancingIpNic = _nicDao.findByIp4AddressAndNetworkId(loadBalancingIpAddress, network.getId());
                if (loadBalancingIpNic == null) {
                    loadBalancingIpNic = _networkMgr.savePlaceholderNic(network, loadBalancingIpAddress, null, null);
                }

                // Save a mapping between the source IP address and the load balancing IP address NIC
                mapping = new InlineLoadBalancerNicMapVO(srcIp, loadBalancingIpNic.getId());
                _inlineLoadBalancerNicMapDao.persist(mapping);

                // On the firewall provider for the network, create a static NAT rule between the source IP
                // address and the load balancing IP address
                try {
                    applyStaticNatRuleForInlineLBRule(zone, network, revoked, srcIp, loadBalancingIpNic.getIPv4Address());
                } catch (ResourceUnavailableException ex) {
                    // Rollback db operation
                    _inlineLoadBalancerNicMapDao.expunge(mapping.getId());
                    _nicDao.expunge(loadBalancingIpNic.getId());
                    throw ex;
                }

                s_logger.debug(""Created static nat rule for inline load balancer"");
                nic.setState(MappingState.Create);
            } else {
                loadBalancingIpNic = _nicDao.findById(mapping.getNicId());
            }
        } else {
            if (mapping != null) {
                // Find the NIC that the mapping refers to
                loadBalancingIpNic = _nicDao.findById(mapping.getNicId());

                int count = _ipAddrMgr.getRuleCountForIp(sourceIpId, Purpose.LoadBalancing, FirewallRule.State.Active);
                if (count == 0) {
                    // On the firewall provider for the network, delete the static NAT rule between the source IP
                    // address and the load balancing IP address
                    applyStaticNatRuleForInlineLBRule(zone, network, revoked, srcIp, loadBalancingIpNic.getIPv4Address());

                    // Delete the mapping between the source IP address and the load balancing IP address
                    _inlineLoadBalancerNicMapDao.expunge(mapping.getId());

                    // Delete the NIC
                    _nicDao.expunge(loadBalancingIpNic.getId());

                    s_logger.debug(""Revoked static nat rule for inline load balancer"");
                    nic.setState(MappingState.Remove);
                }
            } else {
                s_logger.debug(""Revoking a rule for an inline load balancer that has not been programmed yet."");
                nic.setNic(null);
                return nic;
            }
        }

        nic.setNic(loadBalancingIpNic);
        return nic;
    }

    public boolean isNccServiceProvider(Network network) {
        NetworkOffering networkOffering = _networkOfferingDao.findById(network.getNetworkOfferingId());
        if(null!= networkOffering && networkOffering.getServicePackage() != null ) {
            return true;
        }
        else {
            return false;
        }
    }

    public HostVO getNetScalerControlCenterForNetwork(Network guestConfig) {
        long zoneId = guestConfig.getDataCenterId();
        return _hostDao.findByTypeNameAndZoneId(zoneId, ""NetscalerControlCenter"", Type.NetScalerControlCenter);
    }

    @Override
    public boolean applyLoadBalancerRules(Network network, List<LoadBalancingRule> loadBalancingRules) throws ResourceUnavailableException {
        // Find the external load balancer in this zone
        long zoneId = network.getDataCenterId();
        DataCenterVO zone = _dcDao.findById(zoneId);

        if (loadBalancingRules == null || loadBalancingRules.isEmpty()) {
            return true;
        }

        HostVO externalLoadBalancer = null;

        if(isNccServiceProvider(network)) {
            externalLoadBalancer  = getNetScalerControlCenterForNetwork(network);
        } else {
            ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork(network);
            if (lbDeviceVO == null) {
                s_logger.warn(""There is no external load balancer device assigned to this network either network is not implement are already shutdown so just returning"");
                return true;
            } else {
                externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());
            }
        }



        boolean externalLoadBalancerIsInline = _networkMgr.isNetworkInlineMode(network);

        if (network.getState() == Network.State.Allocated) {
            s_logger.debug(""External load balancer was asked to apply LB rules for network with ID "" + network.getId() +
                ""; this network is not implemented. Skipping backend commands."");
            return true;
        }

        List<LoadBalancerTO> loadBalancersToApply = new ArrayList<LoadBalancerTO>();
        List<MappingState> mappingStates = new ArrayList<MappingState>();
        for (int i = 0; i < loadBalancingRules.size(); i++) {
            LoadBalancingRule rule = loadBalancingRules.get(i);

            boolean revoked = (rule.getState().equals(FirewallRule.State.Revoke));
            String protocol = rule.getProtocol();
            String algorithm = rule.getAlgorithm();
            String uuid = rule.getUuid();
            String srcIp = rule.getSourceIp().addr();
            String srcIpVlan = null;
            String srcIpGateway = null;
            String srcIpNetmask = null;
            Long vlanid =  _networkModel.getPublicIpAddress(rule.getSourceIp().addr(), network.getDataCenterId()).getVlanId();
            if(vlanid != null ) {
              VlanVO publicVlan =   _vlanDao.findById(vlanid);
              srcIpVlan =  publicVlan.getVlanTag();
              srcIpGateway = publicVlan.getVlanGateway();
              srcIpNetmask = publicVlan.getVlanNetmask();
            }
            int srcPort = rule.getSourcePortStart();
            List<LbDestination> destinations = rule.getDestinations();

            if (externalLoadBalancerIsInline) {
                long ipId = _networkModel.getPublicIpAddress(rule.getSourceIp().addr(), network.getDataCenterId()).getId();
                MappingNic nic = getLoadBalancingIpNic(zone, network, ipId, revoked, null);
                mappingStates.add(nic.getState());
                Nic loadBalancingIpNic = nic.getNic();
                if (loadBalancingIpNic == null) {
                    continue;
                }

                // Change the source IP address for the load balancing rule to be the load balancing IP address
                srcIp = loadBalancingIpNic.getIPv4Address();
            }

            if ((destinations != null && !destinations.isEmpty()) || rule.isAutoScaleConfig()) {
                boolean inline = _networkMgr.isNetworkInlineMode(network);
                LoadBalancerTO loadBalancer =
                    new LoadBalancerTO(uuid, srcIp, srcPort, protocol, algorithm, revoked, false, inline, destinations, rule.getStickinessPolicies(),
                        rule.getHealthCheckPolicies(), rule.getLbSslCert(), rule.getLbProtocol());
                loadBalancer.setNetworkId(network.getId());
                loadBalancer.setSrcIpVlan(srcIpVlan);
                loadBalancer.setSrcIpNetmask(srcIpNetmask);
                loadBalancer.setSrcIpGateway(srcIpGateway);
                if (rule.isAutoScaleConfig()) {
                    loadBalancer.setAutoScaleVmGroup(rule.getAutoScaleVmGroup());
                }
                loadBalancersToApply.add(loadBalancer);
            }
        }

        try {
            if (loadBalancersToApply.size() > 0) {
                int numLoadBalancersForCommand = loadBalancersToApply.size();
                LoadBalancerTO[] loadBalancersForCommand = loadBalancersToApply.toArray(new LoadBalancerTO[numLoadBalancersForCommand]);
                LoadBalancerConfigCommand cmd = new LoadBalancerConfigCommand(loadBalancersForCommand, null);
                long guestVlanTag = Integer.parseInt(BroadcastDomainType.getValue(network.getBroadcastUri()));
                cmd.setAccessDetail(NetworkElementCommand.GUEST_VLAN_TAG, String.valueOf(guestVlanTag));
                Answer answer = _agentMgr.easySend(externalLoadBalancer.getId(), cmd);
                if (answer == null || !answer.getResult()) {
                    String details = (answer != null) ? answer.getDetails() : ""details unavailable"";
                    String msg = ""Unable to apply load balancer rules to the external load balancer appliance in zone "" + zone.getName() + "" due to: "" + details + ""."";
                    s_logger.error(msg);
                    throw new ResourceUnavailableException(msg, DataCenter.class, network.getDataCenterId());
                }
            }
        } catch (Exception ex) {
            if (externalLoadBalancerIsInline) {
                s_logger.error(""Rollbacking static nat operation of inline mode load balancing due to error on applying LB rules!"");
                String existedGuestIp = loadBalancersToApply.get(0).getSrcIp();
                // Rollback static NAT operation in current session
                for (int i = 0; i < loadBalancingRules.size(); i++) {
                    LoadBalancingRule rule = loadBalancingRules.get(i);
                    MappingState state = mappingStates.get(i);
                    boolean revoke;
                    if (state == MappingState.Create) {
                        revoke = true;
                    } else if (state == MappingState.Remove) {
                        revoke = false;
                    } else {
                        continue;
                    }
                    long sourceIpId = _networkModel.getPublicIpAddress(rule.getSourceIp().addr(), network.getDataCenterId()).getId();
                    getLoadBalancingIpNic(zone, network, sourceIpId, revoke, existedGuestIp);
                }
            }
            throw new ResourceUnavailableException(ex.getMessage(), DataCenter.class, network.getDataCenterId());
        }

        return true;
    }

    @Override
    public boolean manageGuestNetworkWithExternalLoadBalancer(boolean add, Network guestConfig) throws ResourceUnavailableException, InsufficientCapacityException {
        if (guestConfig.getTrafficType() != TrafficType.Guest) {
            s_logger.trace(""External load balancer can only be used for guest networks."");
            return false;
        }

        long zoneId = guestConfig.getDataCenterId();
        DataCenterVO zone = _dcDao.findById(zoneId);
        HostVO externalLoadBalancer = null;

        if (add) {
            ExternalLoadBalancerDeviceVO lbDeviceVO = null;
            // on restart network, device could have been allocated already, skip allocation if a device is assigned
            lbDeviceVO = getExternalLoadBalancerForNetwork(guestConfig);
            if (lbDeviceVO == null) {
                // allocate a load balancer device for the network
                lbDeviceVO = allocateLoadBalancerForNetwork(guestConfig);
                if (lbDeviceVO == null) {
                    String msg = ""failed to alloacate a external load balancer for the network "" + guestConfig.getId();
                    s_logger.error(msg);
                    throw new InsufficientNetworkCapacityException(msg, DataCenter.class, guestConfig.getDataCenterId());
                }
            }
            externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());
            s_logger.debug(""Allocated external load balancer device:"" + lbDeviceVO.getId() + "" for the network: "" + guestConfig.getId());
        } else {
            // find the load balancer device allocated for the network
            ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork(guestConfig);
            if (lbDeviceVO == null) {
                s_logger.warn(""Network shutdwon requested on external load balancer element, which did not implement the network.""
                    + "" Either network implement failed half way through or already network shutdown is completed. So just returning."");
                return true;
            }

            externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());
            assert (externalLoadBalancer != null) : ""There is no device assigned to this network how did shutdown network ended up here??"";
        }

        // Send a command to the external load balancer to implement or shutdown the guest network
        String guestVlanTag = BroadcastDomainType.getValue(guestConfig.getBroadcastUri());
        String selfIp = null;
        String guestVlanNetmask = NetUtils.cidr2Netmask(guestConfig.getCidr());
        Integer networkRate = _networkModel.getNetworkRate(guestConfig.getId(), null);

        if (add) {
            // on restart network, network could have already been implemented. If already implemented then return
            Nic selfipNic = getPlaceholderNic(guestConfig);
            if (selfipNic != null) {
                return true;
            }

            // Acquire a self-ip address from the guest network IP address range
            selfIp = _ipAddrMgr.acquireGuestIpAddress(guestConfig, null);
            if (selfIp == null) {
                String msg = ""failed to acquire guest IP address so not implementing the network on the external load balancer "";
                s_logger.error(msg);
                throw new InsufficientNetworkCapacityException(msg, Network.class, guestConfig.getId());
            }
        } else {
            // get the self-ip used by the load balancer
            Nic selfipNic = getPlaceholderNic(guestConfig);
            if (selfipNic == null) {
                s_logger.warn(""Network shutdwon requested on external load balancer element, which did not implement the network.""
                    + "" Either network implement failed half way through or already network shutdown is completed. So just returning."");
                return true;
            }
            selfIp = selfipNic.getIPv4Address();
        }

        // It's a hack, using isOneToOneNat field for indicate if it's inline or not
        boolean inline = _networkMgr.isNetworkInlineMode(guestConfig);
        IpAddressTO ip =
            new IpAddressTO(guestConfig.getAccountId(), null, add, false, true, guestVlanTag, selfIp, guestVlanNetmask, null, networkRate, inline);
        IpAddressTO[] ips = new IpAddressTO[1];
        ips[0] = ip;
        IpAssocCommand cmd = new IpAssocCommand(ips);
        Answer answer = _agentMgr.easySend(externalLoadBalancer.getId(), cmd);

        if (answer == null || !answer.getResult()) {
            String action = add ? ""implement"" : ""shutdown"";
            String answerDetails = (answer != null) ? answer.getDetails() : null;
            answerDetails = (answerDetails != null) ? "" due to "" + answerDetails : """";
            String msg = ""External load balancer was unable to "" + action + "" the guest network on the external load balancer in zone "" + zone.getName() + answerDetails;
            s_logger.error(msg);
            throw new ResourceUnavailableException(msg, Network.class, guestConfig.getId());
        }

        if (add) {
            // Insert a new NIC for this guest network to reserve the self IP
            _networkMgr.savePlaceholderNic(guestConfig, selfIp, null, null);
        } else {
            // release the self-ip obtained from guest network
            Nic selfipNic = getPlaceholderNic(guestConfig);
            _nicDao.remove(selfipNic.getId());

            // release the load balancer allocated for the network
            boolean releasedLB = freeLoadBalancerForNetwork(guestConfig);
            if (!releasedLB) {
                String msg = ""Failed to release the external load balancer used for the network: "" + guestConfig.getId();
                s_logger.error(msg);
            }
        }

        if (s_logger.isDebugEnabled()) {
            Account account = _accountDao.findByIdIncludingRemoved(guestConfig.getAccountId());
            String action = add ? ""implemented"" : ""shut down"";
            s_logger.debug(""External load balancer has "" + action + "" the guest network for account "" + account.getAccountName() + ""(id = "" + account.getAccountId() +
                "") with VLAN tag "" + guestVlanTag);
        }

        return true;
    }

    @Override
    public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {
        super.configure(name, params);
        _defaultLbCapacity = NumbersUtil.parseLong(_configDao.getValue(Config.DefaultExternalLoadBalancerCapacity.key()), 50);
        _resourceMgr.registerResourceStateAdapter(this.getClass().getSimpleName(), this);
        return true;
    }

    @Override
    public boolean start() {
        return true;
    }

    @Override
    public boolean stop() {
        return true;
    }

    @Override
    public HostVO createHostVOForConnectedAgent(HostVO host, StartupCommand[] cmd) {
        // TODO Auto-generated method stub
        return null;
    }

    @Override
    public HostVO createHostVOForDirectConnectAgent(HostVO host, StartupCommand[] startup, ServerResource resource, Map<String, String> details, List<String> hostTags) {
        if (!(startup[0] instanceof StartupExternalLoadBalancerCommand)) {
            return null;
        }
        if(host.getName().equalsIgnoreCase(""NetScalerControlCenter"")) {
            host.setType(Host.Type.NetScalerControlCenter);
        }
        else {
            host.setType(Host.Type.ExternalLoadBalancer);
        }
        return host;
    }

    @Override
    public DeleteHostAnswer deleteHost(HostVO host, boolean isForced, boolean isForceDeleteStorage) throws UnableDeleteHostException {
        if (host.getType() != com.cloud.host.Host.Type.ExternalLoadBalancer) {
            return null;
        }
        return new DeleteHostAnswer(true);
    }

    protected IpDeployer getIpDeployerForInlineMode(Network network) {
        //We won't deploy IP, instead the firewall in front of us would do it
        List<Provider> providers = _networkMgr.getProvidersForServiceInNetwork(network, Service.Firewall);
        //Only support one provider now
        if (providers == null) {
            s_logger.error(""Cannot find firewall provider for network "" + network.getId());
            return null;
        }
        if (providers.size() != 1) {
            s_logger.error(""Found "" + providers.size() + "" firewall provider for network "" + network.getId());
            return null;
        }

        NetworkElement element = _networkModel.getElementImplementingProvider(providers.get(0).getName());
        if (!(element instanceof IpDeployer)) {
            s_logger.error(""The firewall provider for network "" + network.getName() + "" don't have ability to deploy IP address!"");
            return null;
        }
        s_logger.info(""Let "" + element.getName() + "" handle ip association for "" + getName() + "" in network "" + network.getId());
        return (IpDeployer)element;
    }

    @Override
    public List<LoadBalancerTO> getLBHealthChecks(Network network, List<LoadBalancingRule> loadBalancingRules) throws ResourceUnavailableException {

        // Find the external load balancer in this zone
        long zoneId = network.getDataCenterId();
        DataCenterVO zone = _dcDao.findById(zoneId);

        if (loadBalancingRules == null || loadBalancingRules.isEmpty()) {
            return null;
        }

        HostVO externalLoadBalancer = null;

        if(isNccServiceProvider(network)) {
            externalLoadBalancer  = getNetScalerControlCenterForNetwork(network);
        } else {
            ExternalLoadBalancerDeviceVO lbDeviceVO = getExternalLoadBalancerForNetwork(network);
            if (lbDeviceVO == null) {
                s_logger.warn(""There is no external load balancer device assigned to this network either network is not implement are already shutdown so just returning"");
                return null;
            } else {
                externalLoadBalancer = _hostDao.findById(lbDeviceVO.getHostId());
            }
        }

        boolean externalLoadBalancerIsInline = _networkMgr.isNetworkInlineMode(network);

        if (network.getState() == Network.State.Allocated) {
            s_logger.debug(""External load balancer was asked to apply LB rules for network with ID "" + network.getId() +
                ""; this network is not implemented. Skipping backend commands."");
            return null;
        }

        List<LoadBalancerTO> loadBalancersToApply = new ArrayList<LoadBalancerTO>();
        List<MappingState> mappingStates = new ArrayList<MappingState>();
        for (final LoadBalancingRule rule : loadBalancingRules) {
            boolean revoked = (FirewallRule.State.Revoke.equals(rule.getState()));
            String protocol = rule.getProtocol();
            String algorithm = rule.getAlgorithm();
            String uuid = rule.getUuid();
            String srcIp = rule.getSourceIp().addr();
            int srcPort = rule.getSourcePortStart();
            List<LbDestination> destinations = rule.getDestinations();

            if (externalLoadBalancerIsInline) {
                long sourceIpId = _networkModel.getPublicIpAddress(rule.getSourceIp().addr(), network.getDataCenterId()).getId();
                MappingNic nic = getLoadBalancingIpNic(zone, network, sourceIpId, revoked, null);
                mappingStates.add(nic.getState());
                Nic loadBalancingIpNic = nic.getNic();
                if (loadBalancingIpNic == null) {
                    continue;
                }

                // Change the source IP address for the load balancing rule to
                // be the load balancing IP address
                srcIp = loadBalancingIpNic.getIPv4Address();
            }

            if ((destinations != null && !destinations.isEmpty()) || !rule.isAutoScaleConfig()) {
                boolean inline = _networkMgr.isNetworkInlineMode(network);
                LoadBalancerTO loadBalancer =
                    new LoadBalancerTO(uuid, srcIp, srcPort, protocol, algorithm, revoked, false, inline, destinations, rule.getStickinessPolicies(),
                        rule.getHealthCheckPolicies(), rule.getLbSslCert(), rule.getLbProtocol());
                loadBalancersToApply.add(loadBalancer);
            }
        }

        try {
            if (loadBalancersToApply.size() > 0) {
                int numLoadBalancersForCommand = loadBalancersToApply.size();
                LoadBalancerTO[] loadBalancersForCommand = loadBalancersToApply.toArray(new LoadBalancerTO[numLoadBalancersForCommand]);
                HealthCheckLBConfigCommand cmd = new HealthCheckLBConfigCommand(loadBalancersForCommand, network.getId());
                long guestVlanTag = Integer.parseInt(BroadcastDomainType.getValue(network.getBroadcastUri()));
                cmd.setAccessDetail(NetworkElementCommand.GUEST_VLAN_TAG, String.valueOf(guestVlanTag));

                HealthCheckLBConfigAnswer answer = (HealthCheckLBConfigAnswer) _agentMgr.easySend(externalLoadBalancer.getId(), cmd);
                // easySend will return null on error
                return answer == null ? null : answer.getLoadBalancers();
            }
        } catch (Exception ex) {
            s_logger.error(""Exception Occured "", ex);
        }
        //null return is handled by clients
        return null;
    }

    private NicVO getPlaceholderNic(Network network) {
        List<NicVO> guestIps = _nicDao.listByNetworkId(network.getId());
        for (NicVO guestIp : guestIps) {
            // only external firewall and external load balancer will create NicVO with PlaceHolder reservation strategy
            if (guestIp.getReservationStrategy().equals(ReservationStrategy.PlaceHolder) && guestIp.getVmType() == null && guestIp.getReserver() == null &&
                !guestIp.getIPv4Address().equals(network.getGateway())) {
                return guestIp;
            }
        }
        return null;
    }

}
",blob
635,"public class ExtendedCompletionList {
  private boolean inComplete;
  private List<ExtendedCompletionItem> items;

  public ExtendedCompletionList(boolean incomplete, List<ExtendedCompletionItem> items) {
    this.inComplete = incomplete;
    this.items = items;
  }

  public ExtendedCompletionList() {}

  public List<ExtendedCompletionItem> getItems() {
    return items;
  }

  public void setItems(List<ExtendedCompletionItem> items) {
    this.items = items;
  }

  public boolean isInComplete() {
    return inComplete;
  }

  public void setInComplete(boolean inComplete) {
    this.inComplete = inComplete;
  }
}
",data class
828,"	public class TypeRefWithoutModifiersElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), ""org.eclipse.n4js.ts.TypeExpressions.TypeRefWithoutModifiers"");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Alternatives cAlternatives_0_0 = (Alternatives)cGroup_0.eContents().get(0);
		private final RuleCall cParameterizedTypeRefParserRuleCall_0_0_0 = (RuleCall)cAlternatives_0_0.eContents().get(0);
		private final RuleCall cThisTypeRefParserRuleCall_0_0_1 = (RuleCall)cAlternatives_0_0.eContents().get(1);
		private final Assignment cDynamicAssignment_0_1 = (Assignment)cGroup_0.eContents().get(1);
		private final Keyword cDynamicPlusSignKeyword_0_1_0 = (Keyword)cDynamicAssignment_0_1.eContents().get(0);
		private final RuleCall cTypeTypeRefParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cFunctionTypeExpressionOLDParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cUnionTypeExpressionOLDParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cIntersectionTypeExpressionOLDParserRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		
		//TypeRefWithoutModifiers StaticBaseTypeRef:
		//	(ParameterizedTypeRef | ThisTypeRef) => dynamic?='+'? | TypeTypeRef
		//	| FunctionTypeExpressionOLD
		//	| UnionTypeExpressionOLD
		//	| IntersectionTypeExpressionOLD;
		@Override public ParserRule getRule() { return rule; }
		
		//(ParameterizedTypeRef | ThisTypeRef) => dynamic?='+'? | TypeTypeRef | FunctionTypeExpressionOLD | UnionTypeExpressionOLD
		//| IntersectionTypeExpressionOLD
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//(ParameterizedTypeRef | ThisTypeRef) => dynamic?='+'?
		public Group getGroup_0() { return cGroup_0; }
		
		//ParameterizedTypeRef | ThisTypeRef
		public Alternatives getAlternatives_0_0() { return cAlternatives_0_0; }
		
		//ParameterizedTypeRef
		public RuleCall getParameterizedTypeRefParserRuleCall_0_0_0() { return cParameterizedTypeRefParserRuleCall_0_0_0; }
		
		//ThisTypeRef
		public RuleCall getThisTypeRefParserRuleCall_0_0_1() { return cThisTypeRefParserRuleCall_0_0_1; }
		
		//=> dynamic?='+'?
		public Assignment getDynamicAssignment_0_1() { return cDynamicAssignment_0_1; }
		
		//'+'
		public Keyword getDynamicPlusSignKeyword_0_1_0() { return cDynamicPlusSignKeyword_0_1_0; }
		
		//TypeTypeRef
		public RuleCall getTypeTypeRefParserRuleCall_1() { return cTypeTypeRefParserRuleCall_1; }
		
		//FunctionTypeExpressionOLD
		public RuleCall getFunctionTypeExpressionOLDParserRuleCall_2() { return cFunctionTypeExpressionOLDParserRuleCall_2; }
		
		//UnionTypeExpressionOLD
		public RuleCall getUnionTypeExpressionOLDParserRuleCall_3() { return cUnionTypeExpressionOLDParserRuleCall_3; }
		
		//IntersectionTypeExpressionOLD
		public RuleCall getIntersectionTypeExpressionOLDParserRuleCall_4() { return cIntersectionTypeExpressionOLDParserRuleCall_4; }
	}
",data class
55,"public abstract class TestConfiguration {

	private String downloadUrl;

	private final String description;

	private TestSuite suite;

	public TestConfiguration(String description) {
		this.description = description;
	}

	public String getDownloadUrl() {
		return downloadUrl;
	}

	public void setDownloadUrl(String downloadUrl) {
		this.downloadUrl = downloadUrl;
	}

	public String getDescription() {
		return description;
	}

	@Override
	public String toString() {
		return getClass().getSimpleName() + "" ["" + description + ""]"";
	}

	public TestSuite createSuite(TestSuite parentSuite) {
		suite = new TestSuite(""Testing on "" + getDescription());
		parentSuite.addTest(suite);
		suite.addTest(new Activation(""TestSuite: "" + getDescription(), true));
		return suite;
	}

	public void add(Class<? extends TestCase> clazz) {
		Assert.isNotNull(suite, ""Invoke createSuite() first"");
		suite.addTestSuite(clazz);
	}

	public void done() {
		Assert.isNotNull(suite, ""Invoke createSuite() first"");
		suite.addTest(new Activation(""done"", false));
		suite = null;
	}

	private final class Activation extends TestCase {

		private final boolean activate;

		private Activation(String name, boolean activate) {
			super(name);
			this.activate = activate;
		}

		@Override
		protected void runTest() throws Throwable {
			if (activate) {
				activate();
			}
			else {
				getDefault().activate();
			}
		}

	}

	protected abstract TestConfiguration getDefault();

	public abstract void activate();

	public abstract TestHarness createHarness();

}
",data class
463,"public final class CallResolverDialog extends JDialog {

  /**
   * These panels show the individual steps necessary for resolving indirect calls. They give the
   * user a way to follow the progress of the call resolver operation.
   */
  private final IconPanel[] panels = new IconPanel[] {new IconPanel(""1. Loading target""),
      new IconPanel(""2. Find indirect calls""),
      new IconPanel(""3. Start debugger"", new ResumeButton()), new IconPanel(""4. Set breakpoints""),
      new IconPanel(""5. Resolving breakpoints""), new IconPanel(""6. Stop call resolving"")};

  /**
   * Information about the call resolving progress is printed here.
   */
  private final JTextArea outputArea = new JTextArea();

  /**
   * This button is used to show the resolves functions as a list in the output text field.
   */
  private final JButton listResolvedFunctionsButton =
      new JButton(new ListResolvedFunctionsAction());

  /**
   * This button is used to turn the resolved functions into a graph which is then opened in a new
   * window.
   */
  private final JButton graphResolvedFunctionsButton =
      new JButton(new GraphResolvedFunctionsAction());

  private final JButton portResultsButton = new JButton(new GraphAllFunctionsAction());

  /**
   * Action of the Next button.
   */
  private final NextAction nextAction = new NextAction();

  /**
   * Used to resolve the indirect function calls.
   */
  private final CallResolver callResolver;

  /**
   * Creates a new dialog object.
   *
   * @param parent Parent window of the dialog.
   * @param target The target whose calls are resolved.
   */
  private CallResolverDialog(final JFrame parent, final ICallResolverTarget target) {
    super(parent, ""Call Resolver"");

    assert parent != null;
    assert target != null;

    callResolver = new InternalCallResolver(target, parent);

    setLayout(new BorderLayout());

    add(new LabelPanel(), BorderLayout.NORTH);
    add(new OutputPanel());
    add(new ButtonPanel(), BorderLayout.SOUTH);

    setSize(700, 600);
    setResizable(false);
    setLocationRelativeTo(parent);

    // We need to disable all dialogs to smoothen the lookup.
    Settings.setShowDialogs(false);

    setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);

    addWindowListener(new WindowAdapter() {
      @Override
      public void windowClosed(final WindowEvent e) {
        close();
      }

      @Override
      public void windowClosing(final WindowEvent e) {
        setVisible(false);

        dispose();
      }
    });

    updateGui();
  }

  /**
   * Shows a call resolver dialog.
   *
   * @param parent Parent window of the dialog.
   * @param target The target whose calls are resolved.
   */
  public static void show(final JFrame parent, final ICallResolverTarget target) {
    final CallResolverDialog dialog = new CallResolverDialog(parent, target);

    dialog.setVisible(true);
  }

  /**
   * Adds a line of text to the output panel.
   *
   * @param string The text to add.
   */
  private void appendOutput(final String string) {
    outputArea.setText(outputArea.getText() + string + ""\n"");
    outputArea.setCaretPosition(outputArea.getDocument().getLength());
  }

  private void close() {
    Settings.setShowDialogs(true);

    callResolver.dispose();

    setVisible(false);
  }

  private void graphAllFunctions() {
    new Thread() {
      @Override
      public void run() {
        final View view = OutputGraphGenerator.createCompleteView(
            callResolver.getTarget(), callResolver.getIndirectAddresses(),
            callResolver.getResolvedAddresses());

        final View2D view2d = PluginInterface.instance().showInLastWindow(view);

        view2d.doHierarchicalLayout();

        try {
          view.save();
        } catch (final CouldntSaveDataException e) {
          e.printStackTrace();
        }
      }
    }.start();
  }

  /**
   * Shows the results of the call resolver operation in a new call graph view.
   */
  private void graphResolvedFunctions() {
    new Thread() {
      @Override
      public void run() {
        final View view = OutputGraphGenerator.createLoggedView(
            callResolver.getTarget(), callResolver.getIndirectAddresses(),
            callResolver.getResolvedAddresses());

        final View2D view2d = PluginInterface.instance().showInLastWindow(view);

        view2d.doHierarchicalLayout();

        try {
          view.save();
        } catch (final CouldntSaveDataException e) {
          e.printStackTrace();
        }
      }
    }.start();
  }

  /**
   * Shows the results of the call resolver operation in the text output field.
   */
  private void listResolvedFunctions() {
    outputArea.setText(OutputListGenerator.generate(callResolver.getResolvedAddresses()));

    outputArea.setCaretPosition(0);
  }

  /**
   * Updates the GUI depending on the state of the resolver process.
   */
  private void updateGui() {
    final int currentStep = callResolver.getCurrentStep();

    for (int i = 0; i < panels.length; i++) {
      panels[i].setEnabled(i <= currentStep);
      panels[i].setDone(i < currentStep);
    }

    listResolvedFunctionsButton.setEnabled(currentStep == panels.length);
    graphResolvedFunctionsButton.setEnabled(currentStep == panels.length);
    portResultsButton.setEnabled(currentStep == panels.length);

    nextAction.putValue(Action.NAME, currentStep == panels.length ? ""Reset"" : ""Next"");
  }

  /**
   * This panel contains the Next/Reset and Cancel buttons shown at the bottom of the dialog.
   */
  private class ButtonPanel extends JPanel {

    public ButtonPanel() {
      super(new BorderLayout());
      final JPanel innerButtonPanel = new JPanel(new BorderLayout());

      innerButtonPanel.add(new JButton(nextAction), BorderLayout.WEST);
      innerButtonPanel.add(new JButton(new CancelAction()), BorderLayout.EAST);

      add(innerButtonPanel, BorderLayout.EAST);
    }
  }

  /**
   * Action that is used to close the dialog when the user clicks on the Cancel button.
   */
  private class CancelAction extends AbstractAction {

    public CancelAction() {
      super(""Cancel"");
    }

    @Override
    public void actionPerformed(final ActionEvent e) {
      close();
    }
  }

  /**
   * Action that is used to show all resolver results in a new graph.
   */
  private class GraphAllFunctionsAction extends AbstractAction {

    public GraphAllFunctionsAction() {
      super(""Create complete call graph view"");
    }

    @Override
    public void actionPerformed(final ActionEvent e) {
      graphAllFunctions();
    }
  }

  /**
   * Action that is used to show the resolver results in a new graph.
   */
  private class GraphResolvedFunctionsAction extends AbstractAction {

    public GraphResolvedFunctionsAction() {
      super(""Create limited call graph view"");
    }

    @Override
    public void actionPerformed(final ActionEvent e) {
      graphResolvedFunctions();
    }
  }

  /**
   * Class for displaying the panels that show the progress.
   */
  private static class IconPanel extends JPanel {

    /**
     * Shows text that describes the step.
     */
    private final JLabel textLabel;

    private JComponent additionalComponent;

    /**
     * Image shown when the step is complete.
     */
    private static ImageIcon ACCEPT_IMAGE;

    /**
     * Image shown when the step is active.
     */
    private static ImageIcon BULLET_IMAGE;

    public IconPanel(final String text) {
      this(text, null);
    }

    /**
     * Creates a new panel object.
     *
     * @param text Text that describes the step.
     */
    public IconPanel(final String text, final JComponent additionalComponent) {
      super(new BorderLayout());

      if (ACCEPT_IMAGE == null) {
        try {
          ACCEPT_IMAGE =
              new ImageIcon(CallResolverDialog.class.getResource(""accept.png"").toURI().toURL());
          BULLET_IMAGE = new ImageIcon(
              CallResolverDialog.class.getResource(""bullet_blue.png"").toURI().toURL());
        } catch (MalformedURLException | URISyntaxException e) {
          e.printStackTrace();
        }
      }

      textLabel = new JLabel(text);
      textLabel.setEnabled(false);

      add(textLabel);

      if (additionalComponent != null) {
        this.additionalComponent = additionalComponent;
        add(additionalComponent, BorderLayout.EAST);
      }

      setPreferredSize(new Dimension(200, 20));
    }

    /**
     * Sets a flag that says whether the step is done or not.
     *
     * @param done True, if the step is done. False, if it is not.
     */
    public void setDone(final boolean done) {
      textLabel.setIcon(done ? ACCEPT_IMAGE : BULLET_IMAGE);
    }

    @Override
    public void setEnabled(final boolean enabled) {
      super.setEnabled(enabled);

      if (additionalComponent != null) {
        additionalComponent.setEnabled(enabled);
      }

      textLabel.setEnabled(enabled);
    }
  }

  /**
   * Extended call resolver class that updates the dialog on relevant events.
   */
  private class InternalCallResolver extends CallResolver {
    /**
     * Creates a new call resolver object.
     *
     * @param target The target whose calls are resolved.
     * @param parent
     */
    public InternalCallResolver(final ICallResolverTarget target, final JFrame parent) {
      super(target, parent);
    }

    @Override
    protected void debuggerChanged() {
      appendOutput(""Error: Target debugger changed. Resetting."");

      updateGui();
    }

    @Override
    protected void debuggerClosed() {
      appendOutput(""Target debugger was closed."");

      updateGui();
    }

    @Override
    protected void errorConnectingDebugger(final DebugException e) {
      appendOutput(""Error: Could not start the debugger."");
    }

    @Override
    protected void errorLoadingModule(final Module module, final CouldntLoadDataException e) {
      appendOutput(
          String.format(""Error loading module '%s' (%s)"", module.getName(), e.getMessage()));
    }

    @Override
    protected void errorNoDebugger() {
      appendOutput(""Error: No debugger configured for the selected target."");
    }

    @Override
    protected void errorNotAttached() {
      appendOutput(""Error: The debugger is not attached to the target process."");
    }

    @Override
    protected void errorResuming(final DebugException e) {
      appendOutput(""Error: Debugger could not be resumed after a breakpoint was hit."");
    }

    @Override
    protected void foundIndirectCallAddresses(final List<IndirectCall> indirectCallAddresses) {
      appendOutput(String.format(""Found %d indirect calls"", indirectCallAddresses.size()));

      if (indirectCallAddresses.isEmpty()) {
        appendOutput(""No indirect function calls found: The resolving process is complete"");
      }
    }

    @Override
    protected void resolvedCall(
        final BigInteger lastIndirectCall, final ResolvedFunction resolvedFunction) {
      final Function function = resolvedFunction.getFunction();

      final Address functionAddress =
          function == null ? resolvedFunction.getAddress() : function.getAddress();
      final String functionName =
          function == null ? resolvedFunction.getMemoryModule().getName() + ""!???""
              : function.getModule().getName() + ""!"" + function.getName();

      appendOutput(String.format(""Done resolving: %08X -> %08X (%s)"", lastIndirectCall.longValue(),
          functionAddress.toLong(), functionName));
    }
  }

  /**
   * The upper part of the dialog that contains the progress labels and the results buttons.
   */
  private class LabelPanel extends JPanel {

    public LabelPanel() {
      super(new GridLayout(panels.length + 1, 1));

      for (final IconPanel panel : panels) {
        add(panel);
      }

      final JPanel resultsPanel = new JPanel();

      resultsPanel.add(listResolvedFunctionsButton);
      resultsPanel.add(graphResolvedFunctionsButton);
      resultsPanel.add(portResultsButton);

      add(resultsPanel);

      setBorder(new TitledBorder(""""));
    }
  }

  /**
   * Action class used to show the resolved functions in the output list.
   */
  private class ListResolvedFunctionsAction extends AbstractAction {

    public ListResolvedFunctionsAction() {
      super(""Show resolved functions"");
    }

    @Override
    public void actionPerformed(final ActionEvent e) {
      listResolvedFunctions();
    }
  }

  /**
   * Action class that handles clicks on the Next button.
   */
  private class NextAction extends AbstractAction {

    /**
     * Creates a new action object.
     */
    public NextAction() {
      super(""Next"");
    }

    @Override
    public void actionPerformed(final ActionEvent event) {
      callResolver.next();

      updateGui();
    }
  }

  /**
   * The part of the panel that contains the output field.
   */
  private class OutputPanel extends JPanel {

    public OutputPanel() {
      super(new BorderLayout());

      outputArea.setEditable(false);
      outputArea.setFont(GuiHelper.MONOSPACED_FONT);

      add(new JScrollPane(outputArea));
    }
  }

  /**
   * Action class for the Resume button.
   */
  private class ResumeAction extends AbstractAction {

    public ResumeAction() {
      super(""Resume"");
    }

    @Override
    public void actionPerformed(final ActionEvent event) {
      try {
        callResolver.getTarget().getDebugger().resume();
      } catch (final DebugException exception) {
        appendOutput(
            String.format(""Error: Could not resume the debugger (%s)"", exception.toString()));
      }
    }
  }

  /**
   * Button for resuming the debugger.
   */
  private class ResumeButton extends JButton {

    public ResumeButton() {
      super(new ResumeAction());

      setPreferredSize(new Dimension(100, 20));
    }
  }
}
",blob
431,"public class Scanner {
    private final List<Node> tokens;

    private int currentPosition = 0;

    public Scanner(final List<Node> tokens) {
        this.tokens = tokens;
    }

    public NodeSelect scan() {
        return scanSelect();
    }

    public void checkTail() {
        final int num1 = currentPosition;
        final NodeItem item1 = nextToken();
        if ((item1 != null) && (item1.getNodeType() != NodeType.OPERATION || item1.getValue().length() != 0)) {
            currentPosition = num1;
            throwSyntaxError(SyntaxError.EXPECTING_END_OF_STRING);
        }
    }

    private NodeSelect scanSelect() {
        final Node node1 = ensureToken(NodeType.NAME, ""select"", SyntaxError.EXPECTING_SELECT); //$NON-NLS-1$
        final NodeSelect select1 = new NodeSelect();
        if (scanToken(NodeType.OPERATION, ""*"") != null) //$NON-NLS-1$
        {
            select1.setFields(null);
        } else {
            select1.setFields(scanFieldNameList(false, NodeType.FIELD_LIST));
        }

        while (true) {
            if (scanToken(NodeType.NAME, ""from"") != null) //$NON-NLS-1$
            {
                if (select1.getFrom() != null) {
                    --currentPosition;
                    throwSyntaxError(SyntaxError.DUPLICATE_FROM);
                }
                select1.setFrom(scanTableName());
                continue;
            }

            if (scanToken(NodeType.NAME, ""where"") != null) //$NON-NLS-1$
            {
                if (select1.getWhere() != null) {
                    --currentPosition;
                    throwSyntaxError(SyntaxError.DUPLICATE_WHERE);
                }
                select1.setWhere(scanWhere(select1.getFrom()));
                continue;
            }

            if (scanToken(NodeType.NAME, ""group"") != null) //$NON-NLS-1$
            {
                ensureToken(NodeType.NAME, ""by"", SyntaxError.EXPECTING_BY); //$NON-NLS-1$
                if (select1.getGroupBy() != null) {
                    --currentPosition;
                    throwSyntaxError(SyntaxError.DUPLICATE_GROUP_BY);
                }
                select1.setGroupBy(scanFieldNameList(false, NodeType.GROUP_FIELD_LIST));
                continue;
            }

            if (scanToken(NodeType.NAME, ""order"") != null) //$NON-NLS-1$
            {
                ensureToken(NodeType.NAME, ""by"", SyntaxError.EXPECTING_BY); //$NON-NLS-1$
                if (select1.getOrderBy() != null) {
                    --currentPosition;
                    throwSyntaxError(SyntaxError.DUPLICATE_ORDER_BY);
                }
                select1.setOrderBy(scanFieldNameList(true, NodeType.ORDER_FIELD_LIST));
                continue;
            }

            if (scanToken(NodeType.NAME, ""asof"") != null) //$NON-NLS-1$
            {
                if (select1.getAsOf() != null) {
                    --currentPosition;
                    throwSyntaxError(SyntaxError.DUPLICATE_AS_OF);
                }
                select1.setAsOf(scanValue(select1.getFrom()));
                continue;
            }

            if (scanToken(NodeType.NAME, ""mode"") != null) //$NON-NLS-1$
            {
                if (select1.getMode() != null) {
                    currentPosition--;
                    throwSyntaxError(SyntaxError.DUPLICATE_MODE);
                }
                select1.setMode(ScanMode());
                continue;
            }

            select1.setStartOffset(node1.getStartOffset());
            select1.setEndOffset(((NodeItem) tokens.get(tokens.size() - 1)).getEndOffset());
            return select1;
        }
    }

    private Node scanWhere(final NodeTableName table) {
        return scanCondition4(table);
    }

    private Node scanCondition4(final NodeTableName table) {
        Node node1 = scanCondition3(table);
        NodeOrOperator operator1 = null;
        while (true) {
            Node node2 = scanToken(NodeType.NAME, ""or""); //$NON-NLS-1$
            if (node2 == null) {
                node2 = scanToken(NodeType.OPERATION, ""||""); //$NON-NLS-1$
            }
            if (node2 == null) {
                break;
            }
            if (operator1 == null) {
                operator1 = new NodeOrOperator();
                operator1.add(node1);
            }
            operator1.add(scanCondition3(table));
        }
        if (operator1 != null) {
            operator1.setStartOffset(operator1.getItem(0).getStartOffset());
            operator1.setEndOffset(operator1.getItem(operator1.getCount() - 1).getEndOffset());
            node1 = operator1;
        }
        return node1;
    }

    private Node scanCondition3(final NodeTableName table) {
        Node node1 = scanCondition2(table);
        NodeAndOperator operator1 = null;
        while (true) {
            Node node2 = scanToken(NodeType.NAME, ""and""); //$NON-NLS-1$
            if (node2 == null) {
                node2 = scanToken(NodeType.OPERATION, ""&&""); //$NON-NLS-1$
            }
            if (node2 == null) {
                break;
            }
            if (operator1 == null) {
                operator1 = new NodeAndOperator();
                operator1.add(node1);
            }
            operator1.add(scanCondition2(table));
        }
        if (operator1 != null) {
            operator1.setStartOffset(operator1.getItem(0).getStartOffset());
            operator1.setEndOffset(operator1.getItem(operator1.getCount() - 1).getEndOffset());
            node1 = operator1;
        }
        return node1;
    }

    private Node scanCondition2(final NodeTableName table) {
        Node node1 = scanToken(NodeType.NAME, ""not""); //$NON-NLS-1$
        if (node1 == null) {
            node1 = scanToken(NodeType.OPERATION, ""!""); //$NON-NLS-1$
        }
        if (node1 != null) {
            final Node node2 = scanCondition2(table);
            final Node node3 = new NodeNotOperator(node2);
            node3.setStartOffset(node1.getStartOffset());
            node3.setEndOffset(node2.getEndOffset());
            return node3;
        }
        node1 = scanToken(NodeType.NAME, ""ever""); //$NON-NLS-1$
        if (node1 != null) {
            final Node node4 = scanCondition2(table);
            final Node node5 = new NodeEverOperator(node4);
            node5.setStartOffset(node1.getStartOffset());
            node5.setEndOffset(node4.getEndOffset());
            return node5;
        }
        node1 = scanToken(NodeType.NAME, ""never""); //$NON-NLS-1$
        if (node1 != null) {
            final Node node6 = scanCondition2(table);
            final Node node7 = new NodeNotOperator(new NodeEverOperator(node6));
            node7.setStartOffset(node1.getStartOffset());
            node7.setEndOffset(node6.getEndOffset());
            return node7;
        }
        return scanCondition1(table);
    }

    private Node scanCondition1(final NodeTableName table) {
        final Node node1 = scanToken(NodeType.OPERATION, ""(""); //$NON-NLS-1$
        if (node1 != null) {
            final Node node2 = scanWhere(table);
            final Node node3 = ensureToken(NodeType.OPERATION, "")"", SyntaxError.EXPECTING_LEFT_BRACKET); //$NON-NLS-1$
            node2.setStartOffset(node1.getStartOffset());
            node2.setEndOffset(node3.getEndOffset());
            node2.setHasParantheses(true);
            return node2;
        }
        final NodeCondition condition1 = new NodeCondition();
        Node node4 = condition1;
        condition1.setLeft(scanFieldName(table));
        final Stack<NodeType> stack1 = new Stack<NodeType>();

        while (true) {
            if (scanToken(NodeType.NAME, ""not"") != null) //$NON-NLS-1$
            {
                stack1.push(NodeType.NOT);
                continue;
            }

            if (scanToken(NodeType.NAME, ""ever"") != null) //$NON-NLS-1$
            {
                stack1.push(NodeType.EVER);
                continue;
            }

            if (scanToken(NodeType.NAME, ""never"") != null) //$NON-NLS-1$
            {
                stack1.push(NodeType.NOT);
                stack1.push(NodeType.EVER);
                continue;
            }

            break;
        }

        while (true) {
            if (stack1.size() <= 0) {
                condition1.setCondition(scanConditionOperator(node4 != condition1));
                if (condition1.getCondition() == Condition.NONE) {
                    throwSyntaxError(SyntaxError.EXPECTING_COMPARISON_OPERATOR);
                }
                if (condition1.getCondition() == Condition.GROUP) {
                    condition1.setRight(scanValue(table));
                } else if (condition1.getCondition() == Condition.IN) {
                    final Node node5 = ensureToken(NodeType.OPERATION, ""("", SyntaxError.EXPECTING_LEFT_BRACKET); //$NON-NLS-1$
                    final Node node6 = scanValueList(table);
                    final Node node7 = ensureToken(NodeType.OPERATION, "")"", SyntaxError.EXPECTING_RIGHT_BRACKET); //$NON-NLS-1$
                    node6.setStartOffset(node5.getStartOffset());
                    node6.setEndOffset(node7.getEndOffset());
                    condition1.setRight(node6);
                } else if (condition1.getCondition() == Condition.UNDER) {
                    condition1.setRight(scanValue(table));
                } else {
                    Node node8 = TryScanFieldName();
                    if (node8 == null) {
                        node8 = TryScanExpression();
                    }
                    if (node8 != null) {
                        condition1.setRight(node8);
                    } else {
                        throwSyntaxError(SyntaxError.EXPECTING_FIELD_OR_EXPRESSION);
                    }
                }
                node4.setStartOffset(condition1.getLeft().getStartOffset());
                node4.setEndOffset(condition1.getRight().getEndOffset());
                return node4;
            }

            final NodeType nodeType = stack1.pop();
            if (nodeType == NodeType.NOT) {
                node4 = new NodeNotOperator(node4);
            } else if (nodeType == NodeType.EVER) {
                node4 = new NodeEverOperator(node4);
            }
        }
    }

    private Node scanValueList(final NodeTableName table) {
        final NodeValueList list1 = new NodeValueList();
        do {
            list1.add(scanExpression(table));
        } while (scanToken(NodeType.OPERATION, "","") != null); //$NON-NLS-1$
        list1.setStartOffset(list1.getItem(0).getStartOffset());
        list1.setEndOffset(list1.getItem(list1.getCount() - 1).getEndOffset());
        return list1;
    }

    private Node scanValue(final NodeTableName table) {
        final Node node = TryScanSingleValue();
        if (node == null) {
            throwSyntaxError(SyntaxError.EXPECTING_VALUE);
        }
        return node;
    }

    private Node scanExpression(final NodeTableName nodeTable) {
        final Node node = TryScanExpression();
        if (node == null) {
            throwSyntaxError(SyntaxError.EXPECTING_VALUE);
            return null;
        }
        return node;
    }

    private Condition scanConditionOperator(final boolean afterNotOrEver) {
        final int num1 = currentPosition;
        final NodeItem item1 = nextToken();
        if ((item1 != null)
            && ((item1.getNodeType() == NodeType.NAME)
                || ((item1.getNodeType() == NodeType.OPERATION) && !afterNotOrEver))) {
            Condition condition1 = ConditionalOperators.find(item1.getValue());

            if (condition1 == Condition.IN && scanToken(NodeType.NAME, ""group"") != null) //$NON-NLS-1$
            {
                condition1 = Condition.GROUP;
            } else if (condition1 == Condition.CONTAINS && scanToken(NodeType.NAME, ""words"") != null) //$NON-NLS-1$
            {
                condition1 = Condition.CONTAINS_WORDS;
            }

            if (condition1 != Condition.NONE) {
                return condition1;
            }
        }
        currentPosition = num1;
        if (!afterNotOrEver) {
            return Condition.NONE;
        }
        return Condition.EQUALS;
    }

    private NodeTableName scanTableName() {
        final int savedCurrentPosition = currentPosition;
        final NodeItem tokenNode = nextToken();
        if (tokenNode != null && tokenNode.getNodeType() == NodeType.NAME) {
            return new NodeTableName((NodeName) tokenNode);
        }
        currentPosition = savedCurrentPosition;
        throwSyntaxError(SyntaxError.EXPECTING_TABLE_NAME);
        return null;
    }

    // direction is true if each field name in the field name list can be
    // suffixed by an optional
    // direction indicator - asc or desc
    private NodeFieldList scanFieldNameList(final boolean direction, final NodeType nodeType) {
        final NodeFieldList fieldListNode = new NodeFieldList(nodeType);
        while (true) {
            final NodeFieldName fieldNameNode = scanFieldName(null);
            if (direction) {
                if (scanToken(NodeType.NAME, ""asc"") != null) //$NON-NLS-1$
                {
                    fieldNameNode.setDirection(Direction.ASCENDING);
                } else if (scanToken(NodeType.NAME, ""desc"") != null) //$NON-NLS-1$
                {
                    fieldNameNode.setDirection(Direction.DESCENDING);
                }
            }
            fieldListNode.add(fieldNameNode);

            /*
             * if the next token is not a comma operator, then the field list is
             * finished
             */
            if (scanToken(NodeType.OPERATION, "","") == null) //$NON-NLS-1$
            {
                if (fieldListNode.getCount() != 0) {
                    /*
                     * if the field list node is not empty, set it's start and
                     * end offset by using the starting and ending node in the
                     * list
                     */
                    fieldListNode.setStartOffset(fieldListNode.getItem(0).getStartOffset());
                    fieldListNode.setEndOffset(fieldListNode.getItem(fieldListNode.getCount() - 1).getEndOffset());
                }
                return fieldListNode;
            }
        }
    }

    private NodeFieldName scanFieldName(final NodeTableName table) {
        final Node node = TryScanFieldName();
        if (node != null) {
            return (NodeFieldName) node;
        }
        throwSyntaxError(SyntaxError.EXPECTING_FIELD_NAME);
        return null;
    }

    private NodeMode ScanMode() {
        ensureToken(NodeType.OPERATION, ""("", SyntaxError.EXPECTING_LEFT_BRACKET); //$NON-NLS-1$
        final NodeMode mode = new NodeMode();
        do {
            final int pos = currentPosition;
            final NodeItem item = nextToken();
            if ((item == null) || !(item.getNodeType().equals(NodeType.NAME))) {
                currentPosition = pos;
                throwSyntaxError(SyntaxError.EXPECTING_MODE);
                return null;
            }
            mode.add(item);
        } while (scanToken(NodeType.OPERATION, "","") != null); //$NON-NLS-1$
        ensureToken(NodeType.OPERATION, "")"", SyntaxError.EXPECTING_RIGHT_BRACKET); //$NON-NLS-1$
        mode.setStartOffset(mode.getItem(0).getStartOffset());
        mode.setEndOffset(mode.getItem(mode.getCount() - 1).getEndOffset());
        return mode;
    }

    private NodeItem ensureToken(final NodeType type, final String str, final SyntaxError syntaxError) {
        final NodeItem tokenNode = scanToken(type, str);
        if (tokenNode == null) {
            throwSyntaxError(syntaxError);
        }
        return tokenNode;
    }

    private void throwSyntaxError(final SyntaxError error) {
        NodeItem causeNode = null;
        if (currentPosition < tokens.size()) {
            causeNode = (NodeItem) tokens.get(currentPosition);
        }
        throw new SyntaxException(causeNode, error);
    }

    private NodeItem scanToken(final NodeType type, final String str) {
        final int savedCurrentPosition = currentPosition;
        final NodeItem tokenNode = nextToken();
        if (tokenNode != null && tokenNode.getNodeType() == type && str.equalsIgnoreCase(tokenNode.getValue())) {
            return tokenNode;
        }
        currentPosition = savedCurrentPosition;
        return null;
    }

    private NodeItem nextToken() {
        if (currentPosition < tokens.size()) {
            return (NodeItem) tokens.get(currentPosition++);
        }
        return null;
    }

    private Node TryScanExpression() {
        int num;
        Node node = TryScanSingleValue();
        if (node == null) {
            return null;
        }
        while (true) {
            num = currentPosition;
            final NodeItem item = nextToken();
            if (item != null) {
                Arithmetic none = Arithmetic.NONE;
                Node node2 = null;
                if (item.getNodeType() == NodeType.NUMBER) {
                    none = ArithmeticalOperators.find(item.getValue().substring(0, 1));
                    if (none != Arithmetic.NONE) {
                        item.setValue(item.getValue().substring(1));
                        node2 = item;
                    }
                } else if (item.getNodeType() == NodeType.OPERATION) {
                    none = ArithmeticalOperators.find(item.getValue());
                    if (none != Arithmetic.NONE) {
                        node2 = TryScanSingleValue();
                    }
                }
                if ((none != Arithmetic.NONE) && (node2 != null)) {
                    final NodeArithmetic arithmetic2 = new NodeArithmetic();
                    arithmetic2.setArithmetic(none);
                    arithmetic2.setLeft(node);
                    arithmetic2.setRight(node2);
                    arithmetic2.setStartOffset(arithmetic2.getLeft().getStartOffset());
                    arithmetic2.setEndOffset(arithmetic2.getRight().getEndOffset());
                    node = arithmetic2;
                    continue;
                }
            }
            currentPosition = num;
            return node;
        }
    }

    private Node TryScanFieldName() {
        Node node = null;
        final int pos = currentPosition;
        final Node node2 = nextToken();
        if ((node2 != null) && (node2.getNodeType() == NodeType.NAME)) {
            final NodeItem item = scanToken(NodeType.OPERATION, "".""); //$NON-NLS-1$
            Node node3 = null;
            if (item != null) {
                node3 = nextToken();
                if ((node3 != null) && (node3.getNodeType() == NodeType.NAME)) {
                    node = new NodeFieldName((NodeName) node2, (NodeName) node3);
                }
            } else {
                node = new NodeFieldName((NodeName) node2);
            }
        }
        if (node == null) {
            currentPosition = pos;
            return null;
        }
        return node;
    }

    private Node TryScanSingleValue() {
        final int pos = currentPosition;
        final Node node2 = nextToken();
        if ((node2 != null)
            && (((node2.getNodeType() == NodeType.NUMBER) || (node2.getNodeType() == NodeType.STRING))
                || ((node2.getNodeType() == NodeType.VARIABLE) || (node2.getNodeType() == NodeType.BOOL_VALUE)))) {
            return node2;
        }
        currentPosition = pos;
        return null;
    }

}
",blob
991,"public class DimsDataList implements Serializable {

	
	/**
	 * 
	 */
	private static final long serialVersionUID = -5902704017223885965L;
	
	
	private List<DimsData> dimsData;

	private boolean        expression;
		
	public DimsDataList() {
	}

	public DimsDataList(List<DimsData> chunk) {
		dimsData = chunk;
	}
	
	public DimsDataList(int[] dataShape) throws Exception {
		
		try {
						
			// For now we just assume the first dimensions are the slow ones to make an axis out
			// of. Later read the axis from the meta list but we do not have examples of this so
			// far.
			int xaxis=-1,yaxis=-1;
			for (int i = 0; i<dataShape.length; ++i) {
				add(new DimsData(i));
			}
			for (int i = dataShape.length-1; i>=0; i--) {
				
				if (dataShape[i]>1) {
					if (yaxis<0) {
						getDimsData(i).setPlotAxis(AxisType.Y);
						yaxis = i;
						continue;
					} else  if (xaxis<0) {
						getDimsData(i).setPlotAxis(AxisType.X);
						xaxis = i;
						continue;
					}
				}
			}
			
			// If we only found a y it may be a multiple-dimension set with only 1D possible.
			// In that case change y to x.
			if (yaxis>-1 && xaxis<0) {
				getDimsData(yaxis).setPlotAxis(AxisType.X);
			}
		} finally {
			//file.close();
		}
	}

	public Iterable<DimsData> iterable() {
		return dimsData;
	}
	
	public void add(DimsData dimension) {
		if (dimsData==null) dimsData = new ArrayList<DimsData>(3);
		if (dimsData.size()>dimension.getDimension() && dimension.getDimension()>-1) {
			dimsData.set(dimension.getDimension(), dimension);
		} else {
			dimsData.add(dimension);
		}
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((dimsData == null) ? 0 : dimsData.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		DimsDataList other = (DimsDataList) obj;
		if (dimsData == null) {
			if (other.dimsData != null)
				return false;
		} else if (!dimsData.equals(other.dimsData))
			return false;
		return true;
	}

	public static Object[] getDefault() {
		return new DimsData[]{new DimsData(0)};
	}
	
	public Object[] getElements() {
		if (dimsData==null) return null;
		return dimsData.toArray(new DimsData[dimsData.size()]);
	}

	public int size() {
		if (dimsData==null) return 0;
		return dimsData.size();
	}

	public DimsData getDimsData(int i) {
		if (dimsData==null) return null;
		return dimsData.get(i);
	}

	public Iterator<DimsData> iterator() {
		if (dimsData==null) return null;
		return dimsData.iterator();
	}
	
	public void clear() {
		if (dimsData!=null) dimsData.clear();
	}
	
	public String toString() {
		return toString(null);
	}
	public String toString(int[] shape) {
		
		final StringBuilder buf = new StringBuilder();
		buf.append(""[ "");
		
		int index = 0;
		for (DimsData d : dimsData) {
			
			final int upper = shape!=null ? shape[index] : -1;
			buf.append(d.getUserString(upper));
			if (d!=dimsData.get(dimsData.size()-1)) buf.append("",  "");
			++index;
		}
		buf.append("" ]"");
		return buf.toString();
	}

	public boolean isRangeDefined() {
		for (DimsData data : iterable()) {
			if (data.getSliceRange()!=null) return true;
		}
		return false;
	}
	
	public int getAxisCount() {
		if (dimsData==null) return -1;
		int count = 0;
		for (DimsData dd : dimsData) {
			if (!dd.getPlotAxis().hasValue()) count++;
		}
		return count;
	}
	
	public int getRangeCount() {
		int count = 0;
		for (DimsData dd : dimsData) {
			if (dd.getPlotAxis()==AxisType.RANGE) count++;
		}
		return count;
	}

	public boolean is2D() {
		return getAxisCount()==2;
	}
	
	public DimsDataList clone() {
		final DimsDataList clone = new DimsDataList();
		for (DimsData dd : iterable()) {
			DimsData dnew = dd.clone();
			clone.add(dnew);
		}
		clone.expression = expression;
		return clone;
	}

	/**
	 * Sets any axes there are to  the axis passed in
	 */
	public void normalise(AxisType axis) {
		for (DimsData dd : iterable()) {
			if (!dd.getPlotAxis().hasValue()) dd.setPlotAxis(axis);
		}
	}

	/**
	 * Probably not best algorithm but we are dealing with very small arrays here.
	 * This is simply trying to ensure that only one dimension is selected as an
	 * axis because the plot has changed.
	 * 
	 * @param iaxisToFind
	 */
	public void setSingleAxisOnly(AxisType iaxisToFind, AxisType iaxisValue) {
		DimsData found = null;
		for (DimsData dd : iterable()) {
			if (dd.getPlotAxis()==iaxisToFind) {
				dd.setPlotAxis(iaxisValue);
				found=dd;
			}
		}
		
		if (found!=null) {
			for (DimsData dd : iterable()) {
				if (dd==found) continue;
				dd.setPlotAxis(AxisType.SLICE);
			}
			return;
		} else { // We have to decide which of the others is x
			
			for (DimsData dd : iterable()) {
				if (!dd.getPlotAxis().hasValue()) {
				    dd.setPlotAxis(iaxisValue);
				    found=dd;
				}
			}
			for (DimsData dd : iterable()) {
				if (dd==found) continue;
				dd.setPlotAxis(AxisType.SLICE);
			}
		}
	}

	/**
	 * Bit of a complex  method. It simply tries to leave the data with
	 * two axes selected by finding the most likely two dimensions that
	 * should be plot axes.
	 * 
	 * @param firstAxis
	 * @param secondAxis
	 */
	public void setTwoAxesOnly(AxisType firstAxis, AxisType secondAxis) {
		boolean foundFirst = false, foundSecond = false;
		for (DimsData dd : iterable()) {
			if (dd.getPlotAxis()==firstAxis)  foundFirst  = true;
			if (dd.getPlotAxis()==secondAxis) foundSecond = true;
		}
		
		if (foundFirst&&foundSecond) {
			for (DimsData dd : iterable()) {
				if (dd.getPlotAxis()==firstAxis)  continue;
				if (dd.getPlotAxis()==secondAxis) continue;
				if (dd.getPlotAxis()==AxisType.RANGE) continue;
				dd.setPlotAxis(AxisType.SLICE);
			}
			return;
		} else { // We have to decide which of the others is first and second
			
			if (!foundFirst)  foundFirst  = processAxis(firstAxis, secondAxis);
			if (!foundSecond) foundSecond = processAxis(secondAxis, firstAxis);
			
			for (DimsData dd : iterable()) {
				if (dd.getPlotAxis()==firstAxis)  continue;
				if (dd.getPlotAxis()==secondAxis) continue;
				if (dd.getPlotAxis()==AxisType.RANGE) continue;
				dd.setPlotAxis(AxisType.SLICE);
			}
			return;
				
		}
		
	}
	
	/**
	 * Bit of a complex  method. It simply tries to leave the data with
	 * two axes selected by finding the most likely two dimensions that
	 * should be plot axes.
	 * 
	 * @param firstAxis
	 * @param secondAxis
	 * @param thirdAxis
	 */
	public void setThreeAxesOnly(AxisType firstAxis, AxisType secondAxis, AxisType thirdAxis) {

		boolean foundFirst = false, foundSecond = false, foundThird = false;
		for (DimsData dd : iterable()) {
			if (dd.getPlotAxis()==firstAxis)  foundFirst  = true;
			if (dd.getPlotAxis()==secondAxis) foundSecond = true;
			if (dd.getPlotAxis()==thirdAxis)  foundThird  = true;
		}
		
		if (foundFirst&&foundSecond&&foundThird) {
			for (DimsData dd : iterable()) {
				if (dd.getPlotAxis()==firstAxis)  continue;
				if (dd.getPlotAxis()==secondAxis) continue;
				if (dd.getPlotAxis()==thirdAxis)  continue;
				if (dd.getPlotAxis()==AxisType.RANGE) continue;
				dd.setPlotAxis(AxisType.SLICE);
			}
			return;
		} else { // We have to decide which of the others is first and second
			
			if (!foundFirst)  foundFirst  = processAxis(firstAxis,  secondAxis, thirdAxis);
			if (!foundSecond) foundSecond = processAxis(secondAxis, firstAxis,  thirdAxis);
			if (!foundThird)  foundThird  = processAxis(thirdAxis,  firstAxis,  secondAxis);
			
			for (DimsData dd : iterable()) {
				if (dd.getPlotAxis()==firstAxis)  continue;
				if (dd.getPlotAxis()==secondAxis) continue;
				if (dd.getPlotAxis()==thirdAxis)  continue;
				if (dd.getPlotAxis()==AxisType.RANGE) continue;
				dd.setPlotAxis(AxisType.SLICE);
			}
			return;
				
		}

	}

	
	private final boolean processAxis(AxisType axis, AxisType... ignoredAxes) {
		
		final List<Object> ignored = asList(ignoredAxes);
		for (DimsData dd : iterable()) {
			if (!dd.getPlotAxis().hasValue() && !ignored.contains(dd.getPlotAxis())) {
			    dd.setPlotAxis(axis);
			    return true;
			}
		}	
		
		for (DimsData dd : iterable()) {
			if (!ignored.contains(dd.getPlotAxis())) {
				dd.setPlotAxis(axis);
				return true;
			}
		}
		
		return false;
	}
	
	/**
	 * Convert a primitive array to a list.
	 * @param array - an array of primitives
	 * @return
	 */
	@SuppressWarnings(""unchecked"")
    private static final <T> List<T> asList(final Object array) {
		
        if (!array.getClass().isArray()) throw new IllegalArgumentException(""Not an array"");
        return new AbstractList<T>() {
            @Override
            public T get(int index) {
                return (T) Array.get(array, index);
            }

            @Override
            public int size() {
                return Array.getLength(array);
            }
        };
    }

	public boolean isXFirst() {
		for (DimsData dd : iterable()) {
			if (dd.getPlotAxis().hasValue()) continue;
			return dd.getPlotAxis()==AxisType.X;
		}
		return false;
	}

	public void reverseImage() {
		for (DimsData dd : iterable()) {
			if (dd.getPlotAxis()==AxisType.X) {
				dd.setPlotAxis(AxisType.Y);
				continue;
			}
			
			if (dd.getPlotAxis()==AxisType.Y) {
				dd.setPlotAxis(AxisType.X);
				continue;
			}
		}
	}

	public boolean isExpression() {
		return expression;
	}

	public void setExpression(boolean expression) {
		this.expression = expression;
	}

	public boolean isEmpty() {
		return dimsData==null || dimsData.isEmpty();
	}

	public boolean isAdvanced() {
		for (DimsData dd : iterable()) {
            if (dd.getPlotAxis().isAdvanced()) return true;
		}
		return false;
	}

	/**
	 * DO NOT USE THIS IS FOR XML SERLIALIZATION
	 * @return
	 */
	public List<DimsData> getDimsData() {
		return dimsData;
	}

	/**
	 * DO NOT USE THIS IS FOR XML SERLIALIZATION
	 * @return
	 */
	public void setDimsData(List<DimsData> dimsData) {
		this.dimsData = dimsData;
	}

	public void removeLargeStacks(ISliceSystem slicingSystem, int maxStack) {
		
		for (DimsData dd : getDimsData()) {
			if (dd.getPlotAxis().isStack(slicingSystem)) {
				if (dd.getSliceRange(true)==null || """".equals(dd.getSliceRange(true)) || ""all"".equals(dd.getSliceRange(true))) {
					final ILazyDataset lz = slicingSystem.getData().getLazySet();
					if (lz!=null) {
						final int size = lz.getShape()[dd.getDimension()];
						if (size>=maxStack) { // We set a default slice
							dd.setSliceRange(""0:25"");
						}
					}
				}
			}
		}
		
	}

	public Slice[] toSliceArray(int[] dataShape) {
		
		final Slice[] ret = new Slice[size()];
		for (int i = 0; i < size(); i++) {
			DimsData dd = getDimsData(i);			
			if (dd.isSlice()) {
				ret[i] = new Slice(dd.getSlice(), dd.getSlice()+1);
			} else {
				ret[i] = new Slice(dataShape[dd.getDimension()]);
			}
		}
		return ret;	
	}

	/**
	 * Export to Map from DimsDataList
	 * @return
	 */
	public Map<Integer, String> toMap() {
		final Map<Integer, String> ret = new HashMap<Integer, String>(size());
		for (DimsData dd : iterable()) {
			if (dd.isSlice()) {
				ret.put(dd.getDimension(), String.valueOf(dd.getSlice()));
			} else if (dd.isTextRange()) {
				ret.put(dd.getDimension(), dd.getSliceRange()!=null ? dd.getSliceRange() : ""all"");
			} else if ( dd.getPlotAxis()!=null){
				ret.put(dd.getDimension(), dd.getPlotAxis().getName());
			}
		}
	    return ret;
	}

    /**
     * Set the current DimsDataList to what is defined in the pass in map.
     * @param map
     * @param shape
     */
	public void fromMap(Map<Integer, String> map, int[] shape) {
		
		clear();
		
		for (int i = 0; i < shape.length; i++) {
			add(new DimsData(i));
		}

		if (map.isEmpty()) { // Make one up
			getDimsData(0).setSliceRange(""all"");
			if (size()==2) {
				getDimsData(1).setPlotAxis(AxisType.X);

			} else if (size()>2) {
				getDimsData(1).setPlotAxis(AxisType.Y);
				getDimsData(2).setPlotAxis(AxisType.X);
				for (int i = 3; i < size(); i++) {
					getDimsData(i).setSlice(0);
				}
			}

		} else { // Init one from map saved

			int dim = 0;
			
			for (DimsData dd : iterable()) {
				String value = map.get(dd.getDimension());
				if (value==null) value = map.get(String.valueOf(dd.getDimension()));
				if (value!=null) {
					if (""all"".equals(value)) {
						dd.setPlotAxis(AxisType.RANGE);
						continue;
					}
					
					AxisType at = AxisType.forLabel(value);
					if (at!=null) {
						dd.setPlotAxis(at);
						continue;
					}
					
					try {
						dd.setSlice(Integer.parseInt(value));
					} catch (Exception ne) {
						dd.setSliceRange(value);
					}
				} else {
					AxisType type = AxisType.forAxis(dim);
					dd.setPlotAxis(type);
					++dim;
				}
			}

		}
		
	}

}
",blob
1110,"  public boolean equals(TListSentryPrivilegesRequest that) {
    if (that == null)
      return false;

    boolean this_present_protocol_version = true;
    boolean that_present_protocol_version = true;
    if (this_present_protocol_version || that_present_protocol_version) {
      if (!(this_present_protocol_version && that_present_protocol_version))
        return false;
      if (this.protocol_version != that.protocol_version)
        return false;
    }

    boolean this_present_requestorUserName = true && this.isSetRequestorUserName();
    boolean that_present_requestorUserName = true && that.isSetRequestorUserName();
    if (this_present_requestorUserName || that_present_requestorUserName) {
      if (!(this_present_requestorUserName && that_present_requestorUserName))
        return false;
      if (!this.requestorUserName.equals(that.requestorUserName))
        return false;
    }

    boolean this_present_roleName = true && this.isSetRoleName();
    boolean that_present_roleName = true && that.isSetRoleName();
    if (this_present_roleName || that_present_roleName) {
      if (!(this_present_roleName && that_present_roleName))
        return false;
      if (!this.roleName.equals(that.roleName))
        return false;
    }

    boolean this_present_authorizableHierarchy = true && this.isSetAuthorizableHierarchy();
    boolean that_present_authorizableHierarchy = true && that.isSetAuthorizableHierarchy();
    if (this_present_authorizableHierarchy || that_present_authorizableHierarchy) {
      if (!(this_present_authorizableHierarchy && that_present_authorizableHierarchy))
        return false;
      if (!this.authorizableHierarchy.equals(that.authorizableHierarchy))
        return false;
    }

    return true;
  }
",long method
1051,"@Generated(""com.amazonaws:aws-java-sdk-code-generator"")
public class ListKeysResult extends com.ibm.cloud.objectstorage.AmazonWebServiceResult<com.ibm.cloud.objectstorage.ResponseMetadata> implements Serializable, Cloneable {

    /**
     * <p>
     * A list of keys.
     * </p>
     */
    private com.ibm.cloud.objectstorage.internal.SdkInternalList<KeyListEntry> keys;
    /**
     * <p>
     * When <code>Truncated</code> is true, this element is present and contains the value to use for the
     * <code>Marker</code> parameter in a subsequent request.
     * </p>
     */
    private String nextMarker;
    /**
     * <p>
     * A flag that indicates whether there are more items in the list. When this value is true, the list in this
     * response is truncated. To retrieve more items, pass the value of the <code>NextMarker</code> element in this
     * response to the <code>Marker</code> parameter in a subsequent request.
     * </p>
     */
    private Boolean truncated;

    /**
     * <p>
     * A list of keys.
     * </p>
     * 
     * @return A list of keys.
     */

    public java.util.List<KeyListEntry> getKeys() {
        if (keys == null) {
            keys = new com.ibm.cloud.objectstorage.internal.SdkInternalList<KeyListEntry>();
        }
        return keys;
    }

    /**
     * <p>
     * A list of keys.
     * </p>
     * 
     * @param keys
     *        A list of keys.
     */

    public void setKeys(java.util.Collection<KeyListEntry> keys) {
        if (keys == null) {
            this.keys = null;
            return;
        }

        this.keys = new com.ibm.cloud.objectstorage.internal.SdkInternalList<KeyListEntry>(keys);
    }

    /**
     * <p>
     * A list of keys.
     * </p>
     * <p>
     * <b>NOTE:</b> This method appends the values to the existing list (if any). Use
     * {@link #setKeys(java.util.Collection)} or {@link #withKeys(java.util.Collection)} if you want to override the
     * existing values.
     * </p>
     * 
     * @param keys
     *        A list of keys.
     * @return Returns a reference to this object so that method calls can be chained together.
     */

    public ListKeysResult withKeys(KeyListEntry... keys) {
        if (this.keys == null) {
            setKeys(new com.ibm.cloud.objectstorage.internal.SdkInternalList<KeyListEntry>(keys.length));
        }
        for (KeyListEntry ele : keys) {
            this.keys.add(ele);
        }
        return this;
    }

    /**
     * <p>
     * A list of keys.
     * </p>
     * 
     * @param keys
     *        A list of keys.
     * @return Returns a reference to this object so that method calls can be chained together.
     */

    public ListKeysResult withKeys(java.util.Collection<KeyListEntry> keys) {
        setKeys(keys);
        return this;
    }

    /**
     * <p>
     * When <code>Truncated</code> is true, this element is present and contains the value to use for the
     * <code>Marker</code> parameter in a subsequent request.
     * </p>
     * 
     * @param nextMarker
     *        When <code>Truncated</code> is true, this element is present and contains the value to use for the
     *        <code>Marker</code> parameter in a subsequent request.
     */

    public void setNextMarker(String nextMarker) {
        this.nextMarker = nextMarker;
    }

    /**
     * <p>
     * When <code>Truncated</code> is true, this element is present and contains the value to use for the
     * <code>Marker</code> parameter in a subsequent request.
     * </p>
     * 
     * @return When <code>Truncated</code> is true, this element is present and contains the value to use for the
     *         <code>Marker</code> parameter in a subsequent request.
     */

    public String getNextMarker() {
        return this.nextMarker;
    }

    /**
     * <p>
     * When <code>Truncated</code> is true, this element is present and contains the value to use for the
     * <code>Marker</code> parameter in a subsequent request.
     * </p>
     * 
     * @param nextMarker
     *        When <code>Truncated</code> is true, this element is present and contains the value to use for the
     *        <code>Marker</code> parameter in a subsequent request.
     * @return Returns a reference to this object so that method calls can be chained together.
     */

    public ListKeysResult withNextMarker(String nextMarker) {
        setNextMarker(nextMarker);
        return this;
    }

    /**
     * <p>
     * A flag that indicates whether there are more items in the list. When this value is true, the list in this
     * response is truncated. To retrieve more items, pass the value of the <code>NextMarker</code> element in this
     * response to the <code>Marker</code> parameter in a subsequent request.
     * </p>
     * 
     * @param truncated
     *        A flag that indicates whether there are more items in the list. When this value is true, the list in this
     *        response is truncated. To retrieve more items, pass the value of the <code>NextMarker</code> element in
     *        this response to the <code>Marker</code> parameter in a subsequent request.
     */

    public void setTruncated(Boolean truncated) {
        this.truncated = truncated;
    }

    /**
     * <p>
     * A flag that indicates whether there are more items in the list. When this value is true, the list in this
     * response is truncated. To retrieve more items, pass the value of the <code>NextMarker</code> element in this
     * response to the <code>Marker</code> parameter in a subsequent request.
     * </p>
     * 
     * @return A flag that indicates whether there are more items in the list. When this value is true, the list in this
     *         response is truncated. To retrieve more items, pass the value of the <code>NextMarker</code> element in
     *         this response to the <code>Marker</code> parameter in a subsequent request.
     */

    public Boolean getTruncated() {
        return this.truncated;
    }

    /**
     * <p>
     * A flag that indicates whether there are more items in the list. When this value is true, the list in this
     * response is truncated. To retrieve more items, pass the value of the <code>NextMarker</code> element in this
     * response to the <code>Marker</code> parameter in a subsequent request.
     * </p>
     * 
     * @param truncated
     *        A flag that indicates whether there are more items in the list. When this value is true, the list in this
     *        response is truncated. To retrieve more items, pass the value of the <code>NextMarker</code> element in
     *        this response to the <code>Marker</code> parameter in a subsequent request.
     * @return Returns a reference to this object so that method calls can be chained together.
     */

    public ListKeysResult withTruncated(Boolean truncated) {
        setTruncated(truncated);
        return this;
    }

    /**
     * <p>
     * A flag that indicates whether there are more items in the list. When this value is true, the list in this
     * response is truncated. To retrieve more items, pass the value of the <code>NextMarker</code> element in this
     * response to the <code>Marker</code> parameter in a subsequent request.
     * </p>
     * 
     * @return A flag that indicates whether there are more items in the list. When this value is true, the list in this
     *         response is truncated. To retrieve more items, pass the value of the <code>NextMarker</code> element in
     *         this response to the <code>Marker</code> parameter in a subsequent request.
     */

    public Boolean isTruncated() {
        return this.truncated;
    }

    /**
     * Returns a string representation of this object; useful for testing and debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(""{"");
        if (getKeys() != null)
            sb.append(""Keys: "").append(getKeys()).append("","");
        if (getNextMarker() != null)
            sb.append(""NextMarker: "").append(getNextMarker()).append("","");
        if (getTruncated() != null)
            sb.append(""Truncated: "").append(getTruncated());
        sb.append(""}"");
        return sb.toString();
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;

        if (obj instanceof ListKeysResult == false)
            return false;
        ListKeysResult other = (ListKeysResult) obj;
        if (other.getKeys() == null ^ this.getKeys() == null)
            return false;
        if (other.getKeys() != null && other.getKeys().equals(this.getKeys()) == false)
            return false;
        if (other.getNextMarker() == null ^ this.getNextMarker() == null)
            return false;
        if (other.getNextMarker() != null && other.getNextMarker().equals(this.getNextMarker()) == false)
            return false;
        if (other.getTruncated() == null ^ this.getTruncated() == null)
            return false;
        if (other.getTruncated() != null && other.getTruncated().equals(this.getTruncated()) == false)
            return false;
        return true;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;

        hashCode = prime * hashCode + ((getKeys() == null) ? 0 : getKeys().hashCode());
        hashCode = prime * hashCode + ((getNextMarker() == null) ? 0 : getNextMarker().hashCode());
        hashCode = prime * hashCode + ((getTruncated() == null) ? 0 : getTruncated().hashCode());
        return hashCode;
    }

    @Override
    public ListKeysResult clone() {
        try {
            return (ListKeysResult) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(""Got a CloneNotSupportedException from Object.clone() "" + ""even though we're Cloneable!"", e);
        }
    }

}
",blob
85,"public class LoopedModelImpl extends MinimalEObjectImpl.Container implements LoopedModel
{
  /**
   * The cached value of the '{@link #getVisibility() <em>Visibility</em>}' attribute list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getVisibility()
   * @generated
   * @ordered
   */
  protected EList<String> visibility;

  /**
   * The cached value of the '{@link #getStatic() <em>Static</em>}' attribute list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getStatic()
   * @generated
   * @ordered
   */
  protected EList<String> static_;

  /**
   * The cached value of the '{@link #getSynchronized() <em>Synchronized</em>}' attribute list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getSynchronized()
   * @generated
   * @ordered
   */
  protected EList<String> synchronized_;

  /**
   * The cached value of the '{@link #getAbstract() <em>Abstract</em>}' attribute list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getAbstract()
   * @generated
   * @ordered
   */
  protected EList<String> abstract_;

  /**
   * The cached value of the '{@link #getFinal() <em>Final</em>}' attribute list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getFinal()
   * @generated
   * @ordered
   */
  protected EList<String> final_;

  /**
   * The default value of the '{@link #getName() <em>Name</em>}' attribute.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getName()
   * @generated
   * @ordered
   */
  protected static final String NAME_EDEFAULT = null;

  /**
   * The cached value of the '{@link #getName() <em>Name</em>}' attribute.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getName()
   * @generated
   * @ordered
   */
  protected String name = NAME_EDEFAULT;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  protected LoopedModelImpl()
  {
    super();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  protected EClass eStaticClass()
  {
    return UnorderedGroupsTestPackage.Literals.LOOPED_MODEL;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EList<String> getVisibility()
  {
    if (visibility == null)
    {
      visibility = new EDataTypeEList<String>(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY);
    }
    return visibility;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EList<String> getStatic()
  {
    if (static_ == null)
    {
      static_ = new EDataTypeEList<String>(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC);
    }
    return static_;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EList<String> getSynchronized()
  {
    if (synchronized_ == null)
    {
      synchronized_ = new EDataTypeEList<String>(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED);
    }
    return synchronized_;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EList<String> getAbstract()
  {
    if (abstract_ == null)
    {
      abstract_ = new EDataTypeEList<String>(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT);
    }
    return abstract_;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EList<String> getFinal()
  {
    if (final_ == null)
    {
      final_ = new EDataTypeEList<String>(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL);
    }
    return final_;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public String getName()
  {
    return name;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public void setName(String newName)
  {
    String oldName = name;
    name = newName;
    if (eNotificationRequired())
      eNotify(new ENotificationImpl(this, Notification.SET, UnorderedGroupsTestPackage.LOOPED_MODEL__NAME, oldName, name));
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  {
    switch (featureID)
    {
      case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:
        return getVisibility();
      case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:
        return getStatic();
      case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:
        return getSynchronized();
      case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:
        return getAbstract();
      case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:
        return getFinal();
      case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:
        return getName();
    }
    return super.eGet(featureID, resolve, coreType);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @SuppressWarnings(""unchecked"")
  @Override
  public void eSet(int featureID, Object newValue)
  {
    switch (featureID)
    {
      case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:
        getVisibility().clear();
        getVisibility().addAll((Collection<? extends String>)newValue);
        return;
      case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:
        getStatic().clear();
        getStatic().addAll((Collection<? extends String>)newValue);
        return;
      case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:
        getSynchronized().clear();
        getSynchronized().addAll((Collection<? extends String>)newValue);
        return;
      case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:
        getAbstract().clear();
        getAbstract().addAll((Collection<? extends String>)newValue);
        return;
      case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:
        getFinal().clear();
        getFinal().addAll((Collection<? extends String>)newValue);
        return;
      case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:
        setName((String)newValue);
        return;
    }
    super.eSet(featureID, newValue);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public void eUnset(int featureID)
  {
    switch (featureID)
    {
      case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:
        getVisibility().clear();
        return;
      case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:
        getStatic().clear();
        return;
      case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:
        getSynchronized().clear();
        return;
      case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:
        getAbstract().clear();
        return;
      case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:
        getFinal().clear();
        return;
      case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:
        setName(NAME_EDEFAULT);
        return;
    }
    super.eUnset(featureID);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public boolean eIsSet(int featureID)
  {
    switch (featureID)
    {
      case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:
        return visibility != null && !visibility.isEmpty();
      case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:
        return static_ != null && !static_.isEmpty();
      case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:
        return synchronized_ != null && !synchronized_.isEmpty();
      case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:
        return abstract_ != null && !abstract_.isEmpty();
      case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:
        return final_ != null && !final_.isEmpty();
      case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:
        return NAME_EDEFAULT == null ? name != null : !NAME_EDEFAULT.equals(name);
    }
    return super.eIsSet(featureID);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public String toString()
  {
    if (eIsProxy()) return super.toString();

    StringBuffer result = new StringBuffer(super.toString());
    result.append("" (visibility: "");
    result.append(visibility);
    result.append("", static: "");
    result.append(static_);
    result.append("", synchronized: "");
    result.append(synchronized_);
    result.append("", abstract: "");
    result.append(abstract_);
    result.append("", final: "");
    result.append(final_);
    result.append("", name: "");
    result.append(name);
    result.append(')');
    return result.toString();
  }

} //LoopedModelImpl
",data class
103,"public final class AtlasPerfTracer {
    protected final Logger logger;
    protected final String tag;
    private   final long   startTimeMs;

    private static long reportingThresholdMs = 0L;

    public static Logger getPerfLogger(String name) {
        return LoggerFactory.getLogger(""org.apache.atlas.perf."" + name);
    }

    public static Logger getPerfLogger(Class<?> cls) {
        return AtlasPerfTracer.getPerfLogger(cls.getName());
    }

    public static boolean isPerfTraceEnabled(Logger logger) {
        return logger.isDebugEnabled();
    }

    public static AtlasPerfTracer getPerfTracer(Logger logger, String tag) {
        return new AtlasPerfTracer(logger, tag);
    }

    public static void log(AtlasPerfTracer tracer) {
        if (tracer != null) {
            tracer.log();
        }
    }

    private AtlasPerfTracer(Logger logger, String tag) {
        this.logger = logger;
        this.tag    = tag;
        startTimeMs = System.currentTimeMillis();
    }

    public String getTag() {
        return tag;
    }

    public long getStartTime() {
        return startTimeMs;
    }

    public long getElapsedTime() {
        return System.currentTimeMillis() - startTimeMs;
    }

    public void log() {
        long elapsedTime = getElapsedTime();
        if (elapsedTime > reportingThresholdMs) {
            logger.debug(""PERF|{}|{}"", tag, elapsedTime);
        }
    }
}
",data class
536,"    protected void refreshInternal(Collection objs, OpCallbacks call) {
    	if (objs == null || objs.isEmpty())
    		return;
        List<Exception> exceps = null;
        try {
            // collect instances that need a refresh
            Collection<OpenJPAStateManager> load = null;
            StateManagerImpl sm;
            Object obj;
            for (Iterator<?> itr = objs.iterator(); itr.hasNext();) {
                obj = itr.next();
                if (obj == null)
                    continue;

                try {
                    sm = getStateManagerImpl(obj, true);
                    if ((processArgument(OpCallbacks.OP_REFRESH, obj, sm, call)
                        & OpCallbacks.ACT_RUN) == 0)
                        continue;

                    if (sm != null) {
                        if (sm.isDetached())
                            throw newDetachedException(obj, ""refresh"");
                        else if (sm.beforeRefresh(true)) {
                        	if (load == null)
                        		load = new ArrayList<>(objs.size());
                            load.add(sm);
                        }
                        int level = _fc.getReadLockLevel();
                        int timeout = _fc.getLockTimeout();
                        _lm.refreshLock(sm, level, timeout, null);
                        sm.readLocked(level, level);
                    } else if (assertPersistenceCapable(obj).pcIsDetached()
                        == Boolean.TRUE)
                        throw newDetachedException(obj, ""refresh"");
                } catch (OpenJPAException ke) {
                    exceps = add(exceps, ke);
                }
            }

            // refresh all
            if (load != null) {
                Collection<Object> failed = _store.loadAll(load, null,
                    StoreManager.FORCE_LOAD_REFRESH, _fc, null);
                if (failed != null && !failed.isEmpty())
                    exceps = add(exceps, newObjectNotFoundException(failed));

                // perform post-refresh transitions and make sure all fetch
                // group fields are loaded
                for (Iterator<OpenJPAStateManager> itr = load.iterator(); itr.hasNext();) {
                    sm = (StateManagerImpl) itr.next();
                    if (failed != null && failed.contains(sm.getId()))
                        continue;

                    try {
                        sm.afterRefresh();
                        sm.load(_fc, StateManagerImpl.LOAD_FGS, null, null,
                            false);
                    } catch (OpenJPAException ke) {
                        exceps = add(exceps, ke);
                    }
                }
            }

            // now invoke postRefresh on all the instances
            for (Iterator<?> itr = objs.iterator(); itr.hasNext();) {
                try {
                    sm = getStateManagerImpl(itr.next(), true);
                    if (sm != null && !sm.isDetached())
                        fireLifecycleEvent(sm.getManagedInstance(), null,
                            sm.getMetaData(), LifecycleEvent.AFTER_REFRESH);
                } catch (OpenJPAException ke) {
                    exceps = add(exceps, ke);
                }
            }
        } catch (OpenJPAException ke) {
            throw ke;
        } catch (RuntimeException re) {
            throw new GeneralException(re);
        }
        throwNestedExceptions(exceps, false);
    }
",long method
976,"@Entity
@Table(name=""xa_access_audit"")
public class AuthzAuditEventDbObj implements Serializable {

	private static final Log LOG = LogFactory.getLog(AuthzAuditEventDbObj.class);

	private static final long serialVersionUID = 1L;

	static int MaxValueLengthAccessType = 255;
	static int MaxValueLengthAclEnforcer = 255;
	static int MaxValueLengthAgentId = 255;
	static int MaxValueLengthClientIp = 255;
	static int MaxValueLengthClientType = 255;
	static int MaxValueLengthRepoName = 255;
	static int MaxValueLengthResultReason = 255;
	static int MaxValueLengthSessionId = 255;
	static int MaxValueLengthRequestUser = 255;
	static int MaxValueLengthAction = 2000;
	static int MaxValueLengthRequestData = 4000;
	static int MaxValueLengthResourcePath = 4000;
	static int MaxValueLengthResourceType = 255;

	private long   auditId;
	private int    repositoryType;
	private String repositoryName;
	private String user;
	private Date   timeStamp;
	private String accessType;
	private String resourcePath;
	private String resourceType;
	private String action;
	private int    accessResult;
	private String agentId;
	private long   policyId;
	private String resultReason;
	private String aclEnforcer;
	private String sessionId;
	private String clientType;
	private String clientIP;
	private String requestData;
	private long seqNum;
	private long eventCount;
	private long eventDurationMS;
	private String tags;

	public static void init(Properties props)
	{
		LOG.info(""AuthzAuditEventDbObj.init()"");

		final String AUDIT_DB_MAX_COLUMN_VALUE = ""xasecure.audit.destination.db.max.column.length"";
		MaxValueLengthAccessType = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""access_type"", MaxValueLengthAccessType);
		logMaxColumnValue(""access_type"", MaxValueLengthAccessType);

		MaxValueLengthAclEnforcer = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""acl_enforcer"", MaxValueLengthAclEnforcer);
		logMaxColumnValue(""acl_enforcer"", MaxValueLengthAclEnforcer);

		MaxValueLengthAction = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""action"", MaxValueLengthAction);
		logMaxColumnValue(""action"", MaxValueLengthAction);

		MaxValueLengthAgentId = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""agent_id"", MaxValueLengthAgentId);
		logMaxColumnValue(""agent_id"", MaxValueLengthAgentId);

		MaxValueLengthClientIp = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""client_id"", MaxValueLengthClientIp);
		logMaxColumnValue(""client_id"", MaxValueLengthClientIp);

		MaxValueLengthClientType = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""client_type"", MaxValueLengthClientType);
		logMaxColumnValue(""client_type"", MaxValueLengthClientType);

		MaxValueLengthRepoName = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""repo_name"", MaxValueLengthRepoName);
		logMaxColumnValue(""repo_name"", MaxValueLengthRepoName);

		MaxValueLengthResultReason = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""result_reason"", MaxValueLengthResultReason);
		logMaxColumnValue(""result_reason"", MaxValueLengthResultReason);

		MaxValueLengthSessionId = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""session_id"", MaxValueLengthSessionId);
		logMaxColumnValue(""session_id"", MaxValueLengthSessionId);

		MaxValueLengthRequestUser = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""request_user"", MaxValueLengthRequestUser);
		logMaxColumnValue(""request_user"", MaxValueLengthRequestUser);

		MaxValueLengthRequestData = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""request_data"", MaxValueLengthRequestData);
		logMaxColumnValue(""request_data"", MaxValueLengthRequestData);

		MaxValueLengthResourcePath = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""resource_path"", MaxValueLengthResourcePath);
		logMaxColumnValue(""resource_path"", MaxValueLengthResourcePath);

		MaxValueLengthResourceType = MiscUtil.getIntProperty(props, AUDIT_DB_MAX_COLUMN_VALUE + ""."" + ""resource_type"", MaxValueLengthResourceType);
		logMaxColumnValue(""resource_type"", MaxValueLengthResourceType);
	}

	public static void logMaxColumnValue(String columnName, int configuredMaxValueLength) {
		LOG.info(""Setting max column value for column["" + columnName + ""] to ["" + configuredMaxValueLength + ""]."");
		if (configuredMaxValueLength == 0) {
			LOG.info(""Max length of column["" + columnName + ""] was 0! Column will NOT be emitted in the audit."");
		} else if (configuredMaxValueLength < 0) {
			LOG.info(""Max length of column["" + columnName + ""] was less than 0! Column value will never be truncated."");
		}
	}


	public AuthzAuditEventDbObj() {
		super();
	}

	public AuthzAuditEventDbObj(AuthzAuditEvent event) {
		super();
		Date utcDate=null;
		if(event.getEventTime()!=null){
			utcDate=MiscUtil.getUTCDateForLocalDate(event.getEventTime());
		}else{
			utcDate=MiscUtil.getUTCDate();
		}
		this.repositoryType = event.getRepositoryType();
		this.repositoryName = event.getRepositoryName();
		this.user           = event.getUser();
		this.timeStamp      = utcDate;
		this.accessType     = event.getAccessType();
		this.resourcePath   = event.getResourcePath();
		this.resourceType   = event.getResourceType();
		this.action         = event.getAction();
		this.accessResult   = event.getAccessResult();
		this.agentId        = event.getAgentId();
		this.policyId       = event.getPolicyId();
		this.resultReason   = event.getResultReason();
		this.aclEnforcer    = event.getAclEnforcer();
		this.sessionId      = event.getSessionId();
		this.clientType     = event.getClientType();
		this.clientIP       = event.getClientIP();
		this.requestData    = event.getRequestData();
		this.seqNum         = event.getSeqNum();
		this.eventCount     = event.getEventCount();
		this.eventDurationMS= event.getEventDurationMS();
		this.tags           = StringUtils.join(event.getTags(), "", "");
	}

	@Id
	@SequenceGenerator(name=""XA_ACCESS_AUDIT_SEQ"",sequenceName=""XA_ACCESS_AUDIT_SEQ"",allocationSize=1)
	@GeneratedValue(strategy=GenerationType.AUTO,generator=""XA_ACCESS_AUDIT_SEQ"")
	@Column(name = ""id"", unique = true, nullable = false)
	public long getAuditId() {
		return this.auditId;
	}

	public void setAuditId(long auditId) {
		this.auditId = auditId;
	}

	@Column(name = ""repo_type"")
	public int getRepositoryType() {
		return this.repositoryType;
	}

	public void setRepositoryType(int repositoryType) {
		this.repositoryType = repositoryType;
	}

	@Column(name = ""repo_name"")
	public String getRepositoryName() {
		return truncate(this.repositoryName, MaxValueLengthRepoName, ""repo_name"");
	}

	public void setRepositoryName(String repositoryName) {
		this.repositoryName = repositoryName;
	}

	@Column(name = ""request_user"")
	public String getUser() {
		return truncate(this.user, MaxValueLengthRequestUser, ""request_user"");
	}

	public void setUser(String user) {
		this.user = user;
	}

	@Temporal(TemporalType.TIMESTAMP)
	@Column(name = ""event_time"")
	public Date getTimeStamp() {
		return this.timeStamp;
	}

	public void setTimeStamp(Date timeStamp) {
		this.timeStamp = timeStamp;
	}

	@Column(name = ""access_type"")
	public String getAccessType() {
		return truncate(this.accessType, MaxValueLengthAccessType, ""access_type"");
	}

	public void setAccessType(String accessType) {
		this.accessType = accessType;
	}

	@Column(name = ""resource_path"")
	public String getResourcePath() {
		return truncate(this.resourcePath, MaxValueLengthResourcePath, ""resource_path"");
	}

	public void setResourcePath(String resourcePath) {
		this.resourcePath = resourcePath;
	}

	@Column(name = ""resource_type"")
	public String getResourceType() {
		return truncate(this.resourceType, MaxValueLengthResourceType, ""resource_type"");
	}

	public void setResourceType(String resourceType) {
		this.resourceType = resourceType;
	}

	@Column(name = ""action"")
	public String getAction() {
		return truncate(this.action, MaxValueLengthAction, ""action"");
	}

	public void setAction(String action) {
		this.action = action;
	}

	@Column(name = ""access_result"")
	public int getAccessResult() {
		return this.accessResult;
	}

	public void setAccessResult(int accessResult) {
		this.accessResult = accessResult;
	}

	@Column(name = ""agent_id"")
	public String getAgentId() {
		return truncate(this.agentId, MaxValueLengthAgentId, ""agent_id"");
	}

	public void setAgentId(String agentId) {
		this.agentId = agentId;
	}

	@Column(name = ""policy_id"")
	public long getPolicyId() {
		return this.policyId;
	}

	public void setPolicyId(long policyId) {
		this.policyId = policyId;
	}

	@Column(name = ""result_reason"")
	public String getResultReason() {
		return truncate(this.resultReason, MaxValueLengthResultReason, ""result_reason"");
	}

	public void setResultReason(String resultReason) {
		this.resultReason = resultReason;
	}

	@Column(name = ""acl_enforcer"")
	public String getAclEnforcer() {
		return truncate(this.aclEnforcer, MaxValueLengthAclEnforcer, ""acl_enforcer"");
	}

	public void setAclEnforcer(String aclEnforcer) {
		this.aclEnforcer = aclEnforcer;
	}

	@Column(name = ""session_id"")
	public String getSessionId() {
		return truncate(this.sessionId, MaxValueLengthSessionId, ""session_id"");
	}

	public void setSessionId(String sessionId) {
		this.sessionId = sessionId;
	}

	@Column(name = ""client_type"")
	public String getClientType() {
		return truncate(this.clientType, MaxValueLengthClientType, ""client_type"");
	}

	public void setClientType(String clientType) {
		this.clientType = clientType;
	}

	@Column(name = ""client_ip"")
	public String getClientIP() {
		return truncate(this.clientIP, MaxValueLengthClientIp, ""client_ip"");
	}

	public void setClientIP(String clientIP) {
		this.clientIP = clientIP;
	}

	@Column(name = ""request_data"")
	public String getRequestData() {
		return truncate(this.requestData, MaxValueLengthRequestData, ""request_data"");
	}

	public void setRequestData(String requestData) {
		this.requestData = requestData;
	}

	@Column(name = ""seq_num"")
	public long getSeqNum() { return this.seqNum; }

	public void setSeqNum(long seqNum) { this.seqNum = seqNum; }

	@Column(name = ""event_count"")
	public long getEventCount() { return this.eventCount; }

	public void setEventCount(long eventCount) { this.eventCount = eventCount; }

	@Column(name = ""event_dur_ms"")
	public long getEventDurationMS() { return this.eventDurationMS; }

	public void setEventDurationMS(long eventDurationMS) { this.eventDurationMS = eventDurationMS; }

	@Column(name = ""tags"")
	public String getTags() {
		return this.tags;
	}

	public void setTags(String tags) {
		this.tags = tags;
	}

	static final String TruncationMarker = ""..."";
	static final int TruncationMarkerLength = TruncationMarker.length();

	protected String truncate(String value, int limit, String columnName) {
		if (LOG.isDebugEnabled()) {
			LOG.debug(String.format(""==> getTrunctedValue(%s, %d, %s)"", value, limit, columnName));
		}

		String result = value;
		if (value != null) {
			if (limit < 0) {
				if (LOG.isDebugEnabled()) {
					LOG.debug(String.format(""Truncation is suppressed for column[%s]: old value [%s], new value[%s]"", columnName, value, result));
				}
			} else if (limit == 0) {
				if (LOG.isDebugEnabled()) {
					LOG.debug(String.format(""Column[%s] is to be excluded from audit: old value [%s], new value[%s]"", columnName, value, result));
				}
				result = null;
			} else {
				if (value.length() > limit) {
					if (limit <= TruncationMarkerLength) {
						// NOTE: If value is to be truncated to a size that is less than of equal to the Truncation Marker then we won't put the marker in!!
						result = value.substring(0, limit);
					} else {
						StringBuilder sb = new StringBuilder(value.substring(0, limit - TruncationMarkerLength));
						sb.append(TruncationMarker);
						result = sb.toString();
					}
					if (LOG.isDebugEnabled()) {
						LOG.debug(String.format(""Truncating value for column[%s] to [%d] characters: old value [%s], new value[%s]"", columnName, limit, value, result));
					}
				}
			}
		}

		if (LOG.isDebugEnabled()) {
			LOG.debug(String.format(""<== getTrunctedValue(%s, %d, %s): %s"", value, limit, columnName, result));
		}
		return result;
	}
}
",data class
546,"abstract class RTFParser extends AbstractFilter
{
  /** The current RTF group nesting level. */
  public int level;

  private int state;
  private StringBuffer currentCharacters;
  private String pendingKeyword;                // where keywords go while we
                                                // read their parameters
  private int pendingCharacter;                 // for the \'xx construct

  private long binaryBytesLeft;                  // in a \bin blob?
  ByteArrayOutputStream binaryBuf;
  private boolean[] savedSpecials;

  /** A stream to which to write warnings and debugging information
   *  while parsing. This is set to <code>System.out</code> to log
   *  any anomalous information to stdout. */
  protected PrintStream warnings;

  // value for the 'state' variable
  private final int S_text = 0;          // reading random text
  private final int S_backslashed = 1;   // read a backslash, waiting for next
  private final int S_token = 2;         // reading a multicharacter token
  private final int S_parameter = 3;     // reading a token's parameter

  private final int S_aftertick = 4;     // after reading \'
  private final int S_aftertickc = 5;    // after reading \'x

  private final int S_inblob = 6;        // in a \bin blob

  /** Implemented by subclasses to interpret a parameter-less RTF keyword.
   *  The keyword is passed without the leading '/' or any delimiting
   *  whitespace. */
  public abstract boolean handleKeyword(String keyword);
  /** Implemented by subclasses to interpret a keyword with a parameter.
   *  @param keyword   The keyword, as with <code>handleKeyword(String)</code>.
   *  @param parameter The parameter following the keyword. */
  public abstract boolean handleKeyword(String keyword, int parameter);
  /** Implemented by subclasses to interpret text from the RTF stream. */
  public abstract void handleText(String text);
  public void handleText(char ch)
  { handleText(String.valueOf(ch)); }
  /** Implemented by subclasses to handle the contents of the \bin keyword. */
  public abstract void handleBinaryBlob(byte[] data);
  /** Implemented by subclasses to react to an increase
   *  in the nesting level. */
  public abstract void begingroup();
  /** Implemented by subclasses to react to the end of a group. */
  public abstract void endgroup();

  // table of non-text characters in rtf
  static final boolean[] rtfSpecialsTable;
  static {
    rtfSpecialsTable = noSpecialsTable.clone();
    rtfSpecialsTable['\n'] = true;
    rtfSpecialsTable['\r'] = true;
    rtfSpecialsTable['{'] = true;
    rtfSpecialsTable['}'] = true;
    rtfSpecialsTable['\\'] = true;
  }

  public RTFParser()
  {
    currentCharacters = new StringBuffer();
    state = S_text;
    pendingKeyword = null;
    level = 0;
    //warnings = System.out;

    specialsTable = rtfSpecialsTable;
  }

  // TODO: Handle wrapup at end of file correctly.

  public void writeSpecial(int b)
    throws IOException
  {
    write((char)b);
  }

    protected void warning(String s) {
        if (warnings != null) {
            warnings.println(s);
        }
    }

  public void write(String s)
    throws IOException
  {
    if (state != S_text) {
      int index = 0;
      int length = s.length();
      while(index < length && state != S_text) {
        write(s.charAt(index));
        index ++;
      }

      if(index >= length)
        return;

      s = s.substring(index);
    }

    if (currentCharacters.length() > 0)
      currentCharacters.append(s);
    else
      handleText(s);
  }

  @SuppressWarnings(""fallthrough"")
  public void write(char ch)
    throws IOException
  {
    boolean ok;

    switch (state)
    {
      case S_text:
        if (ch == '\n' || ch == '\r') {
          break;  // unadorned newlines are ignored
        } else if (ch == '{') {
          if (currentCharacters.length() > 0) {
            handleText(currentCharacters.toString());
            currentCharacters = new StringBuffer();
          }
          level ++;
          begingroup();
        } else if(ch == '}') {
          if (currentCharacters.length() > 0) {
            handleText(currentCharacters.toString());
            currentCharacters = new StringBuffer();
          }
          if (level == 0)
            throw new IOException(""Too many close-groups in RTF text"");
          endgroup();
          level --;
        } else if(ch == '\\') {
          if (currentCharacters.length() > 0) {
            handleText(currentCharacters.toString());
            currentCharacters = new StringBuffer();
          }
          state = S_backslashed;
        } else {
          currentCharacters.append(ch);
        }
        break;
      case S_backslashed:
        if (ch == '\'') {
          state = S_aftertick;
          break;
        }
        if (!Character.isLetter(ch)) {
          char[] newstring = new char[1];
          newstring[0] = ch;
          if (!handleKeyword(new String(newstring))) {
            warning(""Unknown keyword: "" + newstring + "" ("" + (byte)ch + "")"");
          }
          state = S_text;
          pendingKeyword = null;
          /* currentCharacters is already an empty stringBuffer */
          break;
        }

        state = S_token;
        /* FALL THROUGH */
      case S_token:
        if (Character.isLetter(ch)) {
          currentCharacters.append(ch);
        } else {
          pendingKeyword = currentCharacters.toString();
          currentCharacters = new StringBuffer();

          // Parameter following?
          if (Character.isDigit(ch) || (ch == '-')) {
            state = S_parameter;
            currentCharacters.append(ch);
          } else {
            ok = handleKeyword(pendingKeyword);
            if (!ok)
              warning(""Unknown keyword: "" + pendingKeyword);
            pendingKeyword = null;
            state = S_text;

            // Non-space delimiters get included in the text
            if (!Character.isWhitespace(ch))
              write(ch);
          }
        }
        break;
      case S_parameter:
        if (Character.isDigit(ch)) {
          currentCharacters.append(ch);
        } else {
          /* TODO: Test correct behavior of \bin keyword */
          if (pendingKeyword.equals(""bin"")) {  /* magic layer-breaking kwd */
            long parameter = Long.parseLong(currentCharacters.toString());
            pendingKeyword = null;
            state = S_inblob;
            binaryBytesLeft = parameter;
            if (binaryBytesLeft > Integer.MAX_VALUE)
                binaryBuf = new ByteArrayOutputStream(Integer.MAX_VALUE);
            else
                binaryBuf = new ByteArrayOutputStream((int)binaryBytesLeft);
            savedSpecials = specialsTable;
            specialsTable = allSpecialsTable;
            break;
          }

          int parameter = Integer.parseInt(currentCharacters.toString());
          ok = handleKeyword(pendingKeyword, parameter);
          if (!ok)
            warning(""Unknown keyword: "" + pendingKeyword +
                    "" (param "" + currentCharacters + "")"");
          pendingKeyword = null;
          currentCharacters = new StringBuffer();
          state = S_text;

          // Delimiters here are interpreted as text too
          if (!Character.isWhitespace(ch))
            write(ch);
        }
        break;
      case S_aftertick:
        if (Character.digit(ch, 16) == -1)
          state = S_text;
        else {
          pendingCharacter = Character.digit(ch, 16);
          state = S_aftertickc;
        }
        break;
      case S_aftertickc:
        state = S_text;
        if (Character.digit(ch, 16) != -1)
        {
          pendingCharacter = pendingCharacter * 16 + Character.digit(ch, 16);
          ch = translationTable[pendingCharacter];
          if (ch != 0)
              handleText(ch);
        }
        break;
      case S_inblob:
        binaryBuf.write(ch);
        binaryBytesLeft --;
        if (binaryBytesLeft == 0) {
            state = S_text;
            specialsTable = savedSpecials;
            savedSpecials = null;
            handleBinaryBlob(binaryBuf.toByteArray());
            binaryBuf = null;
        }
      }
  }

  /** Flushes any buffered but not yet written characters.
   *  Subclasses which override this method should call this
   *  method <em>before</em> flushing
   *  any of their own buffers. */
  public void flush()
    throws IOException
  {
    super.flush();

    if (state == S_text && currentCharacters.length() > 0) {
      handleText(currentCharacters.toString());
      currentCharacters = new StringBuffer();
    }
  }

  /** Closes the parser. Currently, this simply does a <code>flush()</code>,
   *  followed by some minimal consistency checks. */
  public void close()
    throws IOException
  {
    flush();

    if (state != S_text || level > 0) {
      warning(""Truncated RTF file."");

      /* TODO: any sane way to handle termination in a non-S_text state? */
      /* probably not */

      /* this will cause subclasses to behave more reasonably
         some of the time */
      while (level > 0) {
          endgroup();
          level --;
      }
    }

    super.close();
  }

}
",blob
1434,"  private void finishRestore(final Timer.Context context, Map<String, List<HoodieRollbackStat>> commitToStats,
      List<String> commitsToRollback, final String startRestoreTime, final String restoreToInstant) throws IOException {
    HoodieTable<T> table = HoodieTable.getHoodieTable(
        new HoodieTableMetaClient(jsc.hadoopConfiguration(), config.getBasePath(), true), config, jsc);
    Optional<Long> durationInMs = Optional.empty();
    Long numFilesDeleted = 0L;
    for (Map.Entry<String, List<HoodieRollbackStat>> commitToStat : commitToStats.entrySet()) {
      List<HoodieRollbackStat> stats = commitToStat.getValue();
      numFilesDeleted = stats.stream().mapToLong(stat -> stat.getSuccessDeleteFiles().size())
          .sum();
    }
    if (context != null) {
      durationInMs = Optional.of(metrics.getDurationInMs(context.stop()));
      metrics.updateRollbackMetrics(durationInMs.get(), numFilesDeleted);
    }
    HoodieRestoreMetadata restoreMetadata = AvroUtils
        .convertRestoreMetadata(startRestoreTime, durationInMs, commitsToRollback, commitToStats);
    table.getActiveTimeline().saveAsComplete(
        new HoodieInstant(true, HoodieTimeline.RESTORE_ACTION, startRestoreTime),
        AvroUtils.serializeRestoreMetadata(restoreMetadata));
    logger.info(""Commits "" + commitsToRollback + "" rollback is complete. Restored dataset to "" + restoreToInstant);

    if (!table.getActiveTimeline().getCleanerTimeline().empty()) {
      logger.info(""Cleaning up older restore meta files"");
      // Cleanup of older cleaner meta files
      // TODO - make the commit archival generic and archive rollback metadata
      FSUtils.deleteOlderRollbackMetaFiles(fs, table.getMetaClient().getMetaPath(),
          table.getActiveTimeline().getRestoreTimeline().getInstants());
    }
  }
",feature envy
434,"@XmlType(name = ""remoteProcessGroup"")
public class RemoteProcessGroupDTO extends ComponentDTO {

    private String targetUri;
    private String targetUris;
    private Boolean targetSecure;

    private String name;
    private String comments;
    private String communicationsTimeout;
    private String yieldDuration;
    private String transportProtocol;
    private String localNetworkInterface;
    private String proxyHost;
    private Integer proxyPort;
    private String proxyUser;
    private String proxyPassword;

    private Collection<String> authorizationIssues;
    private Collection<String> validationErrors;
    private Boolean transmitting;

    private Integer inputPortCount;
    private Integer outputPortCount;

    private Integer activeRemoteInputPortCount;
    private Integer inactiveRemoteInputPortCount;
    private Integer activeRemoteOutputPortCount;
    private Integer inactiveRemoteOutputPortCount;

    private Date flowRefreshed;

    private RemoteProcessGroupContentsDTO contents;

    public RemoteProcessGroupDTO() {
        super();
    }

    public RemoteProcessGroupDTO(final RemoteProcessGroupDTO toCopy) {
        setId(toCopy.getId());
        setPosition(toCopy.getPosition());
        targetUri = toCopy.getTargetUri();
        name = toCopy.getName();
    }

    public void setTargetUri(final String targetUri) {
        this.targetUri = targetUri;
    }

    /**
     * @return target uri of this remote process group.
     * If target uri is not set, but uris are set, then returns the first url in the urls.
     * If neither target uri nor uris are set, then returns null.
     */
    @ApiModelProperty(
            value = ""The target URI of the remote process group."" +
                    "" If target uri is not set, but uris are set, then returns the first url in the urls."" +
                    "" If neither target uri nor uris are set, then returns null.""
    )
    public String getTargetUri() {
        if (targetUri == null || targetUri.length() == 0) {
            synchronized (this) {
                if (targetUri == null || targetUri.length() == 0) {
                    if (targetUris != null && targetUris.length() > 0) {
                        if (targetUris.indexOf(',') > -1) {
                            targetUri = targetUris.substring(0, targetUris.indexOf(','));
                        } else {
                            targetUri = targetUris;
                        }
                    }
                }
            }
        }

        return this.targetUri;
    }

    public void setTargetUris(String targetUris) {
        this.targetUris = targetUris;
    }

    /**
     * @return target uris of this remote process group
     * If targetUris was not set but target uri was set, then returns a collection containing the single uri.
     * If neither target uris nor uri were set, then returns null.
     */
    @ApiModelProperty(
            value = ""The target URI of the remote process group."" +
                    "" If target uris is not set but target uri is set,"" +
                    "" then returns a collection containing the single target uri."" +
                    "" If neither target uris nor uris are set, then returns null.""
    )
    public String getTargetUris() {
        if (targetUris == null || targetUris.length() == 0) {
            synchronized (this) {
                if (targetUris == null || targetUris.length() == 0) {
                    targetUris = targetUri;
                }
            }
        }

        return this.targetUris;
    }

    /**
     * @param name of this remote process group
     */
    @ApiModelProperty(
            value = ""The name of the remote process group.""
    )
    public void setName(final String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }

    /**
     * @return Comments for this remote process group
     */
    @ApiModelProperty(
            value = ""The comments for the remote process group.""
    )
    public String getComments() {
        return comments;
    }

    public void setComments(String comments) {
        this.comments = comments;
    }

    /**
     * @return any remote authorization issues for this remote process group
     */
    @ApiModelProperty(
            value = ""Any remote authorization issues for the remote process group.""
    )
    public Collection<String> getAuthorizationIssues() {
        return authorizationIssues;
    }

    public void setAuthorizationIssues(Collection<String> authorizationIssues) {
        this.authorizationIssues = authorizationIssues;
    }

    /**
     * @return whether or not this remote process group is actively transmitting
     */
    @ApiModelProperty(
            value = ""Whether the remote process group is actively transmitting.""
    )
    public Boolean isTransmitting() {
        return transmitting;
    }

    public void setTransmitting(Boolean transmitting) {
        this.transmitting = transmitting;
    }

    /**
     * @return whether or not the target is running securely
     */
    @ApiModelProperty(
            value = ""Whether the target is running securely.""
    )
    public Boolean isTargetSecure() {
        return targetSecure;
    }

    public void setTargetSecure(Boolean targetSecure) {
        this.targetSecure = targetSecure;
    }

    /**
     * @return the time period used for the timeout when communicating with this RemoteProcessGroup
     */
    @ApiModelProperty(
            value = ""The time period used for the timeout when communicating with the target.""
    )
    public String getCommunicationsTimeout() {
        return communicationsTimeout;
    }

    public void setCommunicationsTimeout(String communicationsTimeout) {
        this.communicationsTimeout = communicationsTimeout;
    }

    /**
     * @return when yielding, this amount of time must elapse before this remote process group is scheduled again
     */
    @ApiModelProperty(
            value = ""When yielding, this amount of time must elapse before the remote process group is scheduled again.""
    )
    public String getYieldDuration() {
        return yieldDuration;
    }

    public void setYieldDuration(String yieldDuration) {
        this.yieldDuration = yieldDuration;
    }

    /**
     * @return number of active remote input ports
     */
    @ApiModelProperty(
            value = ""The number of active remote input ports.""
    )
    public Integer getActiveRemoteInputPortCount() {
        return activeRemoteInputPortCount;
    }

    public void setActiveRemoteInputPortCount(Integer activeRemoteInputPortCount) {
        this.activeRemoteInputPortCount = activeRemoteInputPortCount;
    }

    /**
     * @return number of inactive remote input ports
     */
    @ApiModelProperty(
            value = ""The number of inactive remote input ports.""
    )
    public Integer getInactiveRemoteInputPortCount() {
        return inactiveRemoteInputPortCount;
    }

    public void setInactiveRemoteInputPortCount(Integer inactiveRemoteInputPortCount) {
        this.inactiveRemoteInputPortCount = inactiveRemoteInputPortCount;
    }

    /**
     * @return number of active remote output ports
     */
    @ApiModelProperty(
            value = ""The number of active remote output ports.""
    )
    public Integer getActiveRemoteOutputPortCount() {
        return activeRemoteOutputPortCount;
    }

    public void setActiveRemoteOutputPortCount(Integer activeRemoteOutputPortCount) {
        this.activeRemoteOutputPortCount = activeRemoteOutputPortCount;
    }

    /**
     * @return number of inactive remote output ports
     */
    @ApiModelProperty(
            value = ""The number of inactive remote output ports.""
    )
    public Integer getInactiveRemoteOutputPortCount() {
        return inactiveRemoteOutputPortCount;
    }

    public void setInactiveRemoteOutputPortCount(Integer inactiveRemoteOutputPortCount) {
        this.inactiveRemoteOutputPortCount = inactiveRemoteOutputPortCount;
    }

    /**
     * @return number of Remote Input Ports currently available in the remote NiFi instance
     */
    @ApiModelProperty(
            value = ""The number of remote input ports currently available on the target.""
    )
    public Integer getInputPortCount() {
        return inputPortCount;
    }

    public void setInputPortCount(Integer inputPortCount) {
        this.inputPortCount = inputPortCount;
    }

    /**
     * @return number of Remote Output Ports currently available in the remote NiFi instance
     */
    @ApiModelProperty(
            value = ""The number of remote output ports currently available on the target.""
    )
    public Integer getOutputPortCount() {
        return outputPortCount;
    }

    public void setOutputPortCount(Integer outputPortCount) {
        this.outputPortCount = outputPortCount;
    }

    /**
     * @return contents of this remote process group. Will contain available input/output ports
     */
    @ApiModelProperty(
            value = ""The contents of the remote process group. Will contain available input/output ports.""
    )
    public RemoteProcessGroupContentsDTO getContents() {
        return contents;
    }

    public void setContents(RemoteProcessGroupContentsDTO contents) {
        this.contents = contents;
    }

    /**
     * @return the flow for this remote group was last refreshed
     */
    @XmlJavaTypeAdapter(DateTimeAdapter.class)
    @ApiModelProperty(
            value = ""The timestamp when this remote process group was last refreshed."",
            dataType = ""string""
    )
    public Date getFlowRefreshed() {
        return flowRefreshed;
    }

    public void setFlowRefreshed(Date flowRefreshed) {
        this.flowRefreshed = flowRefreshed;
    }

    public String getTransportProtocol() {
        return transportProtocol;
    }

    public void setTransportProtocol(String transportProtocol) {
        this.transportProtocol = transportProtocol;
    }

    @ApiModelProperty(""The local network interface to send/receive data. If not specified, any local address is used. If clustered, all nodes must have an interface with this identifier."")
    public String getLocalNetworkInterface() {
        return localNetworkInterface;
    }

    public void setLocalNetworkInterface(String localNetworkInterface) {
        this.localNetworkInterface = localNetworkInterface;
    }

    @ApiModelProperty(
            ""The validation errors for the remote process group. These validation errors represent the problems with the remote process group that must be resolved before it can transmit.""
    )
    public Collection<String> getValidationErrors() {
        return validationErrors;
    }

    public void setValidationErrors(Collection<String> validationErrors) {
        this.validationErrors = validationErrors;
    }

    public String getProxyHost() {
        return proxyHost;
    }

    public void setProxyHost(String proxyHost) {
        this.proxyHost = proxyHost;
    }

    public Integer getProxyPort() {
        return proxyPort;
    }

    public void setProxyPort(Integer proxyPort) {
        this.proxyPort = proxyPort;
    }

    public String getProxyUser() {
        return proxyUser;
    }

    public void setProxyUser(String proxyUser) {
        this.proxyUser = proxyUser;
    }

    public String getProxyPassword() {
        return proxyPassword;
    }

    public void setProxyPassword(String proxyPassword) {
        this.proxyPassword = proxyPassword;
    }
}
",data class
712,"	public BindStatus(RequestContext requestContext, String path, boolean htmlEscape) throws IllegalStateException {
		this.requestContext = requestContext;
		this.path = path;
		this.htmlEscape = htmlEscape;

		// determine name of the object and property
		String beanName;
		int dotPos = path.indexOf('.');
		if (dotPos == -1) {
			// property not set, only the object itself
			beanName = path;
			this.expression = null;
		}
		else {
			beanName = path.substring(0, dotPos);
			this.expression = path.substring(dotPos + 1);
		}

		this.errors = requestContext.getErrors(beanName, false);

		if (this.errors != null) {
			// Usual case: A BindingResult is available as request attribute.
			// Can determine error codes and messages for the given expression.
			// Can use a custom PropertyEditor, as registered by a form controller.
			if (this.expression != null) {
				if (""*"".equals(this.expression)) {
					this.objectErrors = this.errors.getAllErrors();
				}
				else if (this.expression.endsWith(""*"")) {
					this.objectErrors = this.errors.getFieldErrors(this.expression);
				}
				else {
					this.objectErrors = this.errors.getFieldErrors(this.expression);
					this.value = this.errors.getFieldValue(this.expression);
					this.valueType = this.errors.getFieldType(this.expression);
					if (this.errors instanceof BindingResult) {
						this.bindingResult = (BindingResult) this.errors;
						this.actualValue = this.bindingResult.getRawFieldValue(this.expression);
						this.editor = this.bindingResult.findEditor(this.expression, null);
					}
					else {
						this.actualValue = this.value;
					}
				}
			}
			else {
				this.objectErrors = this.errors.getGlobalErrors();
			}
			this.errorCodes = initErrorCodes(this.objectErrors);
		}

		else {
			// No BindingResult available as request attribute:
			// Probably forwarded directly to a form view.
			// Let's do the best we can: extract a plain target if appropriate.
			Object target = requestContext.getModelObject(beanName);
			if (target == null) {
				throw new IllegalStateException(""Neither BindingResult nor plain target object for bean name '"" +
						beanName + ""' available as request attribute"");
			}
			if (this.expression != null && !""*"".equals(this.expression) && !this.expression.endsWith(""*"")) {
				BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(target);
				this.value = bw.getPropertyValue(this.expression);
				this.valueType = bw.getPropertyType(this.expression);
				this.actualValue = this.value;
			}
			this.errorCodes = new String[0];
			this.errorMessages = new String[0];
		}

		if (htmlEscape && this.value instanceof String) {
			this.value = HtmlUtils.htmlEscape((String) this.value);
		}
	}
",feature envy
698,"public final class IntermediateModel {
    private final Metadata metadata;

    private final Map<String, OperationModel> operations;

    private final Map<String, ShapeModel> shapes;

    private final CustomizationConfig customizationConfig;

    private final ServiceExamples examples;

    private final Map<String, AuthorizerModel> customAuthorizers;

    @JsonIgnore
    private final Optional<OperationModel> endpointOperation;

    @JsonIgnore
    private final Map<String, PaginatorDefinition> paginators;

    @JsonIgnore
    private final NamingStrategy namingStrategy;

    @JsonCreator
    public IntermediateModel(
        @JsonProperty(""metadata"") Metadata metadata,
        @JsonProperty(""operations"") Map<String, OperationModel> operations,
        @JsonProperty(""shapes"") Map<String, ShapeModel> shapes,
        @JsonProperty(""customizationConfig"") CustomizationConfig customizationConfig,
        @JsonProperty(""serviceExamples"") ServiceExamples examples) {

        this(metadata, operations, shapes, customizationConfig, examples, null,
             Collections.emptyMap(), Collections.emptyMap(), null);
    }

    public IntermediateModel(
        Metadata metadata,
        Map<String, OperationModel> operations,
        Map<String, ShapeModel> shapes,
        CustomizationConfig customizationConfig,
        ServiceExamples examples,
        OperationModel endpointOperation,
        Map<String, AuthorizerModel> customAuthorizers,
        Map<String, PaginatorDefinition> paginators,
        NamingStrategy namingStrategy) {
        this.metadata = metadata;
        this.operations = operations;
        this.shapes = shapes;
        this.customizationConfig = customizationConfig;
        this.examples = examples;
        this.endpointOperation = Optional.ofNullable(endpointOperation);
        this.customAuthorizers = customAuthorizers;
        this.paginators = paginators;
        this.namingStrategy = namingStrategy;
    }

    public Metadata getMetadata() {
        return metadata;
    }

    public Map<String, OperationModel> getOperations() {
        return operations;
    }

    public OperationModel getOperation(String operationName) {
        return getOperations().get(operationName);
    }

    public Map<String, ShapeModel> getShapes() {
        return shapes;
    }

    public ShapeModel getShapeByC2jName(String c2jName) {
        return Utils.findShapeModelByC2jName(this, c2jName);
    }

    public CustomizationConfig getCustomizationConfig() {
        return customizationConfig;
    }

    public ServiceExamples getExamples() {
        return examples;
    }

    public Map<String, PaginatorDefinition> getPaginators() {
        return paginators;
    }

    public NamingStrategy getNamingStrategy() {
        return namingStrategy;
    }

    public String getCustomRetryPolicy() {
        return customizationConfig.getCustomRetryPolicy();
    }

    public String getSdkModeledExceptionBaseFqcn() {
        return String.format(""%s.%s"",
                             metadata.getFullModelPackageName(),
                             getSdkModeledExceptionBaseClassName());
    }

    public String getSdkModeledExceptionBaseClassName() {
        if (customizationConfig.getSdkModeledExceptionBaseClassName() != null) {
            return customizationConfig.getSdkModeledExceptionBaseClassName();
        } else {
            return metadata.getBaseExceptionName();
        }
    }

    public String getSdkRequestBaseClassName() {
        if (customizationConfig.getSdkRequestBaseClassName() != null) {
            return customizationConfig.getSdkRequestBaseClassName();
        } else {
            return metadata.getBaseRequestName();
        }
    }

    public String getSdkResponseBaseClassName() {
        if (customizationConfig.getSdkResponseBaseClassName() != null) {
            return customizationConfig.getSdkResponseBaseClassName();
        } else {
            return metadata.getBaseResponseName();
        }
    }

    public String getFileHeader() throws IOException {
        return loadDefaultFileHeader();
    }

    private String loadDefaultFileHeader() throws IOException {
        try (InputStream inputStream = getClass()
            .getResourceAsStream(""/software/amazon/awssdk/codegen/DefaultFileHeader.txt"")) {
            return IoUtils.toUtf8String(inputStream)
                          .replaceFirst(""%COPYRIGHT_DATE_RANGE%"", getCopyrightDateRange());
        }
    }

    private String getCopyrightDateRange() {
        int currentYear = ZonedDateTime.now().getYear();
        int copyrightStartYear = currentYear - 5;
        return String.format(""%d-%d"", copyrightStartYear, currentYear);
    }

    public String getSdkBaseResponseFqcn() {
        if (metadata.getProtocol() == Protocol.API_GATEWAY) {
            return ""software.amazon.awssdk.opensdk.BaseResult"";
        } else {
            return String.format(""%s<%s>"",
                                 AwsResponse.class.getName(),
                                 getResponseMetadataClassName());
        }
    }

    private String getResponseMetadataClassName() {
        return AwsResponseMetadata.class.getName();
    }

    @JsonIgnore
    public List<OperationModel> simpleMethodsRequiringTesting() {
        return getOperations().values().stream()
                              .filter(v -> v.getInputShape().isSimpleMethod())
                              .collect(Collectors.toList());
    }

    public Map<String, AuthorizerModel> getCustomAuthorizers() {
        return customAuthorizers;
    }

    public Optional<OperationModel> getEndpointOperation() {
        return endpointOperation;
    }

    public boolean hasPaginators() {
        return paginators.size() > 0;
    }

    public boolean containsRequestSigners() {
        return getShapes().values().stream()
                          .filter(ShapeModel::isRequestSignerAware)
                          .findAny()
                          .isPresent();
    }

    public boolean containsRequestEventStreams() {
        return getOperations().values().stream()
                              .filter(opModel -> opModel.hasEventStreamInput())
                              .findAny()
                              .isPresent();
    }
}
",data class
839,"    private Object invoke(String methodName, Object returnValueIfNonExistent,
                          Class<?>[] paramTypes, Object[] params)
        throws DocletInvokeException {
            Method meth;
            try {
                meth = docletClass.getMethod(methodName, paramTypes);
            } catch (NoSuchMethodException exc) {
                if (returnValueIfNonExistent == null) {
                    messager.error(Messager.NOPOS, ""main.doclet_method_not_found"",
                                   docletClassName, methodName);
                    throw new DocletInvokeException();
                } else {
                    return returnValueIfNonExistent;
                }
            } catch (SecurityException exc) {
                messager.error(Messager.NOPOS, ""main.doclet_method_not_accessible"",
                               docletClassName, methodName);
                throw new DocletInvokeException();
            }
            if (!Modifier.isStatic(meth.getModifiers())) {
                messager.error(Messager.NOPOS, ""main.doclet_method_must_be_static"",
                               docletClassName, methodName);
                throw new DocletInvokeException();
            }
            ClassLoader savedCCL =
                Thread.currentThread().getContextClassLoader();
            try {
                if (appClassLoader != null) // will be null if doclet class provided via API
                    Thread.currentThread().setContextClassLoader(appClassLoader);
                return meth.invoke(null , params);
            } catch (IllegalArgumentException | NullPointerException exc) {
                messager.error(Messager.NOPOS, ""main.internal_error_exception_thrown"",
                               docletClassName, methodName, exc.toString());
                throw new DocletInvokeException();
            } catch (IllegalAccessException exc) {
                messager.error(Messager.NOPOS, ""main.doclet_method_not_accessible"",
                               docletClassName, methodName);
                throw new DocletInvokeException();
            }
            catch (InvocationTargetException exc) {
                Throwable err = exc.getTargetException();
                if (apiMode)
                    throw new ClientCodeException(err);
                if (err instanceof java.lang.OutOfMemoryError) {
                    messager.error(Messager.NOPOS, ""main.out.of.memory"");
                } else {
                    messager.error(Messager.NOPOS, ""main.exception_thrown"",
                               docletClassName, methodName, exc.toString());
                    exc.getTargetException().printStackTrace(System.err);
                }
                throw new DocletInvokeException();
            } finally {
                Thread.currentThread().setContextClassLoader(savedCCL);
            }
    }
",long method
484,"public class ConstraintBasePanel extends FormComponentPanel
{
    /** Default serialVersionUID */
    private static final long serialVersionUID = 1L;
    private static final String CLS_NM = ConstraintPanel.class.getName();
    private static final Logger log = Logger.getLogger( CLS_NM );

    protected static final String TIMEOUT = ""timeout"";
    protected static final String SUNDAY = ""sunday"";
    protected static final String MONDAY = ""monday"";
    protected static final String TUESDAY = ""tuesday"";
    protected static final String WEDNESDAY = ""wednesday"";
    protected static final String THURSDAY = ""thursday"";
    protected static final String FRIDAY = ""friday"";
    protected static final String SATURDAY = ""saturday"";

    protected static final String BEGIN_TIME = ""beginTime"";
    protected static final String END_TIME = ""endTime"";
    protected static final String BEGIN_DATE = ""beginDate"";
    protected static final String END_DATE = ""endDate"";
    protected static final String BEGIN_LOCK_DATE = ""beginLockDate"";
    protected static final String END_LOCK_DATE = ""endLockDate"";

    protected static final String DAY1 = ""1"";
    protected static final String DAY2 = ""2"";
    protected static final String DAY3 = ""3"";
    protected static final String DAY4 = ""4"";
    protected static final String DAY5 = ""5"";
    protected static final String DAY6 = ""6"";
    protected static final String DAY7 = ""7"";
    // These are used by this panel component's PropertyModel objects:

    protected Date beginTime;
    protected Date beginDate;
    protected Date endTime;
    protected Date endDate;
    protected Date beginLockDate;
    protected Date endLockDate;

    // These are the actual Wicket JQuery controls to process the input:
    protected TimePicker beginTimeTP;
    protected TimePicker endTimeTP;
    protected DatePicker beginDateDP;
    protected DatePicker endDateDP;
    protected DatePicker beginLockDateDP;
    protected DatePicker endLockDateDP;

    // The Wicket checkBoxes are used for constructing a {@link us.uts.fortress.rbac.User#dayMask} entity attribute into model model:
    protected CheckBox sundayCB;
    protected CheckBox mondayCB;
    protected CheckBox tuesdayCB;
    protected CheckBox wednesdayCB;
    protected CheckBox thursdayCB;
    protected CheckBox fridayCB;
    protected CheckBox saturdayCB;

    // These are used by CheckBox control to store the dayMask fields until mapped to {@link us.uts.fortress.rbac.User#dayMask} into model object:
    protected Boolean sunday = false;
    protected Boolean monday = false;
    protected Boolean tuesday = false;
    protected Boolean wednesday = false;
    protected Boolean thursday = false;
    protected Boolean friday = false;
    protected Boolean saturday = false;


    public ConstraintBasePanel( String id, final IModel constraint )
    {
        super( id, constraint );
        final Spinner<Integer> timeout = new Spinner<>( TIMEOUT );
        timeout.setRequired( false );
        add( timeout );

        // Add the dayMask's day of week CheckBoxes:
        sundayCB = new CheckBox( SUNDAY, new PropertyModel<Boolean>( this, SUNDAY ) )
        {
            /** Default serialVersionUID */
            private static final long serialVersionUID = 1L;


            @Override
            protected void onBeforeRender()
            {
                if ( this.getParent().getDefaultModelObject() != null )
                {
                    super.onBeforeRender();
                    Constraint constraint = ( Constraint ) this.getParent().getDefaultModelObject();
                    setSunday( isDayOfWeek( constraint, DAY1 ) );
                }
            }
        };
        add( sundayCB );
        mondayCB = new CheckBox( ""monday"", new PropertyModel<Boolean>( this, MONDAY ) )
        {
            /** Default serialVersionUID */
            private static final long serialVersionUID = 1L;


            @Override
            protected void onBeforeRender()
            {
                if ( this.getParent().getDefaultModelObject() != null )
                {
                    super.onBeforeRender();
                    Constraint constraint = ( Constraint ) this.getParent().getDefaultModelObject();
                    setMonday( isDayOfWeek( constraint, DAY2 ) );
                }
            }
        };
        add( mondayCB );
        tuesdayCB = new CheckBox( TUESDAY, new PropertyModel<Boolean>( this, TUESDAY ) )
        {
            /** Default serialVersionUID */
            private static final long serialVersionUID = 1L;


            @Override
            protected void onBeforeRender()
            {
                if ( this.getParent().getDefaultModelObject() != null )
                {
                    super.onBeforeRender();
                    Constraint constraint = ( Constraint ) this.getParent().getDefaultModelObject();
                    setTuesday( isDayOfWeek( constraint, DAY3 ) );
                }
            }
        };
        add( tuesdayCB );
        wednesdayCB = new CheckBox( WEDNESDAY, new PropertyModel<Boolean>( this, WEDNESDAY ) )
        {
            /** Default serialVersionUID */
            private static final long serialVersionUID = 1L;


            @Override
            protected void onBeforeRender()
            {
                if ( this.getParent().getDefaultModelObject() != null )
                {
                    super.onBeforeRender();
                    Constraint constraint = ( Constraint ) this.getParent().getDefaultModelObject();
                    setWednesday( isDayOfWeek( constraint, DAY4 ) );
                }
            }
        };
        add( wednesdayCB );
        thursdayCB = new CheckBox( THURSDAY, new PropertyModel<Boolean>( this, THURSDAY ) )
        {
            /** Default serialVersionUID */
            private static final long serialVersionUID = 1L;


            @Override
            protected void onBeforeRender()
            {
                if ( this.getParent().getDefaultModelObject() != null )
                {
                    super.onBeforeRender();
                    Constraint constraint = ( Constraint ) this.getParent().getDefaultModelObject();
                    setThursday( isDayOfWeek( constraint, DAY5 ) );
                }
            }
        };
        add( thursdayCB );
        fridayCB = new CheckBox( FRIDAY, new PropertyModel<Boolean>( this, FRIDAY ) )
        {
            /** Default serialVersionUID */
            private static final long serialVersionUID = 1L;


            @Override
            protected void onBeforeRender()
            {
                if ( this.getParent().getDefaultModelObject() != null )
                {
                    super.onBeforeRender();
                    Constraint constraint = ( Constraint ) this.getParent().getDefaultModelObject();
                    setFriday( isDayOfWeek( constraint, DAY6 ) );
                }
            }
        };
        add( fridayCB );
        saturdayCB = new CheckBox( SATURDAY, new PropertyModel<Boolean>( this, SATURDAY ) )
        {
            /** Default serialVersionUID */
            private static final long serialVersionUID = 1L;


            @Override
            protected void onBeforeRender()
            {
                if ( this.getParent().getDefaultModelObject() != null )
                {
                    super.onBeforeRender();
                    Constraint constraint = ( Constraint ) this.getParent().getDefaultModelObject();
                    setSaturday( isDayOfWeek( constraint, DAY7 ) );
                }
            }
        };
        add( saturdayCB );
    }


    /**
     * This method is used to convert from the panel component model to the domain model:
     */
    @Override
    public void convertInput()
    {
        Constraint constraint = ( Constraint ) getDefaultModelObject();
        if ( constraint != null )
        {
            constraint.setBeginTime( convertTime( beginTimeTP ) );
            constraint.setEndTime( convertTime( endTimeTP ) );
            constraint.setBeginDate( convertDate( beginDateDP ) );
            constraint.setEndDate( convertDate( endDateDP ) );
            constraint.setBeginLockDate( convertDate( beginLockDateDP ) );
            constraint.setEndLockDate( convertDate( endLockDateDP ) );

            setSunday( sundayCB.getConvertedInput() );
            setMonday( mondayCB.getConvertedInput() );
            setTuesday( tuesdayCB.getConvertedInput() );
            setWednesday( wednesdayCB.getConvertedInput() );
            setThursday( thursdayCB.getConvertedInput() );
            setFriday( fridayCB.getConvertedInput() );
            setSaturday( saturdayCB.getConvertedInput() );

            String szDayMask = """";
            if ( sunday )
                szDayMask += DAY1;
            if ( monday )
                szDayMask += DAY2;
            if ( tuesday )
                szDayMask += DAY3;
            if ( wednesday )
                szDayMask += DAY4;
            if ( thursday )
                szDayMask += DAY5;
            if ( friday )
                szDayMask += DAY6;
            if ( saturday )
                szDayMask += DAY7;

            constraint.setDayMask( szDayMask );
            setConvertedInput( constraint );
        }
        else
        {
            log.warn( ""constraint was null"" );
        }
    }


    protected boolean isDayOfWeek( Constraint constraint, String szDay )
    {
        boolean isSet = false;
        if ( constraint != null && constraint.getDayMask() != null
            && ( constraint.getDayMask().contains( szDay ) || constraint.getDayMask().equals( ""all"" ) ) )
        {
            isSet = true;
        }
        return isSet;
    }


    protected String convertTime( TimePicker time )
    {
        String szTime = null;
        if ( time != null )
        {
            Date localDate = time.getConvertedInput();
            if ( localDate != null )
            {
                Calendar calendar = Calendar.getInstance();
                calendar.setTime( localDate );
                log.debug( ""localDate="" + localDate.toString() );
                if ( calendar.get( Calendar.HOUR_OF_DAY ) < 10 )
                    szTime = ""0"" + calendar.get( Calendar.HOUR_OF_DAY );
                else
                    szTime = """" + calendar.get( Calendar.HOUR_OF_DAY );
                if ( calendar.get( Calendar.MINUTE ) < 10 )
                    szTime += ""0"" + calendar.get( Calendar.MINUTE );
                else
                    szTime += """" + calendar.get( Calendar.MINUTE );
            }
        }
        return szTime;
    }


    protected String convertDate( DatePicker date )
    {
        String szDate = null;
        if ( date != null )
        {
            Date localDate = date.getConvertedInput();
            if ( localDate != null )
            {
                Calendar calendar = Calendar.getInstance();
                calendar.setTime( localDate );
                log.debug( ""localDate="" + localDate.toString() );
                szDate = """" + calendar.get( Calendar.YEAR );

                if ( ( calendar.get( Calendar.MONTH ) + 1 ) < 10 )
                    szDate += ""0"" + ( calendar.get( Calendar.MONTH ) + 1 );
                else
                    szDate += """" + ( calendar.get( Calendar.MONTH ) + 1 );
                if ( calendar.get( Calendar.DAY_OF_MONTH ) < 10 )
                    szDate += ""0"" + calendar.get( Calendar.DAY_OF_MONTH );
                else
                    szDate += """" + calendar.get( Calendar.DAY_OF_MONTH );
            }
        }
        return szDate;
    }


    protected Date renderTime( Date date, String szTime )
    {
        if ( szTime != null )
        {
            Calendar calendar = Calendar.getInstance();
            try
            {
                int hours = Integer.valueOf( szTime.substring( 0, 2 ) );
                int minutes = Integer.valueOf( szTime.substring( 2, 4 ) );
                // zero hours convert to 24 for calendar:
                if(hours == 0)
                {
                    hours = 24;
                }
                calendar.set( 0, 0, 0, hours, minutes );
                date = calendar.getTime();
            }
            catch ( StringIndexOutOfBoundsException e )
            {
                String warning = CLS_NM + "".renderTime bad time: "" + szTime;
                log.warn( warning );
                //warn(warning);
            }
        }
        else
        {
            date = null;
        }
        return date;
    }


    protected Date renderDate( Date date, String szDate )
    {
        if ( szDate != null && !szDate.equalsIgnoreCase( ""none"" ) )
        {
            Calendar calendar = Calendar.getInstance();
            try
            {
                int years = Integer.valueOf( szDate.substring( 0, 4 ) );
                int months = Integer.valueOf( szDate.substring( 4, 6 ) );
                // Convert months because the Calendar uses 0 - 11:
                months = months - 1;
                int days = Integer.valueOf( szDate.substring( 6, 8 ) );
                calendar.set( years, months, days, 0, 0 );
                date = calendar.getTime();
            }
            catch ( StringIndexOutOfBoundsException e )
            {
                String warning = CLS_NM + "".renderDate bad date: "" + szDate;
                log.warn( warning );
                //warn(warning);
            }
        }
        else
        {
            date = null;
        }
        return date;
    }


    protected Boolean getSunday()
    {
        return sunday;
    }


    protected void setSunday( Boolean sunday )
    {
        this.sunday = sunday;
    }


    protected Boolean getMonday()
    {
        return monday;
    }


    protected void setMonday( Boolean monday )
    {
        this.monday = monday;
    }


    protected Boolean getTuesday()
    {
        return tuesday;
    }


    protected void setTuesday( Boolean tuesday )
    {
        this.tuesday = tuesday;
    }


    protected Boolean getWednesday()
    {
        return wednesday;
    }


    protected void setWednesday( Boolean wednesday )
    {
        this.wednesday = wednesday;
    }


    protected Boolean getThursday()
    {
        return thursday;
    }


    protected void setThursday( Boolean thursday )
    {
        this.thursday = thursday;
    }


    protected Boolean getFriday()
    {
        return friday;
    }


    protected void setFriday( Boolean friday )
    {
        this.friday = friday;
    }


    protected Boolean getSaturday()
    {
        return saturday;
    }


    protected void setSaturday( Boolean saturday )
    {
        this.saturday = saturday;
    }
}
",data class
978,"public abstract class EndpointDiscoverer<E extends ExposableEndpoint<O>, O extends Operation>
		implements EndpointsSupplier<E> {

	private final ApplicationContext applicationContext;

	private final Collection<EndpointFilter<E>> filters;

	private final DiscoveredOperationsFactory<O> operationsFactory;

	private final Map<EndpointBean, E> filterEndpoints = new ConcurrentHashMap<>();

	private volatile Collection<E> endpoints;

	/**
	 * Create a new {@link EndpointDiscoverer} instance.
	 * @param applicationContext the source application context
	 * @param parameterValueMapper the parameter value mapper
	 * @param invokerAdvisors invoker advisors to apply
	 * @param filters filters to apply
	 */
	public EndpointDiscoverer(ApplicationContext applicationContext,
			ParameterValueMapper parameterValueMapper,
			Collection<OperationInvokerAdvisor> invokerAdvisors,
			Collection<EndpointFilter<E>> filters) {
		Assert.notNull(applicationContext, ""ApplicationContext must not be null"");
		Assert.notNull(parameterValueMapper, ""ParameterValueMapper must not be null"");
		Assert.notNull(invokerAdvisors, ""InvokerAdvisors must not be null"");
		Assert.notNull(filters, ""Filters must not be null"");
		this.applicationContext = applicationContext;
		this.filters = Collections.unmodifiableCollection(filters);
		this.operationsFactory = getOperationsFactory(parameterValueMapper,
				invokerAdvisors);
	}

	private DiscoveredOperationsFactory<O> getOperationsFactory(
			ParameterValueMapper parameterValueMapper,
			Collection<OperationInvokerAdvisor> invokerAdvisors) {
		return new DiscoveredOperationsFactory<O>(parameterValueMapper, invokerAdvisors) {

			@Override
			protected O createOperation(EndpointId endpointId,
					DiscoveredOperationMethod operationMethod, OperationInvoker invoker) {
				return EndpointDiscoverer.this.createOperation(endpointId,
						operationMethod, invoker);
			}

		};
	}

	@Override
	public final Collection<E> getEndpoints() {
		if (this.endpoints == null) {
			this.endpoints = discoverEndpoints();
		}
		return this.endpoints;
	}

	private Collection<E> discoverEndpoints() {
		Collection<EndpointBean> endpointBeans = createEndpointBeans();
		addExtensionBeans(endpointBeans);
		return convertToEndpoints(endpointBeans);
	}

	private Collection<EndpointBean> createEndpointBeans() {
		Map<EndpointId, EndpointBean> byId = new LinkedHashMap<>();
		String[] beanNames = BeanFactoryUtils.beanNamesForAnnotationIncludingAncestors(
				this.applicationContext, Endpoint.class);
		for (String beanName : beanNames) {
			if (!ScopedProxyUtils.isScopedTarget(beanName)) {
				EndpointBean endpointBean = createEndpointBean(beanName);
				EndpointBean previous = byId.putIfAbsent(endpointBean.getId(),
						endpointBean);
				Assert.state(previous == null,
						() -> ""Found two endpoints with the id '"" + endpointBean.getId()
								+ ""': '"" + endpointBean.getBeanName() + ""' and '""
								+ previous.getBeanName() + ""'"");
			}
		}
		return byId.values();
	}

	private EndpointBean createEndpointBean(String beanName) {
		Object bean = this.applicationContext.getBean(beanName);
		return new EndpointBean(beanName, bean);
	}

	private void addExtensionBeans(Collection<EndpointBean> endpointBeans) {
		Map<EndpointId, EndpointBean> byId = endpointBeans.stream()
				.collect(Collectors.toMap(EndpointBean::getId, Function.identity()));
		String[] beanNames = BeanFactoryUtils.beanNamesForAnnotationIncludingAncestors(
				this.applicationContext, EndpointExtension.class);
		for (String beanName : beanNames) {
			ExtensionBean extensionBean = createExtensionBean(beanName);
			EndpointBean endpointBean = byId.get(extensionBean.getEndpointId());
			Assert.state(endpointBean != null,
					() -> (""Invalid extension '"" + extensionBean.getBeanName()
							+ ""': no endpoint found with id '""
							+ extensionBean.getEndpointId() + ""'""));
			addExtensionBean(endpointBean, extensionBean);
		}
	}

	private ExtensionBean createExtensionBean(String beanName) {
		Object bean = this.applicationContext.getBean(beanName);
		return new ExtensionBean(beanName, bean);
	}

	private void addExtensionBean(EndpointBean endpointBean,
			ExtensionBean extensionBean) {
		if (isExtensionExposed(endpointBean, extensionBean)) {
			Assert.state(
					isEndpointExposed(endpointBean) || isEndpointFiltered(endpointBean),
					() -> ""Endpoint bean '"" + endpointBean.getBeanName()
							+ ""' cannot support the extension bean '""
							+ extensionBean.getBeanName() + ""'"");
			endpointBean.addExtension(extensionBean);
		}
	}

	private Collection<E> convertToEndpoints(Collection<EndpointBean> endpointBeans) {
		Set<E> endpoints = new LinkedHashSet<>();
		for (EndpointBean endpointBean : endpointBeans) {
			if (isEndpointExposed(endpointBean)) {
				endpoints.add(convertToEndpoint(endpointBean));
			}
		}
		return Collections.unmodifiableSet(endpoints);
	}

	private E convertToEndpoint(EndpointBean endpointBean) {
		MultiValueMap<OperationKey, O> indexed = new LinkedMultiValueMap<>();
		EndpointId id = endpointBean.getId();
		addOperations(indexed, id, endpointBean.getBean(), false);
		if (endpointBean.getExtensions().size() > 1) {
			String extensionBeans = endpointBean.getExtensions().stream()
					.map(ExtensionBean::getBeanName).collect(Collectors.joining("", ""));
			throw new IllegalStateException(
					""Found multiple extensions for the endpoint bean ""
							+ endpointBean.getBeanName() + "" ("" + extensionBeans + "")"");
		}
		for (ExtensionBean extensionBean : endpointBean.getExtensions()) {
			addOperations(indexed, id, extensionBean.getBean(), true);
		}
		assertNoDuplicateOperations(endpointBean, indexed);
		List<O> operations = indexed.values().stream().map(this::getLast)
				.filter(Objects::nonNull).collect(Collectors.collectingAndThen(
						Collectors.toList(), Collections::unmodifiableList));
		return createEndpoint(endpointBean.getBean(), id,
				endpointBean.isEnabledByDefault(), operations);
	}

	private void addOperations(MultiValueMap<OperationKey, O> indexed, EndpointId id,
			Object target, boolean replaceLast) {
		Set<OperationKey> replacedLast = new HashSet<>();
		Collection<O> operations = this.operationsFactory.createOperations(id, target);
		for (O operation : operations) {
			OperationKey key = createOperationKey(operation);
			O last = getLast(indexed.get(key));
			if (replaceLast && replacedLast.add(key) && last != null) {
				indexed.get(key).remove(last);
			}
			indexed.add(key, operation);
		}
	}

	private <T> T getLast(List<T> list) {
		return CollectionUtils.isEmpty(list) ? null : list.get(list.size() - 1);
	}

	private void assertNoDuplicateOperations(EndpointBean endpointBean,
			MultiValueMap<OperationKey, O> indexed) {
		List<OperationKey> duplicates = indexed.entrySet().stream()
				.filter((entry) -> entry.getValue().size() > 1).map(Map.Entry::getKey)
				.collect(Collectors.toList());
		if (!duplicates.isEmpty()) {
			Set<ExtensionBean> extensions = endpointBean.getExtensions();
			String extensionBeanNames = extensions.stream()
					.map(ExtensionBean::getBeanName).collect(Collectors.joining("", ""));
			throw new IllegalStateException(
					""Unable to map duplicate endpoint operations: ""
							+ duplicates.toString() + "" to "" + endpointBean.getBeanName()
							+ (extensions.isEmpty() ? """"
									: "" ("" + extensionBeanNames + "")""));
		}
	}

	private boolean isExtensionExposed(EndpointBean endpointBean,
			ExtensionBean extensionBean) {
		return isFilterMatch(extensionBean.getFilter(), endpointBean)
				&& isExtensionExposed(extensionBean.getBean());
	}

	/**
	 * Determine if an extension bean should be exposed. Subclasses can override this
	 * method to provide additional logic.
	 * @param extensionBean the extension bean
	 * @return {@code true} if the extension is exposed
	 */
	protected boolean isExtensionExposed(Object extensionBean) {
		return true;
	}

	private boolean isEndpointExposed(EndpointBean endpointBean) {
		return isFilterMatch(endpointBean.getFilter(), endpointBean)
				&& !isEndpointFiltered(endpointBean)
				&& isEndpointExposed(endpointBean.getBean());
	}

	/**
	 * Determine if an endpoint bean should be exposed. Subclasses can override this
	 * method to provide additional logic.
	 * @param endpointBean the endpoint bean
	 * @return {@code true} if the endpoint is exposed
	 */
	protected boolean isEndpointExposed(Object endpointBean) {
		return true;
	}

	private boolean isEndpointFiltered(EndpointBean endpointBean) {
		for (EndpointFilter<E> filter : this.filters) {
			if (!isFilterMatch(filter, endpointBean)) {
				return true;
			}
		}
		return false;
	}

	@SuppressWarnings(""unchecked"")
	private boolean isFilterMatch(Class<?> filter, EndpointBean endpointBean) {
		if (!isEndpointExposed(endpointBean.getBean())) {
			return false;
		}
		if (filter == null) {
			return true;
		}
		E endpoint = getFilterEndpoint(endpointBean);
		Class<?> generic = ResolvableType.forClass(EndpointFilter.class, filter)
				.resolveGeneric(0);
		if (generic == null || generic.isInstance(endpoint)) {
			EndpointFilter<E> instance = (EndpointFilter<E>) BeanUtils
					.instantiateClass(filter);
			return isFilterMatch(instance, endpoint);
		}
		return false;

	}

	private boolean isFilterMatch(EndpointFilter<E> filter, EndpointBean endpointBean) {
		return isFilterMatch(filter, getFilterEndpoint(endpointBean));
	}

	@SuppressWarnings(""unchecked"")
	private boolean isFilterMatch(EndpointFilter<E> filter, E endpoint) {
		return LambdaSafe.callback(EndpointFilter.class, filter, endpoint)
				.withLogger(EndpointDiscoverer.class).invokeAnd((f) -> f.match(endpoint))
				.get();
	}

	private E getFilterEndpoint(EndpointBean endpointBean) {
		E endpoint = this.filterEndpoints.get(endpointBean);
		if (endpoint == null) {
			endpoint = createEndpoint(endpointBean.getBean(), endpointBean.getId(),
					endpointBean.isEnabledByDefault(), Collections.emptySet());
			this.filterEndpoints.put(endpointBean, endpoint);
		}
		return endpoint;
	}

	@SuppressWarnings(""unchecked"")
	protected Class<? extends E> getEndpointType() {
		return (Class<? extends E>) ResolvableType
				.forClass(EndpointDiscoverer.class, getClass()).resolveGeneric(0);
	}

	/**
	 * Factory method called to create the {@link ExposableEndpoint endpoint}.
	 * @param endpointBean the source endpoint bean
	 * @param id the ID of the endpoint
	 * @param enabledByDefault if the endpoint is enabled by default
	 * @param operations the endpoint operations
	 * @return a created endpoint (a {@link DiscoveredEndpoint} is recommended)
	 */
	protected abstract E createEndpoint(Object endpointBean, EndpointId id,
			boolean enabledByDefault, Collection<O> operations);

	/**
	 * Factory method to create an {@link Operation endpoint operation}.
	 * @param endpointId the endpoint id
	 * @param operationMethod the operation method
	 * @param invoker the invoker to use
	 * @return a created operation
	 */
	protected abstract O createOperation(EndpointId endpointId,
			DiscoveredOperationMethod operationMethod, OperationInvoker invoker);

	/**
	 * Create an {@link OperationKey} for the given operation.
	 * @param operation the source operation
	 * @return the operation key
	 */
	protected abstract OperationKey createOperationKey(O operation);

	/**
	 * A key generated for an {@link Operation} based on specific criteria from the actual
	 * operation implementation.
	 */
	protected static final class OperationKey {

		private final Object key;

		private final Supplier<String> description;

		/**
		 * Create a new {@link OperationKey} instance.
		 * @param key the underlying key for the operation
		 * @param description a human readable description of the key
		 */
		public OperationKey(Object key, Supplier<String> description) {
			Assert.notNull(key, ""Key must not be null"");
			Assert.notNull(description, ""Description must not be null"");
			this.key = key;
			this.description = description;
		}

		@Override
		public boolean equals(Object obj) {
			if (obj == this) {
				return true;
			}
			if (obj == null || getClass() != obj.getClass()) {
				return false;
			}
			return this.key.equals(((OperationKey) obj).key);
		}

		@Override
		public int hashCode() {
			return this.key.hashCode();
		}

		@Override
		public String toString() {
			return this.description.get();
		}

	}

	/**
	 * Information about an {@link Endpoint @Endpoint} bean.
	 */
	private static class EndpointBean {

		private final String beanName;

		private final Object bean;

		private final EndpointId id;

		private boolean enabledByDefault;

		private final Class<?> filter;

		private Set<ExtensionBean> extensions = new LinkedHashSet<>();

		EndpointBean(String beanName, Object bean) {
			AnnotationAttributes attributes = AnnotatedElementUtils
					.findMergedAnnotationAttributes(bean.getClass(), Endpoint.class, true,
							true);
			String id = attributes.getString(""id"");
			Assert.state(StringUtils.hasText(id),
					() -> ""No @Endpoint id attribute specified for ""
							+ bean.getClass().getName());
			this.beanName = beanName;
			this.bean = bean;
			this.id = EndpointId.of(id);
			this.enabledByDefault = (Boolean) attributes.get(""enableByDefault"");
			this.filter = getFilter(this.bean.getClass());
		}

		public void addExtension(ExtensionBean extensionBean) {
			this.extensions.add(extensionBean);
		}

		public Set<ExtensionBean> getExtensions() {
			return this.extensions;
		}

		private Class<?> getFilter(Class<?> type) {
			AnnotationAttributes attributes = AnnotatedElementUtils
					.getMergedAnnotationAttributes(type, FilteredEndpoint.class);
			if (attributes == null) {
				return null;
			}
			return attributes.getClass(""value"");
		}

		public String getBeanName() {
			return this.beanName;
		}

		public Object getBean() {
			return this.bean;
		}

		public EndpointId getId() {
			return this.id;
		}

		public boolean isEnabledByDefault() {
			return this.enabledByDefault;
		}

		public Class<?> getFilter() {
			return this.filter;
		}

	}

	/**
	 * Information about an {@link EndpointExtension EndpointExtension} bean.
	 */
	private static class ExtensionBean {

		private final String beanName;

		private final Object bean;

		private final EndpointId endpointId;

		private final Class<?> filter;

		ExtensionBean(String beanName, Object bean) {
			this.bean = bean;
			this.beanName = beanName;
			AnnotationAttributes attributes = AnnotatedElementUtils
					.getMergedAnnotationAttributes(bean.getClass(),
							EndpointExtension.class);
			Class<?> endpointType = attributes.getClass(""endpoint"");
			AnnotationAttributes endpointAttributes = AnnotatedElementUtils
					.findMergedAnnotationAttributes(endpointType, Endpoint.class, true,
							true);
			Assert.state(endpointAttributes != null, () -> ""Extension ""
					+ endpointType.getName() + "" does not specify an endpoint"");
			this.endpointId = EndpointId.of(endpointAttributes.getString(""id""));
			this.filter = attributes.getClass(""filter"");
		}

		public String getBeanName() {
			return this.beanName;
		}

		public Object getBean() {
			return this.bean;
		}

		public EndpointId getEndpointId() {
			return this.endpointId;
		}

		public Class<?> getFilter() {
			return this.filter;
		}

	}

}
",blob
1293,"  @SuppressWarnings(""unchecked"")
  protected Map<byte[], List<Path>>[] handleBulkLoad(List<TableName> sTableList)
          throws IOException {
    Map<byte[], List<Path>>[] mapForSrc = new Map[sTableList.size()];
    List<String> activeFiles = new ArrayList<>();
    List<String> archiveFiles = new ArrayList<>();
    Pair<Map<TableName, Map<String, Map<String, List<Pair<String, Boolean>>>>>, List<byte[]>> pair =
            backupManager.readBulkloadRows(sTableList);
    Map<TableName, Map<String, Map<String, List<Pair<String, Boolean>>>>> map = pair.getFirst();
    FileSystem tgtFs;
    try {
      tgtFs = FileSystem.get(new URI(backupInfo.getBackupRootDir()), conf);
    } catch (URISyntaxException use) {
      throw new IOException(""Unable to get FileSystem"", use);
    }
    Path rootdir = FSUtils.getRootDir(conf);
    Path tgtRoot = new Path(new Path(backupInfo.getBackupRootDir()), backupId);

    for (Map.Entry<TableName, Map<String, Map<String, List<Pair<String, Boolean>>>>> tblEntry :
      map.entrySet()) {
      TableName srcTable = tblEntry.getKey();

      int srcIdx = getIndex(srcTable, sTableList);
      if (srcIdx < 0) {
        LOG.warn(""Couldn't find "" + srcTable + "" in source table List"");
        continue;
      }
      if (mapForSrc[srcIdx] == null) {
        mapForSrc[srcIdx] = new TreeMap<>(Bytes.BYTES_COMPARATOR);
      }
      Path tblDir = FSUtils.getTableDir(rootdir, srcTable);
      Path tgtTable = new Path(new Path(tgtRoot, srcTable.getNamespaceAsString()),
          srcTable.getQualifierAsString());
      for (Map.Entry<String,Map<String,List<Pair<String, Boolean>>>> regionEntry :
        tblEntry.getValue().entrySet()){
        String regionName = regionEntry.getKey();
        Path regionDir = new Path(tblDir, regionName);
        // map from family to List of hfiles
        for (Map.Entry<String,List<Pair<String, Boolean>>> famEntry :
          regionEntry.getValue().entrySet()) {
          String fam = famEntry.getKey();
          Path famDir = new Path(regionDir, fam);
          List<Path> files;
          if (!mapForSrc[srcIdx].containsKey(Bytes.toBytes(fam))) {
            files = new ArrayList<>();
            mapForSrc[srcIdx].put(Bytes.toBytes(fam), files);
          } else {
            files = mapForSrc[srcIdx].get(Bytes.toBytes(fam));
          }
          Path archiveDir = HFileArchiveUtil.getStoreArchivePath(conf, srcTable, regionName, fam);
          String tblName = srcTable.getQualifierAsString();
          Path tgtFam = new Path(new Path(tgtTable, regionName), fam);
          if (!tgtFs.mkdirs(tgtFam)) {
            throw new IOException(""couldn't create "" + tgtFam);
          }
          for (Pair<String, Boolean> fileWithState : famEntry.getValue()) {
            String file = fileWithState.getFirst();
            int idx = file.lastIndexOf(""/"");
            String filename = file;
            if (idx > 0) {
              filename = file.substring(idx+1);
            }
            Path p = new Path(famDir, filename);
            Path tgt = new Path(tgtFam, filename);
            Path archive = new Path(archiveDir, filename);
            if (fs.exists(p)) {
              if (LOG.isTraceEnabled()) {
                LOG.trace(""found bulk hfile "" + file + "" in "" + famDir + "" for "" + tblName);
              }
              if (LOG.isTraceEnabled()) {
                LOG.trace(""copying "" + p + "" to "" + tgt);
              }
              activeFiles.add(p.toString());
            } else if (fs.exists(archive)){
              LOG.debug(""copying archive "" + archive + "" to "" + tgt);
              archiveFiles.add(archive.toString());
            }
            files.add(tgt);
          }
        }
      }
    }

    copyBulkLoadedFiles(activeFiles, archiveFiles);
    backupManager.deleteBulkLoadedRows(pair.getSecond());
    return mapForSrc;
  }
",long method
1193,"public class MemoryConsumptionTestClient
{
    private static final Logger LOGGER = LoggerFactory.getLogger(MemoryConsumptionTestClient.class);

    private static final String RESULTS_FILE_ARG = ""resultsFile"";

    private static final String JNDI_PROPERTIES_ARG = ""jndiProperties"";
    private static final String JNDI_CONNECTION_FACTORY_ARG = ""jndiConnectionFactory"";
    private static final String JNDI_DESTINATION_ARG = ""jndiDestination"";

    private static final String CONNECTIONS_ARG = ""connections"";
    private static final String SESSIONS_ARG = ""sessions"";
    private static final String PRODUCERS_ARG = ""producers"";
    private static final String MESSAGE_COUNT_ARG = ""messagecount"";
    private static final String MESSAGE_SIZE_ARG = ""size"";
    private static final String PERSISTENT_ARG = ""persistent"";
    private static final String TIMEOUT_ARG = ""timeout"";
    private static final String TRANSACTED_ARG = ""transacted"";
    private static final String JMX_HOST_ARG = ""jmxhost"";
    private static final String JMX_PORT_ARG = ""jmxport"";
    private static final String JMX_USER_ARG = ""jmxuser"";
    private static final String JMX_USER_PASSWORD_ARG = ""jmxpassword"";

    private static final String RESULTS_FILE_DEFAULT = ""results.csv"";
    private static final String JNDI_PROPERTIES_DEFAULT = ""stress-test-client-qpid-jms-client-0-x.properties"";
    private static final String JNDI_CONNECTION_FACTORY_DEFAULT = ""qpidConnectionFactory"";
    private static final String JNDI_DESTINATION_DEFAULT = ""stressTestQueue"";
    private static final String CONNECTIONS_DEFAULT = ""1"";
    private static final String SESSIONS_DEFAULT = ""1"";
    private static final String PRODUCERS_DEFAULT = ""1"";
    private static final String MESSAGE_COUNT_DEFAULT = ""1"";
    private static final String MESSAGE_SIZE_DEFAULT = ""256"";
    private static final String PERSISTENT_DEFAULT = ""false"";
    private static final String TIMEOUT_DEFAULT = ""1000"";
    private static final String TRANSACTED_DEFAULT = ""false"";

    private static final String JMX_HOST_DEFAULT = ""localhost"";
    private static final String JMX_PORT_DEFAULT = ""8999"";
    private static final String JMX_GARBAGE_COLLECTOR_MBEAN = ""gc"";

    public static void main(String[] args) throws Exception
    {
        Map<String,String> options = new HashMap<>();
        options.put(RESULTS_FILE_ARG, RESULTS_FILE_DEFAULT);
        options.put(JNDI_PROPERTIES_ARG, JNDI_PROPERTIES_DEFAULT);
        options.put(JNDI_CONNECTION_FACTORY_ARG, JNDI_CONNECTION_FACTORY_DEFAULT);
        options.put(JNDI_DESTINATION_ARG, JNDI_DESTINATION_DEFAULT);
        options.put(CONNECTIONS_ARG, CONNECTIONS_DEFAULT);
        options.put(SESSIONS_ARG, SESSIONS_DEFAULT);
        options.put(PRODUCERS_ARG, PRODUCERS_DEFAULT);
        options.put(MESSAGE_COUNT_ARG, MESSAGE_COUNT_DEFAULT);
        options.put(MESSAGE_SIZE_ARG, MESSAGE_SIZE_DEFAULT);
        options.put(PERSISTENT_ARG, PERSISTENT_DEFAULT);
        options.put(TIMEOUT_ARG, TIMEOUT_DEFAULT);
        options.put(TRANSACTED_ARG, TRANSACTED_DEFAULT);
        options.put(JMX_HOST_ARG, JMX_HOST_DEFAULT);
        options.put(JMX_PORT_ARG, JMX_PORT_DEFAULT);
        options.put(JMX_USER_ARG, """");
        options.put(JMX_USER_PASSWORD_ARG, """");
        options.put(JMX_GARBAGE_COLLECTOR_MBEAN, ""java.lang:type=GarbageCollector,name=ConcurrentMarkSweep"");

        if(args.length == 1 &&
                (args[0].equals(""-h"") || args[0].equals(""--help"") || args[0].equals(""help"")))
        {
            System.out.println(""arg=value options: \n"" + options.keySet());
            return;
        }

        parseArgumentsIntoConfig(options, args);

        MemoryConsumptionTestClient testClient = new MemoryConsumptionTestClient();
        testClient.runTest(options);
    }

    private static void parseArgumentsIntoConfig(Map<String, String> initialValues, String[] args)
    {
        for(String arg: args)
        {
            int equalPos = arg.indexOf('=');
            if(equalPos == -1)
            {
                throw new IllegalArgumentException(""arguments must have format <name>=<value>: "" + arg);
            }

            if(initialValues.put(arg.substring(0, equalPos), arg.substring(equalPos + 1)) == null)
            {
                throw new IllegalArgumentException(""not a valid configuration property: "" + arg);
            }
        }
    }


    private void runTest(Map<String,String> options) throws Exception
    {
        String resultsFile = options.get(RESULTS_FILE_ARG);
        String jndiProperties = options.get(JNDI_PROPERTIES_ARG);
        String connectionFactoryString = options.get(JNDI_CONNECTION_FACTORY_ARG);
        int numConnections = Integer.parseInt(options.get(CONNECTIONS_ARG));
        int numSessions = Integer.parseInt(options.get(SESSIONS_ARG));
        int numProducers = Integer.parseInt(options.get(PRODUCERS_ARG));
        int numMessage = Integer.parseInt(options.get(MESSAGE_COUNT_ARG));
        int messageSize = Integer.parseInt(options.get(MESSAGE_SIZE_ARG));
        String queueString = options.get(JNDI_DESTINATION_ARG);
        int deliveryMode = Boolean.valueOf(options.get(PERSISTENT_ARG)) ? DeliveryMode.PERSISTENT : DeliveryMode.NON_PERSISTENT;
        long receiveTimeout = Long.parseLong(options.get(TIMEOUT_ARG));
        boolean transacted = Boolean.valueOf(options.get(TRANSACTED_ARG));

        LOGGER.info(""Using options: "" + options);


        // Load JNDI properties
        Context ctx = getInitialContext(jndiProperties);
        final ConnectionFactory conFac = (ConnectionFactory) ctx.lookup(connectionFactoryString);

        Destination destination = ensureQueueCreated(queueString, conFac);
        Map<Connection, List<Session>> connectionsAndSessions = openConnectionsAndSessions(numConnections, numSessions, transacted, conFac);
        publish(numMessage, messageSize, numProducers, deliveryMode, destination, connectionsAndSessions);
        MemoryStatistic memoryStatistics = collectMemoryStatistics(options);
        generateCSV(memoryStatistics, numConnections, numSessions, transacted, numMessage, messageSize, numProducers, deliveryMode, resultsFile);
        purgeQueue(conFac, queueString, receiveTimeout);
        closeConnections(connectionsAndSessions.keySet());
        System.exit(0);
    }

    private void generateCSV(MemoryStatistic memoryStatistics,
                             int numConnections,
                             int numSessions,
                             boolean transacted,
                             int numMessage,
                             int messageSize,
                             int numProducers,
                             int deliveryMode,
                             final String resultsFile) throws IOException
    {
        try (FileWriter writer = new FileWriter(resultsFile))
        {
            writer.write(memoryStatistics.getHeapUsage()
                         + "",""
                         + memoryStatistics.getDirectMemoryUsage()
                         + "",""
                         + numConnections
                         + "",""
                         + numSessions
                         + "",""
                         + numProducers
                         + "",""
                         + transacted
                         + "",""
                         + numMessage
                         + "",""
                         + messageSize
                         + "",""
                         + deliveryMode
                         + "",""
                         + toUserFriendlyName(memoryStatistics.getHeapUsage())
                         + "",""
                         + toUserFriendlyName(memoryStatistics.getDirectMemoryUsage())
                         + System.lineSeparator());
        }
    }

    private void publish(int numberOfMessages, int messageSize, int numberOfProducers, int deliveryMode,
                         Destination destination, Map<Connection, List<Session>> connectionsAndSessions) throws JMSException
    {
        byte[] messageBytes = generateMessage(messageSize);
        for (List<Session> sessions : connectionsAndSessions.values())
        {
            for (Session session: sessions)
            {
                BytesMessage message = session.createBytesMessage();

                if (messageSize > 0)
                {
                    message.writeBytes(messageBytes);
                }

                for(int i = 0; i < numberOfProducers ; i++)
                {
                    MessageProducer prod = session.createProducer(destination);
                    for(int j = 0; j < numberOfMessages ; j++)
                    {
                        prod.send(message, deliveryMode, Message.DEFAULT_PRIORITY, Message.DEFAULT_TIME_TO_LIVE);
                        if(session.getTransacted())
                        {
                            session.commit();
                        }
                    }
                }
            }
        }
    }

    private Map<Connection, List<Session>> openConnectionsAndSessions(int numConnections, int numSessions, boolean transacted, ConnectionFactory conFac) throws JMSException
    {
        Map<Connection, List<Session>> connectionAndSessions = new HashMap<>();
        for (int i= 0; i < numConnections ; i++)
        {
            Connection connection = conFac.createConnection();
            connection.setExceptionListener(jmse -> {
                LOGGER.error(""The sample received an exception through the ExceptionListener"", jmse);
                System.exit(1);
            });

            List<Session> sessions = new ArrayList<>();
            connectionAndSessions.put(connection, sessions);
            connection.start();
            for (int s= 0; s < numSessions ; s++)
            {
                Session session = connection.createSession(transacted, transacted?Session.SESSION_TRANSACTED:Session.AUTO_ACKNOWLEDGE);
                sessions.add(session);
            }
        }
        return connectionAndSessions;
    }

    private Context getInitialContext(final String jndiProperties) throws IOException, NamingException
    {
        Properties properties = new Properties();
        try(InputStream is = this.getClass().getClassLoader().getResourceAsStream(jndiProperties))
        {
            if (is != null)
            {
                properties.load(is);
                return new InitialContext(properties);
            }
        }

        System.out.printf(MemoryConsumptionTestClient.class.getSimpleName() + "": Failed to find '%s' on classpath, using fallback\n"", jndiProperties);
        return new InitialContext();
    }

    private Destination ensureQueueCreated(String queueURL, ConnectionFactory connectionFactory) throws JMSException
    {
        Connection connection = connectionFactory.createConnection();
        Destination destination;
        try
        {
            Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
            destination = session.createQueue(queueURL);
            MessageConsumer consumer = session.createConsumer(destination);
            consumer.close();
            session.close();
        }
        finally
        {
            connection.close();
        }
        return destination;
    }

    private void closeConnections(Collection<Connection> connections) throws JMSException, NamingException
    {
        for (Connection c: connections)
        {
            c.close();
        }
    }

    private void purgeQueue(ConnectionFactory connectionFactory, String queueString, long receiveTimeout) throws JMSException
    {
        LOGGER.debug(""Consuming left over messages, using receive timeout:"" + receiveTimeout);

        Connection connection = connectionFactory.createConnection();
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        Destination destination = session.createQueue(queueString);
        MessageConsumer consumer = session.createConsumer(destination);
        connection.start();

        int count = 0;
        while (true)
        {
            BytesMessage msg = (BytesMessage) consumer.receive(receiveTimeout);

            if(msg == null)
            {
                LOGGER.debug(""Received {} message(s)"", count);
                break;
            }
            else
            {
                count++;
            }
        }

        consumer.close();
        session.close();
        connection.close();
    }

    private MemoryStatistic collectMemoryStatistics(Map<String, String> options) throws Exception
    {
        String host = options.get(JMX_HOST_ARG);
        String port = options.get(JMX_PORT_ARG);
        String user = options.get(JMX_USER_ARG);
        String password = options.get(JMX_USER_PASSWORD_ARG);

        if (!"""".equals(host) && !"""".equals(port) && !"""".equals(user) && !"""".equals(password))
        {
            Map<String, Object> environment = Collections.<String, Object>singletonMap(JMXConnector.CREDENTIALS, new String[]{user, password});

            try(JMXConnector jmxConnector = JMXConnectorFactory.newJMXConnector(new JMXServiceURL(""rmi"", """", 0, ""/jndi/rmi://"" + host + "":"" + port + ""/jmxrmi""), environment))
            {
                jmxConnector.connect();
                final MBeanServerConnection mBeanServerConnection = jmxConnector.getMBeanServerConnection();
                final ObjectName memoryMBean = new ObjectName(""java.lang:type=Memory"");
                String gcCollectorMBeanName = options.get(JMX_GARBAGE_COLLECTOR_MBEAN);
                if (gcCollectorMBeanName.equals(""""))
                {
                    mBeanServerConnection.invoke(memoryMBean, ""gc"", null, null);
                    MemoryStatistic memoryStatistics = new MemoryStatistic();
                    collectMemoryStatistics(memoryStatistics, mBeanServerConnection, memoryMBean);
                    return memoryStatistics;
                }
                else
                {
                    ObjectName gcMBean = new ObjectName(gcCollectorMBeanName);
                    if (mBeanServerConnection.isRegistered(gcMBean))
                    {
                        return collectMemoryStatisticsAfterGCNotification(mBeanServerConnection, gcMBean);
                    }
                    else
                    {
                        Set<ObjectName> existingGCs = mBeanServerConnection.queryNames(new ObjectName(""java.lang:type=GarbageCollector,name=*""), null);
                        throw new IllegalArgumentException(""MBean '"" +gcCollectorMBeanName + ""' does not exists! Registered GC MBeans :"" + existingGCs);
                    }
                }
            }
        }
        return null;
    }

    private MemoryStatistic collectMemoryStatisticsAfterGCNotification(final MBeanServerConnection mBeanServerConnection, ObjectName gcMBean)
            throws MalformedObjectNameException, IOException, InstanceNotFoundException, ReflectionException, MBeanException, InterruptedException
    {
        final MemoryStatistic memoryStatistics = new MemoryStatistic();
        final CountDownLatch notificationReceived = new CountDownLatch(1);
        final ObjectName memoryMBean = new ObjectName(""java.lang:type=Memory"");
        mBeanServerConnection.addNotificationListener(gcMBean, (notification, handback) -> {
            if (notification.getType().equals(""com.sun.management.gc.notification""))
            {
                CompositeData userData = (CompositeData) notification.getUserData();
                try
                {
                    Object gcAction = userData.get(""gcAction"");
                    Object gcCause = userData.get(""gcCause"");
                    if (""System.gc()"".equals(gcCause) && String.valueOf(gcAction).contains(""end of major GC""))
                    {
                        try
                        {
                            collectMemoryStatistics(memoryStatistics, mBeanServerConnection, memoryMBean);
                        }
                        finally
                        {
                            notificationReceived.countDown();
                        }

                    }
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                    notificationReceived.countDown();
                }
            }
        }, null, null);

        mBeanServerConnection.invoke(memoryMBean, ""gc"", null, null);
        if (!notificationReceived.await(5, TimeUnit.SECONDS))
        {
            throw new RuntimeException(""GC notification was not sent in timely manner"");
        }
        return memoryStatistics;
    }

    private void collectMemoryStatistics(MemoryStatistic memoryStatistics, MBeanServerConnection mBeanServerConnection, ObjectName memoryMBean) throws MBeanException, AttributeNotFoundException, InstanceNotFoundException, ReflectionException, IOException, MalformedObjectNameException
    {
        Object heapMemoryUsage = mBeanServerConnection.getAttribute(memoryMBean, ""HeapMemoryUsage"");
        Object used = ((CompositeData) heapMemoryUsage).get(""used"");
        Object directMemoryTotalCapacity = mBeanServerConnection.getAttribute(new ObjectName(""java.nio:type=BufferPool,name=direct""), ""TotalCapacity"");
        memoryStatistics.setHeapUsage(Long.parseLong(String.valueOf(used)));
        memoryStatistics.setDirectMemoryUsage(Long.parseLong(String.valueOf(directMemoryTotalCapacity)));
    }

    private String toUserFriendlyName(Object intValue)
    {
        long value = Long.parseLong(String.valueOf(intValue));
        if (value <= 1024)
        {
            return String.valueOf(value) + ""B"";
        }
        else if (value <= 1024 * 1024)
        {
            return String.valueOf(value/1024) + ""kB"";
        }
        else if (value <= 1024L * 1024L * 1024L)
        {
            return String.valueOf(value/1024L/1024L) + ""MB"";
        }
        else
        {
            return String.valueOf(value/1024L/1024L/1024L) + ""GB"";
        }
    }


    private byte[] generateMessage(int messageSize)
    {
        byte[] sentBytes = new byte[messageSize];
        for(int r = 0 ; r < messageSize ; r++)
        {
            sentBytes[r] = (byte) (48 + (r % 10));
        }
        return sentBytes;
    }

    private class MemoryStatistic
    {
        private long heapUsage;
        private long directMemoryUsage;

        long getHeapUsage()
        {
            return heapUsage;
        }

        void setHeapUsage(long heapUsage)
        {
            this.heapUsage = heapUsage;
        }

        long getDirectMemoryUsage()
        {
            return directMemoryUsage;
        }

        void setDirectMemoryUsage(long directMemoryUsage)
        {
            this.directMemoryUsage = directMemoryUsage;
        }
    }
}
",blob
797,"    class Whitespace implements Text {
        private String text;
        public Whitespace(String text) {
            this.text = text;
        }
        @Override
        public String getText() {
            return text;
        }
    }
",data class
206,"public class BasicBundleInfo {

    private String pkgName;

    /**
     * The main dex depends on + the md5 that is currently dependent
     */
    private String unique_tag;

    private String applicationName;

    private String version;


    public Boolean getIsMBundle() {
        return isMBundle;
    }

    public void setIsMBundle(boolean mainBundle) {
        isMBundle = mainBundle;
    }

    private Boolean isMBundle = false;

    private List<String> dependency = Lists.newArrayList();

    private List<String> activities = Lists.newArrayList();

    private List<String> services = Lists.newArrayList();

    private List<String> receivers = Lists.newArrayList();

    private List<String> contentProviders = Lists.newArrayList();

    private HashMap<String,String> remoteFragments= new HashMap<String,String>();

    private HashMap<String,String> remoteViews = new HashMap<String,String>();

    private HashMap<String,String> remoteTransactors = new HashMap<String,String>();

    private Boolean isInternal = true;

    public HashMap<String, String> getRemoteViews() {
        return remoteViews;
    }

    public void setRemoteViews(HashMap<String, String> remoteViews) {
        this.remoteViews = remoteViews;
    }

    public HashMap<String, String> getRemoteTransactors() {
        return remoteTransactors;
    }

    public void setRemoteTransactors(HashMap<String, String> remoteTransactors) {
        this.remoteTransactors = remoteTransactors;
    }

    public HashMap<String, String> getRemoteFragments() {
        return remoteFragments;
    }

    public void setRemoteFragments(HashMap<String, String> remoteFragments) {
        this.remoteFragments = remoteFragments;
    }

    public String getPkgName() {
        return pkgName;
    }

    public void setPkgName(String pkgName) {
        this.pkgName = pkgName;
    }

    public String getApplicationName() {
        return applicationName;
    }

    public void setApplicationName(String applicationName) {
        this.applicationName = applicationName;
    }

    public String getVersion() {
        return version;
    }

    public void setVersion(String version) {
        this.version = version;
    }

    public List<String> getDependency() {
        return dependency;
    }

    public void setDependency(List<String> dependency) {
        this.dependency = dependency;
    }

    public List<String> getActivities() {
        return activities;
    }

    public void setActivities(List<String> activities) {
        this.activities = activities;
    }

    public List<String> getServices() {
        return services;
    }

    public void setServices(List<String> services) {
        this.services = services;
    }

    public List<String> getReceivers() {
        return receivers;
    }

    public void setReceivers(List<String> receivers) {
        this.receivers = receivers;
    }

    public List<String> getContentProviders() {
        return contentProviders;
    }

    public void setContentProviders(List<String> contentProviders) {
        this.contentProviders = contentProviders;
    }

    public boolean getIsInternal() {
        return isInternal;
    }

    public void setIsInternal(boolean internal) {
        isInternal = internal;
    }

    public String getUnique_tag() {
        return unique_tag;
    }

    public void setUnique_tag(String unique_tag) {
        this.unique_tag = unique_tag;
    }
}
",data class
1262,"    @Override
    @MultiMQAdminCmdMethod
    public Map<String, ConsumerGroupRollBackStat> resetOffset(ResetOffsetRequest resetOffsetRequest) {
        Map<String, ConsumerGroupRollBackStat> groupRollbackStats = Maps.newHashMap();
        for (String consumerGroup : resetOffsetRequest.getConsumerGroupList()) {
            try {
                Map<MessageQueue, Long> rollbackStatsMap =
                    mqAdminExt.resetOffsetByTimestamp(resetOffsetRequest.getTopic(), consumerGroup, resetOffsetRequest.getResetTime(), resetOffsetRequest.isForce());
                ConsumerGroupRollBackStat consumerGroupRollBackStat = new ConsumerGroupRollBackStat(true);
                List<RollbackStats> rollbackStatsList = consumerGroupRollBackStat.getRollbackStatsList();
                for (Map.Entry<MessageQueue, Long> rollbackStatsEntty : rollbackStatsMap.entrySet()) {
                    RollbackStats rollbackStats = new RollbackStats();
                    rollbackStats.setRollbackOffset(rollbackStatsEntty.getValue());
                    rollbackStats.setQueueId(rollbackStatsEntty.getKey().getQueueId());
                    rollbackStats.setBrokerName(rollbackStatsEntty.getKey().getBrokerName());
                    rollbackStatsList.add(rollbackStats);
                }
                groupRollbackStats.put(consumerGroup, consumerGroupRollBackStat);
            }
            catch (MQClientException e) {
                if (ResponseCode.CONSUMER_NOT_ONLINE == e.getResponseCode()) {
                    try {
                        ConsumerGroupRollBackStat consumerGroupRollBackStat = new ConsumerGroupRollBackStat(true);
                        List<RollbackStats> rollbackStatsList = mqAdminExt.resetOffsetByTimestampOld(consumerGroup, resetOffsetRequest.getTopic(), resetOffsetRequest.getResetTime(), true);
                        consumerGroupRollBackStat.setRollbackStatsList(rollbackStatsList);
                        groupRollbackStats.put(consumerGroup, consumerGroupRollBackStat);
                        continue;
                    }
                    catch (Exception err) {
                        logger.error(""op=resetOffset_which_not_online_error"", err);
                    }
                }
                else {
                    logger.error(""op=resetOffset_error"", e);
                }
                groupRollbackStats.put(consumerGroup, new ConsumerGroupRollBackStat(false, e.getMessage()));
            }
            catch (Exception e) {
                logger.error(""op=resetOffset_error"", e);
                groupRollbackStats.put(consumerGroup, new ConsumerGroupRollBackStat(false, e.getMessage()));
            }
        }
        return groupRollbackStats;
    }
",long method
269,"    public PullPoint create(String queueName) throws UnableToCreatePullPointFault {
        org.oasis_open.docs.wsn.b_2.CreatePullPoint request
            = new org.oasis_open.docs.wsn.b_2.CreatePullPoint();
        request.getOtherAttributes().put(NotificationBroker.QNAME_PULLPOINT_QUEUE_NAME, queueName);
        CreatePullPointResponse response = createPullPoint.createPullPoint(request);
        return new PullPoint(response.getPullPoint());
    }
",feature envy
1069,"    private NameRegion[] findLinkComponentsInClosure(ClosureExpression firstArg,
            int offset) {
        if (! (firstArg.getCode() instanceof BlockStatement)) {
            return null;
        }
        
        BlockStatement code = (BlockStatement) firstArg.getCode();
        if (code.getStatements() == null) {
            return null;
        }
        NameRegion controllerName = null;
        NameRegion actionName = null;
        NameRegion viewName = null;

        for (Statement state : code.getStatements()) {
            if (state instanceof ExpressionStatement) {
                if (((ExpressionStatement) state).getExpression() instanceof BinaryExpression) {
                    BinaryExpression bexpr = (BinaryExpression) ((ExpressionStatement) state).getExpression();
                    Expression left = bexpr.getLeftExpression();
                    if (bexpr.getOperation().getText().equals(""="") && left instanceof VariableExpression) {
                        Expression right = bexpr.getRightExpression();
                        Region region;
                        if (right.getStart() <= offset && right.getEnd() >= offset) {
                            region = new Region(right.getStart(), right.getLength());
                        } else {
                            region = null;
                        }

                        String name = left.getText();
                        if (name.equals(""controller"")) {
                            controllerName = new NameRegion(right.getText(), region);
                        } else if (name.equals(""action"")) {
                            actionName = new NameRegion(right.getText(), region);
                        } else if (name.equals(""view"")) {
                            viewName = new NameRegion(right.getText(), region);
                        }
                    }
                }
            }
        }
        return new NameRegion[] { controllerName, actionName, viewName };
    }
",long method
792,"    private String formatQueryString(final String projectUri, final String[] args) {
        final StringBuffer result = new StringBuffer();

        if (projectUri != null) {
            if (isCompatibleMode) {
                result.append(""puri=""); //$NON-NLS-1$
                result.append(URLEncode.encode(projectUri.toString()));
            } else {
                final ArtifactID artifactID = new ArtifactID(projectUri);
                result.append(""pguid=""); //$NON-NLS-1$
                result.append(URLEncode.encode(artifactID.getToolSpecificID()));
            }
        } else if (!isCompatibleMode) {
            result.append(""pcguid=""); //$NON-NLS-1$
            result.append(URLEncode.encode(collectionId.toString()));
        }

        for (int i = 0; i < args.length - 1; i += 2) {
            final String name = args[i];
            final String value = args[i + 1];

            if (name != null) {
                if (result.length() > 0) {
                    result.append('&');
                }

                result.append(URLEncode.encode(name));
            }

            if (value != null) {
                if (name != null) {
                    result.append('=');
                } else if (result.length() > 0) {
                    result.append('&');
                }

                result.append(URLEncode.encode(value));
            }
        }

        return result.toString();
    }
",long method
56,"public class DefaultResourceService implements ResourceService {

	private String servletPath = """";
	
	/**
	 * @param servletPath the servletPath to set
	 */
	public void setServletPath(String servletPath) {
		this.servletPath = servletPath;
	}

	public String getServletPath() {
		return servletPath;
	}

}
",data class
307,"    public void validateDepositDetailForUpdate(final JsonElement element, final FromJsonHelper fromApiJsonHelper,
            final DataValidatorBuilder baseDataValidator) {
        if (fromApiJsonHelper.parameterExists(nameParamName, element)) {
            final String name = fromApiJsonHelper.extractStringNamed(nameParamName, element);
            baseDataValidator.reset().parameter(nameParamName).value(name).notBlank().notExceedingLengthOf(100);
        }

        if (fromApiJsonHelper.parameterExists(shortNameParamName, element)) {
            final String shortName = fromApiJsonHelper.extractStringNamed(shortNameParamName, element);
            baseDataValidator.reset().parameter(shortNameParamName).value(shortName).notBlank().notExceedingLengthOf(4);
        }

        if (fromApiJsonHelper.parameterExists(descriptionParamName, element)) {
            final String description = fromApiJsonHelper.extractStringNamed(descriptionParamName, element);
            baseDataValidator.reset().parameter(descriptionParamName).value(description).notBlank().notExceedingLengthOf(500);
        }

        if (fromApiJsonHelper.parameterExists(currencyCodeParamName, element)) {
            final String currencyCode = fromApiJsonHelper.extractStringNamed(currencyCodeParamName, element);
            baseDataValidator.reset().parameter(currencyCodeParamName).value(currencyCode).notBlank();
        }

        if (fromApiJsonHelper.parameterExists(digitsAfterDecimalParamName, element)) {
            final Integer digitsAfterDecimal = fromApiJsonHelper.extractIntegerSansLocaleNamed(digitsAfterDecimalParamName, element);
            baseDataValidator.reset().parameter(digitsAfterDecimalParamName).value(digitsAfterDecimal).notNull().inMinMaxRange(0, 6);
        }

        if (fromApiJsonHelper.parameterExists(inMultiplesOfParamName, element)) {
            final Integer inMultiplesOf = fromApiJsonHelper.extractIntegerNamed(inMultiplesOfParamName, element, Locale.getDefault());
            baseDataValidator.reset().parameter(inMultiplesOfParamName).value(inMultiplesOf).ignoreIfNull().integerZeroOrGreater();
        }

        if (fromApiJsonHelper.parameterExists(nominalAnnualInterestRateParamName, element)) {
            final BigDecimal interestRate = fromApiJsonHelper.extractBigDecimalWithLocaleNamed(nominalAnnualInterestRateParamName, element);
            baseDataValidator.reset().parameter(nominalAnnualInterestRateParamName).value(interestRate).notNull().zeroOrPositiveAmount();
        }

        if (fromApiJsonHelper.parameterExists(interestCompoundingPeriodTypeParamName, element)) {
            final Integer interestCompoundingPeriodType = fromApiJsonHelper.extractIntegerSansLocaleNamed(
                    interestCompoundingPeriodTypeParamName, element);
            baseDataValidator.reset().parameter(interestCompoundingPeriodTypeParamName).value(interestCompoundingPeriodType).notNull()
                    .isOneOfTheseValues(SavingsCompoundingInterestPeriodType.integerValues());
        }

        if (fromApiJsonHelper.parameterExists(interestCalculationTypeParamName, element)) {
            final Integer interestCalculationType = fromApiJsonHelper.extractIntegerSansLocaleNamed(interestCalculationTypeParamName,
                    element);
            baseDataValidator.reset().parameter(interestCalculationTypeParamName).value(interestCalculationType).notNull()
                    .inMinMaxRange(1, 2);
        }

        if (fromApiJsonHelper.parameterExists(interestCalculationDaysInYearTypeParamName, element)) {
            final Integer interestCalculationDaysInYearType = fromApiJsonHelper.extractIntegerSansLocaleNamed(
                    interestCalculationDaysInYearTypeParamName, element);
            baseDataValidator.reset().parameter(interestCalculationDaysInYearTypeParamName).value(interestCalculationDaysInYearType)
                    .notNull().isOneOfTheseValues(360, 365);
        }

        if (fromApiJsonHelper.parameterExists(minRequiredOpeningBalanceParamName, element)) {
            final BigDecimal minOpeningBalance = fromApiJsonHelper.extractBigDecimalWithLocaleNamed(minRequiredOpeningBalanceParamName,
                    element);
            baseDataValidator.reset().parameter(minRequiredOpeningBalanceParamName).value(minOpeningBalance).ignoreIfNull()
                    .zeroOrPositiveAmount();
        }

        if (fromApiJsonHelper.parameterExists(lockinPeriodFrequencyParamName, element)) {
            final Integer lockinPeriodFrequency = fromApiJsonHelper.extractIntegerWithLocaleNamed(lockinPeriodFrequencyParamName, element);
            baseDataValidator.reset().parameter(lockinPeriodFrequencyParamName).value(lockinPeriodFrequency).ignoreIfNull()
                    .integerZeroOrGreater();
        }

        if (fromApiJsonHelper.parameterExists(lockinPeriodFrequencyTypeParamName, element)) {
            final Integer lockinPeriodFrequencyType = fromApiJsonHelper.extractIntegerSansLocaleNamed(lockinPeriodFrequencyTypeParamName,
                    element);
            baseDataValidator.reset().parameter(lockinPeriodFrequencyTypeParamName).value(lockinPeriodFrequencyType).inMinMaxRange(0, 3);
        }

        if (fromApiJsonHelper.parameterExists(withdrawalFeeForTransfersParamName, element)) {
            final Boolean isWithdrawalFeeApplicableForTransfers = fromApiJsonHelper.extractBooleanNamed(withdrawalFeeForTransfersParamName,
                    element);
            baseDataValidator.reset().parameter(withdrawalFeeForTransfersParamName).value(isWithdrawalFeeApplicableForTransfers)
                    .ignoreIfNull().validateForBooleanValue();
        }

        if (fromApiJsonHelper.parameterExists(feeAmountParamName, element)) {
            final BigDecimal annualFeeAmount = fromApiJsonHelper.extractBigDecimalWithLocaleNamed(feeAmountParamName, element);
            baseDataValidator.reset().parameter(feeAmountParamName).value(annualFeeAmount).ignoreIfNull().zeroOrPositiveAmount();
        }

        if (fromApiJsonHelper.parameterExists(feeOnMonthDayParamName, element)) {
            final MonthDay monthDayOfAnnualFee = fromApiJsonHelper.extractMonthDayNamed(feeOnMonthDayParamName, element);
            baseDataValidator.reset().parameter(feeOnMonthDayParamName).value(monthDayOfAnnualFee).ignoreIfNull();
        }

        if (this.fromApiJsonHelper.parameterExists(minBalanceForInterestCalculationParamName, element)) {
            final BigDecimal minBalanceForInterestCalculation = this.fromApiJsonHelper.extractBigDecimalWithLocaleNamed(
                    minBalanceForInterestCalculationParamName, element);
            baseDataValidator.reset().parameter(minBalanceForInterestCalculationParamName).value(minBalanceForInterestCalculation)
                    .ignoreIfNull().zeroOrPositiveAmount();
        }

        final Long savingsControlAccountId = fromApiJsonHelper.extractLongNamed(
                SAVINGS_PRODUCT_ACCOUNTING_PARAMS.SAVINGS_CONTROL.getValue(), element);
        baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.SAVINGS_CONTROL.getValue()).value(savingsControlAccountId)
                .ignoreIfNull().integerGreaterThanZero();

        final Long savingsReferenceAccountId = fromApiJsonHelper.extractLongNamed(
                SAVINGS_PRODUCT_ACCOUNTING_PARAMS.SAVINGS_REFERENCE.getValue(), element);
        baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.SAVINGS_REFERENCE.getValue())
                .value(savingsReferenceAccountId).ignoreIfNull().integerGreaterThanZero();

        final Long transfersInSuspenseAccountId = fromApiJsonHelper.extractLongNamed(
                SAVINGS_PRODUCT_ACCOUNTING_PARAMS.TRANSFERS_SUSPENSE.getValue(), element);
        baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.TRANSFERS_SUSPENSE.getValue())
                .value(transfersInSuspenseAccountId).ignoreIfNull().integerGreaterThanZero();

        final Long interestOnSavingsAccountId = fromApiJsonHelper.extractLongNamed(
                SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INTEREST_ON_SAVINGS.getValue(), element);
        baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INTEREST_ON_SAVINGS.getValue())
                .value(interestOnSavingsAccountId).ignoreIfNull().integerGreaterThanZero();

        final Long incomeFromFeeId = fromApiJsonHelper.extractLongNamed(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INCOME_FROM_FEES.getValue(),
                element);
        baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INCOME_FROM_FEES.getValue()).value(incomeFromFeeId)
                .ignoreIfNull().integerGreaterThanZero();

        final Long incomeFromPenaltyId = fromApiJsonHelper.extractLongNamed(
                SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INCOME_FROM_PENALTIES.getValue(), element);
        baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INCOME_FROM_PENALTIES.getValue()).value(incomeFromPenaltyId)
                .ignoreIfNull().integerGreaterThanZero();

        validatePaymentChannelFundSourceMappings(fromApiJsonHelper, baseDataValidator, element);
        validateChargeToIncomeAccountMappings(fromApiJsonHelper, baseDataValidator, element);
        validateTaxWithHoldingParams(baseDataValidator, element, false);
    }
",long method
470,"    @Override
    protected void fillMenuBeforeShow(final IMenuManager manager) {
        manager.add(openAction);
        manager.add(downloadToAction);
        manager.add(addAttachmentAction);
        manager.add(deleteAttachmentAction);

        manager.add(new Separator());

        final DownloadAttachmentOpenType preferredOpenType = DownloadAttachmentOpenType.getPreferredOpenType();
        if (DownloadAttachmentOpenType.BROWSER == preferredOpenType) {
            manager.add(openLocallyAction);
        } else {
            manager.add(openInBrowserAction);
        }

        manager.add(copyUrlToClipboardAction);
    }
",feature envy
1252,"	public abstract class ImageSource
	{

		protected int height;
		protected int width;

		public ImageSource( int width, int height )
		{
			this.width = width;
			this.height = height;
		}

		public int getHeight( )
		{
			return height;
		}

		public int getWidth( )
		{
			return width;
		}

		public abstract int getRGB( int x, int y );
	}
",data class
980,"public class AnnotationViewerMain extends JFrame {
  private static final long serialVersionUID = -3201723535833938833L;

  private static final String HELP_MESSAGE = ""Instructions for using Annotation Viewer:\n\n""
          + ""1) In the \""Input Directory\"" field, either type or use the browse\n""
          + ""button to select a directory containing the analyzed documents\n ""
          + ""(in XMI or XCAS format) that you want to view.\n\n""
          + ""2) In the \""TypeSystem or AE Descriptor File\"" field, either type or use the browse\n""
          + ""button to select the TypeSystem or AE descriptor for the AE that generated the\n""
          + ""XMI or XCAS files.  (This is needed for type system infornation only.\n""
          + ""Analysis will not be redone.)\n\n""
          + ""3) Click the \""View\"" button at the buttom of the window.\n\n""
          + ""A list of the analyzed documents will be displayed.\n\n\n""
          + ""4) Select the view type -- either the Java annotation viewer, HTML,\n""
          + ""or XML.  The Java annotation viewer is recommended.\n\n""
          + ""5) Double-click on a document to view it.\n"";

  private File uimaHomeDir;

  private FileSelector inputFileSelector;

  private FileSelector taeDescriptorFileSelector;

  private JButton viewButton;

  private JDialog aboutDialog;

  /** Stores user preferences */
  private Preferences prefs = Preferences.userRoot().node(""org/apache/uima/tools/AnnotationViewer"");

  /**
   * Constructor. Sets up the GUI.
   */
  public AnnotationViewerMain() {
    super(""Annotation Viewer"");

    // set UIMA home dir
    uimaHomeDir = new File(System.getProperty(""uima.home"", ""C:/Program Files/apache-uima""));

    try {
      UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
    } catch (Exception e) {
      // I don't think this should ever happen, but if it does just print error and continue
      // with defalt look and feel
      System.err.println(""Could not set look and feel: "" + e.getMessage());
    }
    // UIManager.put(""Panel.background"",Color.WHITE);
    // Need to set other colors as well

    // Set frame icon image
    try {
      this.setIconImage(Images.getImage(Images.MICROSCOPE));
      // new ImageIcon(getClass().getResource(FRAME_ICON_IMAGE)).getImage());
    } catch (IOException e) {
      System.err.println(""Image could not be loaded: "" + e.getMessage());
    }

    this.getContentPane().setBackground(Color.WHITE);

    // create about dialog
    aboutDialog = new AboutDialog(this, ""About Annotation Viewer"");

    // Create Menu Bar
    JMenuBar menuBar = new JMenuBar();
    setJMenuBar(menuBar);

    JMenu fileMenu = new JMenu(""File"");
    JMenu helpMenu = new JMenu(""Help"");

    // Menu Items
    JMenuItem aboutMenuItem = new JMenuItem(""About"");
    JMenuItem helpMenuItem = new JMenuItem(""Help"");
    JMenuItem exitMenuItem = new JMenuItem(""Exit"");

    fileMenu.add(exitMenuItem);
    helpMenu.add(aboutMenuItem);
    helpMenu.add(helpMenuItem);
    menuBar.add(fileMenu);
    menuBar.add(helpMenu);

    // Labels to identify the text fields
    final Caption labelInputDir = new Caption(""Input Directory: "");
    final Caption labelStyleMapFile = new Caption(""TypeSystem or AE Descriptor File: "");

    JPanel controlPanel = new JPanel();
    controlPanel.setBorder(BorderFactory.createEmptyBorder(4, 4, 4, 4));
    controlPanel.setLayout(new SpringLayout());

    // Once we add components to controlPanel, we'll
    // call SpringUtilities::makeCompactGrid on it.

    // controlPanel.setLayout(new GridLayout(4, 2, 8, 4));

    // Set default values for input fields
    File inputDir = new File(uimaHomeDir, ""examples/data/processed"");
    inputFileSelector = new FileSelector("""", ""Input Directory"", JFileChooser.DIRECTORIES_ONLY,
            inputDir);
    inputFileSelector.setSelected(inputDir.getAbsolutePath());

    taeDescriptorFileSelector = new FileSelector("""", ""TAE Descriptor File"",
            JFileChooser.FILES_ONLY, uimaHomeDir);

    File descriptorFile = new File(uimaHomeDir,
            ""examples/descriptors/analysis_engine/PersonTitleAnnotator.xml"");
    taeDescriptorFileSelector.setSelected(descriptorFile.getAbsolutePath());

    controlPanel.add(labelInputDir);
    controlPanel.add(inputFileSelector);
    controlPanel.add(labelStyleMapFile);
    controlPanel.add(taeDescriptorFileSelector);

    SpringUtilities.makeCompactGrid(controlPanel, 2, 2, // rows, cols
            4, 4, // initX, initY
            4, 4); // xPad, yPad

    // Event Handlling of ""Exit"" Menu Item
    exitMenuItem.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent ae) {
        savePreferences();
        System.exit(0);
      }
    });

    // Event Handlling of ""About"" Menu Item
    aboutMenuItem.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent ae) {
        aboutDialog.setVisible(true);
      }
    });

    // Event Handlling of ""Help"" Menu Item
    helpMenuItem.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent ae) {
        JOptionPane.showMessageDialog(AnnotationViewerMain.this, HELP_MESSAGE,
                ""Annotation Viewer Help"", JOptionPane.PLAIN_MESSAGE);
      }
    });

    // Add the panels to the frame
    Container contentPanel = getContentPane();
    contentPanel.add(controlPanel, BorderLayout.CENTER);

    // add banner
    JLabel banner = new JLabel(Images.getImageIcon(Images.BANNER));
    contentPanel.add(banner, BorderLayout.NORTH);

    // Add the view Button to run TAE
    viewButton = new JButton(""View"");

    // Add the view button to another panel
    JPanel lowerButtonsPanel = new JPanel();
    lowerButtonsPanel.add(viewButton);

    contentPanel.add(lowerButtonsPanel, BorderLayout.SOUTH);
    setContentPane(contentPanel);

    // Event Handling of view Button
    viewButton.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent ee) {
        try {
          viewDocuments();
        } catch (Exception e) {
          displayError(e);
        }
      }
    });

    // load user preferences
    if (System.getProperty(""uima.noprefs"") == null) {
      restorePreferences();
    }
  }

  public void viewDocuments() throws InvalidXMLException, IOException,
          ResourceInitializationException {
    File descriptorFile = new File(taeDescriptorFileSelector.getSelected());
    if (!descriptorFile.exists() || descriptorFile.isDirectory()) {
      displayError(""Descriptor File \"""" + descriptorFile.getPath() + ""\"" does not exist."");
      return;
    }
    File inputDir = new File(inputFileSelector.getSelected());
    if (!inputDir.exists() || !inputDir.isDirectory()) {
      displayError(""Input Directory \"""" + inputDir.getPath() + ""\"" does not exist."");
      return;
    }

    // parse descriptor. Could be either AE or TypeSystem descriptor
    Object descriptor = UIMAFramework.getXMLParser().parse(new XMLInputSource(descriptorFile));
    // instantiate CAS to get type system. Also build style map file if there is none.
    CAS cas;
    File styleMapFile;
    if (descriptor instanceof AnalysisEngineDescription) {
      cas = CasCreationUtils.createCas((AnalysisEngineDescription) descriptor);
      styleMapFile = getStyleMapFile((AnalysisEngineDescription) descriptor, descriptorFile
              .getPath());
    } else if (descriptor instanceof TypeSystemDescription) {
      TypeSystemDescription tsDesc = (TypeSystemDescription) descriptor;
      tsDesc.resolveImports();
      cas = CasCreationUtils.createCas(tsDesc, null, new FsIndexDescription[0]);
      styleMapFile = getStyleMapFile((TypeSystemDescription) descriptor, descriptorFile.getPath());
    } else {
      displayError(""Invalid Descriptor File \"""" + descriptorFile.getPath() + ""\""""
              + ""Must be either an AnalysisEngine or TypeSystem descriptor."");
      return;
    }

    // create Annotation Viewer Main Panel
    PrefsMediator prefsMed = new PrefsMediator();
    // set OUTPUT dir in PrefsMediator, not input dir.
    // PrefsMediator is also used in DocumentAnalyzer, where the
    // output dir is the directory containing XCAS files.
    prefsMed.setOutputDir(inputDir.toString());
    AnnotationViewerDialog viewerDialog = new AnnotationViewerDialog(this,
            ""Analyzed Documents"", prefsMed, styleMapFile, null, cas.getTypeSystem(), null, false,
            cas);
    viewerDialog.pack();
    viewerDialog.setModal(true);
    viewerDialog.setVisible(true);
  }

  /**
   * @param tad 
   * @param descFileName
   * @return the style map file
   * @throws IOException -
   */
  private File getStyleMapFile(AnalysisEngineDescription tad, String descFileName)
          throws IOException {
    File styleMapFile = getStyleMapFileName(descFileName);
    if (!styleMapFile.exists()) {
      // generate default style map
      String xml = AnnotationViewGenerator.autoGenerateStyleMap(tad.getAnalysisEngineMetaData());

      PrintWriter writer;
      writer = new PrintWriter(new BufferedWriter(new FileWriter(styleMapFile)));
      writer.println(xml);
      writer.close();
    }
    return styleMapFile;
  }

  /**
   * @param tsd
   * @param descFileName
   * @return the style map file
   * @throws IOException -
   */
  private File getStyleMapFile(TypeSystemDescription tsd, String descFileName) throws IOException {
    File styleMapFile = getStyleMapFileName(descFileName);
    if (!styleMapFile.exists()) {
      // generate default style map
      String xml = AnnotationViewGenerator.autoGenerateStyleMap(tsd);

      PrintWriter writer;
      writer = new PrintWriter(new BufferedWriter(new FileWriter(styleMapFile)));
      writer.println(xml);
      writer.close();
    }
    return styleMapFile;
  }

  /**
   * Gets the name of the style map file for the given AE or TypeSystem descriptor filename.
   */
  public File getStyleMapFileName(String aDescriptorFileName) {
    String baseName;
    int index = aDescriptorFileName.lastIndexOf(""."");
    if (index > 0) {
      baseName = aDescriptorFileName.substring(0, index);
    } else {
      baseName = aDescriptorFileName;
    }
    return new File(baseName + ""StyleMap.xml"");
  }

  public static void main(String[] args) {
    final AnnotationViewerMain frame = new AnnotationViewerMain();

    frame.addWindowListener(new WindowAdapter() {
      public void windowClosing(WindowEvent e) {
        frame.savePreferences();
        System.exit(0);
      }
    });
    frame.pack();
    frame.setVisible(true);
  }

  /**
   * Save user's preferences using Java's Preference API.
   */
  public void savePreferences() {
    prefs.put(""inDir"", inputFileSelector.getSelected());
    prefs.put(""taeDescriptorFile"", taeDescriptorFileSelector.getSelected());
  }

  /**
   * Reset GUI to preferences last saved via {@link #savePreferences}.
   */
  public void restorePreferences() {
    // figure defaults
    File defaultInputDir = new File(uimaHomeDir, ""examples/data/processed"");
    File defaultTaeDescriptorFile = new File(uimaHomeDir,
            ""examples/descriptors/analysis_engine/PersonTitleAnnotator.xml"");

    // restore preferences
    inputFileSelector.setSelected(prefs.get(""inDir"", defaultInputDir.toString()));
    taeDescriptorFileSelector.setSelected(prefs.get(""taeDescriptorFile"", defaultTaeDescriptorFile
            .toString()));
  }

  /**
   * Displays an error message to the user.
   * 
   * @param aErrorString
   *          error message to display
   */
  public void displayError(String aErrorString) {
    // word-wrap long mesages
    StringBuffer buf = new StringBuffer(aErrorString.length());
    final int CHARS_PER_LINE = 80;
    int charCount = 0;
    StringTokenizer tokenizer = new StringTokenizer(aErrorString, "" \n"", true);

    while (tokenizer.hasMoreTokens()) {
      String tok = tokenizer.nextToken();

      if (tok.equals(""\n"")) {
        buf.append(""\n"");
        charCount = 0;
      } else if ((charCount > 0) && ((charCount + tok.length()) > CHARS_PER_LINE)) {
        buf.append(""\n"").append(tok);
        charCount = tok.length();
      } else {
        buf.append(tok);
        charCount += tok.length();
      }
    }

    JOptionPane.showMessageDialog(AnnotationViewerMain.this, buf.toString(), ""Error"",
            JOptionPane.ERROR_MESSAGE);
  }

  /**
   * Displays an error message to the user.
   * 
   * @param aThrowable
   *          Throwable whose message is to be displayed.
   */
  public void displayError(Throwable aThrowable) {
    aThrowable.printStackTrace();

    String message = aThrowable.toString();

    // For UIMAExceptions or UIMARuntimeExceptions, add cause info.
    // We have to go through this nonsense to support Java 1.3.
    // In 1.4 all exceptions can have a cause, so this wouldn't involve
    // all of this typecasting.
    while ((aThrowable instanceof UIMAException) || (aThrowable instanceof UIMARuntimeException)) {
      if (aThrowable instanceof UIMAException) {
        aThrowable = ((UIMAException) aThrowable).getCause();
      } else if (aThrowable instanceof UIMARuntimeException) {
        aThrowable = ((UIMARuntimeException) aThrowable).getCause();
      }

      if (aThrowable != null) {
        message += (""\nCausedBy: "" + aThrowable.toString());
      }
    }

    displayError(message);
  }
  
  /*
   * (non-Javadoc)
   * 
   * @see java.awt.Component#getPreferredSize()
   */
  public Dimension getPreferredSize() {
    return new Dimension(640, 200);
  }  
}
",blob
910,"public class QueryItemTreeControl extends Composite {
    public static interface QueryItemDoubleClickedListener {
        public void queryItemDoubleClicked(QueryItem queryItem);
    }

    public static interface QueryItemSelectionListener {
        public void queryItemSelected(QueryItem queryItem);
    }

    /*
     * a reference to all the projects on the server
     */
    private final Project[] projects;

    /*
     * a sorted array of the names of the currently ""active"" projects, where
     * active means the user has added the project to team explorer
     */
    private final String[] activeProjectNames;

    /*
     * the tree viewer this composite is based around
     */
    private TreeViewer treeViewer;

    /*
     * used to track the currently selected query in the tree
     */
    private QueryItem selectedQueryItem;

    private final QueryItemType itemTypes;

    /*
     * listener set
     */
    private final Set<QueryItemDoubleClickedListener> queryDoubleClickListeners =
        new HashSet<QueryItemDoubleClickedListener>();
    private final Set<QueryItemSelectionListener> querySelectionListeners = new HashSet<QueryItemSelectionListener>();

    public QueryItemTreeControl(
        final Composite parent,
        final int style,
        final TFSServer server,
        final Project[] projects,
        final QueryItem initialQueryItem,
        final QueryItemType itemTypes) {
        this(
            parent,
            style,
            projects,
            ProjectInfoHelper.getProjectNames(server.getProjectCache().getActiveTeamProjects()),
            initialQueryItem,
            itemTypes);
    }

    public QueryItemTreeControl(
        final Composite parent,
        final int style,
        final Project[] projects,
        final String[] activeProjects,
        final QueryItem initialQueryItem,
        final QueryItemType itemTypes) {
        super(parent, style);
        this.projects = projects;
        selectedQueryItem = initialQueryItem;
        this.itemTypes = itemTypes;

        activeProjectNames = activeProjects;
        Arrays.sort(activeProjectNames);

        if (activeProjectNames.length > 0) {
            /*
             * set up the tree control in this composite
             */
            createUI();
        } else {
            createNoProjectsUI();
        }
    }

    public QueryItem getSelectedQueryItem() {
        return selectedQueryItem;
    }

    public void addQueryItemDoubleClickedListener(final QueryItemDoubleClickedListener listener) {
        synchronized (queryDoubleClickListeners) {
            queryDoubleClickListeners.add(listener);
        }
    }

    public void removeQueryItemDoubleClickedListener(final QueryItemDoubleClickedListener listener) {
        synchronized (queryDoubleClickListeners) {
            queryDoubleClickListeners.remove(listener);
        }
    }

    public void addQueryItemSelectionListener(final QueryItemSelectionListener listener) {
        synchronized (querySelectionListeners) {
            querySelectionListeners.add(listener);
        }
    }

    public void removeQueryItemSelectionListener(final QueryItemSelectionListener listener) {
        synchronized (querySelectionListeners) {
            querySelectionListeners.remove(listener);
        }
    }

    private void createUI() {
        setLayout(new FillLayout());

        treeViewer = new TreeViewer(this, SWT.BORDER);
        treeViewer.setContentProvider(new ContentProvider(activeProjectNames));
        treeViewer.setLabelProvider(new LabelProvider());
        treeViewer.addDoubleClickListener(new DoubleClickListener(treeViewer, queryDoubleClickListeners));
        treeViewer.addSelectionChangedListener(new SelectionChangedListener(querySelectionListeners));

        addContextMenu();

        treeViewer.setInput(projects);

        /*
         * set the initial selection if applicable
         */
        if (selectedQueryItem != null) {
            treeViewer.setSelection(new StructuredSelection(selectedQueryItem), true);
        }
    }

    private void createNoProjectsUI() {
        setLayout(new FillLayout());

        final Label label = new Label(this, SWT.WRAP);
        label.setText(Messages.getString(""QueryItemTreeControl.NoTeamProjectsLabelText"")); //$NON-NLS-1$
    }

    private void addContextMenu() {
        final MenuManager menuMgr = new MenuManager(""#PopUp""); //$NON-NLS-1$
        final IAction copyToClipboardAction = new Action() {
            @Override
            public void run() {
                final IStructuredSelection selection = (IStructuredSelection) treeViewer.getSelection();
                final QueryDefinition queryDefinition = (QueryDefinition) selection.getFirstElement();
                UIHelpers.copyToClipboard(queryDefinition.getQueryText());
            }
        };
        copyToClipboardAction.setText(Messages.getString(""QueryItemTreeControl.CopyWiqlToClipboard"")); //$NON-NLS-1$
        copyToClipboardAction.setEnabled(false);
        menuMgr.add(copyToClipboardAction);

        treeViewer.getControl().setMenu(menuMgr.createContextMenu(treeViewer.getControl()));

        treeViewer.addSelectionChangedListener(new ISelectionChangedListener() {
            @Override
            public void selectionChanged(final SelectionChangedEvent event) {
                final IStructuredSelection selection = (IStructuredSelection) event.getSelection();
                final boolean enable = (selection.getFirstElement() instanceof QueryDefinition);
                copyToClipboardAction.setEnabled(enable);
            }
        });
    }

    private class SelectionChangedListener implements ISelectionChangedListener {
        private final Set<QueryItemSelectionListener> listeners;

        public SelectionChangedListener(final Set<QueryItemSelectionListener> listeners) {
            this.listeners = listeners;
        }

        @Override
        public void selectionChanged(final SelectionChangedEvent event) {
            final Object selected = ((IStructuredSelection) event.getSelection()).getFirstElement();
            if (selected instanceof QueryItem && itemTypes.contains(((QueryItem) selected).getType())) {
                selectedQueryItem = (QueryItem) selected;
            } else {
                selectedQueryItem = null;
            }

            synchronized (listeners) {
                for (final QueryItemSelectionListener listener : listeners) {
                    listener.queryItemSelected(selectedQueryItem);
                }
            }
        }
    }

    private static class DoubleClickListener extends TreeViewerDoubleClickListener {
        private final Set<QueryItemDoubleClickedListener> listeners;

        public DoubleClickListener(final TreeViewer treeViewer, final Set<QueryItemDoubleClickedListener> listeners) {
            super(treeViewer);
            this.listeners = listeners;
        }

        @Override
        public void doubleClick(final DoubleClickEvent event) {
            super.doubleClick(event);

            final Object element = ((IStructuredSelection) event.getSelection()).getFirstElement();
            if (element instanceof QueryDefinition) {
                final QueryDefinition queryDefinition = (QueryDefinition) element;
                synchronized (listeners) {
                    for (final QueryItemDoubleClickedListener listener : listeners) {
                        listener.queryItemDoubleClicked(queryDefinition);
                    }
                }
            }
        }
    }

    private class ContentProvider extends TreeContentProvider {
        private final String[] activeProjectNames;

        public ContentProvider(final String[] activeProjectNames) {
            this.activeProjectNames = activeProjectNames;
        }

        @Override
        public Object getParent(final Object element) {
            if (element instanceof QueryHierarchy) {
                return null;
            }

            return ((QueryItem) element).getParent();
        }

        @Override
        public Object[] getChildren(final Object parentElement) {
            final QueryItemType displayTypes = getDisplayTypes();

            if (parentElement instanceof QueryFolder) {
                final List<QueryItem> childList = new ArrayList<QueryItem>();
                final QueryItem[] children = ((QueryFolder) parentElement).getItems();

                for (final QueryItem child : children) {
                    if (displayTypes.contains(child.getType())) {
                        childList.add(child);
                    }
                }

                return childList.toArray(new QueryItem[childList.size()]);
            }

            return null;
        }

        @Override
        public boolean hasChildren(final Object element) {
            final QueryItemType displayTypes = getDisplayTypes();

            if (element instanceof QueryFolder) {
                final QueryItem[] children = ((QueryFolder) element).getItems();

                for (int i = 0; i < children.length; i++) {
                    if (displayTypes.contains(children[i].getType())) {
                        return true;
                    }
                }
            }

            return false;
        }

        private QueryItemType getDisplayTypes() {
            if (itemTypes.contains(QueryItemType.QUERY_DEFINITION)) {
                return QueryItemType.ALL;
            } else if (itemTypes.contains(QueryItemType.QUERY_FOLDER)) {
                return QueryItemType.ALL_FOLDERS;
            }

            return itemTypes;
        }

        @Override
        public Object[] getElements(final Object inputElement) {
            final Project[] projects = (Project[]) inputElement;
            final List<QueryHierarchy> queryHierarchies = new ArrayList<QueryHierarchy>();

            final Map<String, Project> availableProjects = new HashMap<String, Project>();
            for (final Project project : projects) {
                availableProjects.put(project.getName(), project);
            }

            for (final String activeProjectName : activeProjectNames) {
                final Project project = availableProjects.get(activeProjectName);
                if (project != null) {
                    queryHierarchies.add(project.getQueryHierarchy());
                }
            }

            return queryHierarchies.toArray(new QueryHierarchy[queryHierarchies.size()]);
        }
    }

    private static class LabelProvider extends org.eclipse.jface.viewers.LabelProvider {
        private final Map<QueryDefinition, StoredQuery> definitionToQueryMap =
            new HashMap<QueryDefinition, StoredQuery>();
        private final ImageHelper imageHelper = new ImageHelper(TFSCommonUIClientPlugin.PLUGIN_ID);

        public LabelProvider() {
        }

        @Override
        public Image getImage(final Object element) {
            if (element instanceof QueryHierarchy) {
                return imageHelper.getImage(""images/common/team_project.gif""); //$NON-NLS-1$
            }
            if (element instanceof QueryFolder) {
                final QueryFolder queryFolder = (QueryFolder) element;

                if (GUID.EMPTY.getGUIDString().replaceAll(""-"", """").equals(queryFolder.getParent().getID())) //$NON-NLS-1$ //$NON-NLS-2$
                {
                    // This is a top level ""Team Queries"" / ""My Queries"" folder
                    if (queryFolder.isPersonal()) {
                        return imageHelper.getImage(""images/wit/query_group_my.gif""); //$NON-NLS-1$
                    }
                    return imageHelper.getImage(""images/wit/query_group_team.gif""); //$NON-NLS-1$
                }

                return PlatformUI.getWorkbench().getSharedImages().getImage(ISharedImages.IMG_OBJ_FOLDER);
            }
            if (element instanceof QueryDefinition) {
                final QueryDefinition queryDefinition = (QueryDefinition) element;

                StoredQuery query = definitionToQueryMap.get(queryDefinition);

                if (query == null) {
                    query = new StoredQueryImpl(
                        queryDefinition.getID(),
                        queryDefinition.getName(),
                        queryDefinition.getQueryText(),
                        queryDefinition.isPersonal() ? QueryScope.PRIVATE : QueryScope.PUBLIC,
                        queryDefinition.getProject().getID(),
                        (ProjectImpl) queryDefinition.getProject(),
                        queryDefinition.isDeleted(),
                        queryDefinition.getProject().getWITContext());

                    definitionToQueryMap.put(queryDefinition, query);
                }

                if (QueryType.LIST.equals(queryDefinition.getQueryType())) {
                    return imageHelper.getImage(""images/wit/query_type_flat.gif""); //$NON-NLS-1$
                } else if (QueryType.TREE.equals(queryDefinition.getQueryType())) {
                    return imageHelper.getImage(""images/wit/query_type_tree.gif""); //$NON-NLS-1$
                } else if (QueryType.ONE_HOP.equals(queryDefinition.getQueryType())) {
                    return imageHelper.getImage(""images/wit/query_type_onehop.gif""); //$NON-NLS-1$
                }

                return imageHelper.getImage(""images/wit/query_type_flat_error.gif""); //$NON-NLS-1$
            }

            return imageHelper.getImage(""images/wit/query.gif""); //$NON-NLS-1$
        }

        @Override
        public String getText(final Object element) {
            return ((QueryItem) element).getName();
        }

        @Override
        public void dispose() {
            imageHelper.dispose();
        }
    }
}
",blob
1017,"public class DataSourceLoginService extends AbstractLoginService
{
    private static final Logger LOG = Log.getLogger(DataSourceLoginService.class);

    private String _jndiName = ""javax.sql.DataSource/default"";
    private DataSource _datasource;
    private Server _server;
    private String _userTableName = ""users"";
    private String _userTableKey = ""id"";
    private String _userTableUserField = ""username"";
    private String _userTablePasswordField = ""pwd"";
    private String _roleTableName = ""roles"";
    private String _roleTableKey = ""id"";
    private String _roleTableRoleField = ""role"";
    private String _userRoleTableName = ""user_roles"";
    private String _userRoleTableUserKey = ""user_id"";
    private String _userRoleTableRoleKey = ""role_id"";
    private String _userSql;
    private String _roleSql;
    private boolean _createTables = false;
    
    
    /**
     * DBUser
     */
    public class DBUserPrincipal extends UserPrincipal
    {
        private int _key;
        
        public DBUserPrincipal(String name, Credential credential, int key)
        {
            super(name, credential);
            _key = key;
        }
        
        public int getKey ()
        {
            return _key;
        }
        
    }

    /* ------------------------------------------------------------ */
    public DataSourceLoginService()
    {
    }

    /* ------------------------------------------------------------ */
    public DataSourceLoginService(String name)
    {
        setName(name);
    }

    /* ------------------------------------------------------------ */
    public DataSourceLoginService(String name, IdentityService identityService)
    {
        setName(name);
        setIdentityService(identityService);
    }

    /* ------------------------------------------------------------ */
    public void setJndiName (String jndi)
    {
        _jndiName = jndi;
    }

    /* ------------------------------------------------------------ */
    public String getJndiName ()
    {
        return _jndiName;
    }

    /* ------------------------------------------------------------ */
    public void setServer (Server server)
    {
        _server=server;
    }

    /* ------------------------------------------------------------ */
    public Server getServer()
    {
        return _server;
    }

    /* ------------------------------------------------------------ */
    public void setCreateTables(boolean createTables)
    {
        _createTables = createTables;
    }

    /* ------------------------------------------------------------ */
    public boolean getCreateTables()
    {
        return _createTables;
    }

    /* ------------------------------------------------------------ */
    public void setUserTableName (String name)
    {
        _userTableName=name;
    }

    /* ------------------------------------------------------------ */
    public String getUserTableName()
    {
        return _userTableName;
    }

    /* ------------------------------------------------------------ */
    public String getUserTableKey()
    {
        return _userTableKey;
    }


    /* ------------------------------------------------------------ */
    public void setUserTableKey(String tableKey)
    {
        _userTableKey = tableKey;
    }


    /* ------------------------------------------------------------ */
    public String getUserTableUserField()
    {
        return _userTableUserField;
    }


    /* ------------------------------------------------------------ */
    public void setUserTableUserField(String tableUserField)
    {
        _userTableUserField = tableUserField;
    }


    /* ------------------------------------------------------------ */
    public String getUserTablePasswordField()
    {
        return _userTablePasswordField;
    }


    /* ------------------------------------------------------------ */
    public void setUserTablePasswordField(String tablePasswordField)
    {
        _userTablePasswordField = tablePasswordField;
    }


    /* ------------------------------------------------------------ */
    public String getRoleTableName()
    {
        return _roleTableName;
    }


    /* ------------------------------------------------------------ */
    public void setRoleTableName(String tableName)
    {
        _roleTableName = tableName;
    }


    /* ------------------------------------------------------------ */
    public String getRoleTableKey()
    {
        return _roleTableKey;
    }


    /* ------------------------------------------------------------ */
    public void setRoleTableKey(String tableKey)
    {
        _roleTableKey = tableKey;
    }


    /* ------------------------------------------------------------ */
    public String getRoleTableRoleField()
    {
        return _roleTableRoleField;
    }


    /* ------------------------------------------------------------ */
    public void setRoleTableRoleField(String tableRoleField)
    {
        _roleTableRoleField = tableRoleField;
    }


    /* ------------------------------------------------------------ */
    public String getUserRoleTableName()
    {
        return _userRoleTableName;
    }


    /* ------------------------------------------------------------ */
    public void setUserRoleTableName(String roleTableName)
    {
        _userRoleTableName = roleTableName;
    }


    /* ------------------------------------------------------------ */
    public String getUserRoleTableUserKey()
    {
        return _userRoleTableUserKey;
    }


    /* ------------------------------------------------------------ */
    public void setUserRoleTableUserKey(String roleTableUserKey)
    {
        _userRoleTableUserKey = roleTableUserKey;
    }


    /* ------------------------------------------------------------ */
    public String getUserRoleTableRoleKey()
    {
        return _userRoleTableRoleKey;
    }


    /* ------------------------------------------------------------ */
    public void setUserRoleTableRoleKey(String roleTableRoleKey)
    {
        _userRoleTableRoleKey = roleTableRoleKey;
    }

  
    
    /* ------------------------------------------------------------ */
    @Override
    public UserPrincipal loadUserInfo (String username)
    {
        try
        {
            try (Connection connection = getConnection();
                    PreparedStatement statement1 = connection.prepareStatement(_userSql))
            {
                statement1.setObject(1, username);
                try (ResultSet rs1 = statement1.executeQuery())
                {
                    if (rs1.next())
                    {
                        int key = rs1.getInt(_userTableKey);
                        String credentials = rs1.getString(_userTablePasswordField);
                        
                        return new DBUserPrincipal(username, Credential.getCredential(credentials), key);
                    }
                }
            }
        }
        catch (NamingException e)
        {
            LOG.warn(""No datasource for ""+_jndiName, e);
        }
        catch (SQLException e)
        {
            LOG.warn(""Problem loading user info for ""+username, e);
        }
        return null;
    }
    
    
    /* ------------------------------------------------------------ */
    @Override
    public String[] loadRoleInfo (UserPrincipal user)
    {
        DBUserPrincipal dbuser = (DBUserPrincipal)user;

        try
        {
            try (Connection connection = getConnection();
                    PreparedStatement statement2 = connection.prepareStatement(_roleSql))
            {

                List<String> roles = new ArrayList<String>();

                statement2.setInt(1, dbuser.getKey());
                try (ResultSet rs2 = statement2.executeQuery())
                {
                    while (rs2.next())
                    {
                        roles.add(rs2.getString(_roleTableRoleField));
                    }
                    
                    return roles.toArray(new String[roles.size()]);
                }
            }
        }
        catch (NamingException e)
        {
            LOG.warn(""No datasource for ""+_jndiName, e);
        }
        catch (SQLException e)
        {
            LOG.warn(""Problem loading user info for ""+user.getName(), e);
        }
        return null;
    }
    
 

    /* ------------------------------------------------------------ */
    /**
     * Lookup the datasource for the jndiName and formulate the
     * necessary sql query strings based on the configured table
     * and column names.
     *
     * @throws NamingException if unable to init jndi
     * @throws SQLException if unable to init database
     */
    public void initDb() throws NamingException, SQLException
    {
        if (_datasource != null)
            return;

        @SuppressWarnings(""unused"")
        InitialContext ic = new InitialContext();
        assert ic!=null;

        // TODO Should we try webapp scope too?

        // try finding the datasource in the Server scope
        if (_server != null)
        {
            try
            {
                _datasource = (DataSource)NamingEntryUtil.lookup(_server, _jndiName);
            }
            catch (NameNotFoundException e)
            {
                //next try the jvm scope
            }
        }


        //try finding the datasource in the jvm scope
        if (_datasource==null)
        {
            _datasource = (DataSource)NamingEntryUtil.lookup(null, _jndiName);
        }

        // set up the select statements based on the table and column names configured
        _userSql = ""select "" + _userTableKey + "","" + _userTablePasswordField
                  + "" from "" + _userTableName
                  + "" where ""+ _userTableUserField + "" = ?"";

        _roleSql = ""select r."" + _roleTableRoleField
                  + "" from "" + _roleTableName + "" r, "" + _userRoleTableName
                  + "" u where u.""+ _userRoleTableUserKey + "" = ?""
                  + "" and r."" + _roleTableKey + "" = u."" + _userRoleTableRoleKey;

        prepareTables();
    }

    /* ------------------------------------------------------------ */
    /**
     * @throws NamingException
     * @throws SQLException
     */
    private void prepareTables()
    throws NamingException, SQLException
    {
        if (_createTables)
        {
            boolean autocommit = true;
            Connection connection = getConnection();
            try (Statement stmt = connection.createStatement())
            {
                autocommit = connection.getAutoCommit();
                connection.setAutoCommit(false);
                DatabaseMetaData metaData = connection.getMetaData();

                //check if tables exist
                String tableName = (metaData.storesLowerCaseIdentifiers()? _userTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_userTableName.toUpperCase(Locale.ENGLISH): _userTableName));
                try (ResultSet result = metaData.getTables(null, null, tableName, null))
                {
                    if (!result.next())
                    {
                        //user table default
                        /*
                         * create table _userTableName (_userTableKey integer,
                         * _userTableUserField varchar(100) not null unique,
                         * _userTablePasswordField varchar(20) not null, primary key(_userTableKey));
                         */
                        stmt.executeUpdate(""create table ""+_userTableName+ ""(""+_userTableKey+"" integer,""+
                                _userTableUserField+"" varchar(100) not null unique,""+
                                _userTablePasswordField+"" varchar(20) not null, primary key(""+_userTableKey+""))"");
                        if (LOG.isDebugEnabled()) LOG.debug(""Created table ""+_userTableName);
                    }
                }

                tableName = (metaData.storesLowerCaseIdentifiers()? _roleTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_roleTableName.toUpperCase(Locale.ENGLISH): _roleTableName));
                try (ResultSet result = metaData.getTables(null, null, tableName, null))
                {
                    if (!result.next())
                    {
                        //role table default
                        /*
                         * create table _roleTableName (_roleTableKey integer,
                         * _roleTableRoleField varchar(100) not null unique, primary key(_roleTableKey));
                         */
                        String str = ""create table ""+_roleTableName+"" (""+_roleTableKey+"" integer, ""+
                        _roleTableRoleField+"" varchar(100) not null unique, primary key(""+_roleTableKey+""))"";
                        stmt.executeUpdate(str);
                        if (LOG.isDebugEnabled()) LOG.debug(""Created table ""+_roleTableName);
                    }
                }

                tableName = (metaData.storesLowerCaseIdentifiers()? _userRoleTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_userRoleTableName.toUpperCase(Locale.ENGLISH): _userRoleTableName));
                try (ResultSet result = metaData.getTables(null, null, tableName, null))
                {
                    if (!result.next())
                    {
                        //user-role table
                        /*
                         * create table _userRoleTableName (_userRoleTableUserKey integer,
                         * _userRoleTableRoleKey integer,
                         * primary key (_userRoleTableUserKey, _userRoleTableRoleKey));
                         *
                         * create index idx_user_role on _userRoleTableName (_userRoleTableUserKey);
                         */
                        stmt.executeUpdate(""create table ""+_userRoleTableName+"" (""+_userRoleTableUserKey+"" integer, ""+
                                _userRoleTableRoleKey+"" integer, ""+
                                ""primary key (""+_userRoleTableUserKey+"", ""+_userRoleTableRoleKey+""))"");
                        stmt.executeUpdate(""create index indx_user_role on ""+_userRoleTableName+""(""+_userRoleTableUserKey+"")"");
                        if (LOG.isDebugEnabled()) LOG.debug(""Created table ""+_userRoleTableName +"" and index"");
                    }
                }
                connection.commit();
            }
            finally
            {
                try
                {
                    connection.setAutoCommit(autocommit);
                }
                catch (SQLException e)
                {
                    if (LOG.isDebugEnabled()) LOG.debug(""Prepare tables"", e);
                }
                finally
                {
                    try
                    {
                        connection.close();
                    }
                    catch (SQLException e)
                    {
                        if (LOG.isDebugEnabled()) LOG.debug(""Prepare tables"", e);
                    }
                }
            }
        }
        else if (LOG.isDebugEnabled())
        {
            LOG.debug(""createTables false"");
        }
    }

    /* ------------------------------------------------------------ */
    /**
     * @return
     * @throws NamingException
     * @throws SQLException
     */
    private Connection getConnection ()
    throws NamingException, SQLException
    {
        initDb();
        return _datasource.getConnection();
    }
}
",data class
1417,"@XmlRootElement(name = ""roles"", namespace = ""http://org.apache.cxf.fediz/"")
public class Roles {

    private Collection<Role> roles;

    public Roles() {
    }

    public Roles(Collection<Role> roles) {
        this.roles = roles;
    }

    @XmlElementRef
    public Collection<Role> getRoles() {
        return roles;
    }

    public void setRoles(Collection<Role> roles) {
        this.roles = roles;
    }
}
",data class
903,,blob
280,"public class JpegRewriter extends BinaryFileParser {
    private static final ByteOrder JPEG_BYTE_ORDER = ByteOrder.BIG_ENDIAN;
    private static final SegmentFilter EXIF_SEGMENT_FILTER = new SegmentFilter() {
        @Override
        public boolean filter(final JFIFPieceSegment segment) {
            return segment.isExifSegment();
        }
    };
    private static final SegmentFilter XMP_SEGMENT_FILTER = new SegmentFilter() {
        @Override
        public boolean filter(final JFIFPieceSegment segment) {
            return segment.isXmpSegment();
        }
    };
    private static final SegmentFilter PHOTOSHOP_APP13_SEGMENT_FILTER = new SegmentFilter() {
        @Override
        public boolean filter(final JFIFPieceSegment segment) {
            return segment.isPhotoshopApp13Segment();
        }
    };

    /**
     * Constructor. to guess whether a file contains an image based on its file
     * extension.
     */
    public JpegRewriter() {
        setByteOrder(JPEG_BYTE_ORDER);
    }

    protected static class JFIFPieces {
        public final List<JFIFPiece> pieces;
        public final List<JFIFPiece> segmentPieces;

        public JFIFPieces(final List<JFIFPiece> pieces,
                final List<JFIFPiece> segmentPieces) {
            this.pieces = pieces;
            this.segmentPieces = segmentPieces;
        }

    }

    protected abstract static class JFIFPiece {
        protected abstract void write(OutputStream os) throws IOException;

        @Override
        public String toString() {
            return ""["" + this.getClass().getName() + ""]"";
        }
    }

    protected static class JFIFPieceSegment extends JFIFPiece {
        public final int marker;
        private final byte[] markerBytes;
        private final byte[] segmentLengthBytes;
        private final byte[] segmentData;

        public JFIFPieceSegment(final int marker, final byte[] segmentData) {
            this(marker,
                    ByteConversions.toBytes((short) marker, JPEG_BYTE_ORDER),
                    ByteConversions.toBytes((short) (segmentData.length + 2), JPEG_BYTE_ORDER),
                    segmentData);
        }

        JFIFPieceSegment(final int marker, final byte[] markerBytes,
                final byte[] segmentLengthBytes, final byte[] segmentData) {
            this.marker = marker;
            this.markerBytes = markerBytes;
            this.segmentLengthBytes = segmentLengthBytes;
            this.segmentData = segmentData; // TODO clone?
        }

        @Override
        public String toString() {
            return ""["" + this.getClass().getName() + "" (0x""
                    + Integer.toHexString(marker) + "")]"";
        }

        @Override
        protected void write(final OutputStream os) throws IOException {
            os.write(markerBytes);
            os.write(segmentLengthBytes);
            os.write(segmentData);
        }

        public boolean isApp1Segment() {
            return marker == JpegConstants.JPEG_APP1_MARKER;
        }

        public boolean isAppSegment() {
            return marker >= JpegConstants.JPEG_APP0_MARKER && marker <= JpegConstants.JPEG_APP15_MARKER;
        }

        public boolean isExifSegment() {
            if (marker != JpegConstants.JPEG_APP1_MARKER) {
                return false;
            }
            if (!startsWith(segmentData, JpegConstants.EXIF_IDENTIFIER_CODE)) {
                return false;
            }
            return true;
        }

        public boolean isPhotoshopApp13Segment() {
            if (marker != JpegConstants.JPEG_APP13_MARKER) {
                return false;
            }
            if (!new IptcParser().isPhotoshopJpegSegment(segmentData)) {
                return false;
            }
            return true;
        }

        public boolean isXmpSegment() {
            if (marker != JpegConstants.JPEG_APP1_MARKER) {
                return false;
            }
            if (!startsWith(segmentData, JpegConstants.XMP_IDENTIFIER)) {
                return false;
            }
            return true;
        }

        public byte[] getSegmentData() {
            return segmentData; // TODO clone?
        }

    }

    static class JFIFPieceImageData extends JFIFPiece {
        private final byte[] markerBytes;
        private final byte[] imageData;

        JFIFPieceImageData(final byte[] markerBytes, final byte[] imageData) {
            super();
            this.markerBytes = markerBytes;
            this.imageData = imageData;
        }

        @Override
        protected void write(final OutputStream os) throws IOException {
            os.write(markerBytes);
            os.write(imageData);
        }
    }

    protected JFIFPieces analyzeJFIF(final ByteSource byteSource) throws ImageReadException, IOException {
        final List<JFIFPiece> pieces = new ArrayList<>();
        final List<JFIFPiece> segmentPieces = new ArrayList<>();

        final JpegUtils.Visitor visitor = new JpegUtils.Visitor() {
            // return false to exit before reading image data.
            @Override
            public boolean beginSOS() {
                return true;
            }

            @Override
            public void visitSOS(final int marker, final byte[] markerBytes, final byte[] imageData) {
                pieces.add(new JFIFPieceImageData(markerBytes, imageData));
            }

            // return false to exit traversal.
            @Override
            public boolean visitSegment(final int marker, final byte[] markerBytes,
                    final int segmentLength, final byte[] segmentLengthBytes,
                    final byte[] segmentData) throws ImageReadException, IOException {
                final JFIFPiece piece = new JFIFPieceSegment(marker, markerBytes,
                        segmentLengthBytes, segmentData);
                pieces.add(piece);
                segmentPieces.add(piece);

                return true;
            }
        };

        new JpegUtils().traverseJFIF(byteSource, visitor);

        return new JFIFPieces(pieces, segmentPieces);
    }

    private interface SegmentFilter {
        boolean filter(JFIFPieceSegment segment);
    }

    protected <T extends JFIFPiece> List<T> removeXmpSegments(final List<T> segments) {
        return filterSegments(segments, XMP_SEGMENT_FILTER);
    }

    protected <T extends JFIFPiece> List<T> removePhotoshopApp13Segments(
            final List<T> segments) {
        return filterSegments(segments, PHOTOSHOP_APP13_SEGMENT_FILTER);
    }

    protected <T extends JFIFPiece> List<T> findPhotoshopApp13Segments(
            final List<T> segments) {
        return filterSegments(segments, PHOTOSHOP_APP13_SEGMENT_FILTER, true);
    }

    protected <T extends JFIFPiece> List<T> removeExifSegments(final List<T> segments) {
        return filterSegments(segments, EXIF_SEGMENT_FILTER);
    }

    protected <T extends JFIFPiece> List<T> filterSegments(final List<T> segments,
            final SegmentFilter filter) {
        return filterSegments(segments, filter, false);
    }

    protected <T extends JFIFPiece> List<T> filterSegments(final List<T> segments,
            final SegmentFilter filter, final boolean reverse) {
        final List<T> result = new ArrayList<>();

        for (final T piece : segments) {
            if (piece instanceof JFIFPieceSegment) {
                if (filter.filter((JFIFPieceSegment) piece) ^ !reverse) {
                    result.add(piece);
                }
            } else if (!reverse) {
                result.add(piece);
            }
        }

        return result;
    }

    protected <T extends JFIFPiece, U extends JFIFPiece> List<JFIFPiece> insertBeforeFirstAppSegments(
            final List<T> segments, final List<U> newSegments) throws ImageWriteException {
        int firstAppIndex = -1;
        for (int i = 0; i < segments.size(); i++) {
            final JFIFPiece piece = segments.get(i);
            if (!(piece instanceof JFIFPieceSegment)) {
                continue;
            }

            final JFIFPieceSegment segment = (JFIFPieceSegment) piece;
            if (segment.isAppSegment()) {
                if (firstAppIndex == -1) {
                    firstAppIndex = i;
                }
            }
        }

        final List<JFIFPiece> result = new ArrayList<JFIFPiece>(segments);
        if (firstAppIndex == -1) {
            throw new ImageWriteException(""JPEG file has no APP segments."");
        }
        result.addAll(firstAppIndex, newSegments);
        return result;
    }

    protected <T extends JFIFPiece, U extends JFIFPiece> List<JFIFPiece> insertAfterLastAppSegments(
            final List<T> segments, final List<U> newSegments) throws ImageWriteException {
        int lastAppIndex = -1;
        for (int i = 0; i < segments.size(); i++) {
            final JFIFPiece piece = segments.get(i);
            if (!(piece instanceof JFIFPieceSegment)) {
                continue;
            }

            final JFIFPieceSegment segment = (JFIFPieceSegment) piece;
            if (segment.isAppSegment()) {
                lastAppIndex = i;
            }
        }

        final List<JFIFPiece> result = new ArrayList<JFIFPiece>(segments);
        if (lastAppIndex == -1) {
            if (segments.size() < 1) {
                throw new ImageWriteException(""JPEG file has no APP segments."");
            }
            result.addAll(1, newSegments);
        } else {
            result.addAll(lastAppIndex + 1, newSegments);
        }

        return result;
    }

    protected void writeSegments(final OutputStream outputStream,
            final List<? extends JFIFPiece> segments) throws IOException {
        try (DataOutputStream os = new DataOutputStream(outputStream)) {
            JpegConstants.SOI.writeTo(os);

            for (final JFIFPiece piece : segments) {
                piece.write(os);
            }
        }
    }

    // private void writeSegment(OutputStream os, JFIFPieceSegment piece)
    // throws ImageWriteException, IOException
    // {
    // byte markerBytes[] = convertShortToByteArray(JPEG_APP1_MARKER,
    // JPEG_BYTE_ORDER);
    // if (piece.segmentData.length > 0xffff)
    // throw new JpegSegmentOverflowException(""Jpeg segment is too long: ""
    // + piece.segmentData.length);
    // int segmentLength = piece.segmentData.length + 2;
    // byte segmentLengthBytes[] = convertShortToByteArray(segmentLength,
    // JPEG_BYTE_ORDER);
    //
    // os.write(markerBytes);
    // os.write(segmentLengthBytes);
    // os.write(piece.segmentData);
    // }

    public static class JpegSegmentOverflowException extends ImageWriteException {
        private static final long serialVersionUID = -1062145751550646846L;

        public JpegSegmentOverflowException(final String message) {
            super(message);
        }
    }

}
",blob
845,"    public void read(org.apache.thrift.protocol.TProtocol iprot, FetchRuleKeyLogsRequest struct) throws org.apache.thrift.TException {
      org.apache.thrift.protocol.TField schemeField;
      iprot.readStructBegin();
      while (true)
      {
        schemeField = iprot.readFieldBegin();
        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (schemeField.id) {
          case 1: // RULE_KEYS
            if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
              {
                org.apache.thrift.protocol.TList _list184 = iprot.readListBegin();
                struct.ruleKeys = new java.util.ArrayList<java.lang.String>(_list184.size);
                java.lang.String _elem185;
                for (int _i186 = 0; _i186 < _list184.size; ++_i186)
                {
                  _elem185 = iprot.readString();
                  struct.ruleKeys.add(_elem185);
                }
                iprot.readListEnd();
              }
              struct.setRuleKeysIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 2: // REPOSITORY
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.repository = iprot.readString();
              struct.setRepositoryIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 3: // SCHEDULE_TYPE
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.scheduleType = iprot.readString();
              struct.setScheduleTypeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 4: // DISTRIBUTED_BUILD_MODE_ENABLED
            if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
              struct.distributedBuildModeEnabled = iprot.readBool();
              struct.setDistributedBuildModeEnabledIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      struct.validate();
    }
",long method
566,"    class Whitespace implements Text {
        private String text;
        public Whitespace(String text) {
            this.text = text;
        }
        @Override
        public String getText() {
            return text;
        }
    }
",data class
504,"    @Override
    public Object getValue(final String columnLabel, final Class<?> type) throws SQLException {
        Object result;
        if (Object.class == type) {
            result = decrypt(columnLabel, resultSet.getObject(columnLabel));
        } else if (boolean.class == type) {
            result = decrypt(columnLabel, resultSet.getBoolean(columnLabel));
        } else if (byte.class == type) {
            result = decrypt(columnLabel, resultSet.getByte(columnLabel));
        } else if (short.class == type) {
            result = decrypt(columnLabel, resultSet.getShort(columnLabel));
        } else if (int.class == type) {
            result = decrypt(columnLabel, resultSet.getInt(columnLabel));
        } else if (long.class == type) {
            result = decrypt(columnLabel, resultSet.getLong(columnLabel));
        } else if (float.class == type) {
            result = decrypt(columnLabel, resultSet.getFloat(columnLabel));
        } else if (double.class == type) {
            result = decrypt(columnLabel, resultSet.getDouble(columnLabel));
        } else if (String.class == type) {
            result = decrypt(columnLabel, resultSet.getString(columnLabel));
        } else if (BigDecimal.class == type) {
            result = decrypt(columnLabel, resultSet.getBigDecimal(columnLabel));
        } else if (byte[].class == type) {
            result = resultSet.getBytes(columnLabel);
        } else if (Date.class == type) {
            result = resultSet.getDate(columnLabel);
        } else if (Time.class == type) {
            result = resultSet.getTime(columnLabel);
        } else if (Timestamp.class == type) {
            result = resultSet.getTimestamp(columnLabel);
        } else if (URL.class == type) {
            result = resultSet.getURL(columnLabel);
        } else if (Blob.class == type) {
            result = resultSet.getBlob(columnLabel);
        } else if (Clob.class == type) {
            result = resultSet.getClob(columnLabel);
        } else if (SQLXML.class == type) {
            result = resultSet.getSQLXML(columnLabel);
        } else if (Reader.class == type) {
            result = resultSet.getCharacterStream(columnLabel);
        } else {
            result = decrypt(columnLabel, resultSet.getObject(columnLabel));
        }
        return result;
    }
",long method
1167,"		void cleanup() {
			for (final BundleWire requiredWire : requiredWires.getAllValues()) {
				final ConciergeBundleWiring bw = ((ConciergeBundleWire) requiredWire).providerWiring;
				if (bw != null) {
					bw.inUseSet.remove(revision);
				}
			}
			for (final BundleWire hostWire : providedWires
					.lookup(HostNamespace.HOST_NAMESPACE)) {
				final ConciergeBundleWiring bw = ((ConciergeBundleWire) hostWire).requirerWiring;
				if (bw != null) {
					bw.inUseSet.remove(revision);
				}
			}
		}
",feature envy
565,"@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = ""EObject"", propOrder = { ""extensions"" })
public class EObject {

	@XmlElement(name = ""Extension"", namespace = ""http://www.omg.org/XMI"")
	protected List<Extension> extensions;
	@XmlAttribute(namespace = ""http://www.omg.org/XMI"")
	@XmlJavaTypeAdapter(CollapsedStringAdapter.class)
	@XmlID
	protected String id;
	@XmlAttribute(namespace = ""http://www.omg.org/XMI"")
	protected QName type;
	@XmlAttribute(namespace = ""http://www.omg.org/XMI"")
	protected String version;
	@XmlAttribute
	protected String href;
	@XmlAttribute(namespace = ""http://www.omg.org/XMI"")
	@XmlIDREF
	protected Object idref;
	@XmlAttribute(namespace = ""http://www.omg.org/XMI"")
	protected String label;
	@XmlAttribute(namespace = ""http://www.omg.org/XMI"")
	protected String uuid;

	/**
	 * Gets the value of the extensions property.
	 * 
	 * <p>
	 * This accessor method returns a reference to the live list, not a
	 * snapshot. Therefore any modification you make to the returned list will
	 * be present inside the JAXB object. This is why there is not a
	 * <CODE>set</CODE> method for the extensions property.
	 * 
	 * <p>
	 * For example, to add a new item, do as follows:
	 * 
	 * <pre>
	 * getExtensions().add(newItem);
	 * </pre>
	 * 
	 * 
	 * <p>
	 * Objects of the following type(s) are allowed in the list
	 * {@link Extension }
	 * 
	 * 
	 */
	public List<Extension> getExtensions() {
		if (extensions == null) {
			extensions = new ArrayList<Extension>();
		}
		return this.extensions;
	}

	/**
	 * Gets the value of the id property.
	 * 
	 * @return possible object is {@link String }
	 * 
	 */
	public String getId() {
		return id;
	}

	/**
	 * Sets the value of the id property.
	 * 
	 * @param value
	 *            allowed object is {@link String }
	 * 
	 */
	public void setId(String value) {
		this.id = value;
	}

	/**
	 * Gets the value of the type property.
	 * 
	 * @return possible object is {@link QName }
	 * 
	 */
	public QName getType() {
		return type;
	}

	/**
	 * Sets the value of the type property.
	 * 
	 * @param value
	 *            allowed object is {@link QName }
	 * 
	 */
	public void setType(QName value) {
		this.type = value;
	}

	/**
	 * Gets the value of the version property.
	 * 
	 * @return possible object is {@link String }
	 * 
	 */
	public String getVersion() {
		if (version == null) {
			return ""2.0"";
		} else {
			return version;
		}
	}

	/**
	 * Sets the value of the version property.
	 * 
	 * @param value
	 *            allowed object is {@link String }
	 * 
	 */
	public void setVersion(String value) {
		this.version = value;
	}

	/**
	 * Gets the value of the href property.
	 * 
	 * @return possible object is {@link String }
	 * 
	 */
	public String getHref() {
		return href;
	}

	/**
	 * Sets the value of the href property.
	 * 
	 * @param value
	 *            allowed object is {@link String }
	 * 
	 */
	public void setHref(String value) {
		this.href = value;
	}

	/**
	 * Gets the value of the idref property.
	 * 
	 * @return possible object is {@link Object }
	 * 
	 */
	public Object getIdref() {
		return idref;
	}

	/**
	 * Sets the value of the idref property.
	 * 
	 * @param value
	 *            allowed object is {@link Object }
	 * 
	 */
	public void setIdref(Object value) {
		this.idref = value;
	}

	/**
	 * Gets the value of the label property.
	 * 
	 * @return possible object is {@link String }
	 * 
	 */
	public String getLabel() {
		return label;
	}

	/**
	 * Sets the value of the label property.
	 * 
	 * @param value
	 *            allowed object is {@link String }
	 * 
	 */
	public void setLabel(String value) {
		this.label = value;
	}

	/**
	 * Gets the value of the uuid property.
	 * 
	 * @return possible object is {@link String }
	 * 
	 */
	public String getUuid() {
		return uuid;
	}

	/**
	 * Sets the value of the uuid property.
	 * 
	 * @param value
	 *            allowed object is {@link String }
	 * 
	 */
	public void setUuid(String value) {
		this.uuid = value;
	}

}
",data class
918,"        private final class FindInMethod extends MethodVisitor {

            private final String name;
            private final String desc;
            private final int access;
            private FindInAnno fia;
            private boolean bodyGenerated;

            public FindInMethod(int access, String name, String desc, MethodVisitor mv) {
                super(Opcodes.ASM5, mv);
                this.access = access;
                this.name = name;
                this.desc = desc;
            }

            @Override
            public AnnotationVisitor visitAnnotation(String desc, boolean visible) {
                if (""Lnet/java/html/js/JavaScriptBody;"".equals(desc)) { // NOI18N
                    found++;
                    return new FindInAnno();
                }
                return super.visitAnnotation(desc, visible);
            }

            private void generateJSBody(FindInAnno fia) {
                this.fia = fia;
            }

            @Override
            public void visitCode() {
                if (fia == null) {
                    return;
                }
                generateBody(true);
            }

            private boolean generateBody(boolean hasCode) {
                if (bodyGenerated) {
                    return false;
                }
                bodyGenerated = true;
                if (mv != null) {
                    AnnotationVisitor va = super.visitAnnotation(""Lnet/java/html/js/JavaScriptBody;"", false);
                    AnnotationVisitor varr = va.visitArray(""args"");
                    for (String argName : fia.args) {
                        varr.visit(null, argName);
                    }
                    varr.visitEnd();
                    va.visit(""javacall"", fia.javacall);
                    va.visit(""body"", fia.body);
                    va.visitEnd();
                }
                
                String body;
                List<String> args;
                if (fia.javacall) {
                    body = callback(fia.body);
                    args = new ArrayList<String>(fia.args);
                    args.add(""vm"");
                } else {
                    body = fia.body;
                    args = fia.args;
                }

                super.visitFieldInsn(
                        Opcodes.GETSTATIC, FindInClass.this.name,
                        ""$$fn$$"" + name + ""_"" + found,
                        ""Lorg/netbeans/html/boot/spi/Fn;""
                );
                super.visitInsn(Opcodes.DUP);
                super.visitMethodInsn(
                        Opcodes.INVOKESTATIC,
                        ""org/netbeans/html/boot/spi/Fn"", ""isValid"",
                        ""(Lorg/netbeans/html/boot/spi/Fn;)Z""
                );
                Label ifNotNull = new Label();
                super.visitJumpInsn(Opcodes.IFNE, ifNotNull);

                // init Fn
                super.visitInsn(Opcodes.POP);
                super.visitLdcInsn(Type.getObjectType(FindInClass.this.name));
                super.visitInsn(fia.keepAlive ? Opcodes.ICONST_1 : Opcodes.ICONST_0);
                super.visitLdcInsn(body);
                super.visitIntInsn(Opcodes.SIPUSH, args.size());
                super.visitTypeInsn(Opcodes.ANEWARRAY, ""java/lang/String"");
                boolean needsVM = false;
                for (int i = 0; i < args.size(); i++) {
                    assert !needsVM;
                    String argName = args.get(i);
                    needsVM = ""vm"".equals(argName);
                    super.visitInsn(Opcodes.DUP);
                    super.visitIntInsn(Opcodes.BIPUSH, i);
                    super.visitLdcInsn(argName);
                    super.visitInsn(Opcodes.AASTORE);
                }
                super.visitMethodInsn(Opcodes.INVOKESTATIC,
                        ""org/netbeans/html/boot/spi/Fn"", ""define"",
                        ""(Ljava/lang/Class;ZLjava/lang/String;[Ljava/lang/String;)Lorg/netbeans/html/boot/spi/Fn;""
                );
                Label noPresenter = new Label();
                super.visitInsn(Opcodes.DUP);
                super.visitJumpInsn(Opcodes.IFNULL, noPresenter);
                int cnt = resourcesCnt;
                while (cnt > 0) {
                    String resource = resources[--cnt];
                    if (resource == null) {
                        continue;
                    }
                    super.visitLdcInsn(Type.getObjectType(FindInClass.this.name));
                    super.visitLdcInsn(resource);
                    super.visitMethodInsn(Opcodes.INVOKESTATIC,
                            ""org/netbeans/html/boot/spi/Fn"", ""preload"",
                            ""(Lorg/netbeans/html/boot/spi/Fn;Ljava/lang/Class;Ljava/lang/String;)Lorg/netbeans/html/boot/spi/Fn;""
                    );
                }
                super.visitInsn(Opcodes.DUP);
                super.visitFieldInsn(
                        Opcodes.PUTSTATIC, FindInClass.this.name,
                        ""$$fn$$"" + name + ""_"" + found,
                        ""Lorg/netbeans/html/boot/spi/Fn;""
                );
                // end of Fn init

                super.visitLabel(ifNotNull);

                final int offset;
                if ((access & Opcodes.ACC_STATIC) == 0) {
                    offset = 1;
                    super.visitIntInsn(Opcodes.ALOAD, 0);
                } else {
                    offset = 0;
                    super.visitInsn(Opcodes.ACONST_NULL);
                }

                super.visitIntInsn(Opcodes.SIPUSH, args.size());
                super.visitTypeInsn(Opcodes.ANEWARRAY, ""java/lang/Object"");

                class SV extends SignatureVisitor {

                    private boolean nowReturn;
                    private Type returnType;
                    private int index;
                    private int loadIndex = offset;

                    public SV() {
                        super(Opcodes.ASM5);
                    }

                    @Override
                    public void visitBaseType(char descriptor) {
                        final Type t = Type.getType("""" + descriptor);
                        if (nowReturn) {
                            returnType = t;
                            return;
                        }
                        FindInMethod.super.visitInsn(Opcodes.DUP);
                        FindInMethod.super.visitIntInsn(Opcodes.SIPUSH, index++);
                        FindInMethod.super.visitVarInsn(t.getOpcode(Opcodes.ILOAD), loadIndex++);
                        String factory;
                        switch (descriptor) {
                            case 'I':
                                factory = ""java/lang/Integer"";
                                break;
                            case 'J':
                                factory = ""java/lang/Long"";
                                loadIndex++;
                                break;
                            case 'S':
                                factory = ""java/lang/Short"";
                                break;
                            case 'F':
                                factory = ""java/lang/Float"";
                                break;
                            case 'D':
                                factory = ""java/lang/Double"";
                                loadIndex++;
                                break;
                            case 'Z':
                                factory = ""java/lang/Boolean"";
                                break;
                            case 'C':
                                factory = ""java/lang/Character"";
                                break;
                            case 'B':
                                factory = ""java/lang/Byte"";
                                break;
                            default:
                                throw new IllegalStateException(t.toString());
                        }
                        FindInMethod.super.visitMethodInsn(Opcodes.INVOKESTATIC,
                                factory, ""valueOf"", ""("" + descriptor + "")L"" + factory + "";""
                        );
                        FindInMethod.super.visitInsn(Opcodes.AASTORE);
                    }

                    @Override
                    public SignatureVisitor visitArrayType() {
                        if (nowReturn) {
                            return new SignatureVisitor(Opcodes.ASM5) {
                                @Override
                                public void visitClassType(String name) {
                                    returnType = Type.getType(""["" + Type.getObjectType(name).getDescriptor());
                                }

                                @Override
                                public void visitBaseType(char descriptor) {
                                    returnType = Type.getType(""["" + descriptor);
                                }
                            };
                        }
                        loadObject();
                        return new SignatureWriter();
                    }

                    @Override
                    public void visitClassType(String name) {
                        if (nowReturn) {
                            returnType = Type.getObjectType(name);
                            return;
                        }
                        loadObject();
                    }

                    @Override
                    public SignatureVisitor visitReturnType() {
                        nowReturn = true;
                        return this;
                    }

                    private void loadObject() {
                        FindInMethod.super.visitInsn(Opcodes.DUP);
                        FindInMethod.super.visitIntInsn(Opcodes.SIPUSH, index++);
                        FindInMethod.super.visitVarInsn(Opcodes.ALOAD, loadIndex++);
                        FindInMethod.super.visitInsn(Opcodes.AASTORE);
                    }

                }
                SV sv = new SV();
                SignatureReader sr = new SignatureReader(desc);
                sr.accept(sv);

                if (needsVM) {
                    FindInMethod.super.visitInsn(Opcodes.DUP);
                    FindInMethod.super.visitIntInsn(Opcodes.SIPUSH, sv.index);
                    int lastSlash = FindInClass.this.name.lastIndexOf('/');
                    String jsCallbacks = FindInClass.this.name.substring(0, lastSlash + 1) + ""$JsCallbacks$"";
                    FindInMethod.super.visitFieldInsn(Opcodes.GETSTATIC, jsCallbacks, ""VM"", ""L"" + jsCallbacks + "";"");
                    FindInMethod.super.visitMethodInsn(Opcodes.INVOKEVIRTUAL, jsCallbacks, ""current"", ""()L"" + jsCallbacks + "";"");
                    FindInMethod.super.visitInsn(Opcodes.AASTORE);
                }

                if (fia.wait4js) {
                    super.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                            ""org/netbeans/html/boot/spi/Fn"", ""invoke"", ""(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;""
                    );
                    switch (sv.returnType.getSort()) {
                        case Type.VOID:
                            super.visitInsn(Opcodes.RETURN);
                            break;
                        case Type.ARRAY:
                        case Type.OBJECT:
                            super.visitTypeInsn(Opcodes.CHECKCAST, sv.returnType.getInternalName());
                            super.visitInsn(Opcodes.ARETURN);
                            break;
                        case Type.BOOLEAN: {
                            Label handleNullValue = new Label();
                            super.visitInsn(Opcodes.DUP);
                            super.visitJumpInsn(Opcodes.IFNULL, handleNullValue);
                            super.visitTypeInsn(Opcodes.CHECKCAST, ""java/lang/Boolean"");
                            super.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                                    ""java/lang/Boolean"", ""booleanValue"", ""()Z""
                            );
                            super.visitInsn(Opcodes.IRETURN);
                            super.visitLabel(handleNullValue);
                            super.visitInsn(Opcodes.ICONST_0);
                            super.visitInsn(Opcodes.IRETURN);
                            break;
                        }
                        default:
                            super.visitTypeInsn(Opcodes.CHECKCAST, ""java/lang/Number"");
                            super.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                                    ""java/lang/Number"", sv.returnType.getClassName() + ""Value"", ""()"" + sv.returnType.getDescriptor()
                            );
                            super.visitInsn(sv.returnType.getOpcode(Opcodes.IRETURN));
                    }
                } else {
                    super.visitMethodInsn(Opcodes.INVOKEVIRTUAL,
                            ""org/netbeans/html/boot/spi/Fn"", ""invokeLater"", ""(Ljava/lang/Object;[Ljava/lang/Object;)V""
                    );
                    super.visitInsn(Opcodes.RETURN);
                }
                super.visitLabel(noPresenter);
                if (hasCode) {
                    super.visitCode();
                } else {
                    super.visitTypeInsn(Opcodes.NEW, ""java/lang/IllegalStateException"");
                    super.visitInsn(Opcodes.DUP);
                    super.visitLdcInsn(""No presenter active. Use BrwsrCtx.execute!"");
                    super.visitMethodInsn(Opcodes.INVOKESPECIAL, 
                        ""java/lang/IllegalStateException"", ""<init>"", ""(Ljava/lang/String;)V""
                    );
                    this.visitInsn(Opcodes.ATHROW);
                }
                return true;
            }
            
            @Override
            public void visitEnd() {
                super.visitEnd();
                if (fia != null) {
                    if (generateBody(false)) {
                        // native method
                        super.visitMaxs(1, 0);
                    }
                    FindInClass.this.superField(
                            Opcodes.ACC_PRIVATE | Opcodes.ACC_STATIC,
                            ""$$fn$$"" + name + ""_"" + found,
                            ""Lorg/netbeans/html/boot/spi/Fn;"",
                            null, null
                    );
                }
            }

            private final class FindInAnno extends AnnotationVisitor {

                List<String> args = new ArrayList<String>();
                String body;
                boolean javacall = false;
                boolean wait4js = true;
                boolean keepAlive = true;

                public FindInAnno() {
                    super(Opcodes.ASM5);
                }

                @Override
                public void visit(String name, Object value) {
                    if (name == null) {
                        args.add((String) value);
                        return;
                    }
                    if (name.equals(""javacall"")) { // NOI18N
                        javacall = (Boolean) value;
                        return;
                    }
                    if (name.equals(""wait4js"")) { // NOI18N
                        wait4js = (Boolean) value;
                        return;
                    }
                    if (name.equals(""keepAlive"")) { // NOI18N
                        keepAlive = (Boolean) value;
                        return;
                    }
                    assert name.equals(""body""); // NOI18N
                    body = (String) value;
                }

                @Override
                public AnnotationVisitor visitArray(String name) {
                    return this;
                }

                @Override
                public void visitEnd() {
                    if (body != null) {
                        generateJSBody(this);
                    }
                }
            }
        }
",blob
624,"   public static class Builder {
      /**
       * @see AddDomainOptions#primaryNameServer
       */
      public static AddDomainOptions primaryNameServer(String primaryNameServer) {
         return AddDomainOptions.class.cast(new AddDomainOptions().primaryNameServer(primaryNameServer));
      }

      /**
       * @see AddDomainOptions#responsiblePerson
       */
      public static AddDomainOptions responsiblePerson(String responsiblePerson) {
         return AddDomainOptions.class.cast(new AddDomainOptions().responsiblePerson(responsiblePerson));
      }

      /**
       * @see AddDomainOptions#ttl
       */
      public static AddDomainOptions ttl(int ttl) {
         return AddDomainOptions.class.cast(new AddDomainOptions().ttl(ttl));
      }

      /**
       * @see AddDomainOptions#refresh
       */
      public static AddDomainOptions refresh(int refresh) {
         return AddDomainOptions.class.cast(new AddDomainOptions().refresh(refresh));
      }

      /**
       * @see AddDomainOptions#retry
       */
      public static AddDomainOptions retry(int retry) {
         return AddDomainOptions.class.cast(new AddDomainOptions().retry(retry));
      }

      /**
       * @see AddDomainOptions#expire
       */
      public static AddDomainOptions expire(int expire) {
         return AddDomainOptions.class.cast(new AddDomainOptions().expire(expire));
      }

      /**
       * @see AddDomainOptions#minimum
       */
      public static AddDomainOptions minimum(int minimum) {
         return AddDomainOptions.class.cast(new AddDomainOptions().minimum(minimum));
      }

      /**
       * @see AddDomainOptions#minimalRecords
       */
      public static AddDomainOptions minimalRecords() {
         return AddDomainOptions.class.cast(new AddDomainOptions().minimalRecords());
      }
   }
",blob
1495,"public class Builder {

	public static boolean isForced(Map<?, ?> options) {
		return Boolean.TRUE.equals(options.get(""force""));
	}

	private Properties options = new Properties();
	private BuilderExtension[] extensions = new BuilderExtension[0];

	private Logger logger = new NullLogger();
	private ConfigurationRegistry registry;
	private ConfigObject configObject = null;
	private boolean isIncremental = false;
	private boolean enabledMetadata = false;

	private File sourceDir = null;

	/**
	 * The value is a String[] containing the relative paths of all of the build
	 * files for a given sourceDir.
	 */
	private final Map<File, String[]> buildFilesBySourceDir = new HashMap<>();
	/*[PR 118220] Incremental builder is not called when file is deleted in base library*/
	private final Map<File, List<String>> deleteFilesBySourceDir = new HashMap<>();
	private final Map<File, List<String>> buildResourcesBySourceDir = new HashMap<>();

	private int buildFileCount = 0;
	private int deleteFileCount = 0;
	private int builtFileCount = 0;
	private int buildResourcesCount = 0;
	private File outputDir = null;
	private boolean verdict = false;
	private boolean includeIfUnsure = false;
	/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/
	private boolean isTestsBootPath = false;
	private boolean noWarnIncludeIf = false;
	private boolean noWarnInvalidFlags = false;
	private boolean multipleSources = false;
	private boolean updateAllCopyrights = false;

	/**
	 * J9 JCL Preprocessor builder constructor.  Initializes the needed extensions.
	 */
	public Builder() {
		addExtension(new ExternalMessagesExtension());
		addExtension(new MacroExtension());
		addExtension(new JxeRulesExtension());
		addExtension(new EclipseMetadataExtension());
		addExtension(new JitAttributesExtension());
		addExtension(new TagExtension());
	}

	/**
	 * Sets the preprocess options.
	 *
	 * @param 		options		the preprocess options
	 */
	public void setOptions(Properties options) {
		if (options != null) {
			this.options.putAll(options);
		}
		this.options = options;
	}

	/**
	 * Returns the preprocess options for this builder.
	 *
	 * @return		the preprocess options
	 */
	public Properties getOptions() {
		return this.options;
	}

	/**
	 * Adds an extension to the builder.
	 *
	 * @param 		extension	the extension to add
	 */
	public void addExtension(BuilderExtension extension) {
		if (extension == null) {
			throw new NullPointerException();
		}

		BuilderExtension[] newExtensions = new BuilderExtension[extensions.length + 1];
		if (extensions.length > 0) {
			System.arraycopy(extensions, 0, newExtensions, 0, extensions.length);
		}
		newExtensions[newExtensions.length - 1] = extension;
		this.extensions = newExtensions;

		extension.setBuilder(this);
	}

	/**
	 * Returns the builder extensions/
	 *
	 * @return		the builder extensions
	 */
	public BuilderExtension[] getExtensions() {
		return extensions;
	}

	/**
	 * Returns the logger associated with this builder.
	 *
	 * @return		the logger
	 */
	public Logger getLogger() {
		return logger;
	}

	/**
	 * Sets this builder's logger.
	 *
	 * @param 		logger		the new logger
	 */
	public void setLogger(Logger logger) {
		this.logger = logger;
	}

	/**
	 * Sets whether the build is incremental or not.
	 *
	 * @param 		isIncremental	<code>true</code> if the build is incremental, <code>false</code> otherwise
	 */
	public void setIncremental(boolean isIncremental) {
		this.isIncremental = isIncremental;
	}

	/**
	 * Returns wheter or not this builder will only do an incremental build.
	 *
	 * @return		<code>true</code> if the build is incremental, <code>false</code> otherwise
	 */
	public boolean isIncremental() {
		return this.isIncremental;
	}

	/**
	 * Sets whether or not preprocessor metadata will be generated.
	 *
	 * @param 		enabledMetadata		<code>true</code> if metadata is to be generated,
	 * 									<code>false</code> otherwise
	 */
	public void setMetadata(boolean enabledMetadata) {
		this.enabledMetadata = enabledMetadata;
	}

	/**
	 * Returns whether or not preprocessor metadata is enabled.
	 *
	 * @return		<code>true</code> if metadata will be written, <code>false</code> otherwise
	 */
	public boolean isMetadataEnabled() {
		return this.enabledMetadata;
	}

	/**
	 * Sets whether or not the preprocessor should include files that do not
	 * have a INCLUDE-IF tag.
	 *
	 * @param 		include		<code>true</code> if files with no INCLUDE-IF should
	 * 							be included, <code>false</code> otherwise
	 */
	public void setIncludeIfUnsure(boolean include) {
		this.includeIfUnsure = include;
	}

	/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/
	/**
	 * Sets whether or not the preprocessor is running to generate Tests Boot Path project
	 *
	 * @param 	isTestsBoot		<code>true</code> if preprocessor is running to generate Tests Boot Path project,
	 * 							<code>false</code> otherwise
	 */
	public void setIsTestsBoot(boolean isTestsBoot) {
		this.isTestsBootPath = isTestsBoot;
	}

	/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/
	/**
	 * Sets whether or not the preprocessor should give warningsor errors about the files that do not
	 * have a INCLUDE-IF tag.
	 *
	 * @param 		warning		<code>true</code> if files with no INCLUDE-IF should
	 * 							be marked with warning or error, <code>false</code> otherwise
	 */
	public void setNoWarnIncludeIf(boolean warning) {
		this.noWarnIncludeIf = warning;
	}

	/**
	 * Sets the configuration to preprocess.
	 *
	 * @param 		config		the configuration to preprocess
	 */
	public void setConfiguration(ConfigObject config) {
		if (config.isSet()) {
			System.err.println(""Warning: Builder is using "" + config + "", a set, not a configuration."");
		}
		this.configObject = config;
		this.registry = config.getRegistry();
		this.outputDir = config.getOutputDir();
	}

	/**
	 * Returns this builder's output directory.
	 *
	 * @return		the output directory
	 */
	public File getOutputDir() {
		return this.outputDir;
	}

	/**
	 * Sets this builder's output directory.
	 *
	 * @param 		outputDir	the new output directory
	 */
	public void setOutputDir(File outputDir) {
		if (outputDir == null) {
			throw new NullPointerException();
		}
		this.outputDir = outputDir;
	}

	/**
	 * Returns this builder's configuration source directories.
	 *
	 * @return		the config's source dirs
	 */
	public File getSourceDir() {
		return this.sourceDir;
	}

	/**
	 * Sets the proprocess job's source directory.
	 *
	 * @param 		sourceDir	the source directory to preprocess
	 */
	public void setSourceDir(File sourceDir) {
		if (sourceDir == null) {
			throw new NullPointerException();
		} else {
			this.sourceDir = sourceDir;
		}
	}

	/**
	 * Set builder aware of other sources (to be used by the ExternalMessagesExtension).
	 *
	 * @param 		multipleSources		<code>true</code> if there are other sources, <code>false</code> otherwise
	 */
	public void setMultipleSources(boolean multipleSources) {
		this.multipleSources = multipleSources;
	}

	/**
	 * Returns whether or not the configuration that setup this builder has multiple sources.
	 *
	 * @return		<code>true</code> if there are other sources, <code>false</code> otherwise
	 */
	public boolean hasMultipleSources() {
		return multipleSources;
	}

	/**
	 * Performs the build.
	 */
	public boolean build() {
		//create output dir even if no file is gonna be included in preprocess
		getOutputDir().mkdirs();
		if (validateOptions()) {
			computeBuildFiles();
			notifyBuildBegin();

			PreprocessorFactory factory = newPreprocessorFactory();
			boolean force = isForced(this.options);

			//Ignore folders that do not exist (warning thrown in computeBuildFiles()
			if (sourceDir != null) {
				File metadataDir = new File(outputDir.getParentFile(), ""jppmd"");
				String[] buildFiles = buildFilesBySourceDir.get(sourceDir);
				getLogger().log(""\nPreprocessing "" + sourceDir.getAbsolutePath(), 1);
				builtFileCount = 0;

				for (String buildFile : buildFiles) {
					File sourceFile = new File(sourceDir, buildFile);
					File outputFile = new File(outputDir, buildFile);
					File metadataFile = new File(metadataDir, buildFile + "".jppmd"");

					notifyBuildFileBegin(sourceFile, outputFile, buildFile);

					try (OutputStream metadataOutput = new PhantomOutputStream(metadataFile);
						 OutputStream output = new PhantomOutputStream(outputFile, force)) {

						// configure the preprocessor and let extensions do the same
						JavaPreprocessor jpp;

						if (enabledMetadata) {
							jpp = factory.newPreprocessor(metadataOutput, sourceFile, output, outputFile);
						} else {
							jpp = factory.newPreprocessor(sourceFile, output);
						}

						Calendar cal = new GregorianCalendar();
						if (!updateAllCopyrights) {
							cal.setTime(new Date(sourceFile.lastModified()));
						}
						jpp.setCopyrightYear(cal.get(Calendar.YEAR));
						jpp.addValidFlags(registry.getValidFlags());
						/*[PR 120411] Use a javadoc tag instead of TestBootpath preprocessor tag*/
						jpp.setTestBootPath(isTestsBootPath);
						notifyConfigurePreprocessor(jpp);

						// preprocess
						boolean included = false;
						try {
							included = jpp.preprocess();
							if (included) {
								builtFileCount++;
							}
							handlePreprocessorWarnings(jpp, sourceFile);
						} catch (Throwable t) {
							handlePreprocessorException(t, sourceFile);
						}

						if (!included && outputFile.exists()) {
							outputFile.delete();
						}

						if (!included && metadataFile.exists()) {
							metadataFile.delete();
						}
					} catch (Throwable t) {
						getLogger().log(""Exception occured in file "" + sourceFile.getAbsolutePath() + "", preprocess failed."", 3, t);
						handleBuildException(t);
					} finally {
						notifyBuildFileEnd(sourceFile, outputFile, buildFile);
					}
				}

				logger.log(builtFileCount + "" of "" + buildFileCount + "" file(s) included in preprocess"", 1);

				/*[PR 118220] Incremental builder is not called when file is deleted in base library*/
				List<String> deleteFiles = deleteFilesBySourceDir.get(sourceDir);
				if (deleteFiles != null && deleteFiles.size() != 0) {
					int deletedFilesCount = 0;
					for (String file : deleteFiles) {
						File deleteFile = new File(outputDir, file);
						if (deleteFile.exists()) {
							deletedFilesCount++;
							deleteFile.delete();
						}
					}
					getLogger().log(deletedFilesCount + "" of "" + deleteFileCount
							+ "" file(s) deleted in preprocess from "" + outputDir.getAbsolutePath(), 1);
				}
			}
			/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */
			List<String> buildResources = buildResourcesBySourceDir.get(sourceDir);
			if (buildResources != null && buildResources.size() != 0) {
				int copiedResourcesCount = 0;
				int deletedResorucesCount = 0;
				String outputpath;
				if (isTestsBootPath) {
					outputpath = configObject.getBootTestsOutputPath();
				} else {
					outputpath = configObject.getTestsOutputPath();
				}
				for (String file : buildResources) {
					File resource_out = new File(outputpath, file);
					File resource_src = new File(sourceDir, file);
					if (resource_src.exists()) {
						copyResource(resource_src, resource_out);
						copiedResourcesCount++;
					} else {
						resource_out.delete();
						deletedResorucesCount++;
					}
				}

				getLogger().log(""Total Build Resource Count : "" + buildResourcesCount, 1);
				getLogger().log(""  - "" + copiedResourcesCount + "" resource"" + (copiedResourcesCount > 1 ? ""s are "" : "" is "") + ""copied to "" + outputpath, 1);
				getLogger().log(""  - "" + deletedResorucesCount + "" resource"" + (deletedResorucesCount > 1 ? ""s are "" : "" is "") + ""deleted from "" + outputpath, 1);
			}

			notifyBuildEnd();
		}

		if (logger.getErrorCount() == 0) {
			if (verdict) {
				getLogger().log(""PREPROCESS WAS SUCCESSFUL"", 1);
			}
			return true;
		} else {
			if (verdict) {
				getLogger().log(""PREPROCESS WAS NOT SUCCESSFUL"", 1);
			}
			return false;
		}
	}

	/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */
	public static void copyResource(File source, File destination) {
		destination.delete();

		try {
			SimpleCopy.copyFile(source, destination);
		} catch (IOException e) {
			System.err.println(""ERROR - Could not copy the file to destination"");
			System.err.println(""   Source: "" + source.toString());
			System.err.println(""   Destination: "" + destination.toString());
			e.printStackTrace();
		}
	}

	/**
	 * Validates the build options.
	 */
	private boolean validateOptions() {
		boolean isValid = true;

		if (configObject == null) {
			configObject = registry.getConfiguration(options.getProperty(""config""));
		}
		this.options.putAll(configObject.getOptions());

		// check for the verdict option
		if (options.containsKey(""verdict"")) {
			this.verdict = true;
		}

		if (options.containsKey(""includeifunsure"")) {
			setIncludeIfUnsure(true);
		}
		if (options.containsKey(""nowarnincludeif"")) {
			setNoWarnIncludeIf(true);
		}

		if (options.containsKey(""nowarninvalidflags"")) {
			this.noWarnInvalidFlags = true;
		}

		if (options.containsKey(""updateallcopyrights"")) {
			this.updateAllCopyrights = true;
		}

		// call the method for all the extensions
		String extensionName = """";
		try {
			for (BuilderExtension extension : extensions) {
				extensionName = extension.getName();
				extension.validateOptions(this.options);
			}
		} catch (BuilderConfigurationException e) {
			logger.log(""A configuration exception occured"", Logger.SEVERITY_FATAL, e);
			isValid = false;
		} catch (Exception e) {
			StringBuffer buffer = new StringBuffer(""An exception occured while invoking validateOptions() for the extension \"""");
			buffer.append(extensionName);
			buffer.append(""\"""");
			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e);
		}
		return isValid;
	}

	/**
	 * Notifies the extensions that the build is beginning.
	 */
	private void notifyBuildBegin() {
		// call the method for all the extensions
		String extensionName = """";
		try {
			for (BuilderExtension extension : extensions) {
				extensionName = extension.getName();
				logger.setMessageSource(extensionName);
				extension.notifyBuildBegin();
				logger.setMessageSource(null);
			}
		} catch (Exception e) {
			StringBuffer buffer = new StringBuffer(""An exception occured while invoking notifyBuildBegin() for the extension \"""");
			buffer.append(extensionName);
			buffer.append(""\"""");
			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e);
		}
	}

	/**
	 * Notifies the extensions that the build is ending.
	 */
	private void notifyBuildEnd() {
		// call the method for all the extensions
		String extensionName = """";
		try {
			for (BuilderExtension extension : extensions) {
				extensionName = extension.getName();
				logger.setMessageSource(extensionName);
				extension.notifyBuildEnd();
				logger.setMessageSource(null);
			}
		} catch (Exception e) {
			StringBuffer buffer = new StringBuffer(""An exception occured while invoking notifyBuildEnd() for the extension \"""");
			buffer.append(extensionName);
			buffer.append(""\"""");
			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e);
		}
	}

	/**
	 * Notifies the extensions that the build is beginning on the specified
	 * file.
	 */
	private void notifyBuildFileBegin(File sourceFile, File outputFile, String relativePath) {
		// call the method for all the extensions
		String extensionName = """";
		try {
			for (BuilderExtension extension : extensions) {
				extensionName = extension.getName();
				logger.setMessageSource(extensionName);
				extension.notifyBuildFileBegin(sourceFile, outputFile, relativePath);
				logger.setMessageSource(null);
			}
		} catch (Exception e) {
			StringBuffer buffer = new StringBuffer(""An exception occured while invoking notifyBuildFileBegin() for the extension \"""");
			buffer.append(extensionName);
			buffer.append(""\"""");
			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e);
		}
	}

	/**
	 * Notifies the extensions that the build is ending on the specified file.
	 */
	private void notifyBuildFileEnd(File sourceFile, File outputFile, String relativePath) {
		// call the method for all the extensions
		String extensionName = """";
		try {
			for (BuilderExtension extension : extensions) {
				extensionName = extension.getName();
				logger.setMessageSource(extensionName);
				extension.notifyBuildFileEnd(sourceFile, outputFile, relativePath);
				logger.setMessageSource(null);
			}
		} catch (Exception e) {
			StringBuffer buffer = new StringBuffer(""An exception occured while invoking notifyBuildFileEnd() for the extension \"""");
			buffer.append(extensionName);
			buffer.append(""\"""");
			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e);
		}
	}

	/**
	 * Notifies the extensions that they should configure the preprocessor.
	 */
	private void notifyConfigurePreprocessor(JavaPreprocessor preprocessor) {
		preprocessor.setIncludeIfUnsure(this.includeIfUnsure);
		preprocessor.setNoWarnIncludeIf(this.noWarnIncludeIf);

		// call the method for all the extensions
		String extensionName = """";
		try {
			for (BuilderExtension extension : extensions) {
				extensionName = extension.getName();
				logger.setMessageSource(extensionName);
				extension.notifyConfigurePreprocessor(preprocessor);
				logger.setMessageSource(null);
			}
		} catch (Exception e) {
			StringBuffer buffer = new StringBuffer(""An exception occured while invoking notifyConfigurePreprocessor() for the extension \"""");
			buffer.append(extensionName);
			buffer.append(""\"""");
			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e);
		}
	}

	/**
	 * Handles exceptions thrown while building.
	 */
	private void handleBuildException(Throwable t) {
		if (t instanceof Error) {
			logger.log(""An error occured while building"", Logger.SEVERITY_FATAL, t);
			throw (Error) t;
		} else {
			logger.log(""An exception occured while building"", Logger.SEVERITY_ERROR, t);
		}
	}

	/**
	 * Handles exceptions thrown by the preprocessor.
	 */
	private void handlePreprocessorException(Throwable t, File sourceFile) {
		if (t instanceof Error) {
			logger.log(""An error occured while invoking the preprocessor"", ""preprocessor"", Logger.SEVERITY_FATAL, sourceFile, t);
			throw (Error) t;
		} else {
			logger.log(""An exception occured while invoking the preprocessor"", ""preprocessor"", Logger.SEVERITY_ERROR, sourceFile, t);
		}
	}

	/**
	 * Handles warnings generated by the preprocessor.
	 */
	private void handlePreprocessorWarnings(JavaPreprocessor jpp, File sourceFile) {
		if (jpp.hasWarnings()) {
			for (PreprocessorWarning warning : jpp.getWarnings()) {
				int severity = warning.shouldFail() ? Logger.SEVERITY_ERROR : Logger.SEVERITY_WARNING;
				/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/
				if (warning.getMessage().startsWith(""No INCLUDE-IF"") && sourceFile.getAbsolutePath().endsWith("".java"") && !includeIfUnsure && !isTestsBootPath) {
					severity = Logger.SEVERITY_ERROR;
				}

				if (warning.getMessage().startsWith(""Ignoring copyright"")) {
					severity = Logger.SEVERITY_INFO;
				}

				logger.log(warning.getMessage(), ""preprocessor"", severity, sourceFile, warning.getLine(), warning.getCharstart(), warning.getCharend());
			}
		}

		if (!noWarnInvalidFlags) {
			for (PreprocessorWarning warning : jpp.getInvalidFlags()) {
				logger.log(warning.getMessage(), ""preprocessor"", Logger.SEVERITY_ERROR, sourceFile, warning.getLine(), warning.getCharstart(), warning.getCharend());
			}
		}
	}

	/**
	 * Determines whether the specified source file should be built.
	 */
	private boolean shouldBuild(File sourceFile, File outputFile, String relativePath) {
		// call the method for all the extensions
		for (BuilderExtension extension : extensions) {
			logger.setMessageSource(extension.getName());
			boolean shouldBuild = extension.shouldBuild(sourceFile, outputFile, relativePath);
			logger.setMessageSource(null);
			if (!shouldBuild) {
				return false;
			}
		}

		return true;
	}

	/*[PR 118220] Incremental builder is not called when file is deleted in base library*/
	/**
	 * Returns the deleted Files
	 */
	/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */
	private List<String> getDeletedFiles(File sourceDir) {
		// call the method for all the extensions
		for (BuilderExtension extension : extensions) {
			logger.setMessageSource(extension.getName());
			List<String> elements = extension.getDeleteFiles(sourceDir);
			logger.setMessageSource(null);
			if (elements != null) {
				return elements;
			}
		}

		return null;
	}

	/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */
	private List<String> getBuildResources(File sourceDir) {
		// call the method for all the extensions
		for (BuilderExtension extension : extensions) {
			logger.setMessageSource(extension.getName());
			List<String> elements = extension.getBuildResources(sourceDir);
			logger.setMessageSource(null);
			if (elements != null) {
				return elements;
			}
		}
		return null;
	}

	/**
	 * Creates a new PreprocessorFactory object.
	 */
	private PreprocessorFactory newPreprocessorFactory() {
		PreprocessorFactory factory = new PreprocessorFactory();
		/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/
		factory.setFlags(this.configObject.getFlagsAsArray());
		factory.setRequiredIncludeFlags(this.configObject.getRequiredIncludeFlagSet());
		return factory;
	}

	/**
	 * Recursively searches the given root directory to find all files. The file
	 * paths are returned, relative to the root directory.
	 */
	private List<String> getFiles(File rootDirectory) {
		List<String> fileList = new ArrayList<>();
		File[] files = rootDirectory.listFiles();

		if (files == null) {
			StringBuffer msg = new StringBuffer(""Error reading the source directory \"""");
			msg.append(rootDirectory.getAbsolutePath());
			msg.append(""\"" - No Files copied"");
			getLogger().log(msg.toString(), 2);
			verdict = false;
		} else {
			getFiles(files, """", fileList);
		}

		return fileList;
	}

	/**
	 * This is a helper function to getFiles(File);
	 */
	private static void getFiles(File[] files, String relativePath, List<String> fileList) {
		for (File file : files) {
			if (file.isFile()) {
				fileList.add(relativePath + file.getName());
			} else {
				String childRelativePath = relativePath + file.getName() + File.separator;
				getFiles(file.listFiles(), childRelativePath, fileList);
			}
		}
	}

	private void computeBuildFiles() {
		if (sourceDir.exists()) {
			List<String> allFiles = getFiles(sourceDir);
			List<String> buildFiles = new ArrayList<>(allFiles.size());
			for (int j = 0; j < allFiles.size(); j++) {
				String currentFile = allFiles.get(j).toString();
				if (shouldBuild(sourceDir, outputDir, currentFile)) {
					buildFiles.add(currentFile);
				}
			}

			String[] buildFilesArray = buildFiles.toArray(new String[buildFiles.size()]);
			buildFilesBySourceDir.put(sourceDir, buildFilesArray);
			buildFileCount += buildFilesArray.length;
			/*[PR 118220] Incremental builder is not called when file is deleted in base library*/
			/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */
			List<String> deleteFiles = getDeletedFiles(sourceDir);
			if (deleteFiles != null && deleteFiles.size() != 0) {
				deleteFileCount = deleteFiles.size();
				deleteFilesBySourceDir.put(sourceDir, deleteFiles);
			}

			List<String> buildResources = getBuildResources(sourceDir);
			if (buildResources != null && buildResources.size() != 0) {
				buildResourcesCount = buildResources.size();
				buildResourcesBySourceDir.put(sourceDir, buildResources);
			}
		} else {
			logger.log(""Error: Source directory does not exist: "" + sourceDir.getAbsolutePath(), Logger.SEVERITY_ERROR, new NullPointerException());
			sourceDir = null;
		}
	}

	/**
	 * Returns the number of files preprocessed.
	 *
	 * @return		the number of files preprocessed
	 */
	public int getBuildFileCount() {
		return buildFileCount;
	}

}
",blob
42,"  public SocketServer(NetworkConfig config, SSLConfig sslConfig, MetricRegistry registry, ArrayList<Port> portList) {
    this.host = config.hostName;
    this.port = config.port;
    this.numProcessorThreads = config.numIoThreads;
    this.maxQueuedRequests = config.queuedMaxRequests;
    this.sendBufferSize = config.socketSendBufferBytes;
    this.recvBufferSize = config.socketReceiveBufferBytes;
    this.maxRequestSize = config.socketRequestMaxBytes;
    processors = new ArrayList<Processor>(numProcessorThreads);
    requestResponseChannel = new SocketRequestResponseChannel(numProcessorThreads, maxQueuedRequests);
    metrics = new ServerNetworkMetrics(requestResponseChannel, registry, processors);
    this.acceptors = new ArrayList<Acceptor>();
    this.ports = new HashMap<PortType, Port>();
    this.validatePorts(portList);
    this.initializeSSLFactory(sslConfig);
  }
",feature envy
1307,"public class SimpleMessage implements Message {

    private final MessageId messageId;
    private final String subType;
    private final String mediaType;
    private final SharedInputStream content;
    private final int bodyStartOctet;
    private final Date internalDate;
    private final long size;
    private final Long textualLineCount;
    private final List<Property> properties;
    private final List<MessageAttachment> attachments;

    public SimpleMessage(MessageId messageId, SharedInputStream content, long size, Date internalDate, String subType, String mediaType, int bodyStartOctet, Long textualLineCount, List<Property> properties, List<MessageAttachment> attachments) {
        this.messageId = messageId;
        this.subType = subType;
        this.mediaType = mediaType;
        this.content = content;
        this.bodyStartOctet = bodyStartOctet;
        this.internalDate = internalDate;
        this.size = size;
        this.textualLineCount = textualLineCount;
        this.properties = properties;
        this.attachments = attachments;
    }

    public SimpleMessage(MessageId messageId, SharedInputStream content, long size, Date internalDate, String subType, String mediaType, int bodyStartOctet, Long textualLineCount, List<Property> properties) {
        this(messageId, content, size, internalDate, subType, mediaType, bodyStartOctet, textualLineCount, properties, ImmutableList.<MessageAttachment>of());
    }

    @Override
    public MessageId getMessageId() {
        return messageId;
    }

    @Override
    public Date getInternalDate() {
        return internalDate;
    }

    @Override
    public InputStream getBodyContent() throws IOException {
        return content.newStream(bodyStartOctet, -1);
    }

    @Override
    public String getMediaType() {
        return mediaType;
    }

    @Override
    public String getSubType() {
        return subType;
    }

    @Override
    public long getBodyOctets() {
        return getFullContentOctets() - bodyStartOctet;
    }

    @Override
    public long getHeaderOctets() {
        return bodyStartOctet;
    }

    @Override
    public long getFullContentOctets() {
        return size;
    }

    @Override
    public Long getTextualLineCount() {
        return textualLineCount;
    }

    @Override
    public InputStream getHeaderContent() throws IOException {
        long headerEnd = bodyStartOctet;
        if (headerEnd < 0) {
            headerEnd = 0;
        }
        return content.newStream(0, headerEnd);
    }

    @Override
    public InputStream getFullContent() throws IOException {
        return content.newStream(0, -1);
    }

    @Override
    public List<Property> getProperties() {
        return properties;
    }

    @Override
    public List<MessageAttachment> getAttachments() {
        return attachments;
    }
}
",data class
719,"public class Builder {

	public static boolean isForced(Map<?, ?> options) {
		return Boolean.TRUE.equals(options.get(""force""));
	}

	private Properties options = new Properties();
	private BuilderExtension[] extensions = new BuilderExtension[0];

	private Logger logger = new NullLogger();
	private ConfigurationRegistry registry;
	private ConfigObject configObject = null;
	private boolean isIncremental = false;
	private boolean enabledMetadata = false;

	private File sourceDir = null;

	/**
	 * The value is a String[] containing the relative paths of all of the build
	 * files for a given sourceDir.
	 */
	private final Map<File, String[]> buildFilesBySourceDir = new HashMap<>();
	/*[PR 118220] Incremental builder is not called when file is deleted in base library*/
	private final Map<File, List<String>> deleteFilesBySourceDir = new HashMap<>();
	private final Map<File, List<String>> buildResourcesBySourceDir = new HashMap<>();

	private int buildFileCount = 0;
	private int deleteFileCount = 0;
	private int builtFileCount = 0;
	private int buildResourcesCount = 0;
	private File outputDir = null;
	private boolean verdict = false;
	private boolean includeIfUnsure = false;
	/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/
	private boolean isTestsBootPath = false;
	private boolean noWarnIncludeIf = false;
	private boolean noWarnInvalidFlags = false;
	private boolean multipleSources = false;
	private boolean updateAllCopyrights = false;

	/**
	 * J9 JCL Preprocessor builder constructor.  Initializes the needed extensions.
	 */
	public Builder() {
		addExtension(new ExternalMessagesExtension());
		addExtension(new MacroExtension());
		addExtension(new JxeRulesExtension());
		addExtension(new EclipseMetadataExtension());
		addExtension(new JitAttributesExtension());
		addExtension(new TagExtension());
	}

	/**
	 * Sets the preprocess options.
	 *
	 * @param 		options		the preprocess options
	 */
	public void setOptions(Properties options) {
		if (options != null) {
			this.options.putAll(options);
		}
		this.options = options;
	}

	/**
	 * Returns the preprocess options for this builder.
	 *
	 * @return		the preprocess options
	 */
	public Properties getOptions() {
		return this.options;
	}

	/**
	 * Adds an extension to the builder.
	 *
	 * @param 		extension	the extension to add
	 */
	public void addExtension(BuilderExtension extension) {
		if (extension == null) {
			throw new NullPointerException();
		}

		BuilderExtension[] newExtensions = new BuilderExtension[extensions.length + 1];
		if (extensions.length > 0) {
			System.arraycopy(extensions, 0, newExtensions, 0, extensions.length);
		}
		newExtensions[newExtensions.length - 1] = extension;
		this.extensions = newExtensions;

		extension.setBuilder(this);
	}

	/**
	 * Returns the builder extensions/
	 *
	 * @return		the builder extensions
	 */
	public BuilderExtension[] getExtensions() {
		return extensions;
	}

	/**
	 * Returns the logger associated with this builder.
	 *
	 * @return		the logger
	 */
	public Logger getLogger() {
		return logger;
	}

	/**
	 * Sets this builder's logger.
	 *
	 * @param 		logger		the new logger
	 */
	public void setLogger(Logger logger) {
		this.logger = logger;
	}

	/**
	 * Sets whether the build is incremental or not.
	 *
	 * @param 		isIncremental	<code>true</code> if the build is incremental, <code>false</code> otherwise
	 */
	public void setIncremental(boolean isIncremental) {
		this.isIncremental = isIncremental;
	}

	/**
	 * Returns wheter or not this builder will only do an incremental build.
	 *
	 * @return		<code>true</code> if the build is incremental, <code>false</code> otherwise
	 */
	public boolean isIncremental() {
		return this.isIncremental;
	}

	/**
	 * Sets whether or not preprocessor metadata will be generated.
	 *
	 * @param 		enabledMetadata		<code>true</code> if metadata is to be generated,
	 * 									<code>false</code> otherwise
	 */
	public void setMetadata(boolean enabledMetadata) {
		this.enabledMetadata = enabledMetadata;
	}

	/**
	 * Returns whether or not preprocessor metadata is enabled.
	 *
	 * @return		<code>true</code> if metadata will be written, <code>false</code> otherwise
	 */
	public boolean isMetadataEnabled() {
		return this.enabledMetadata;
	}

	/**
	 * Sets whether or not the preprocessor should include files that do not
	 * have a INCLUDE-IF tag.
	 *
	 * @param 		include		<code>true</code> if files with no INCLUDE-IF should
	 * 							be included, <code>false</code> otherwise
	 */
	public void setIncludeIfUnsure(boolean include) {
		this.includeIfUnsure = include;
	}

	/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/
	/**
	 * Sets whether or not the preprocessor is running to generate Tests Boot Path project
	 *
	 * @param 	isTestsBoot		<code>true</code> if preprocessor is running to generate Tests Boot Path project,
	 * 							<code>false</code> otherwise
	 */
	public void setIsTestsBoot(boolean isTestsBoot) {
		this.isTestsBootPath = isTestsBoot;
	}

	/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/
	/**
	 * Sets whether or not the preprocessor should give warningsor errors about the files that do not
	 * have a INCLUDE-IF tag.
	 *
	 * @param 		warning		<code>true</code> if files with no INCLUDE-IF should
	 * 							be marked with warning or error, <code>false</code> otherwise
	 */
	public void setNoWarnIncludeIf(boolean warning) {
		this.noWarnIncludeIf = warning;
	}

	/**
	 * Sets the configuration to preprocess.
	 *
	 * @param 		config		the configuration to preprocess
	 */
	public void setConfiguration(ConfigObject config) {
		if (config.isSet()) {
			System.err.println(""Warning: Builder is using "" + config + "", a set, not a configuration."");
		}
		this.configObject = config;
		this.registry = config.getRegistry();
		this.outputDir = config.getOutputDir();
	}

	/**
	 * Returns this builder's output directory.
	 *
	 * @return		the output directory
	 */
	public File getOutputDir() {
		return this.outputDir;
	}

	/**
	 * Sets this builder's output directory.
	 *
	 * @param 		outputDir	the new output directory
	 */
	public void setOutputDir(File outputDir) {
		if (outputDir == null) {
			throw new NullPointerException();
		}
		this.outputDir = outputDir;
	}

	/**
	 * Returns this builder's configuration source directories.
	 *
	 * @return		the config's source dirs
	 */
	public File getSourceDir() {
		return this.sourceDir;
	}

	/**
	 * Sets the proprocess job's source directory.
	 *
	 * @param 		sourceDir	the source directory to preprocess
	 */
	public void setSourceDir(File sourceDir) {
		if (sourceDir == null) {
			throw new NullPointerException();
		} else {
			this.sourceDir = sourceDir;
		}
	}

	/**
	 * Set builder aware of other sources (to be used by the ExternalMessagesExtension).
	 *
	 * @param 		multipleSources		<code>true</code> if there are other sources, <code>false</code> otherwise
	 */
	public void setMultipleSources(boolean multipleSources) {
		this.multipleSources = multipleSources;
	}

	/**
	 * Returns whether or not the configuration that setup this builder has multiple sources.
	 *
	 * @return		<code>true</code> if there are other sources, <code>false</code> otherwise
	 */
	public boolean hasMultipleSources() {
		return multipleSources;
	}

	/**
	 * Performs the build.
	 */
	public boolean build() {
		//create output dir even if no file is gonna be included in preprocess
		getOutputDir().mkdirs();
		if (validateOptions()) {
			computeBuildFiles();
			notifyBuildBegin();

			PreprocessorFactory factory = newPreprocessorFactory();
			boolean force = isForced(this.options);

			//Ignore folders that do not exist (warning thrown in computeBuildFiles()
			if (sourceDir != null) {
				File metadataDir = new File(outputDir.getParentFile(), ""jppmd"");
				String[] buildFiles = buildFilesBySourceDir.get(sourceDir);
				getLogger().log(""\nPreprocessing "" + sourceDir.getAbsolutePath(), 1);
				builtFileCount = 0;

				for (String buildFile : buildFiles) {
					File sourceFile = new File(sourceDir, buildFile);
					File outputFile = new File(outputDir, buildFile);
					File metadataFile = new File(metadataDir, buildFile + "".jppmd"");

					notifyBuildFileBegin(sourceFile, outputFile, buildFile);

					try (OutputStream metadataOutput = new PhantomOutputStream(metadataFile);
						 OutputStream output = new PhantomOutputStream(outputFile, force)) {

						// configure the preprocessor and let extensions do the same
						JavaPreprocessor jpp;

						if (enabledMetadata) {
							jpp = factory.newPreprocessor(metadataOutput, sourceFile, output, outputFile);
						} else {
							jpp = factory.newPreprocessor(sourceFile, output);
						}

						Calendar cal = new GregorianCalendar();
						if (!updateAllCopyrights) {
							cal.setTime(new Date(sourceFile.lastModified()));
						}
						jpp.setCopyrightYear(cal.get(Calendar.YEAR));
						jpp.addValidFlags(registry.getValidFlags());
						/*[PR 120411] Use a javadoc tag instead of TestBootpath preprocessor tag*/
						jpp.setTestBootPath(isTestsBootPath);
						notifyConfigurePreprocessor(jpp);

						// preprocess
						boolean included = false;
						try {
							included = jpp.preprocess();
							if (included) {
								builtFileCount++;
							}
							handlePreprocessorWarnings(jpp, sourceFile);
						} catch (Throwable t) {
							handlePreprocessorException(t, sourceFile);
						}

						if (!included && outputFile.exists()) {
							outputFile.delete();
						}

						if (!included && metadataFile.exists()) {
							metadataFile.delete();
						}
					} catch (Throwable t) {
						getLogger().log(""Exception occured in file "" + sourceFile.getAbsolutePath() + "", preprocess failed."", 3, t);
						handleBuildException(t);
					} finally {
						notifyBuildFileEnd(sourceFile, outputFile, buildFile);
					}
				}

				logger.log(builtFileCount + "" of "" + buildFileCount + "" file(s) included in preprocess"", 1);

				/*[PR 118220] Incremental builder is not called when file is deleted in base library*/
				List<String> deleteFiles = deleteFilesBySourceDir.get(sourceDir);
				if (deleteFiles != null && deleteFiles.size() != 0) {
					int deletedFilesCount = 0;
					for (String file : deleteFiles) {
						File deleteFile = new File(outputDir, file);
						if (deleteFile.exists()) {
							deletedFilesCount++;
							deleteFile.delete();
						}
					}
					getLogger().log(deletedFilesCount + "" of "" + deleteFileCount
							+ "" file(s) deleted in preprocess from "" + outputDir.getAbsolutePath(), 1);
				}
			}
			/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */
			List<String> buildResources = buildResourcesBySourceDir.get(sourceDir);
			if (buildResources != null && buildResources.size() != 0) {
				int copiedResourcesCount = 0;
				int deletedResorucesCount = 0;
				String outputpath;
				if (isTestsBootPath) {
					outputpath = configObject.getBootTestsOutputPath();
				} else {
					outputpath = configObject.getTestsOutputPath();
				}
				for (String file : buildResources) {
					File resource_out = new File(outputpath, file);
					File resource_src = new File(sourceDir, file);
					if (resource_src.exists()) {
						copyResource(resource_src, resource_out);
						copiedResourcesCount++;
					} else {
						resource_out.delete();
						deletedResorucesCount++;
					}
				}

				getLogger().log(""Total Build Resource Count : "" + buildResourcesCount, 1);
				getLogger().log(""  - "" + copiedResourcesCount + "" resource"" + (copiedResourcesCount > 1 ? ""s are "" : "" is "") + ""copied to "" + outputpath, 1);
				getLogger().log(""  - "" + deletedResorucesCount + "" resource"" + (deletedResorucesCount > 1 ? ""s are "" : "" is "") + ""deleted from "" + outputpath, 1);
			}

			notifyBuildEnd();
		}

		if (logger.getErrorCount() == 0) {
			if (verdict) {
				getLogger().log(""PREPROCESS WAS SUCCESSFUL"", 1);
			}
			return true;
		} else {
			if (verdict) {
				getLogger().log(""PREPROCESS WAS NOT SUCCESSFUL"", 1);
			}
			return false;
		}
	}

	/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */
	public static void copyResource(File source, File destination) {
		destination.delete();

		try {
			SimpleCopy.copyFile(source, destination);
		} catch (IOException e) {
			System.err.println(""ERROR - Could not copy the file to destination"");
			System.err.println(""   Source: "" + source.toString());
			System.err.println(""   Destination: "" + destination.toString());
			e.printStackTrace();
		}
	}

	/**
	 * Validates the build options.
	 */
	private boolean validateOptions() {
		boolean isValid = true;

		if (configObject == null) {
			configObject = registry.getConfiguration(options.getProperty(""config""));
		}
		this.options.putAll(configObject.getOptions());

		// check for the verdict option
		if (options.containsKey(""verdict"")) {
			this.verdict = true;
		}

		if (options.containsKey(""includeifunsure"")) {
			setIncludeIfUnsure(true);
		}
		if (options.containsKey(""nowarnincludeif"")) {
			setNoWarnIncludeIf(true);
		}

		if (options.containsKey(""nowarninvalidflags"")) {
			this.noWarnInvalidFlags = true;
		}

		if (options.containsKey(""updateallcopyrights"")) {
			this.updateAllCopyrights = true;
		}

		// call the method for all the extensions
		String extensionName = """";
		try {
			for (BuilderExtension extension : extensions) {
				extensionName = extension.getName();
				extension.validateOptions(this.options);
			}
		} catch (BuilderConfigurationException e) {
			logger.log(""A configuration exception occured"", Logger.SEVERITY_FATAL, e);
			isValid = false;
		} catch (Exception e) {
			StringBuffer buffer = new StringBuffer(""An exception occured while invoking validateOptions() for the extension \"""");
			buffer.append(extensionName);
			buffer.append(""\"""");
			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e);
		}
		return isValid;
	}

	/**
	 * Notifies the extensions that the build is beginning.
	 */
	private void notifyBuildBegin() {
		// call the method for all the extensions
		String extensionName = """";
		try {
			for (BuilderExtension extension : extensions) {
				extensionName = extension.getName();
				logger.setMessageSource(extensionName);
				extension.notifyBuildBegin();
				logger.setMessageSource(null);
			}
		} catch (Exception e) {
			StringBuffer buffer = new StringBuffer(""An exception occured while invoking notifyBuildBegin() for the extension \"""");
			buffer.append(extensionName);
			buffer.append(""\"""");
			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e);
		}
	}

	/**
	 * Notifies the extensions that the build is ending.
	 */
	private void notifyBuildEnd() {
		// call the method for all the extensions
		String extensionName = """";
		try {
			for (BuilderExtension extension : extensions) {
				extensionName = extension.getName();
				logger.setMessageSource(extensionName);
				extension.notifyBuildEnd();
				logger.setMessageSource(null);
			}
		} catch (Exception e) {
			StringBuffer buffer = new StringBuffer(""An exception occured while invoking notifyBuildEnd() for the extension \"""");
			buffer.append(extensionName);
			buffer.append(""\"""");
			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e);
		}
	}

	/**
	 * Notifies the extensions that the build is beginning on the specified
	 * file.
	 */
	private void notifyBuildFileBegin(File sourceFile, File outputFile, String relativePath) {
		// call the method for all the extensions
		String extensionName = """";
		try {
			for (BuilderExtension extension : extensions) {
				extensionName = extension.getName();
				logger.setMessageSource(extensionName);
				extension.notifyBuildFileBegin(sourceFile, outputFile, relativePath);
				logger.setMessageSource(null);
			}
		} catch (Exception e) {
			StringBuffer buffer = new StringBuffer(""An exception occured while invoking notifyBuildFileBegin() for the extension \"""");
			buffer.append(extensionName);
			buffer.append(""\"""");
			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e);
		}
	}

	/**
	 * Notifies the extensions that the build is ending on the specified file.
	 */
	private void notifyBuildFileEnd(File sourceFile, File outputFile, String relativePath) {
		// call the method for all the extensions
		String extensionName = """";
		try {
			for (BuilderExtension extension : extensions) {
				extensionName = extension.getName();
				logger.setMessageSource(extensionName);
				extension.notifyBuildFileEnd(sourceFile, outputFile, relativePath);
				logger.setMessageSource(null);
			}
		} catch (Exception e) {
			StringBuffer buffer = new StringBuffer(""An exception occured while invoking notifyBuildFileEnd() for the extension \"""");
			buffer.append(extensionName);
			buffer.append(""\"""");
			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e);
		}
	}

	/**
	 * Notifies the extensions that they should configure the preprocessor.
	 */
	private void notifyConfigurePreprocessor(JavaPreprocessor preprocessor) {
		preprocessor.setIncludeIfUnsure(this.includeIfUnsure);
		preprocessor.setNoWarnIncludeIf(this.noWarnIncludeIf);

		// call the method for all the extensions
		String extensionName = """";
		try {
			for (BuilderExtension extension : extensions) {
				extensionName = extension.getName();
				logger.setMessageSource(extensionName);
				extension.notifyConfigurePreprocessor(preprocessor);
				logger.setMessageSource(null);
			}
		} catch (Exception e) {
			StringBuffer buffer = new StringBuffer(""An exception occured while invoking notifyConfigurePreprocessor() for the extension \"""");
			buffer.append(extensionName);
			buffer.append(""\"""");
			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e);
		}
	}

	/**
	 * Handles exceptions thrown while building.
	 */
	private void handleBuildException(Throwable t) {
		if (t instanceof Error) {
			logger.log(""An error occured while building"", Logger.SEVERITY_FATAL, t);
			throw (Error) t;
		} else {
			logger.log(""An exception occured while building"", Logger.SEVERITY_ERROR, t);
		}
	}

	/**
	 * Handles exceptions thrown by the preprocessor.
	 */
	private void handlePreprocessorException(Throwable t, File sourceFile) {
		if (t instanceof Error) {
			logger.log(""An error occured while invoking the preprocessor"", ""preprocessor"", Logger.SEVERITY_FATAL, sourceFile, t);
			throw (Error) t;
		} else {
			logger.log(""An exception occured while invoking the preprocessor"", ""preprocessor"", Logger.SEVERITY_ERROR, sourceFile, t);
		}
	}

	/**
	 * Handles warnings generated by the preprocessor.
	 */
	private void handlePreprocessorWarnings(JavaPreprocessor jpp, File sourceFile) {
		if (jpp.hasWarnings()) {
			for (PreprocessorWarning warning : jpp.getWarnings()) {
				int severity = warning.shouldFail() ? Logger.SEVERITY_ERROR : Logger.SEVERITY_WARNING;
				/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/
				if (warning.getMessage().startsWith(""No INCLUDE-IF"") && sourceFile.getAbsolutePath().endsWith("".java"") && !includeIfUnsure && !isTestsBootPath) {
					severity = Logger.SEVERITY_ERROR;
				}

				if (warning.getMessage().startsWith(""Ignoring copyright"")) {
					severity = Logger.SEVERITY_INFO;
				}

				logger.log(warning.getMessage(), ""preprocessor"", severity, sourceFile, warning.getLine(), warning.getCharstart(), warning.getCharend());
			}
		}

		if (!noWarnInvalidFlags) {
			for (PreprocessorWarning warning : jpp.getInvalidFlags()) {
				logger.log(warning.getMessage(), ""preprocessor"", Logger.SEVERITY_ERROR, sourceFile, warning.getLine(), warning.getCharstart(), warning.getCharend());
			}
		}
	}

	/**
	 * Determines whether the specified source file should be built.
	 */
	private boolean shouldBuild(File sourceFile, File outputFile, String relativePath) {
		// call the method for all the extensions
		for (BuilderExtension extension : extensions) {
			logger.setMessageSource(extension.getName());
			boolean shouldBuild = extension.shouldBuild(sourceFile, outputFile, relativePath);
			logger.setMessageSource(null);
			if (!shouldBuild) {
				return false;
			}
		}

		return true;
	}

	/*[PR 118220] Incremental builder is not called when file is deleted in base library*/
	/**
	 * Returns the deleted Files
	 */
	/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */
	private List<String> getDeletedFiles(File sourceDir) {
		// call the method for all the extensions
		for (BuilderExtension extension : extensions) {
			logger.setMessageSource(extension.getName());
			List<String> elements = extension.getDeleteFiles(sourceDir);
			logger.setMessageSource(null);
			if (elements != null) {
				return elements;
			}
		}

		return null;
	}

	/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */
	private List<String> getBuildResources(File sourceDir) {
		// call the method for all the extensions
		for (BuilderExtension extension : extensions) {
			logger.setMessageSource(extension.getName());
			List<String> elements = extension.getBuildResources(sourceDir);
			logger.setMessageSource(null);
			if (elements != null) {
				return elements;
			}
		}
		return null;
	}

	/**
	 * Creates a new PreprocessorFactory object.
	 */
	private PreprocessorFactory newPreprocessorFactory() {
		PreprocessorFactory factory = new PreprocessorFactory();
		/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/
		factory.setFlags(this.configObject.getFlagsAsArray());
		factory.setRequiredIncludeFlags(this.configObject.getRequiredIncludeFlagSet());
		return factory;
	}

	/**
	 * Recursively searches the given root directory to find all files. The file
	 * paths are returned, relative to the root directory.
	 */
	private List<String> getFiles(File rootDirectory) {
		List<String> fileList = new ArrayList<>();
		File[] files = rootDirectory.listFiles();

		if (files == null) {
			StringBuffer msg = new StringBuffer(""Error reading the source directory \"""");
			msg.append(rootDirectory.getAbsolutePath());
			msg.append(""\"" - No Files copied"");
			getLogger().log(msg.toString(), 2);
			verdict = false;
		} else {
			getFiles(files, """", fileList);
		}

		return fileList;
	}

	/**
	 * This is a helper function to getFiles(File);
	 */
	private static void getFiles(File[] files, String relativePath, List<String> fileList) {
		for (File file : files) {
			if (file.isFile()) {
				fileList.add(relativePath + file.getName());
			} else {
				String childRelativePath = relativePath + file.getName() + File.separator;
				getFiles(file.listFiles(), childRelativePath, fileList);
			}
		}
	}

	private void computeBuildFiles() {
		if (sourceDir.exists()) {
			List<String> allFiles = getFiles(sourceDir);
			List<String> buildFiles = new ArrayList<>(allFiles.size());
			for (int j = 0; j < allFiles.size(); j++) {
				String currentFile = allFiles.get(j).toString();
				if (shouldBuild(sourceDir, outputDir, currentFile)) {
					buildFiles.add(currentFile);
				}
			}

			String[] buildFilesArray = buildFiles.toArray(new String[buildFiles.size()]);
			buildFilesBySourceDir.put(sourceDir, buildFilesArray);
			buildFileCount += buildFilesArray.length;
			/*[PR 118220] Incremental builder is not called when file is deleted in base library*/
			/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */
			List<String> deleteFiles = getDeletedFiles(sourceDir);
			if (deleteFiles != null && deleteFiles.size() != 0) {
				deleteFileCount = deleteFiles.size();
				deleteFilesBySourceDir.put(sourceDir, deleteFiles);
			}

			List<String> buildResources = getBuildResources(sourceDir);
			if (buildResources != null && buildResources.size() != 0) {
				buildResourcesCount = buildResources.size();
				buildResourcesBySourceDir.put(sourceDir, buildResources);
			}
		} else {
			logger.log(""Error: Source directory does not exist: "" + sourceDir.getAbsolutePath(), Logger.SEVERITY_ERROR, new NullPointerException());
			sourceDir = null;
		}
	}

	/**
	 * Returns the number of files preprocessed.
	 *
	 * @return		the number of files preprocessed
	 */
	public int getBuildFileCount() {
		return buildFileCount;
	}

}
",blob
875,"        static class Event {

            final Type type;
            final TruffleFile file;
            final IOException ioe;
            final BasicFileAttributes attrs;

            Event(Type type, TruffleFile file, BasicFileAttributes attrs) {
                this.type = type;
                this.file = file;
                this.attrs = attrs;
                this.ioe = null;
            }

            Event(Type type, TruffleFile file, IOException ioe) {
                this.type = type;
                this.file = file;
                this.attrs = null;
                this.ioe = ioe;
            }

            enum Type {
                PRE_VISIT_DIRECTORY,
                VISIT,
                POST_VISIT_DIRECTORY
            }
        }
",data class
144,"public class GangliaServer implements MonitorService {
  /*
   * The Ganglia protocol specific stuff: the xdr_* methods
   * and the sendToGanglia* methods have been shamelessly ripped off
   * from Hadoop. All hail the yellow elephant!
   */

  private static final Logger logger =
          LoggerFactory.getLogger(GangliaServer.class);
  public static final int BUFFER_SIZE = 1500; // as per libgmond.c
  protected byte[] buffer = new byte[BUFFER_SIZE];
  protected int offset;
  private final List<SocketAddress> addresses = new ArrayList<SocketAddress>();
  private DatagramSocket socket = null;
  private ScheduledExecutorService service =
          Executors.newSingleThreadScheduledExecutor();
  private List<HostInfo> hosts;
  protected final GangliaCollector collectorRunnable;
  private int pollFrequency = 60;
  public static final String DEFAULT_UNITS = """";
  public static final int DEFAULT_TMAX = 60;
  public static final int DEFAULT_DMAX = 0;
  public static final int DEFAULT_SLOPE = 3;
  public static final String GANGLIA_DOUBLE_TYPE = ""double"";
  private volatile boolean isGanglia3 = false;
  private String hostname;
  public final String CONF_POLL_FREQUENCY = ""pollFrequency"";
  public final int DEFAULT_POLL_FREQUENCY = 60;
  public final String CONF_HOSTS = ""hosts"";
  public final String CONF_ISGANGLIA3 = ""isGanglia3"";
  private static final String GANGLIA_CONTEXT = ""flume."";

  public GangliaServer() throws FlumeException {
    collectorRunnable = new GangliaCollector();
  }

  /**
   * Puts a string into the buffer by first writing the size of the string as an
   * int, followed by the bytes of the string, padded if necessary to a multiple
   * of 4.
   *
   * @param s the string to be written to buffer at offset location
   */
  protected void xdr_string(String s) {
    byte[] bytes = s.getBytes();
    int len = bytes.length;
    xdr_int(len);
    System.arraycopy(bytes, 0, buffer, offset, len);
    offset += len;
    pad();
  }

  /**
   * Pads the buffer with zero bytes up to the nearest multiple of 4.
   */
  private void pad() {
    int newOffset = ((offset + 3) / 4) * 4;
    while (offset < newOffset) {
      buffer[offset++] = 0;
    }
  }

  /**
   * Puts an integer into the buffer as 4 bytes, big-endian.
   */
  protected void xdr_int(int i) {
    buffer[offset++] = (byte) ((i >> 24) & 0xff);
    buffer[offset++] = (byte) ((i >> 16) & 0xff);
    buffer[offset++] = (byte) ((i >> 8) & 0xff);
    buffer[offset++] = (byte) (i & 0xff);
  }

  public synchronized void sendToGangliaNodes() {
    DatagramPacket packet;
    for (SocketAddress addr : addresses) {
      try {
        packet = new DatagramPacket(buffer, offset, addr);
        socket.send(packet);
      } catch (Exception ex) {
        logger.warn(""Could not send metrics to metrics server: ""
                + addr.toString(), ex);
      }
    }
    offset = 0;
  }

  /**
   * Start this server, causing it to poll JMX at the configured frequency.
   */
  @Override
  public void start() {
    try {
      socket = new DatagramSocket();
      hostname = InetAddress.getLocalHost().getHostName();
    } catch (SocketException ex) {
      logger.error(""Could not create socket for metrics collection."");
      throw new FlumeException(
              ""Could not create socket for metrics collection."", ex);
    } catch (Exception ex2) {
      logger.warn(""Unknown error occured"", ex2);
    }
    for (HostInfo host : hosts) {
      addresses.add(new InetSocketAddress(
              host.getHostName(), host.getPortNumber()));
    }
    collectorRunnable.server = this;
    if (service.isShutdown() || service.isTerminated()) {
      service = Executors.newSingleThreadScheduledExecutor();
    }
    service.scheduleWithFixedDelay(collectorRunnable, 0,
            pollFrequency, TimeUnit.SECONDS);
  }

  /**
   * Stop this server.
   */
  @Override
  public void stop() {
    service.shutdown();

    while (!service.isTerminated()) {
      try {
        logger.warn(""Waiting for ganglia service to stop"");
        service.awaitTermination(500, TimeUnit.MILLISECONDS);
      } catch (InterruptedException ex) {
        logger.warn(""Interrupted while waiting""
                + "" for ganglia monitor to shutdown"", ex);
        service.shutdownNow();
      }
    }
    addresses.clear();
  }

  /**
   *
   * @param pollFrequency Seconds between consecutive JMX polls.
   */
  public void setPollFrequency(int pollFrequency) {
    this.pollFrequency = pollFrequency;
  }

  /**
   *
   * @return Seconds between consecutive JMX polls
   */
  public int getPollFrequency() {
    return pollFrequency;
  }

  /**
   *
   * @param isGanglia3 When true, ganglia 3 messages will be sent, else Ganglia
   * 3.1 formatted messages are sent.
   */
  public void setIsGanglia3(boolean isGanglia3) {
    this.isGanglia3 = isGanglia3;
  }

  /**
   *
   * @return True if the server is currently sending ganglia 3 formatted msgs.
   * False if the server returns Ganglia 3.1
   */
  public boolean isGanglia3() {
    return this.isGanglia3;
  }

  protected void createGangliaMessage(String name, String value) {
    logger.debug(""Sending ganglia3 formatted message.""
            + name + "": "" + value);
    name = hostname + ""."" + name;
    xdr_int(0);
    String type = ""string"";
    try {
      Float.parseFloat(value);
      type = ""float"";
    } catch (NumberFormatException ex) {
      // The param is a string, and so leave the type as is.
    }
    xdr_string(type); // metric type
    xdr_string(name);
    xdr_string(value);
    xdr_string(DEFAULT_UNITS);
    xdr_int(DEFAULT_SLOPE);
    xdr_int(DEFAULT_TMAX);
    xdr_int(DEFAULT_DMAX);
  }

  protected void createGangliaMessage31(String name, String value) {
    logger.debug(""Sending ganglia 3.1 formatted message: ""
            + name + "": "" + value);
    xdr_int(128); // metric_id = metadata_msg
    xdr_string(hostname); // hostname
    xdr_string(name); // metric name
    xdr_int(0); // spoof = False
    String type = ""string"";
    try {
      Float.parseFloat(value);
      type = ""float"";
    } catch (NumberFormatException ex) {
      // The param is a string, and so leave the type as is.
    }
    xdr_string(type); // metric type
    xdr_string(name); // metric name
    xdr_string(DEFAULT_UNITS); // units
    xdr_int(DEFAULT_SLOPE); // slope
    xdr_int(DEFAULT_TMAX); // tmax, the maximum time between metrics
    xdr_int(DEFAULT_DMAX); // dmax, the maximum data value
    xdr_int(1); /*Num of the entries in extra_value field for Ganglia 3.1.x*/
    xdr_string(""GROUP""); /*Group attribute*/
    xdr_string(""flume""); /*Group value*/

    this.sendToGangliaNodes();

    // Now we send out a message with the actual value.
    // Technically, we only need to send out the metadata message once for
    // each metric, but I don't want to have to record which metrics we did and
    // did not send.
    xdr_int(133); // we are sending a string value
    xdr_string(hostname); // hostName
    xdr_string(name); // metric name
    xdr_int(0); // spoof = False
    xdr_string(""%s""); // format field
    xdr_string(value); // metric value
  }

  @Override
  public void configure(Context context) {
    this.pollFrequency = context.getInteger(this.CONF_POLL_FREQUENCY, 60);
    String localHosts = context.getString(this.CONF_HOSTS);
    if (localHosts == null || localHosts.isEmpty()) {
      throw new ConfigurationException(""Hosts list cannot be empty."");
    }
    this.hosts = this.getHostsFromString(localHosts);
    this.isGanglia3 = context.getBoolean(this.CONF_ISGANGLIA3, false);
  }

  private List<HostInfo> getHostsFromString(String hosts)
          throws FlumeException {
    List<HostInfo> hostInfoList = new ArrayList<HostInfo>();
    String[] hostsAndPorts = hosts.split("","");
    int i = 0;
    for (String host : hostsAndPorts) {
      String[] hostAndPort = host.split("":"");
      if (hostAndPort.length < 2) {
        logger.warn(""Invalid ganglia host: "", host);
        continue;
      }
      try {
        hostInfoList.add(new HostInfo(""ganglia_host-"" + String.valueOf(i),
                hostAndPort[0], Integer.parseInt(hostAndPort[1])));
      } catch (Exception e) {
        logger.warn(""Invalid ganglia host: "" + host, e);
        continue;
      }
    }
    if (hostInfoList.isEmpty()) {
      throw new FlumeException(""No valid ganglia hosts defined!"");
    }
    return hostInfoList;
  }

  /**
   * Worker which polls JMX for all mbeans with
   * {@link javax.management.ObjectName} within the flume namespace:
   * org.apache.flume. All attributes of such beans are sent to the all hosts
   * specified by the server that owns it's instance.
   *
   */
  protected class GangliaCollector implements Runnable {

    private GangliaServer server;

    @Override
    public void run() {
      try {
        Map<String, Map<String, String>> metricsMap =
                JMXPollUtil.getAllMBeans();
        for (String component : metricsMap.keySet()) {
          Map<String, String> attributeMap = metricsMap.get(component);
          for (String attribute : attributeMap.keySet()) {
            if (isGanglia3) {
              server.createGangliaMessage(GANGLIA_CONTEXT + component + "".""
                      + attribute,
                      attributeMap.get(attribute));
            } else {
              server.createGangliaMessage31(GANGLIA_CONTEXT + component + "".""
                      + attribute,
                      attributeMap.get(attribute));
            }
            server.sendToGangliaNodes();
          }
        }
      } catch (Throwable t) {
        logger.error(""Unexpected error"", t);
      }
    }
  }
}
",blob
1303,"  public static class MetaColumn implements Named {
    public final String tableCat;
    public final String tableSchem;
    public final String tableName;
    public final String columnName;
    public final int dataType;
    public final String typeName;
    public final Integer columnSize;
    public final Integer bufferLength = null;
    public final Integer decimalDigits;
    public final Integer numPrecRadix;
    public final int nullable;
    public final String remarks = null;
    public final String columnDef = null;
    public final Integer sqlDataType = null;
    public final Integer sqlDatetimeSub = null;
    public final Integer charOctetLength;
    public final int ordinalPosition;
    @NotNull
    public final String isNullable;
    public final String scopeCatalog = null;
    public final String scopeSchema = null;
    public final String scopeTable = null;
    public final Short sourceDataType = null;
    @NotNull
    public final String isAutoincrement = """";
    @NotNull
    public final String isGeneratedcolumn = """";

    public MetaColumn(
        String tableCat,
        String tableSchem,
        String tableName,
        String columnName,
        int dataType,
        String typeName,
        Integer columnSize,
        Integer decimalDigits,
        Integer numPrecRadix,
        int nullable,
        Integer charOctetLength,
        int ordinalPosition,
        String isNullable) {
      this.tableCat = tableCat;
      this.tableSchem = tableSchem;
      this.tableName = tableName;
      this.columnName = columnName;
      this.dataType = dataType;
      this.typeName = typeName;
      this.columnSize = columnSize;
      this.decimalDigits = decimalDigits;
      this.numPrecRadix = numPrecRadix;
      this.nullable = nullable;
      this.charOctetLength = charOctetLength;
      this.ordinalPosition = ordinalPosition;
      this.isNullable = isNullable;
    }

    @Override
    public String getName() {
      return columnName;
    }
  }
",data class
927,"@SuppressWarnings(""serial"")
public class GitHubUser implements Serializable {

	private final long id;

	private final String url;

	private final String login;

	private final String avatarUrl;

	private final String gravatarId;

	private String name;

	private String email;

    public GitHubUser(long id, String url, String login, String avatarUrl, String gravatarId) {
        this.id = id;
        this.url = url;
        this.login = login;
        this.avatarUrl = avatarUrl;
        this.gravatarId = gravatarId;
    }

    public Long getId() { return id; }
	
	public String getUrl() { return url; }

	public String getLogin() { return login; }

	public String getAvatarUrl() { return avatarUrl; }

	public String getGravatarId() { return gravatarId; }
	
	public String getName() { return name; }
	
	public void setName(String name) { this.name = name; }
	
	public String getEmail() { return email; }
	
	public void setEmail(String email) { this.email = email; }
}
",data class
844,"	public static class Undertow {

		/**
		 * Maximum size of the HTTP post content. When the value is -1, the default, the
		 * size is unlimited.
		 */
		private DataSize maxHttpPostSize = DataSize.ofBytes(-1);

		/**
		 * Size of each buffer. The default is derived from the maximum amount of memory
		 * that is available to the JVM.
		 */
		private DataSize bufferSize;

		/**
		 * Number of I/O threads to create for the worker. The default is derived from the
		 * number of available processors.
		 */
		private Integer ioThreads;

		/**
		 * Number of worker threads. The default is 8 times the number of I/O threads.
		 */
		private Integer workerThreads;

		/**
		 * Whether to allocate buffers outside the Java heap. The default is derived from
		 * the maximum amount of memory that is available to the JVM.
		 */
		private Boolean directBuffers;

		/**
		 * Whether servlet filters should be initialized on startup.
		 */
		private boolean eagerFilterInit = true;

		private final Accesslog accesslog = new Accesslog();

		public DataSize getMaxHttpPostSize() {
			return this.maxHttpPostSize;
		}

		public void setMaxHttpPostSize(DataSize maxHttpPostSize) {
			this.maxHttpPostSize = maxHttpPostSize;
		}

		public DataSize getBufferSize() {
			return this.bufferSize;
		}

		public void setBufferSize(DataSize bufferSize) {
			this.bufferSize = bufferSize;
		}

		public Integer getIoThreads() {
			return this.ioThreads;
		}

		public void setIoThreads(Integer ioThreads) {
			this.ioThreads = ioThreads;
		}

		public Integer getWorkerThreads() {
			return this.workerThreads;
		}

		public void setWorkerThreads(Integer workerThreads) {
			this.workerThreads = workerThreads;
		}

		public Boolean getDirectBuffers() {
			return this.directBuffers;
		}

		public void setDirectBuffers(Boolean directBuffers) {
			this.directBuffers = directBuffers;
		}

		public boolean isEagerFilterInit() {
			return this.eagerFilterInit;
		}

		public void setEagerFilterInit(boolean eagerFilterInit) {
			this.eagerFilterInit = eagerFilterInit;
		}

		public Accesslog getAccesslog() {
			return this.accesslog;
		}

		/**
		 * Undertow access log properties.
		 */
		public static class Accesslog {

			/**
			 * Whether to enable the access log.
			 */
			private boolean enabled = false;

			/**
			 * Format pattern for access logs.
			 */
			private String pattern = ""common"";

			/**
			 * Log file name prefix.
			 */
			protected String prefix = ""access_log."";

			/**
			 * Log file name suffix.
			 */
			private String suffix = ""log"";

			/**
			 * Undertow access log directory.
			 */
			private File dir = new File(""logs"");

			/**
			 * Whether to enable access log rotation.
			 */
			private boolean rotate = true;

			public boolean isEnabled() {
				return this.enabled;
			}

			public void setEnabled(boolean enabled) {
				this.enabled = enabled;
			}

			public String getPattern() {
				return this.pattern;
			}

			public void setPattern(String pattern) {
				this.pattern = pattern;
			}

			public String getPrefix() {
				return this.prefix;
			}

			public void setPrefix(String prefix) {
				this.prefix = prefix;
			}

			public String getSuffix() {
				return this.suffix;
			}

			public void setSuffix(String suffix) {
				this.suffix = suffix;
			}

			public File getDir() {
				return this.dir;
			}

			public void setDir(File dir) {
				this.dir = dir;
			}

			public boolean isRotate() {
				return this.rotate;
			}

			public void setRotate(boolean rotate) {
				this.rotate = rotate;
			}

		}

	}
",blob
1155,"    public void validateDepositDetailForUpdate(final JsonElement element, final FromJsonHelper fromApiJsonHelper,
            final DataValidatorBuilder baseDataValidator) {
        if (fromApiJsonHelper.parameterExists(nameParamName, element)) {
            final String name = fromApiJsonHelper.extractStringNamed(nameParamName, element);
            baseDataValidator.reset().parameter(nameParamName).value(name).notBlank().notExceedingLengthOf(100);
        }

        if (fromApiJsonHelper.parameterExists(shortNameParamName, element)) {
            final String shortName = fromApiJsonHelper.extractStringNamed(shortNameParamName, element);
            baseDataValidator.reset().parameter(shortNameParamName).value(shortName).notBlank().notExceedingLengthOf(4);
        }

        if (fromApiJsonHelper.parameterExists(descriptionParamName, element)) {
            final String description = fromApiJsonHelper.extractStringNamed(descriptionParamName, element);
            baseDataValidator.reset().parameter(descriptionParamName).value(description).notBlank().notExceedingLengthOf(500);
        }

        if (fromApiJsonHelper.parameterExists(currencyCodeParamName, element)) {
            final String currencyCode = fromApiJsonHelper.extractStringNamed(currencyCodeParamName, element);
            baseDataValidator.reset().parameter(currencyCodeParamName).value(currencyCode).notBlank();
        }

        if (fromApiJsonHelper.parameterExists(digitsAfterDecimalParamName, element)) {
            final Integer digitsAfterDecimal = fromApiJsonHelper.extractIntegerSansLocaleNamed(digitsAfterDecimalParamName, element);
            baseDataValidator.reset().parameter(digitsAfterDecimalParamName).value(digitsAfterDecimal).notNull().inMinMaxRange(0, 6);
        }

        if (fromApiJsonHelper.parameterExists(inMultiplesOfParamName, element)) {
            final Integer inMultiplesOf = fromApiJsonHelper.extractIntegerNamed(inMultiplesOfParamName, element, Locale.getDefault());
            baseDataValidator.reset().parameter(inMultiplesOfParamName).value(inMultiplesOf).ignoreIfNull().integerZeroOrGreater();
        }

        if (fromApiJsonHelper.parameterExists(nominalAnnualInterestRateParamName, element)) {
            final BigDecimal interestRate = fromApiJsonHelper.extractBigDecimalWithLocaleNamed(nominalAnnualInterestRateParamName, element);
            baseDataValidator.reset().parameter(nominalAnnualInterestRateParamName).value(interestRate).notNull().zeroOrPositiveAmount();
        }

        if (fromApiJsonHelper.parameterExists(interestCompoundingPeriodTypeParamName, element)) {
            final Integer interestCompoundingPeriodType = fromApiJsonHelper.extractIntegerSansLocaleNamed(
                    interestCompoundingPeriodTypeParamName, element);
            baseDataValidator.reset().parameter(interestCompoundingPeriodTypeParamName).value(interestCompoundingPeriodType).notNull()
                    .isOneOfTheseValues(SavingsCompoundingInterestPeriodType.integerValues());
        }

        if (fromApiJsonHelper.parameterExists(interestCalculationTypeParamName, element)) {
            final Integer interestCalculationType = fromApiJsonHelper.extractIntegerSansLocaleNamed(interestCalculationTypeParamName,
                    element);
            baseDataValidator.reset().parameter(interestCalculationTypeParamName).value(interestCalculationType).notNull()
                    .inMinMaxRange(1, 2);
        }

        if (fromApiJsonHelper.parameterExists(interestCalculationDaysInYearTypeParamName, element)) {
            final Integer interestCalculationDaysInYearType = fromApiJsonHelper.extractIntegerSansLocaleNamed(
                    interestCalculationDaysInYearTypeParamName, element);
            baseDataValidator.reset().parameter(interestCalculationDaysInYearTypeParamName).value(interestCalculationDaysInYearType)
                    .notNull().isOneOfTheseValues(360, 365);
        }

        if (fromApiJsonHelper.parameterExists(minRequiredOpeningBalanceParamName, element)) {
            final BigDecimal minOpeningBalance = fromApiJsonHelper.extractBigDecimalWithLocaleNamed(minRequiredOpeningBalanceParamName,
                    element);
            baseDataValidator.reset().parameter(minRequiredOpeningBalanceParamName).value(minOpeningBalance).ignoreIfNull()
                    .zeroOrPositiveAmount();
        }

        if (fromApiJsonHelper.parameterExists(lockinPeriodFrequencyParamName, element)) {
            final Integer lockinPeriodFrequency = fromApiJsonHelper.extractIntegerWithLocaleNamed(lockinPeriodFrequencyParamName, element);
            baseDataValidator.reset().parameter(lockinPeriodFrequencyParamName).value(lockinPeriodFrequency).ignoreIfNull()
                    .integerZeroOrGreater();
        }

        if (fromApiJsonHelper.parameterExists(lockinPeriodFrequencyTypeParamName, element)) {
            final Integer lockinPeriodFrequencyType = fromApiJsonHelper.extractIntegerSansLocaleNamed(lockinPeriodFrequencyTypeParamName,
                    element);
            baseDataValidator.reset().parameter(lockinPeriodFrequencyTypeParamName).value(lockinPeriodFrequencyType).inMinMaxRange(0, 3);
        }

        if (fromApiJsonHelper.parameterExists(withdrawalFeeForTransfersParamName, element)) {
            final Boolean isWithdrawalFeeApplicableForTransfers = fromApiJsonHelper.extractBooleanNamed(withdrawalFeeForTransfersParamName,
                    element);
            baseDataValidator.reset().parameter(withdrawalFeeForTransfersParamName).value(isWithdrawalFeeApplicableForTransfers)
                    .ignoreIfNull().validateForBooleanValue();
        }

        if (fromApiJsonHelper.parameterExists(feeAmountParamName, element)) {
            final BigDecimal annualFeeAmount = fromApiJsonHelper.extractBigDecimalWithLocaleNamed(feeAmountParamName, element);
            baseDataValidator.reset().parameter(feeAmountParamName).value(annualFeeAmount).ignoreIfNull().zeroOrPositiveAmount();
        }

        if (fromApiJsonHelper.parameterExists(feeOnMonthDayParamName, element)) {
            final MonthDay monthDayOfAnnualFee = fromApiJsonHelper.extractMonthDayNamed(feeOnMonthDayParamName, element);
            baseDataValidator.reset().parameter(feeOnMonthDayParamName).value(monthDayOfAnnualFee).ignoreIfNull();
        }

        if (this.fromApiJsonHelper.parameterExists(minBalanceForInterestCalculationParamName, element)) {
            final BigDecimal minBalanceForInterestCalculation = this.fromApiJsonHelper.extractBigDecimalWithLocaleNamed(
                    minBalanceForInterestCalculationParamName, element);
            baseDataValidator.reset().parameter(minBalanceForInterestCalculationParamName).value(minBalanceForInterestCalculation)
                    .ignoreIfNull().zeroOrPositiveAmount();
        }

        final Long savingsControlAccountId = fromApiJsonHelper.extractLongNamed(
                SAVINGS_PRODUCT_ACCOUNTING_PARAMS.SAVINGS_CONTROL.getValue(), element);
        baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.SAVINGS_CONTROL.getValue()).value(savingsControlAccountId)
                .ignoreIfNull().integerGreaterThanZero();

        final Long savingsReferenceAccountId = fromApiJsonHelper.extractLongNamed(
                SAVINGS_PRODUCT_ACCOUNTING_PARAMS.SAVINGS_REFERENCE.getValue(), element);
        baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.SAVINGS_REFERENCE.getValue())
                .value(savingsReferenceAccountId).ignoreIfNull().integerGreaterThanZero();

        final Long transfersInSuspenseAccountId = fromApiJsonHelper.extractLongNamed(
                SAVINGS_PRODUCT_ACCOUNTING_PARAMS.TRANSFERS_SUSPENSE.getValue(), element);
        baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.TRANSFERS_SUSPENSE.getValue())
                .value(transfersInSuspenseAccountId).ignoreIfNull().integerGreaterThanZero();

        final Long interestOnSavingsAccountId = fromApiJsonHelper.extractLongNamed(
                SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INTEREST_ON_SAVINGS.getValue(), element);
        baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INTEREST_ON_SAVINGS.getValue())
                .value(interestOnSavingsAccountId).ignoreIfNull().integerGreaterThanZero();

        final Long incomeFromFeeId = fromApiJsonHelper.extractLongNamed(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INCOME_FROM_FEES.getValue(),
                element);
        baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INCOME_FROM_FEES.getValue()).value(incomeFromFeeId)
                .ignoreIfNull().integerGreaterThanZero();

        final Long incomeFromPenaltyId = fromApiJsonHelper.extractLongNamed(
                SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INCOME_FROM_PENALTIES.getValue(), element);
        baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INCOME_FROM_PENALTIES.getValue()).value(incomeFromPenaltyId)
                .ignoreIfNull().integerGreaterThanZero();

        validatePaymentChannelFundSourceMappings(fromApiJsonHelper, baseDataValidator, element);
        validateChargeToIncomeAccountMappings(fromApiJsonHelper, baseDataValidator, element);
        validateTaxWithHoldingParams(baseDataValidator, element, false);
    }
",feature envy
1484,"    public void read(org.apache.thrift.protocol.TProtocol iprot, WMTrigger struct) throws org.apache.thrift.TException {
      org.apache.thrift.protocol.TField schemeField;
      iprot.readStructBegin();
      while (true)
      {
        schemeField = iprot.readFieldBegin();
        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (schemeField.id) {
          case 1: // RESOURCE_PLAN_NAME
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.resourcePlanName = iprot.readString();
              struct.setResourcePlanNameIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 2: // TRIGGER_NAME
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.triggerName = iprot.readString();
              struct.setTriggerNameIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 3: // TRIGGER_EXPRESSION
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.triggerExpression = iprot.readString();
              struct.setTriggerExpressionIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 4: // ACTION_EXPRESSION
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.actionExpression = iprot.readString();
              struct.setActionExpressionIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 5: // IS_IN_UNMANAGED
            if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
              struct.isInUnmanaged = iprot.readBool();
              struct.setIsInUnmanagedIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 6: // NS
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.ns = iprot.readString();
              struct.setNsIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();
      struct.validate();
    }
",long method
1029,"public class WireAdminImpl implements WireAdmin, ServiceListener {

	private BundleContext m_bundleContext;

    // A Map containing a service reference associated to a producer and a List
    // of wire objects	
    private Map m_consumers = new HashMap(); /* ServiceReferences, List */
	
    private Map m_producers = new HashMap(); /* ServiceReferences, List */

	private List m_wires; // List containing the wires

	//private BindingController wireAdminListenersBindingController;

    // Filter corresponding to a consumer service
	private Filter m_consumerFilter;
    
    //  Filter corresponding to a producer service
	private Filter m_producerFilter;

    // EventManager
    private EventManager m_eventManager;

	private static int m_wireCount = 0;
    
    private AsyncMethodCaller m_asyncMethodCaller = new AsyncMethodCaller();        //m_eventDispatcher.stop();
    
    private static PrintStream m_traceout = null;
    
    private static PrintStream m_errorout = System.err;

	/**
     * Constructor with package visibility
     * 
	 * @param bundleContext the bundle context
	 */
	WireAdminImpl(BundleContext bundleContext) 
    {
		m_bundleContext = bundleContext;
        
        if(bundleContext.getProperty(""fr.imag.adele.wireadmin.trace"") != null)
        {
            String value = bundleContext.getProperty(""fr.imag.adele.wireadmin.trace"");
            if(value.equals(""true""))
            {
                m_traceout = System.out;
            }
        }
        // Create the event manager (the event manager will start its own thread)       
        m_eventManager = new EventManager(m_bundleContext);
        
		try 
        {
			m_producerFilter = m_bundleContext.createFilter(
					""(objectClass=org.osgi.service.wireadmin.Producer)"");
			m_consumerFilter = m_bundleContext.createFilter(
					""(objectClass=org.osgi.service.wireadmin.Consumer)"");
		} 
        catch (InvalidSyntaxException e) 
        {
			// never thrown since LDAP expressions are correct
		}

        // Recover persistent wires
        getPersistentWires();

        // Activate thread that does asynchronous calls to
        // the producersConnected and consummersConnected methods
        new Thread(m_asyncMethodCaller).start();

        // Gets all producers and consumers that are present at the
        // moment the wire admin is created
        try 
        {
            // Registration for events must be done first, as some service
            // can be registered during initialization
            
            m_bundleContext.addServiceListener(this,""(|""+m_producerFilter.toString()+m_consumerFilter.toString()+"")"");

            // Replacement for the two following lines which work under OSCAR, 
            // but not work under IBM's SMF
            //m_bundleContext.addServiceListener(this,m_consumerFilter.toString());
            //m_bundleContext.addServiceListener(this,m_producerFilter.toString());
            
            // Get all producers
            ServiceReference[] producerRefs = m_bundleContext.getServiceReferences(Producer.class.getName(),null);
            
            if(producerRefs!=null)
            {
                // lock the producers Map to avoid concurrent modifications due
                // to service events
                synchronized(m_producers)
                {
                    for(int i=0;i<producerRefs.length;i++)
                    {
                        ServiceReference currentRef=(ServiceReference)producerRefs[i];
                        
                        Iterator wireIt = m_wires.iterator();
                        while(wireIt.hasNext())
                        {
                            WireImpl currentWire = (WireImpl) wireIt.next();
                            if(currentWire.getProducerPID().equals(currentRef.getProperty(Constants.SERVICE_PID)))
                            {
                                currentWire.bindProducer(currentRef);
                            }
                        }
                        m_producers.put(currentRef,new ArrayList());
                    }
                }
            }

            // Get all the consumers
            ServiceReference[] consumerRefs = m_bundleContext.getServiceReferences(Consumer.class.getName(),null);
            
            if(consumerRefs!=null)
            {
                for(int i=0;i<consumerRefs.length;i++)
                {
                    // lock the consumers to avoid concurrent modifications due
                    // to service events
                    synchronized(m_consumers)
                    {
                        ServiceReference currentRef=(ServiceReference)consumerRefs[i];

                        Iterator wireIt = m_wires.iterator();
                        while(wireIt.hasNext())
                        {
                            WireImpl currentWire = (WireImpl) wireIt.next();
                            if(currentWire.getConsumerPID().equals(currentRef.getProperty(Constants.SERVICE_PID)))
                            {
                                currentWire.bindConsumer(currentRef);
                            }
                        }
                        m_consumers.put(currentRef,new ArrayList());
                    }
                }
            }
        } 
        catch (InvalidSyntaxException e) 
        {
            trace(e);
        }

        // Iterate over all the wires, when a wire is connected
        // add it to the list of wires associated to a particular
        // producer or consumer
        synchronized(m_wires)
        {
            Iterator wireIterator = m_wires.iterator();
            while(wireIterator.hasNext())
            {
                WireImpl currentWire = (WireImpl) wireIterator.next();
                if(currentWire.isConnected())
                {                
                    // p. 327 ""If both Producer and consumer services are registered
                    // with the framework, they are connected by the WireAdmin service""
                    List wires = (List) m_producers.get(currentWire.getProducerServiceRef());
                    wires.add(currentWire);
                    m_asyncMethodCaller.consumersConnected(currentWire.getProducer(),(Wire[])wires.toArray(new Wire[wires.size()]));
                    
                    wires = (List) m_consumers.get(currentWire.getConsumerServiceRef());
                    wires.add(currentWire);
                    m_asyncMethodCaller.producersConnected(currentWire.getConsumer(),(Wire[])wires.toArray(new Wire[wires.size()]));
                }            
            }
        }       
	}
    
    /**
     * Pass the service reference to the event dispatcher
     * 
     * @param ref the service reference
     */
    void setServiceReference(ServiceReference ref)
    {
        m_eventManager.setServiceReference(ref);
    }

	/**
	 * Create a new <tt>Wire</tt> object that connects a Producer
	 * service to a Consumer service.
	 *
	 * The Producer service and Consumer service do not
	 * have to be registered when the <tt>Wire</tt> object is created.
	 *
	 * <p>The <tt>Wire</tt> configuration data must be persistently stored.
	 * All <tt>Wire</tt> connections are reestablished when the
	 * <tt>WireAdmin</tt> service is registered.
	 * A <tt>Wire</tt> can be permanently removed by using the
	 * {@link #deleteWire} method.
	 *
	 * <p>The <tt>Wire</tt> object's properties must have case
	 * insensitive <tt>String</tt> objects as keys (like the Framework).
	 * However, the case of the key must be preserved.
	 * The type of the value of the property must be one of the following:
	 *
	 * <pre>
	 * type        = basetype
	 *  | vector | arrays
	 *
	 * basetype = String | Integer | Long
	 *  | Float | Double | Byte
	 *  | Short | Character
	 *  | Boolean
	 *
	 * primitive   = long | int | short
	 *  | char | byte | double | float
	 *
	 * arrays   = primitive '[]' | basetype '[]'
	 *
	 * vector   = Vector of basetype
	 * </pre>
	 *
	 * <p>The <tt>WireAdmin</tt> service must automatically add the
	 * following <tt>Wire</tt> properties:
	 * <ul>
	 * <li>
	 * {@link WireConstants#WIREADMIN_PID} set to the value of the <tt>Wire</tt> object's
	 * persistent identity (PID). This value is generated by the
	 * Wire Admin service when a <tt>Wire</tt> object is created.
	 * </li>
	 * <li>
	 * {@link WireConstants#WIREADMIN_PRODUCER_PID} set to the value of
	 * Producer service's PID.
	 * </li>
	 * <li>
	 * {@link WireConstants#WIREADMIN_CONSUMER_PID} set to the value of
	 * Consumer service's PID.
	 * </li>
	 * </ul>
	 * If the <tt>properties</tt> argument
	 * already contains any of these keys, then the supplied values
	 * are replaced with the values assigned by the Wire Admin service.
	 *
	 * <p>The Wire Admin service must broadcast a <tt>WireAdminEvent</tt> of type
	 * {@link WireAdminEvent#WIRE_CREATED}
	 * after the new <tt>Wire</tt> object becomes available from {@link #getWires}.
	 *
	 * @param producerPID The <tt>service.pid</tt> of the Producer service
	 * to be connected to the <tt>Wire</tt> object.
	 * @param consumerPID The <tt>service.pid</tt> of the Consumer service
	 * to be connected to the <tt>Wire</tt> object.
	 * @param properties The <tt>Wire</tt> object's properties. This argument may be <tt>null</tt>
	 * if the caller does not wish to define any <tt>Wire</tt> object's properties.
	 * @return The <tt>Wire</tt> object for this connection.
	 * @throws java.lang.IllegalArgumentException If
	 * <tt>properties</tt> contains case variants of the same key name.
	 */
	public Wire createWire(String producerPID, String consumerPID, Dictionary props) 
    {
        ServiceReference producerServiceRef = null;
        ServiceReference consumerServiceRef = null;

        Dictionary properties;
        
        if(props == null)
        {
        	properties = new Hashtable();
        }
        else
        {
        	//Clone the dictionary
        	properties = cloneProperties(props);
        }

        // Addition of mandatory properties
        properties.put(WireConstants.WIREADMIN_CONSUMER_PID, consumerPID);
        properties.put(WireConstants.WIREADMIN_PRODUCER_PID, producerPID);
        properties.put(WireConstants.WIREADMIN_PID, generateWirePID());

        // p.327 ""Wire objects can be created when the producer or consumer
        // service is not registered
        WireImpl wire = new WireImpl(producerPID, consumerPID, properties);

        // Initialize the wire
        wire.initialize(m_bundleContext,m_eventManager);

        // Add the wire to the list 
        synchronized(m_wires)
        {
            m_wires.add(wire);            
        }

        // p. 357 ""The Wire Admin service must broadcast a WireAdminEvent of 
        // type WireAdminEvent.WIRE_CREATED  after the new Wire object becomes 
        // available from getWires(java.lang.String).""
        m_eventManager.fireEvent(WireAdminEvent.WIRE_CREATED,wire);

        synchronized (m_producers)
        {
            Iterator producerIterator = m_producers.keySet().iterator();
            while(producerIterator.hasNext())
            {
                producerServiceRef = (ServiceReference) producerIterator.next();
                if (producerServiceRef.getProperty(Constants.SERVICE_PID).equals(producerPID)) 
                {
                    wire.bindProducer(producerServiceRef);                    
                    break;
                }
            }
        }        
        
        synchronized (m_consumers)
        {
            Iterator consumerIterator = m_consumers.keySet().iterator();
            while(consumerIterator.hasNext())
            {
                consumerServiceRef = (ServiceReference) consumerIterator.next();
                if (consumerServiceRef.getProperty(Constants.SERVICE_PID).equals(consumerPID)) 
                {
                    wire.bindConsumer(consumerServiceRef);
                    break;
                }
                
            }
        }
        
        
        // p.327 If both Producer and Consumer services are registered, they are 
        // connected by the wire admin service. 
        if(wire.isConnected())
        {
            List wires = (List) m_producers.get(producerServiceRef);
            wires.add(wire);
            m_asyncMethodCaller.consumersConnected(wire.getProducer(),(Wire[])wires.toArray(new Wire[wires.size()]));

            wires = (List) m_consumers.get(consumerServiceRef);
            wires.add(wire);
            m_asyncMethodCaller.producersConnected(wire.getConsumer(),(Wire[])wires.toArray(new Wire[wires.size()]));
        }

        // Newly created wires are immediately persisted to avoid information
        // loss in case of crashes.  (spec not clear about this)        
        persistWires();

        return wire;
    }

	/**
	 * Delete a <tt>Wire</tt> object.
	 *
	 * <p>The <tt>Wire</tt> object representing a connection between
	 * a Producer service and a Consumer service must be
	 * removed.
	 * The persistently stored configuration data for the <tt>Wire</tt> object
	 * must destroyed. The <tt>Wire</tt> object's method {@link Wire#isValid} will return <tt>false</tt>
	 * after it is deleted.
	 *
	 * <p>The Wire Admin service must broadcast a <tt>WireAdminEvent</tt> of type
	 * {@link WireAdminEvent#WIRE_DELETED}
	 * after the <tt>Wire</tt> object becomes invalid.
	 *
	 * @param wire The <tt>Wire</tt> object which is to be deleted.
	 */
	public void deleteWire(Wire wire) 
    {
        if(m_wires.contains(wire))
        {
            WireImpl wireImpl = (WireImpl) wire;
            m_wires.remove(wire);
            if(wireImpl.isConnected())
            {
                List wires = (List) m_producers.get(wireImpl.getProducerServiceRef());
                wires.remove(wireImpl);
                m_asyncMethodCaller.consumersConnected(wireImpl.getProducer(),(Wire[])wires.toArray(new Wire[wires.size()]));

                wires = (List) m_consumers.get(wireImpl.getConsumerServiceRef());
                wires.remove(wireImpl);
                m_asyncMethodCaller.producersConnected(wireImpl.getConsumer(),(Wire[])wires.toArray(new Wire[wires.size()]));
            }
            
            wireImpl.invalidate();

            // fire an event
            m_eventManager.fireEvent(WireAdminEvent.WIRE_DELETED,wireImpl);
            
            // Persist state to avoid losses in case of crashes (spec not clear about this).        
            persistWires();
        }
        else
        {
            traceln(""WireAdminImpl: Cannot delete a wire that is not managed by this service"");
        }

	}

	/**
	 * Update the properties of a <tt>Wire</tt> object.
	 *
	 * The persistently stored configuration data for the <tt>Wire</tt> object
	 * is updated with the new properties and then the Consumer and Producer
	 * services will be called at the respective {@link Consumer#producersConnected}
	 * and {@link Producer#consumersConnected} methods.
	 *
	 * <p>The Wire Admin service must broadcast a <tt>WireAdminEvent</tt> of type
	 * {@link WireAdminEvent#WIRE_UPDATED}
	 * after the updated properties are available from the <tt>Wire</tt> object.
	 *
	 * @param wire The <tt>Wire</tt> object which is to be updated.
	 * @param properties The new <tt>Wire</tt> object's properties or <tt>null</tt> if no properties are required.
	 */
	public void updateWire(Wire wire, Dictionary props) 
    {
        if(m_wires.contains(wire) == false)
        {
            traceln(""WireAdminImpl: Cannot update a wire that is not managed by this service"");
            return;
        }
        
        // Clone the dictionary
        Dictionary properties = cloneProperties(props);

        // Put again the mandatory properties, in case they are not set
        properties.put(WireConstants.WIREADMIN_CONSUMER_PID,wire.getProperties().get(WireConstants.WIREADMIN_CONSUMER_PID));
        properties.put(WireConstants.WIREADMIN_PRODUCER_PID,wire.getProperties().get(WireConstants.WIREADMIN_PRODUCER_PID));
        properties.put(WireConstants.WIREADMIN_PID,wire.getProperties().get(WireConstants.WIREADMIN_PID));
        
        WireImpl wireImpl = (WireImpl) wire;
        
        wireImpl.updateProperties(properties);
        
        // Call methods on Consumer and Producer
        if(wireImpl.isConnected())
        {
            List wires = (List) m_producers.get(wireImpl.getProducerServiceRef());
            m_asyncMethodCaller.consumersConnected(wireImpl.getProducer(),(Wire[])wires.toArray(new Wire[wires.size()]));

            wires = (List) m_consumers.get(wireImpl.getConsumerServiceRef());
            m_asyncMethodCaller.producersConnected(wireImpl.getConsumer(),(Wire[])wires.toArray(new Wire[wires.size()]));
        }

        // fire an event
        m_eventManager.fireEvent(WireAdminEvent.WIRE_UPDATED,wireImpl);
	}

	/**
	 * Return the <tt>Wire</tt> objects that match the given <tt>filter</tt>.
	 *
	 * <p>The list of available <tt>Wire</tt> objects is matched against the
	 * specified <tt>filter</tt>. <tt>Wire</tt> objects which match the
	 * <tt>filter</tt> must be returned. These <tt>Wire</tt> objects are not necessarily
	 * connected. The Wire Admin service should not return
	 * invalid <tt>Wire</tt> objects, but it is possible that a <tt>Wire</tt>
	 * object is deleted after it was placed in the list.
	 *
	 * <p>The filter matches against the <tt>Wire</tt> object's properties including
	 * {@link WireConstants#WIREADMIN_PRODUCER_PID}, {@link WireConstants#WIREADMIN_CONSUMER_PID}
	 * and {@link WireConstants#WIREADMIN_PID}.
	 *
	 * @param filter Filter string to select <tt>Wire</tt> objects
	 * or <tt>null</tt> to select all <tt>Wire</tt> objects.
	 * @return An array of <tt>Wire</tt> objects which match the <tt>filter</tt>
	 * or <tt>null</tt> if no <tt>Wire</tt> objects match the <tt>filter</tt>.
	 * @throws org.osgi.framework.InvalidSyntaxException If the specified <tt>filter</tt>
	 * has an invalid syntax.
	 * @see org.osgi.framework.Filter
	 */
	public Wire[] getWires(String filter) throws InvalidSyntaxException 
    {
		List res = null;
		if (filter == null) 
        {
            return (Wire [])m_wires.toArray(new Wire[m_wires.size()]);
		} 
        else 
        {
			Filter tempFilter = m_bundleContext.createFilter(filter);
			Iterator iter = m_wires.iterator();
			while (iter.hasNext()) 
            {
				WireImpl currentWire = (WireImpl) iter.next();
				if (tempFilter.match(currentWire.getProperties())) 
                {
					if (res == null)
                    {
						res = new ArrayList();
                    }
					res.add(currentWire);
				}
			}
		}
		if (res == null) 
        {
			return null;
		} 
        else 
        {
            return (Wire [])res.toArray(new Wire[res.size()]);
		}
	}

    /**
     * listens Producer and Consumer services changes
     * @see org.osgi.framework.ServiceListener#serviceChanged(org.osgi.framework.ServiceEvent)
     */
    public void serviceChanged(ServiceEvent e) 
    {
		ServiceReference serviceRef = e.getServiceReference();
		// A consumer service changed
		if (m_consumerFilter.match(serviceRef)) 
        {
			switch (e.getType()) 
            {
                case ServiceEvent.REGISTERED :
                    traceln(""consumer registered"");
                    
                    List wires = new ArrayList();

                    synchronized(m_consumers)
                    {
                        m_consumers.put(serviceRef,wires);
                    }
                    synchronized(m_wires)
                    {
                        Iterator wireIt = m_wires.iterator();
                        boolean called = false;
                        // Iterate over all existing wires
                        while(wireIt.hasNext())
                        {
                            WireImpl currentWire = (WireImpl) wireIt.next();

                            if(currentWire.getConsumerPID().equals(serviceRef.getProperty(Constants.SERVICE_PID)))
                            {
                                // This wire is associated to the newly arrived consumer
                                currentWire.bindConsumer(serviceRef);
                                if(currentWire.isConnected())
                                {
                                    // The wire has been connected, both producer and consumer
                                    // must be updated
                                    wires.add(currentWire);
                                    called = true;
                                    m_asyncMethodCaller.producersConnected(currentWire.getConsumer(),(Wire[])wires.toArray(new Wire[wires.size()]));
                                    List producerWires = (List) m_producers.get(currentWire.getProducerServiceRef());
                                    producerWires.add(currentWire);
                                    m_asyncMethodCaller.consumersConnected(currentWire.getProducer(),(Wire[])producerWires.toArray(new Wire[producerWires.size()]));                                    
                                }
                            }
                        }
                        if(!called)
                        {
                            // P. 329 ""If the Consumer service has no Wire objects attached when it
                            // is registered, the WireAdmin service must always call producersConnected(null)
                            m_asyncMethodCaller.producersConnected((Consumer) m_bundleContext.getService(serviceRef),null);
                        }
                    }
                    break;
                case ServiceEvent.UNREGISTERING :
                    traceln(""consumer unregistering"");
                    
                    synchronized(m_consumers)
                    {
                        m_consumers.remove(serviceRef);
                    }
                    synchronized(m_wires)
                    {
                        Iterator wireIt = m_wires.iterator();
                        while(wireIt.hasNext())
                        {
                            WireImpl currentWire = (WireImpl) wireIt.next();
                            if(currentWire.getConsumerPID().equals(serviceRef.getProperty(Constants.SERVICE_PID)))
                            {
                                // p. 328 ""When a Consumer or Producer service is unregistered
                                // from the OSGi framework, the other object in the association
                                // is informed that the Wire object is no longer valid""

                                if(currentWire.isConnected())
                                {
                                    currentWire.unbindConsumer();                               
                                    List producerWires = (List) m_producers.get(currentWire.getProducerServiceRef());
                                    producerWires.remove(currentWire);
                                    m_asyncMethodCaller.consumersConnected(currentWire.getProducer(),(Wire[])producerWires.toArray(new Wire[producerWires.size()]));
                                }
                                else
                                {
                                    currentWire.unbindConsumer();    
                                }
                            }
                        }
                    }
                    break;
                case ServiceEvent.MODIFIED :
                    // TODO Respond to consumer service modification
                    traceln(""consumer service modified"");
                    break;

            }
        }
        // Removed else to manage services which are both producers AND consumers
		if (m_producerFilter.match(serviceRef)) 
        {
            switch (e.getType()) 
            {
                case ServiceEvent.REGISTERED :
                    traceln(""producer registered"");
                    
                    List wires = new ArrayList();

                    synchronized(m_producers)
                    {
                        m_producers.put(serviceRef,wires);
                    }
                    synchronized(m_wires)
                    {
                        Iterator wireIt = m_wires.iterator();
                        boolean called = false;
                        // Iterate over all existing wires
                        while(wireIt.hasNext())
                        {
                            WireImpl currentWire = (WireImpl) wireIt.next();
                            if(currentWire.getProducerPID().equals(serviceRef.getProperty(Constants.SERVICE_PID)))
                            {
                                // This wire is associated to the newly arrived producer
                                currentWire.bindProducer(serviceRef);
                                if(currentWire.isConnected())
                                {
                                    // The wire has been connected, both producer and consumer
                                    // must be updated
                                    wires.add(currentWire);
                                    called = true;
                                    m_asyncMethodCaller.consumersConnected(currentWire.getProducer(),(Wire[])wires.toArray(new Wire[wires.size()]));
                                    List consumerWires = (List) m_consumers.get(currentWire.getConsumerServiceRef());
                                    consumerWires.add(currentWire);
                                    m_asyncMethodCaller.producersConnected(currentWire.getConsumer(),(Wire[])consumerWires.toArray(new Wire[consumerWires.size()]));                                    
                                }
                            }
                        }
                        if(!called)
                        {
                            // P. 329 ""If the Producer service has no Wire objects attached when it
                            // is registered, the WireAdmin service must always call consumersConnected(null)
                            m_asyncMethodCaller.consumersConnected((Producer) m_bundleContext.getService(serviceRef),null);
                        }
                    }
                    break;
                case ServiceEvent.UNREGISTERING :
                    traceln(""Producer unregistering"");
                    
                    synchronized(m_producers)
                    {
                        m_producers.remove(serviceRef);
                    }
                    synchronized(m_wires)
                    {
                        Iterator wireIt = m_wires.iterator();
                        while(wireIt.hasNext())
                        {
                            WireImpl currentWire = (WireImpl) wireIt.next();
                            if(currentWire.getProducerPID().equals(serviceRef.getProperty(Constants.SERVICE_PID)))
                            {
                                // p. 328 ""When a Consumer or Producer service is unregistered
                                // from the OSGi framework, the other object in the association
                                // is informed that the Wire object is no longer valid""

                                if(currentWire.isConnected())
                                {
                                    currentWire.unbindProducer();                               
                                    List consumerWires = (List) m_consumers.get(currentWire.getConsumerServiceRef());
                                    consumerWires.remove(currentWire);
                                    m_asyncMethodCaller.producersConnected(currentWire.getConsumer(),(Wire[])consumerWires.toArray(new Wire[consumerWires.size()]));
                                }
                                else
                                {
                                    currentWire.unbindProducer();    
                                }
                            }
                        }
                    }
                    break;
                case ServiceEvent.MODIFIED :
                    // TODO Respond to producer service modification
                    traceln(""producer service modified"");
                    break;
            }
        }        
    }


	/**
	 * release all references before stop
	 */
	synchronized void releaseAll() 
    {
        Iterator wireIt = m_wires.iterator();
        while(wireIt.hasNext())
        {
            WireImpl currentWire = (WireImpl) wireIt.next();
            currentWire.invalidate();
        }
        
        Iterator producerIt = m_producers.keySet().iterator();        
        while (producerIt.hasNext())
        {
            ServiceReference producerRef = (ServiceReference) producerIt.next();
            ((Producer)m_bundleContext.getService(producerRef)).consumersConnected(null);            
        }
        
        Iterator consumerIt = m_consumers.keySet().iterator();        
        while (consumerIt.hasNext())
        {
            ServiceReference consumerRef = (ServiceReference) consumerIt.next();
            ((Consumer)m_bundleContext.getService(consumerRef)).producersConnected(null);            
        }

        // Stop the thread
        m_asyncMethodCaller.stop();
        
        // Notify the event manager so that it stops its thread
        m_eventManager.stop();
        
        persistWires();

	}

    /**
     * This method generates a PID. The pid is generated from the bundle id,
     * a hash code from the current time and a counter.
     * 
     * @return a wire PID
     */
    private String generateWirePID()
    {
        Date d = new Date();
        String PID=""wire.""+m_bundleContext.getBundle().getBundleId()+d.hashCode()+m_wireCount;
        m_wireCount ++;
        
        // Maybe the counter should go above 9?
        if(m_wireCount>9)
        {
            m_wireCount = 0;
        }
        return PID;
    }
    
    /**
     * Recover persistent wires 
     *
     */
    private void getPersistentWires()
    {
        
        try
        {
            ObjectInputStream ois = new ObjectInputStream(new FileInputStream(m_bundleContext.getDataFile(""wires.ser"")));
            m_wires = (ArrayList) ois.readObject();
            ois.close();
            if(m_wires!=null)
            {
                traceln(""Deserialized ""+m_wires.size()+"" wires"");
                Iterator wireIt = m_wires.iterator();
                while(wireIt.hasNext())
                {
                    WireImpl currentWire = (WireImpl) wireIt.next();
                    currentWire.initialize(m_bundleContext,m_eventManager);     
                }
            }
            else
            {
                traceln(""Couldn't Deserialize wires"");
                m_wires = new ArrayList();
            }
        }
        catch(FileNotFoundException ex)
        {
            // do not show anything as this exception is thrown every
            // time the wire admin service is launched for the first
            // time
            m_wires = new ArrayList();
        }
        catch(Exception ex)
        {
            trace(ex);
            m_wires = new ArrayList();
        }
    }
    
    /**
     * Persist existing wires
     *
     */
    private void persistWires()
    {
        try
        {
            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(m_bundleContext.getDataFile(""wires.ser"")));
            oos.writeObject(m_wires);
            oos.close();
            traceln(""Serialized ""+m_wires.size()+"" wires"");
        }
        catch(Exception ex)
        {
            trace(ex);
        }
    }

    /**
     * print an error 
     * @param message message to error 
     */
    static void error(String message)
    {
        if (m_errorout != null) 
        {
            m_errorout.println(message);
        }
    }

	/**
	 * print a trace 
	 * @param message message to trace
	 */
	static void traceln(String message)
    {
		if (m_traceout != null) 
        {
			trace(message);
			trace(""\n"");
		}
	}

	/**
	 * print a trace 
	 * @param message message to trace
	 */
	static void trace(String message)
    {
		if (m_traceout != null) 
        {
			m_traceout.print(message);
		}
	}
	/**
	 * print a trace 
	 * @param e exception to trace
	 */
	static void trace(Exception e) 
    {
		if (m_traceout != null) 
        {
			e.printStackTrace(m_traceout);
		}
	}

	/**
	 * Clone a dictionary
	 * 
	 * @param dictionary The dictionary to clone
	 * @return a copy of the dicionary
	 */
    private Dictionary cloneProperties(Dictionary dictionary){
        Dictionary properties=new Hashtable();
        
        if (dictionary == null) {
            properties = new Hashtable();
        } else {
            Enumeration enumeration=dictionary.keys();
            while(enumeration.hasMoreElements()){
                Object key=enumeration.nextElement();
                Object value=dictionary.get(key);
                properties.put(key,value);
            }
        }
        
        return properties;
    }
	
    /**
     * This class enables calls to Producer.consumersConnected and Consumer.producersConnected
     * to be done asynchronously
     * 
     * p.333 ""The WireAdmin service can call the consumersConnected or producersConnected
     * methods during the registration of the consumer of producer service""
     *
    **/
    class AsyncMethodCaller implements Runnable
    {
        private boolean m_stop = false;

        private List m_methodCallStack = new ArrayList();

        public void run()
        {
            while (!m_stop)
            {
                Object nextTarget[] = null;

                synchronized (m_methodCallStack)
                {
                    while (m_methodCallStack.size() == 0)
                    {
                        try
                        {
                            m_methodCallStack.wait();
                        } 
                        catch (InterruptedException ex)
                        {
                            // Ignore.
                        }
                    }
                    nextTarget = (Object[]) m_methodCallStack.remove(0);
                }
                
                if(nextTarget[0] instanceof Producer)
                {
                    try
                    {
                        ((Producer)nextTarget[0]).consumersConnected((Wire[])nextTarget[1]);
                    }
                    catch(Exception ex)
                    {
                        trace(ex);
                    }
                }
                // Removed else because nextTarget can be both producer and consumer                
                if(nextTarget[0] instanceof Consumer)
                {
                    try
                    {
                        ((Consumer)nextTarget[0]).producersConnected((Wire[])nextTarget[1]);
                    }
                    catch(Exception ex)
                    {
                        trace(ex);
                    }
                }
            }
        }

        /**
         * Place a call to Consumer.producersConnected on the stack
         * 
         * @param c the consumer
         * @param wires the wires
         */
        public void producersConnected(Consumer c,Wire []wires)
        {
            synchronized (m_methodCallStack)
            {
                m_methodCallStack.add(new Object[]{c,wires});
                m_methodCallStack.notify();
            }
        }

        /**
         * Place a call to Producer.consumersConnected on the stack
         * 
         * @param p the producer
         * @param wires the wires
         */
        public void consumersConnected(Producer p,Wire []wires)
        {
            synchronized (m_methodCallStack)
            {
                m_methodCallStack.add(new Object[]{p,wires});
                m_methodCallStack.notify();
            }
        }

        /**
         * stop the dispatcher
         *
         */
        void stop()
        {
            m_stop = true;
        }
    }
}
",blob
876,"public class ShuffleWriteMetrics {
    private long bytesWritten;

    private long recordsWritten;

    private long writeTime;

    public long getBytesWritten ()
    {
        return bytesWritten;
    }

    public void setBytesWritten (long bytesWritten)
    {
        this.bytesWritten = bytesWritten;
    }

    public long getRecordsWritten ()
    {
        return recordsWritten;
    }

    public void setRecordsWritten (long recordsWritten)
    {
        this.recordsWritten = recordsWritten;
    }

    public long getWriteTime ()
    {
        return writeTime;
    }

    public void setWriteTime (long writeTime)
    {
        this.writeTime = writeTime;
    }
}
",data class
58,"public class _ConfigurationSettingsServiceSoapService
    extends SOAP11Service
    implements _ConfigurationSettingsServiceSoap
{
    private static final QName PORT_QNAME = new QName(
                ""http://schemas.microsoft.com/TeamFoundation/2005/06/WorkItemTracking/configurationSettingsService/03"",
                ""ConfigurationSettingsServiceSoapService"");
    private static final String ENDPOINT_PATH = ""/tfs/DefaultCollection/WorkItemTracking/v1.0/ConfigurationSettingsService.asmx"";

    public _ConfigurationSettingsServiceSoapService(
        final URI endpoint,
        final QName port)
    {
        super(endpoint, port);
    }

    public _ConfigurationSettingsServiceSoapService(
        final HttpClient client,
        URI endpoint,
        QName port)
    {
        super(client, endpoint, port);
    }

    /**
     * @return the qualified name of the WSDL port this service implementation can be used with
     */
    public static QName getPortQName()
    {
        return _ConfigurationSettingsServiceSoapService.PORT_QNAME;
    }

    /**
     * @return the path part to use when constructing a URI to contact a host that provides this service
     */
    public static String getEndpointPath()
    {
        return _ConfigurationSettingsServiceSoapService.ENDPOINT_PATH;
    }

    public String getWorkitemTrackingVersion()
        throws TransportException, SOAPFault
    {
        final _ConfigurationSettingsServiceSoap_GetWorkitemTrackingVersion requestData = new _ConfigurationSettingsServiceSoap_GetWorkitemTrackingVersion();

        final SOAPRequest request = createSOAPRequest(
                ""GetWorkitemTrackingVersion"",
                new SOAPMethodRequestWriter()
                {
                    public void writeSOAPRequest(
                        final XMLStreamWriter writer,
                        final OutputStream out)
                        throws XMLStreamException, IOException
                    {
                        requestData.writeAsElement(
                            writer,
                            ""GetWorkitemTrackingVersion"");
                    }
                });

        final _ConfigurationSettingsServiceSoap_GetWorkitemTrackingVersionResponse responseData = new _ConfigurationSettingsServiceSoap_GetWorkitemTrackingVersionResponse();

        executeSOAPRequest(
            request,
            ""GetWorkitemTrackingVersionResponse"",
            new SOAPMethodResponseReader()
            {
                public void readSOAPResponse(
                    final XMLStreamReader reader,
                    final InputStream in)
                    throws XMLStreamException, IOException
                {
                    responseData.readFromElement(reader);
                }
            });

        return responseData.getGetWorkitemTrackingVersionResult();
    }

    public long getMaxAttachmentSize()
        throws TransportException, SOAPFault
    {
        final _ConfigurationSettingsServiceSoap_GetMaxAttachmentSize requestData = new _ConfigurationSettingsServiceSoap_GetMaxAttachmentSize();

        final SOAPRequest request = createSOAPRequest(
                ""GetMaxAttachmentSize"",
                new SOAPMethodRequestWriter()
                {
                    public void writeSOAPRequest(
                        final XMLStreamWriter writer,
                        final OutputStream out)
                        throws XMLStreamException, IOException
                    {
                        requestData.writeAsElement(
                            writer,
                            ""GetMaxAttachmentSize"");
                    }
                });

        final _ConfigurationSettingsServiceSoap_GetMaxAttachmentSizeResponse responseData = new _ConfigurationSettingsServiceSoap_GetMaxAttachmentSizeResponse();

        executeSOAPRequest(
            request,
            ""GetMaxAttachmentSizeResponse"",
            new SOAPMethodResponseReader()
            {
                public void readSOAPResponse(
                    final XMLStreamReader reader,
                    final InputStream in)
                    throws XMLStreamException, IOException
                {
                    responseData.readFromElement(reader);
                }
            });

        return responseData.getGetMaxAttachmentSizeResult();
    }

    public void setMaxAttachmentSize(final long maxSize)
        throws TransportException, SOAPFault
    {
        final _ConfigurationSettingsServiceSoap_SetMaxAttachmentSize requestData = new _ConfigurationSettingsServiceSoap_SetMaxAttachmentSize(
                    maxSize);

        final SOAPRequest request = createSOAPRequest(
                ""SetMaxAttachmentSize"",
                new SOAPMethodRequestWriter()
                {
                    public void writeSOAPRequest(
                        final XMLStreamWriter writer,
                        final OutputStream out)
                        throws XMLStreamException, IOException
                    {
                        requestData.writeAsElement(
                            writer,
                            ""SetMaxAttachmentSize"");
                    }
                });

        final _ConfigurationSettingsServiceSoap_SetMaxAttachmentSizeResponse responseData = new _ConfigurationSettingsServiceSoap_SetMaxAttachmentSizeResponse();

        executeSOAPRequest(
            request,
            ""SetMaxAttachmentSizeResponse"",
            new SOAPMethodResponseReader()
            {
                public void readSOAPResponse(
                    final XMLStreamReader reader,
                    final InputStream in)
                    throws XMLStreamException, IOException
                {
                    responseData.readFromElement(reader);
                }
            });
    }

    public boolean getInProcBuildCompletionNotificationAvailability()
        throws TransportException, SOAPFault
    {
        final _ConfigurationSettingsServiceSoap_GetInProcBuildCompletionNotificationAvailability requestData = new _ConfigurationSettingsServiceSoap_GetInProcBuildCompletionNotificationAvailability();

        final SOAPRequest request = createSOAPRequest(
                ""GetInProcBuildCompletionNotificationAvailability"",
                new SOAPMethodRequestWriter()
                {
                    public void writeSOAPRequest(
                        final XMLStreamWriter writer,
                        final OutputStream out)
                        throws XMLStreamException, IOException
                    {
                        requestData.writeAsElement(
                            writer,
                            ""GetInProcBuildCompletionNotificationAvailability"");
                    }
                });

        final _ConfigurationSettingsServiceSoap_GetInProcBuildCompletionNotificationAvailabilityResponse responseData = new _ConfigurationSettingsServiceSoap_GetInProcBuildCompletionNotificationAvailabilityResponse();

        executeSOAPRequest(
            request,
            ""GetInProcBuildCompletionNotificationAvailabilityResponse"",
            new SOAPMethodResponseReader()
            {
                public void readSOAPResponse(
                    final XMLStreamReader reader,
                    final InputStream in)
                    throws XMLStreamException, IOException
                {
                    responseData.readFromElement(reader);
                }
            });

        return responseData.isGetInProcBuildCompletionNotificationAvailabilityResult();
    }

    public void setInProcBuildCompletionNotificationAvailability(final boolean isEnabled)
        throws TransportException, SOAPFault
    {
        final _ConfigurationSettingsServiceSoap_SetInProcBuildCompletionNotificationAvailability requestData = new _ConfigurationSettingsServiceSoap_SetInProcBuildCompletionNotificationAvailability(
                    isEnabled);

        final SOAPRequest request = createSOAPRequest(
                ""SetInProcBuildCompletionNotificationAvailability"",
                new SOAPMethodRequestWriter()
                {
                    public void writeSOAPRequest(
                        final XMLStreamWriter writer,
                        final OutputStream out)
                        throws XMLStreamException, IOException
                    {
                        requestData.writeAsElement(
                            writer,
                            ""SetInProcBuildCompletionNotificationAvailability"");
                    }
                });

        final _ConfigurationSettingsServiceSoap_SetInProcBuildCompletionNotificationAvailabilityResponse responseData = new _ConfigurationSettingsServiceSoap_SetInProcBuildCompletionNotificationAvailabilityResponse();

        executeSOAPRequest(
            request,
            ""SetInProcBuildCompletionNotificationAvailabilityResponse"",
            new SOAPMethodResponseReader()
            {
                public void readSOAPResponse(
                    final XMLStreamReader reader,
                    final InputStream in)
                    throws XMLStreamException, IOException
                {
                    responseData.readFromElement(reader);
                }
            });
    }

    public int getMaxBuildListSize()
        throws TransportException, SOAPFault
    {
        final _ConfigurationSettingsServiceSoap_GetMaxBuildListSize requestData = new _ConfigurationSettingsServiceSoap_GetMaxBuildListSize();

        final SOAPRequest request = createSOAPRequest(
                ""GetMaxBuildListSize"",
                new SOAPMethodRequestWriter()
                {
                    public void writeSOAPRequest(
                        final XMLStreamWriter writer,
                        final OutputStream out)
                        throws XMLStreamException, IOException
                    {
                        requestData.writeAsElement(
                            writer,
                            ""GetMaxBuildListSize"");
                    }
                });

        final _ConfigurationSettingsServiceSoap_GetMaxBuildListSizeResponse responseData = new _ConfigurationSettingsServiceSoap_GetMaxBuildListSizeResponse();

        executeSOAPRequest(
            request,
            ""GetMaxBuildListSizeResponse"",
            new SOAPMethodResponseReader()
            {
                public void readSOAPResponse(
                    final XMLStreamReader reader,
                    final InputStream in)
                    throws XMLStreamException, IOException
                {
                    responseData.readFromElement(reader);
                }
            });

        return responseData.getGetMaxBuildListSizeResult();
    }

    public void setMaxBuildListSize(final int maxBuildListSize)
        throws TransportException, SOAPFault
    {
        final _ConfigurationSettingsServiceSoap_SetMaxBuildListSize requestData = new _ConfigurationSettingsServiceSoap_SetMaxBuildListSize(
                    maxBuildListSize);

        final SOAPRequest request = createSOAPRequest(
                ""SetMaxBuildListSize"",
                new SOAPMethodRequestWriter()
                {
                    public void writeSOAPRequest(
                        final XMLStreamWriter writer,
                        final OutputStream out)
                        throws XMLStreamException, IOException
                    {
                        requestData.writeAsElement(
                            writer,
                            ""SetMaxBuildListSize"");
                    }
                });

        final _ConfigurationSettingsServiceSoap_SetMaxBuildListSizeResponse responseData = new _ConfigurationSettingsServiceSoap_SetMaxBuildListSizeResponse();

        executeSOAPRequest(
            request,
            ""SetMaxBuildListSizeResponse"",
            new SOAPMethodResponseReader()
            {
                public void readSOAPResponse(
                    final XMLStreamReader reader,
                    final InputStream in)
                    throws XMLStreamException, IOException
                {
                    responseData.readFromElement(reader);
                }
            });
    }

    public int getWorkItemQueryTimeout()
        throws TransportException, SOAPFault
    {
        final _ConfigurationSettingsServiceSoap_GetWorkItemQueryTimeout requestData = new _ConfigurationSettingsServiceSoap_GetWorkItemQueryTimeout();

        final SOAPRequest request = createSOAPRequest(
                ""GetWorkItemQueryTimeout"",
                new SOAPMethodRequestWriter()
                {
                    public void writeSOAPRequest(
                        final XMLStreamWriter writer,
                        final OutputStream out)
                        throws XMLStreamException, IOException
                    {
                        requestData.writeAsElement(
                            writer,
                            ""GetWorkItemQueryTimeout"");
                    }
                });

        final _ConfigurationSettingsServiceSoap_GetWorkItemQueryTimeoutResponse responseData = new _ConfigurationSettingsServiceSoap_GetWorkItemQueryTimeoutResponse();

        executeSOAPRequest(
            request,
            ""GetWorkItemQueryTimeoutResponse"",
            new SOAPMethodResponseReader()
            {
                public void readSOAPResponse(
                    final XMLStreamReader reader,
                    final InputStream in)
                    throws XMLStreamException, IOException
                {
                    responseData.readFromElement(reader);
                }
            });

        return responseData.getGetWorkItemQueryTimeoutResult();
    }

    public void setWorkItemQueryTimeout(final int workItemQueryTimeout)
        throws TransportException, SOAPFault
    {
        final _ConfigurationSettingsServiceSoap_SetWorkItemQueryTimeout requestData = new _ConfigurationSettingsServiceSoap_SetWorkItemQueryTimeout(
                    workItemQueryTimeout);

        final SOAPRequest request = createSOAPRequest(
                ""SetWorkItemQueryTimeout"",
                new SOAPMethodRequestWriter()
                {
                    public void writeSOAPRequest(
                        final XMLStreamWriter writer,
                        final OutputStream out)
                        throws XMLStreamException, IOException
                    {
                        requestData.writeAsElement(
                            writer,
                            ""SetWorkItemQueryTimeout"");
                    }
                });

        final _ConfigurationSettingsServiceSoap_SetWorkItemQueryTimeoutResponse responseData = new _ConfigurationSettingsServiceSoap_SetWorkItemQueryTimeoutResponse();

        executeSOAPRequest(
            request,
            ""SetWorkItemQueryTimeoutResponse"",
            new SOAPMethodResponseReader()
            {
                public void readSOAPResponse(
                    final XMLStreamReader reader,
                    final InputStream in)
                    throws XMLStreamException, IOException
                {
                    responseData.readFromElement(reader);
                }
            });
    }
}
",blob
262,"public class TimingEvent {

  public static class LauncherTimings {
    public static final String FULL_JOB_EXECUTION = ""FullJobExecutionTimer"";
    public static final String WORK_UNITS_CREATION = ""WorkUnitsCreationTimer"";
    public static final String WORK_UNITS_PREPARATION = ""WorkUnitsPreparationTimer"";
    public static final String JOB_ORCHESTRATED = ""JobOrchestrated"";
    public static final String JOB_PREPARE = ""JobPrepareTimer"";
    public static final String JOB_START = ""JobStartTimer"";
    public static final String JOB_RUN = ""JobRunTimer"";
    public static final String JOB_COMMIT = ""JobCommitTimer"";
    public static final String JOB_CLEANUP = ""JobCleanupTimer"";
    public static final String JOB_CANCEL = ""JobCancelTimer"";
    public static final String JOB_COMPLETE = ""JobCompleteTimer"";
    public static final String JOB_FAILED = ""JobFailedTimer"";
    public static final String JOB_SUCCEEDED = ""JobSucceededTimer"";
  }

  public static class RunJobTimings {
    public static final String JOB_LOCAL_SETUP = ""JobLocalSetupTimer"";
    public static final String WORK_UNITS_RUN = ""WorkUnitsRunTimer"";
    public static final String WORK_UNITS_PREPARATION = ""WorkUnitsPreparationTimer"";
    public static final String MR_STAGING_DATA_CLEAN = ""JobMrStagingDataCleanTimer"";
    public static final String MR_DISTRIBUTED_CACHE_SETUP = ""JobMrDistributedCacheSetupTimer"";
    public static final String MR_JOB_SETUP = ""JobMrSetupTimer"";
    public static final String MR_JOB_RUN = ""JobMrRunTimer"";
    public static final String HELIX_JOB_SUBMISSION= ""JobHelixSubmissionTimer"";
    public static final String HELIX_JOB_RUN = ""JobHelixRunTimer"";
  }

  public static class FlowTimings {
    public static final String FLOW_COMPILED = ""FlowCompiled"";
    public static final String FLOW_COMPILE_FAILED = ""FlowCompileFailed"";
  }

  public static class FlowEventConstants {
    public static final String FLOW_NAME_FIELD = ""flowName"";
    public static final String FLOW_GROUP_FIELD = ""flowGroup"";
    public static final String FLOW_EXECUTION_ID_FIELD = ""flowExecutionId"";
    public static final String JOB_NAME_FIELD = ""jobName"";
    public static final String JOB_GROUP_FIELD = ""jobGroup"";
    public static final String JOB_EXECUTION_ID_FIELD = ""jobExecutionId"";
    public static final String SPEC_EXECUTOR_FIELD = ""specExecutor"";
    public static final String LOW_WATERMARK_FIELD = ""lowWatermark"";
    public static final String HIGH_WATERMARK_FIELD = ""highWatermark"";
    public static final String PROCESSED_COUNT_FIELD = ""processedCount"";
  }

  public static final String METADATA_START_TIME = ""startTime"";
  public static final String METADATA_END_TIME = ""endTime"";
  public static final String METADATA_DURATION = ""durationMillis"";
  public static final String METADATA_TIMING_EVENT = ""timingEvent"";
  public static final String METADATA_MESSAGE = ""message"";

  private final String name;
  private final Long startTime;
  private final EventSubmitter submitter;
  private boolean stopped;

  public TimingEvent(EventSubmitter submitter, String name) {
    this.stopped = false;
    this.name = name;
    this.submitter = submitter;
    this.startTime = System.currentTimeMillis();
  }

  /**
   * Stop the timer and submit the event. If the timer was already stopped before, this is a no-op.
   */
  public void stop() {
    stop(Maps.<String, String> newHashMap());
  }

  /**
   * Stop the timer and submit the event, along with the additional metadata specified. If the timer was already stopped
   * before, this is a no-op.
   *
   * @param additionalMetadata a {@link Map} of additional metadata that should be submitted along with this event
   */
  public void stop(Map<String, String> additionalMetadata) {
    if (this.stopped) {
      return;
    }
    this.stopped = true;
    long endTime = System.currentTimeMillis();
    long duration = endTime - this.startTime;

    Map<String, String> finalMetadata = Maps.newHashMap();
    finalMetadata.putAll(additionalMetadata);
    finalMetadata.put(EventSubmitter.EVENT_TYPE, METADATA_TIMING_EVENT);
    finalMetadata.put(METADATA_START_TIME, Long.toString(this.startTime));
    finalMetadata.put(METADATA_END_TIME, Long.toString(endTime));
    finalMetadata.put(METADATA_DURATION, Long.toString(duration));

    this.submitter.submit(this.name, finalMetadata);
  }
}
",blob
273,"    @Override
    public ListenableFuture<Void> recover(QueueManagingVirtualHost<?> virtualHost)
    {
        EventLogger eventLogger = virtualHost.getEventLogger();
        MessageStore store = virtualHost.getMessageStore();
        MessageStore.MessageStoreReader storeReader = store.newMessageStoreReader();
        MessageStoreLogSubject logSubject = new MessageStoreLogSubject(virtualHost.getName(), store.getClass().getSimpleName());

        Map<Queue<?>, Integer> queueRecoveries = new TreeMap<>();
        Map<Long, ServerMessage<?>> recoveredMessages = new HashMap<>();
        Map<Long, StoredMessage<?>> unusedMessages = new TreeMap<>();
        Map<UUID, Integer> unknownQueuesWithMessages = new HashMap<>();
        Map<Queue<?>, Integer> queuesWithUnknownMessages = new HashMap<>();

        eventLogger.message(logSubject, MessageStoreMessages.RECOVERY_START());

        storeReader.visitMessages(new MessageVisitor(recoveredMessages, unusedMessages));

        eventLogger.message(logSubject, TransactionLogMessages.RECOVERY_START(null, false));
        try
        {
            storeReader.visitMessageInstances(new MessageInstanceVisitor(virtualHost,
                                                                         store,
                                                                         queueRecoveries,
                                                                         recoveredMessages,
                                                                         unusedMessages,
                                                                         unknownQueuesWithMessages,
                                                                         queuesWithUnknownMessages));
        }
        finally
        {
            if (!unknownQueuesWithMessages.isEmpty())
            {
                unknownQueuesWithMessages.forEach((queueId, count) -> {
                    LOGGER.info(""Discarded {} entry(s) associated with queue id '{}' as a queue with this ""
                                 + ""id does not appear in the configuration."",
                                 count, queueId);
                });
            }
            if (!queuesWithUnknownMessages.isEmpty())
            {
                queuesWithUnknownMessages.forEach((queue, count) -> {
                    LOGGER.info(""Discarded {} entry(s) associated with queue '{}' as the referenced message ""
                                 + ""does not exist."",
                                 count, queue.getName());
                });
            }
        }

        for(Map.Entry<Queue<?>, Integer> entry : queueRecoveries.entrySet())
        {
            Queue<?> queue = entry.getKey();
            Integer deliveredCount = entry.getValue();
            eventLogger.message(logSubject, TransactionLogMessages.RECOVERED(deliveredCount, queue.getName()));
            eventLogger.message(logSubject, TransactionLogMessages.RECOVERY_COMPLETE(queue.getName(), true));
            queue.completeRecovery();
        }

        for (Queue<?> q : virtualHost.getChildren(Queue.class))
        {
            if (!queueRecoveries.containsKey(q))
            {
                q.completeRecovery();
            }
        }

        storeReader.visitDistributedTransactions(new DistributedTransactionVisitor(virtualHost,
                                                                                   eventLogger,
                                                                                   logSubject, recoveredMessages, unusedMessages));

        for(StoredMessage<?> m : unusedMessages.values())
        {
            LOGGER.debug(""Message id '{}' is orphaned, removing"", m.getMessageNumber());
            m.remove();
        }

        if (unusedMessages.size() > 0)
        {
            LOGGER.info(""Discarded {} orphaned message(s)."", unusedMessages.size());
        }

        eventLogger.message(logSubject, TransactionLogMessages.RECOVERY_COMPLETE(null, false));

        eventLogger.message(logSubject,
                             MessageStoreMessages.RECOVERED(recoveredMessages.size() - unusedMessages.size()));
        eventLogger.message(logSubject, MessageStoreMessages.RECOVERY_COMPLETE());

        return Futures.immediateFuture(null);
    }
",long method
891,"public class ImportsAwareClipboardAction extends TextEditorAction {
	public static class Factory implements IClipboardActionFactory {
		@Inject
		private MembersInjector<ImportsAwareClipboardAction> injector;

		@Override
		public TextEditorAction create(ResourceBundle bundle, String prefix, ITextEditor editor, int operationCode) {
			ImportsAwareClipboardAction action = new ImportsAwareClipboardAction(bundle, prefix, editor, operationCode);
			injector.injectMembers(action);
			return action;
		}

	}

	private static final XbaseClipboardTransfer TRANSFER_INSTANCE = new XbaseClipboardTransfer();
	private final int operationCode;
	private ITextOperationTarget textOperationTarget;
	private @Inject ImportsUtil importsUtil;

	/**
	 * Creates the action.
	 * 
	 * @param bundle
	 *            the resource bundle
	 * @param prefix
	 *            a prefix to be prepended to the various resource keys (described in <code>ResourceAction</code>
	 *            constructor), or <code>null</code> if none
	 * @param editor
	 *            the text editor. May not be <code>null</code>.
	 * @param operationCode
	 *            the operation code
	 */
	public ImportsAwareClipboardAction(ResourceBundle bundle, String prefix, ITextEditor editor,
			final int operationCode) {
		super(bundle, prefix, editor);
		this.operationCode = operationCode;

		if (operationCode == ITextOperationTarget.CUT) {
			setHelpContextId(IAbstractTextEditorHelpContextIds.CUT_ACTION);
			setActionDefinitionId(IWorkbenchCommandConstants.EDIT_CUT);
		} else if (operationCode == ITextOperationTarget.COPY) {
			setHelpContextId(IAbstractTextEditorHelpContextIds.COPY_ACTION);
			setActionDefinitionId(IWorkbenchCommandConstants.EDIT_COPY);
		} else if (operationCode == ITextOperationTarget.PASTE) {
			setHelpContextId(IAbstractTextEditorHelpContextIds.PASTE_ACTION);
			setActionDefinitionId(IWorkbenchCommandConstants.EDIT_PASTE);
		} else {
			Assert.isTrue(false, ""Invalid operation code""); //$NON-NLS-1$
		}
		update();
	}

	protected void internalDoOperation() {
		if (operationCode == ITextOperationTarget.PASTE) {
			doPasteWithImportsOperation();
		} else {
			doCutCopyWithImportsOperation();
		}
	}

	private void doCutCopyWithImportsOperation() {
		try {
			final XbaseClipboardData cbData = createClipboardData();
			if (cbData != null ) {
				ClipboardUtil.clipboardOperation(new Function<Clipboard, Boolean>() {

					@Override
					public Boolean apply(Clipboard clipboard) {
						Map<Object,Transfer> payload = newLinkedHashMap();
						payload.put(cbData, TRANSFER_INSTANCE);
						
						TextTransfer textTransfer = TextTransfer.getInstance();
						String textData = (String) clipboard.getContents(textTransfer);
						if (textData == null || textData.isEmpty()) {
							// StyledText copied any data to ClipBoard
							return Boolean.FALSE;
						}
						payload.put(textData, textTransfer);
						
						RTFTransfer rtfTransfer = RTFTransfer.getInstance();
						String rtfData = (String) clipboard.getContents(rtfTransfer);
						if (rtfData != null && !rtfData.isEmpty()) {
							payload.put(rtfData, rtfTransfer);
						}
						
						List<Object> datas = newArrayList();
						List<Transfer> dataTypes = newArrayList();
						for (Entry<Object, Transfer> entry : payload.entrySet()) {
							datas.add(entry.getKey());
							dataTypes.add(entry.getValue());
						}
						try {
							clipboard.setContents(datas.toArray(), dataTypes.toArray(new Transfer[] {}));
							return Boolean.TRUE;
						} catch (SWTError e) {
							if (e.code != DND.ERROR_CANNOT_SET_CLIPBOARD) {
								throw e;
							}
							if (MessageDialog.openQuestion(getShell(), ActionMessages.CopyQualifiedNameAction_ErrorTitle, ActionMessages.CopyQualifiedNameAction_ErrorDescription)) {
								clipboard.setContents(datas.toArray(), dataTypes.toArray(new Transfer[] {}));
								return Boolean.TRUE;
							}
							return Boolean.FALSE;
						}
					}
				});
			}
		} finally {
			textOperationTarget.doOperation(operationCode);
		}
	}

	private void doPasteWithImportsOperation() {
		XbaseClipboardData xbaseClipboardData = ClipboardUtil
				.clipboardOperation(new Function<Clipboard, XbaseClipboardData>() {
					@Override
					public XbaseClipboardData apply(Clipboard input) {
						Object content = input.getContents(TRANSFER_INSTANCE);
						if (content instanceof XbaseClipboardData) {
							return (XbaseClipboardData) content;
						}
						return null;
					}
				});
		JavaImportData javaImportsContent = ClipboardUtil.getJavaImportsContent();
		String textFromClipboard = ClipboardUtil.getTextFromClipboard();
		XtextEditor xtextEditor = EditorUtils.getXtextEditor(getTextEditor());
		boolean addImports = shouldAddImports(xtextEditor.getDocument(), caretOffset(xtextEditor));
		if (xbaseClipboardData != null && !sameTarget(xbaseClipboardData)) {
			doPasteXbaseCode(xbaseClipboardData, addImports);
		} else if (javaImportsContent != null) {
			doPasteJavaCode(textFromClipboard, javaImportsContent, addImports);
		} else {
			textOperationTarget.doOperation(operationCode);
		}
	}

	/**
	 * Should not add imports when pasting into a {@link XStringLiteral} or Comments (except of JavaDoc)
	 * 
	 * @param document
	 *            - {@link IDocument} to work with
	 * @param caretOffset
	 *            - current caret offset
	 */
	protected boolean shouldAddImports(IDocument document, int caretOffset) {
		if (caretOffset == 0) {
			return true;
		}
		String typeRight = IDocument.DEFAULT_CONTENT_TYPE;
		String typeLeft = IDocument.DEFAULT_CONTENT_TYPE;
		try {
			typeRight = TextUtilities.getContentType(document, IDocumentExtension3.DEFAULT_PARTITIONING, caretOffset,
					false);
			typeLeft = TextUtilities.getContentType(document, IDocumentExtension3.DEFAULT_PARTITIONING,
					caretOffset > 0 ? caretOffset - 1 : caretOffset, false);
		} catch (BadLocationException exception) {
			// Should not happen
		}
		if (COMMENT_PARTITION.equals(typeRight) || STRING_LITERAL_PARTITION.equals(typeRight)
				|| SL_COMMENT_PARTITION.equals(typeRight) || ""__rich_string"".equals(typeRight)) {
			if (typeLeft.equals(typeRight))
				return false;
		}
		return true;
	}

	private int caretOffset(final XtextEditor xtextEditor) {
		ISourceViewer sourceViewer = xtextEditor.getInternalSourceViewer();
		int caretOffset = sourceViewer.getTextWidget().getCaretOffset();
		if (sourceViewer instanceof ITextViewerExtension5) {
			ITextViewerExtension5 extension = (ITextViewerExtension5) sourceViewer;
			caretOffset = extension.widgetOffset2ModelOffset(caretOffset);
		}
		return caretOffset;
	}

	private void doPasteXbaseCode(XbaseClipboardData xbaseClipboardData, boolean withImports) {
		IRewriteTarget target = getTextEditor().getAdapter(IRewriteTarget.class);
		if (target != null) {
			target.beginCompoundChange();
		}
		try {
			textOperationTarget.doOperation(operationCode);
			if (withImports) {
				importsUtil.addImports(xbaseClipboardData.getImports(), xbaseClipboardData.getStaticImports(),
						xbaseClipboardData.getExtensionImports(), getXtextDocument());
			}
		} catch (Exception e) {
			XbaseActivator.getInstance().getLog().log(new Status(IStatus.ERROR,
					XbaseActivator.getInstance().getBundle().getSymbolicName(), ""Unexpected internal error: "", e));
		} finally {
			if (target != null) {
				target.endCompoundChange();
			}
		}
	}

	private void doPasteJavaCode(String textFromClipboard, JavaImportData javaImportsContent, boolean withImports) {
		IRewriteTarget target = getTextEditor().getAdapter(IRewriteTarget.class);
		if (target != null) {
			target.beginCompoundChange();
		}
		try {
			textOperationTarget.doOperation(operationCode);
			if (withImports) {
				importsUtil.addImports(javaImportsContent.getImports(), javaImportsContent.getStaticImports(),
						new String[] {}, getXtextDocument());
			}
		} catch (Exception e) {
			XbaseActivator.getInstance().getLog().log(new Status(IStatus.ERROR,
					XbaseActivator.getInstance().getBundle().getSymbolicName(), ""Unexpected internal error: "", e));
		} finally {
			if (target != null) {
				target.endCompoundChange();
			}
		}
	}

	private boolean sameTarget(XbaseClipboardData xbaseClipboardData) {
		IEditorInput editorInput = getTextEditor().getEditorInput();
		if (editorInput == null) {
			return false;
		}
		return xbaseClipboardData.getSourceIndentifier().equals(editorInput.toString());
	}

	private XbaseClipboardData createClipboardData() {
		try {
			IEditorInput editorInput = getTextEditor().getEditorInput();
			final String sourceIdentifier = editorInput != null ? editorInput.toString() : ""nullEditorInput"";
			IXtextDocument document = getXtextDocument();
			final ISelection selection = getTextEditor().getSelectionProvider().getSelection();
			if (selection instanceof ITextSelection && !selection.isEmpty()) {
				final ITextSelection textSelection = (ITextSelection) selection;
				return document.readOnly(new IUnitOfWork<XbaseClipboardData, XtextResource>() {
					@Override
					public XbaseClipboardData exec(XtextResource state) throws Exception {
						ITextRegion region = new TextRegion(textSelection.getOffset(), textSelection.getLength() - 1);
						Triple<Set<String>, Set<String>, Set<String>> imports = importsUtil.collectImports(state,
								region);
						XbaseClipboardData clipboardData = new XbaseClipboardData(sourceIdentifier,
								Iterables.toArray(imports.getFirst(), String.class),
								Iterables.toArray(imports.getSecond(), String.class),
								Iterables.toArray(imports.getThird(), String.class));
						return clipboardData;
					}
				});
			}
		} catch (Exception e) {
			//TODO Log exception
			return null;
		}
		return null;
	}

	private IXtextDocument getXtextDocument() {
		XtextEditor xtextEditor = EditorUtils.getXtextEditor(getTextEditor());
		IXtextDocument document = xtextEditor.getDocument();
		return document;
	}

	@Override
	public void update() {
		super.update();
		if (isModifyOperation() && !canModifyEditor()) {
			setEnabled(false);
			return;
		}
		ITextEditor editor = getTextEditor();
		if (textOperationTarget == null && editor != null)
			textOperationTarget = editor.getAdapter(ITextOperationTarget.class);
		boolean isEnabled = (textOperationTarget != null && textOperationTarget.canDoOperation(getOperationCode()));
		setEnabled(isEnabled);
	}

	private int getOperationCode() {
		return operationCode;
	}

	@Override
	public void run() {
		if (textOperationTarget == null)
			return;
		ITextEditor editor = getTextEditor();
		if (editor == null)
			return;
		if (isModifyOperation() && !validateEditorInputState())
			return;
		BusyIndicator.showWhile(getDisplay(), new Runnable() {
			@Override
			public void run() {
				internalDoOperation();
			}
		});
	}

	private boolean isModifyOperation() {
		return operationCode != ITextOperationTarget.COPY;
	}

	private Shell getShell() {
		ITextEditor editor = getTextEditor();
		if (editor != null) {
			IWorkbenchPartSite site = editor.getSite();
			Shell shell = site.getShell();
			if (shell != null && !shell.isDisposed()) {
				return shell;
			}
		}
		return null;
	}

	private Display getDisplay() {
		Shell shell = getShell();
		if (shell != null) {
			return shell.getDisplay();
		}
		return null;
	}

	@Override
	public void setEditor(ITextEditor editor) {
		super.setEditor(editor);
		this.textOperationTarget = null;
	}

	public static final class XbaseClipboardData {
		private String sourceIndentifier;
		private String[] imports;
		private String[] staticImports;
		private String[] extensionImports;

		public XbaseClipboardData(String sourceIndentifier, String[] imports, String[] staticImports,
				String[] extensionImports) {
			this.sourceIndentifier = sourceIndentifier;
			this.imports = imports;
			this.staticImports = staticImports;
			this.extensionImports = extensionImports;
		}

		public XbaseClipboardData(byte[] bytes) throws IOException {
			DataInputStream dataIn = new DataInputStream(new ByteArrayInputStream(bytes));
			try {
				sourceIndentifier = dataIn.readUTF();
				imports = readArray(dataIn);
				staticImports = readArray(dataIn);
				extensionImports = readArray(dataIn);
			} finally {
				dataIn.close();
			}
		}

		protected final String[] readArray(DataInputStream dataIn) throws IOException {
			int count = dataIn.readInt();
			String[] array = new String[count];
			for (int i = 0; i < count; i++) {
				array[i] = dataIn.readUTF();
			}
			return array;
		}

		public byte[] serialize() throws IOException {
			ByteArrayOutputStream out = new ByteArrayOutputStream();
			DataOutputStream dataOut = new DataOutputStream(out);
			try {
				dataOut.writeUTF(sourceIndentifier);
				writeArray(dataOut, imports);
				writeArray(dataOut, staticImports);
				writeArray(dataOut, extensionImports);
			} finally {
				dataOut.close();
				out.close();
			}
			return out.toByteArray();
		}

		protected final void writeArray(DataOutputStream dataOut, String[] array) throws IOException {
			dataOut.writeInt(array.length);
			for (int i = 0; i < array.length; i++) {
				dataOut.writeUTF(array[i]);
			}
		}

		public String getSourceIndentifier() {
			return sourceIndentifier;
		}

		public String[] getImports() {
			return imports;
		}

		public String[] getStaticImports() {
			return staticImports;
		}

		public String[] getExtensionImports() {
			return extensionImports;
		}
	}

	private static class XbaseClipboardTransfer extends ByteArrayTransfer {

		private static final String TYPE_NAME = ""xbase-source-with-imports-transfer-format"";

		private static final int TYPEID = registerType(TYPE_NAME);

		@Override
		protected int[] getTypeIds() {
			return new int[] { TYPEID };
		}

		@Override
		protected String[] getTypeNames() {
			return new String[] { TYPE_NAME };
		}

		@Override
		protected void javaToNative(Object data, TransferData transferData) {
			if (data instanceof XbaseClipboardData) {
				try {
					super.javaToNative(((XbaseClipboardData) data).serialize(), transferData);
				} catch (IOException e) {
					//it's best to send nothing if there were problems
				}
			}
		}

		@Override
		protected Object nativeToJava(TransferData transferData) {
			byte[] bytes = (byte[]) super.nativeToJava(transferData);
			if (bytes != null) {
				try {
					return new XbaseClipboardData(bytes);
				} catch (IOException e) {
				}
			}
			return null;
		}
	}

}
",blob
981,"public class Targeting extends APINode {
  @SerializedName(""adgroup_id"")
  private String mAdgroupId = null;
  @SerializedName(""age_max"")
  private Long mAgeMax = null;
  @SerializedName(""age_min"")
  private Long mAgeMin = null;
  @SerializedName(""alternate_auto_targeting_option"")
  private String mAlternateAutoTargetingOption = null;
  @SerializedName(""app_install_state"")
  private String mAppInstallState = null;
  @SerializedName(""audience_network_positions"")
  private List<String> mAudienceNetworkPositions = null;
  @SerializedName(""behaviors"")
  private List<IDName> mBehaviors = null;
  @SerializedName(""brand_safety_content_filter_levels"")
  private List<String> mBrandSafetyContentFilterLevels = null;
  @SerializedName(""brand_safety_content_severity_levels"")
  private List<String> mBrandSafetyContentSeverityLevels = null;
  @SerializedName(""catalog_based_targeting"")
  private CatalogBasedTargeting mCatalogBasedTargeting = null;
  @SerializedName(""cities"")
  private List<IDName> mCities = null;
  @SerializedName(""college_years"")
  private List<Long> mCollegeYears = null;
  @SerializedName(""connections"")
  private List<IDName> mConnections = null;
  @SerializedName(""contextual_targeting_categories"")
  private List<IDName> mContextualTargetingCategories = null;
  @SerializedName(""countries"")
  private List<String> mCountries = null;
  @SerializedName(""country"")
  private List<String> mCountry = null;
  @SerializedName(""country_groups"")
  private List<String> mCountryGroups = null;
  @SerializedName(""custom_audiences"")
  private List<RawCustomAudience> mCustomAudiences = null;
  @SerializedName(""device_platforms"")
  private List<EnumDevicePlatforms> mDevicePlatforms = null;
  @SerializedName(""direct_install_devices"")
  private Boolean mDirectInstallDevices = null;
  @SerializedName(""dynamic_audience_ids"")
  private List<String> mDynamicAudienceIds = null;
  @SerializedName(""education_majors"")
  private List<IDName> mEducationMajors = null;
  @SerializedName(""education_schools"")
  private List<IDName> mEducationSchools = null;
  @SerializedName(""education_statuses"")
  private List<Long> mEducationStatuses = null;
  @SerializedName(""effective_audience_network_positions"")
  private List<String> mEffectiveAudienceNetworkPositions = null;
  @SerializedName(""effective_device_platforms"")
  private List<EnumEffectiveDevicePlatforms> mEffectiveDevicePlatforms = null;
  @SerializedName(""effective_facebook_positions"")
  private List<String> mEffectiveFacebookPositions = null;
  @SerializedName(""effective_instagram_positions"")
  private List<String> mEffectiveInstagramPositions = null;
  @SerializedName(""effective_messenger_positions"")
  private List<String> mEffectiveMessengerPositions = null;
  @SerializedName(""effective_publisher_platforms"")
  private List<String> mEffectivePublisherPlatforms = null;
  @SerializedName(""engagement_specs"")
  private List<TargetingDynamicRule> mEngagementSpecs = null;
  @SerializedName(""ethnic_affinity"")
  private List<IDName> mEthnicAffinity = null;
  @SerializedName(""exclude_reached_since"")
  private List<String> mExcludeReachedSince = null;
  @SerializedName(""excluded_connections"")
  private List<IDName> mExcludedConnections = null;
  @SerializedName(""excluded_custom_audiences"")
  private List<IDName> mExcludedCustomAudiences = null;
  @SerializedName(""excluded_dynamic_audience_ids"")
  private List<String> mExcludedDynamicAudienceIds = null;
  @SerializedName(""excluded_engagement_specs"")
  private List<TargetingDynamicRule> mExcludedEngagementSpecs = null;
  @SerializedName(""excluded_geo_locations"")
  private TargetingGeoLocation mExcludedGeoLocations = null;
  @SerializedName(""excluded_mobile_device_model"")
  private List<String> mExcludedMobileDeviceModel = null;
  @SerializedName(""excluded_product_audience_specs"")
  private List<TargetingProductAudienceSpec> mExcludedProductAudienceSpecs = null;
  @SerializedName(""excluded_publisher_categories"")
  private List<String> mExcludedPublisherCategories = null;
  @SerializedName(""excluded_publisher_list_ids"")
  private List<String> mExcludedPublisherListIds = null;
  @SerializedName(""excluded_user_device"")
  private List<String> mExcludedUserDevice = null;
  @SerializedName(""exclusions"")
  private FlexibleTargeting mExclusions = null;
  @SerializedName(""facebook_positions"")
  private List<String> mFacebookPositions = null;
  @SerializedName(""family_statuses"")
  private List<IDName> mFamilyStatuses = null;
  @SerializedName(""fb_deal_id"")
  private String mFbDealId = null;
  @SerializedName(""flexible_spec"")
  private List<FlexibleTargeting> mFlexibleSpec = null;
  @SerializedName(""friends_of_connections"")
  private List<IDName> mFriendsOfConnections = null;
  @SerializedName(""genders"")
  private List<Long> mGenders = null;
  @SerializedName(""generation"")
  private List<IDName> mGeneration = null;
  @SerializedName(""geo_locations"")
  private TargetingGeoLocation mGeoLocations = null;
  @SerializedName(""home_ownership"")
  private List<IDName> mHomeOwnership = null;
  @SerializedName(""home_type"")
  private List<IDName> mHomeType = null;
  @SerializedName(""home_value"")
  private List<IDName> mHomeValue = null;
  @SerializedName(""household_composition"")
  private List<IDName> mHouseholdComposition = null;
  @SerializedName(""income"")
  private List<IDName> mIncome = null;
  @SerializedName(""industries"")
  private List<IDName> mIndustries = null;
  @SerializedName(""instagram_positions"")
  private List<String> mInstagramPositions = null;
  @SerializedName(""instream_video_sponsorship_placements"")
  private List<String> mInstreamVideoSponsorshipPlacements = null;
  @SerializedName(""interested_in"")
  private List<Long> mInterestedIn = null;
  @SerializedName(""interests"")
  private List<IDName> mInterests = null;
  @SerializedName(""is_whatsapp_destination_ad"")
  private Boolean mIsWhatsappDestinationAd = null;
  @SerializedName(""keywords"")
  private List<String> mKeywords = null;
  @SerializedName(""life_events"")
  private List<IDName> mLifeEvents = null;
  @SerializedName(""locales"")
  private List<Long> mLocales = null;
  @SerializedName(""messenger_positions"")
  private List<String> mMessengerPositions = null;
  @SerializedName(""moms"")
  private List<IDName> mMoms = null;
  @SerializedName(""net_worth"")
  private List<IDName> mNetWorth = null;
  @SerializedName(""office_type"")
  private List<IDName> mOfficeType = null;
  @SerializedName(""place_page_set_ids"")
  private List<String> mPlacePageSetIds = null;
  @SerializedName(""political_views"")
  private List<Long> mPoliticalViews = null;
  @SerializedName(""politics"")
  private List<IDName> mPolitics = null;
  @SerializedName(""product_audience_specs"")
  private List<TargetingProductAudienceSpec> mProductAudienceSpecs = null;
  @SerializedName(""prospecting_audience"")
  private TargetingProspectingAudience mProspectingAudience = null;
  @SerializedName(""publisher_platforms"")
  private List<String> mPublisherPlatforms = null;
  @SerializedName(""publisher_visibility_categories"")
  private List<String> mPublisherVisibilityCategories = null;
  @SerializedName(""radius"")
  private String mRadius = null;
  @SerializedName(""regions"")
  private List<IDName> mRegions = null;
  @SerializedName(""relationship_statuses"")
  private List<Long> mRelationshipStatuses = null;
  @SerializedName(""site_category"")
  private List<String> mSiteCategory = null;
  @SerializedName(""targeting_optimization"")
  private String mTargetingOptimization = null;
  @SerializedName(""user_adclusters"")
  private List<IDName> mUserAdclusters = null;
  @SerializedName(""user_device"")
  private List<String> mUserDevice = null;
  @SerializedName(""user_event"")
  private List<Long> mUserEvent = null;
  @SerializedName(""user_os"")
  private List<String> mUserOs = null;
  @SerializedName(""wireless_carrier"")
  private List<String> mWirelessCarrier = null;
  @SerializedName(""work_employers"")
  private List<IDName> mWorkEmployers = null;
  @SerializedName(""work_positions"")
  private List<IDName> mWorkPositions = null;
  @SerializedName(""zips"")
  private List<String> mZips = null;
  protected static Gson gson = null;

  public Targeting() {
  }

  public String getId() {
    return null;
  }
  public static Targeting loadJSON(String json, APIContext context, String header) {
    Targeting targeting = getGson().fromJson(json, Targeting.class);
    if (context.isDebug()) {
      JsonParser parser = new JsonParser();
      JsonElement o1 = parser.parse(json);
      JsonElement o2 = parser.parse(targeting.toString());
      if (o1.getAsJsonObject().get(""__fb_trace_id__"") != null) {
        o2.getAsJsonObject().add(""__fb_trace_id__"", o1.getAsJsonObject().get(""__fb_trace_id__""));
      }
      if (!o1.equals(o2)) {
        context.log(""[Warning] When parsing response, object is not consistent with JSON:"");
        context.log(""[JSON]"" + o1);
        context.log(""[Object]"" + o2);
      };
    }
    targeting.context = context;
    targeting.rawValue = json;
    targeting.header = header;
    return targeting;
  }

  public static APINodeList<Targeting> parseResponse(String json, APIContext context, APIRequest request, String header) throws MalformedResponseException {
    APINodeList<Targeting> targetings = new APINodeList<Targeting>(request, json, header);
    JsonArray arr;
    JsonObject obj;
    JsonParser parser = new JsonParser();
    Exception exception = null;
    try{
      JsonElement result = parser.parse(json);
      if (result.isJsonArray()) {
        // First, check if it's a pure JSON Array
        arr = result.getAsJsonArray();
        for (int i = 0; i < arr.size(); i++) {
          targetings.add(loadJSON(arr.get(i).getAsJsonObject().toString(), context, header));
        };
        return targetings;
      } else if (result.isJsonObject()) {
        obj = result.getAsJsonObject();
        if (obj.has(""data"")) {
          if (obj.has(""paging"")) {
            JsonObject paging = obj.get(""paging"").getAsJsonObject();
            if (paging.has(""cursors"")) {
                JsonObject cursors = paging.get(""cursors"").getAsJsonObject();
                String before = cursors.has(""before"") ? cursors.get(""before"").getAsString() : null;
                String after = cursors.has(""after"") ? cursors.get(""after"").getAsString() : null;
                targetings.setCursors(before, after);
            }
            String previous = paging.has(""previous"") ? paging.get(""previous"").getAsString() : null;
            String next = paging.has(""next"") ? paging.get(""next"").getAsString() : null;
            targetings.setPaging(previous, next);
            if (context.hasAppSecret()) {
              targetings.setAppSecret(context.getAppSecretProof());
            }
          }
          if (obj.get(""data"").isJsonArray()) {
            // Second, check if it's a JSON array with ""data""
            arr = obj.get(""data"").getAsJsonArray();
            for (int i = 0; i < arr.size(); i++) {
              targetings.add(loadJSON(arr.get(i).getAsJsonObject().toString(), context, header));
            };
          } else if (obj.get(""data"").isJsonObject()) {
            // Third, check if it's a JSON object with ""data""
            obj = obj.get(""data"").getAsJsonObject();
            boolean isRedownload = false;
            for (String s : new String[]{""campaigns"", ""adsets"", ""ads""}) {
              if (obj.has(s)) {
                isRedownload = true;
                obj = obj.getAsJsonObject(s);
                for (Map.Entry<String, JsonElement> entry : obj.entrySet()) {
                  targetings.add(loadJSON(entry.getValue().toString(), context, header));
                }
                break;
              }
            }
            if (!isRedownload) {
              targetings.add(loadJSON(obj.toString(), context, header));
            }
          }
          return targetings;
        } else if (obj.has(""images"")) {
          // Fourth, check if it's a map of image objects
          obj = obj.get(""images"").getAsJsonObject();
          for (Map.Entry<String, JsonElement> entry : obj.entrySet()) {
              targetings.add(loadJSON(entry.getValue().toString(), context, header));
          }
          return targetings;
        } else {
          // Fifth, check if it's an array of objects indexed by id
          boolean isIdIndexedArray = true;
          for (Map.Entry entry : obj.entrySet()) {
            String key = (String) entry.getKey();
            if (key.equals(""__fb_trace_id__"")) {
              continue;
            }
            JsonElement value = (JsonElement) entry.getValue();
            if (
              value != null &&
              value.isJsonObject() &&
              value.getAsJsonObject().has(""id"") &&
              value.getAsJsonObject().get(""id"") != null &&
              value.getAsJsonObject().get(""id"").getAsString().equals(key)
            ) {
              targetings.add(loadJSON(value.toString(), context, header));
            } else {
              isIdIndexedArray = false;
              break;
            }
          }
          if (isIdIndexedArray) {
            return targetings;
          }

          // Sixth, check if it's pure JsonObject
          targetings.clear();
          targetings.add(loadJSON(json, context, header));
          return targetings;
        }
      }
    } catch (Exception e) {
      exception = e;
    }
    throw new MalformedResponseException(
      ""Invalid response string: "" + json,
      exception
    );
  }

  @Override
  public APIContext getContext() {
    return context;
  }

  @Override
  public void setContext(APIContext context) {
    this.context = context;
  }

  @Override
  public String toString() {
    return getGson().toJson(this);
  }


  public String getFieldAdgroupId() {
    return mAdgroupId;
  }

  public Targeting setFieldAdgroupId(String value) {
    this.mAdgroupId = value;
    return this;
  }

  public Long getFieldAgeMax() {
    return mAgeMax;
  }

  public Targeting setFieldAgeMax(Long value) {
    this.mAgeMax = value;
    return this;
  }

  public Long getFieldAgeMin() {
    return mAgeMin;
  }

  public Targeting setFieldAgeMin(Long value) {
    this.mAgeMin = value;
    return this;
  }

  public String getFieldAlternateAutoTargetingOption() {
    return mAlternateAutoTargetingOption;
  }

  public Targeting setFieldAlternateAutoTargetingOption(String value) {
    this.mAlternateAutoTargetingOption = value;
    return this;
  }

  public String getFieldAppInstallState() {
    return mAppInstallState;
  }

  public Targeting setFieldAppInstallState(String value) {
    this.mAppInstallState = value;
    return this;
  }

  public List<String> getFieldAudienceNetworkPositions() {
    return mAudienceNetworkPositions;
  }

  public Targeting setFieldAudienceNetworkPositions(List<String> value) {
    this.mAudienceNetworkPositions = value;
    return this;
  }

  public List<IDName> getFieldBehaviors() {
    return mBehaviors;
  }

  public Targeting setFieldBehaviors(List<IDName> value) {
    this.mBehaviors = value;
    return this;
  }

  public Targeting setFieldBehaviors(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mBehaviors = IDName.getGson().fromJson(value, type);
    return this;
  }
  public List<String> getFieldBrandSafetyContentFilterLevels() {
    return mBrandSafetyContentFilterLevels;
  }

  public Targeting setFieldBrandSafetyContentFilterLevels(List<String> value) {
    this.mBrandSafetyContentFilterLevels = value;
    return this;
  }

  public List<String> getFieldBrandSafetyContentSeverityLevels() {
    return mBrandSafetyContentSeverityLevels;
  }

  public Targeting setFieldBrandSafetyContentSeverityLevels(List<String> value) {
    this.mBrandSafetyContentSeverityLevels = value;
    return this;
  }

  public CatalogBasedTargeting getFieldCatalogBasedTargeting() {
    return mCatalogBasedTargeting;
  }

  public Targeting setFieldCatalogBasedTargeting(CatalogBasedTargeting value) {
    this.mCatalogBasedTargeting = value;
    return this;
  }

  public Targeting setFieldCatalogBasedTargeting(String value) {
    Type type = new TypeToken<CatalogBasedTargeting>(){}.getType();
    this.mCatalogBasedTargeting = CatalogBasedTargeting.getGson().fromJson(value, type);
    return this;
  }
  public List<IDName> getFieldCities() {
    return mCities;
  }

  public Targeting setFieldCities(List<IDName> value) {
    this.mCities = value;
    return this;
  }

  public Targeting setFieldCities(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mCities = IDName.getGson().fromJson(value, type);
    return this;
  }
  public List<Long> getFieldCollegeYears() {
    return mCollegeYears;
  }

  public Targeting setFieldCollegeYears(List<Long> value) {
    this.mCollegeYears = value;
    return this;
  }

  public List<IDName> getFieldConnections() {
    return mConnections;
  }

  public Targeting setFieldConnections(List<IDName> value) {
    this.mConnections = value;
    return this;
  }

  public Targeting setFieldConnections(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mConnections = IDName.getGson().fromJson(value, type);
    return this;
  }
  public List<IDName> getFieldContextualTargetingCategories() {
    return mContextualTargetingCategories;
  }

  public Targeting setFieldContextualTargetingCategories(List<IDName> value) {
    this.mContextualTargetingCategories = value;
    return this;
  }

  public Targeting setFieldContextualTargetingCategories(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mContextualTargetingCategories = IDName.getGson().fromJson(value, type);
    return this;
  }
  public List<String> getFieldCountries() {
    return mCountries;
  }

  public Targeting setFieldCountries(List<String> value) {
    this.mCountries = value;
    return this;
  }

  public List<String> getFieldCountry() {
    return mCountry;
  }

  public Targeting setFieldCountry(List<String> value) {
    this.mCountry = value;
    return this;
  }

  public List<String> getFieldCountryGroups() {
    return mCountryGroups;
  }

  public Targeting setFieldCountryGroups(List<String> value) {
    this.mCountryGroups = value;
    return this;
  }

  public List<RawCustomAudience> getFieldCustomAudiences() {
    return mCustomAudiences;
  }

  public Targeting setFieldCustomAudiences(List<RawCustomAudience> value) {
    this.mCustomAudiences = value;
    return this;
  }

  public Targeting setFieldCustomAudiences(String value) {
    Type type = new TypeToken<List<RawCustomAudience>>(){}.getType();
    this.mCustomAudiences = RawCustomAudience.getGson().fromJson(value, type);
    return this;
  }
  public List<EnumDevicePlatforms> getFieldDevicePlatforms() {
    return mDevicePlatforms;
  }

  public Targeting setFieldDevicePlatforms(List<EnumDevicePlatforms> value) {
    this.mDevicePlatforms = value;
    return this;
  }

  public Boolean getFieldDirectInstallDevices() {
    return mDirectInstallDevices;
  }

  public Targeting setFieldDirectInstallDevices(Boolean value) {
    this.mDirectInstallDevices = value;
    return this;
  }

  public List<String> getFieldDynamicAudienceIds() {
    return mDynamicAudienceIds;
  }

  public Targeting setFieldDynamicAudienceIds(List<String> value) {
    this.mDynamicAudienceIds = value;
    return this;
  }

  public List<IDName> getFieldEducationMajors() {
    return mEducationMajors;
  }

  public Targeting setFieldEducationMajors(List<IDName> value) {
    this.mEducationMajors = value;
    return this;
  }

  public Targeting setFieldEducationMajors(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mEducationMajors = IDName.getGson().fromJson(value, type);
    return this;
  }
  public List<IDName> getFieldEducationSchools() {
    return mEducationSchools;
  }

  public Targeting setFieldEducationSchools(List<IDName> value) {
    this.mEducationSchools = value;
    return this;
  }

  public Targeting setFieldEducationSchools(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mEducationSchools = IDName.getGson().fromJson(value, type);
    return this;
  }
  public List<Long> getFieldEducationStatuses() {
    return mEducationStatuses;
  }

  public Targeting setFieldEducationStatuses(List<Long> value) {
    this.mEducationStatuses = value;
    return this;
  }

  public List<String> getFieldEffectiveAudienceNetworkPositions() {
    return mEffectiveAudienceNetworkPositions;
  }

  public Targeting setFieldEffectiveAudienceNetworkPositions(List<String> value) {
    this.mEffectiveAudienceNetworkPositions = value;
    return this;
  }

  public List<EnumEffectiveDevicePlatforms> getFieldEffectiveDevicePlatforms() {
    return mEffectiveDevicePlatforms;
  }

  public Targeting setFieldEffectiveDevicePlatforms(List<EnumEffectiveDevicePlatforms> value) {
    this.mEffectiveDevicePlatforms = value;
    return this;
  }

  public List<String> getFieldEffectiveFacebookPositions() {
    return mEffectiveFacebookPositions;
  }

  public Targeting setFieldEffectiveFacebookPositions(List<String> value) {
    this.mEffectiveFacebookPositions = value;
    return this;
  }

  public List<String> getFieldEffectiveInstagramPositions() {
    return mEffectiveInstagramPositions;
  }

  public Targeting setFieldEffectiveInstagramPositions(List<String> value) {
    this.mEffectiveInstagramPositions = value;
    return this;
  }

  public List<String> getFieldEffectiveMessengerPositions() {
    return mEffectiveMessengerPositions;
  }

  public Targeting setFieldEffectiveMessengerPositions(List<String> value) {
    this.mEffectiveMessengerPositions = value;
    return this;
  }

  public List<String> getFieldEffectivePublisherPlatforms() {
    return mEffectivePublisherPlatforms;
  }

  public Targeting setFieldEffectivePublisherPlatforms(List<String> value) {
    this.mEffectivePublisherPlatforms = value;
    return this;
  }

  public List<TargetingDynamicRule> getFieldEngagementSpecs() {
    return mEngagementSpecs;
  }

  public Targeting setFieldEngagementSpecs(List<TargetingDynamicRule> value) {
    this.mEngagementSpecs = value;
    return this;
  }

  public Targeting setFieldEngagementSpecs(String value) {
    Type type = new TypeToken<List<TargetingDynamicRule>>(){}.getType();
    this.mEngagementSpecs = TargetingDynamicRule.getGson().fromJson(value, type);
    return this;
  }
  public List<IDName> getFieldEthnicAffinity() {
    return mEthnicAffinity;
  }

  public Targeting setFieldEthnicAffinity(List<IDName> value) {
    this.mEthnicAffinity = value;
    return this;
  }

  public Targeting setFieldEthnicAffinity(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mEthnicAffinity = IDName.getGson().fromJson(value, type);
    return this;
  }
  public List<String> getFieldExcludeReachedSince() {
    return mExcludeReachedSince;
  }

  public Targeting setFieldExcludeReachedSince(List<String> value) {
    this.mExcludeReachedSince = value;
    return this;
  }

  public List<IDName> getFieldExcludedConnections() {
    return mExcludedConnections;
  }

  public Targeting setFieldExcludedConnections(List<IDName> value) {
    this.mExcludedConnections = value;
    return this;
  }

  public Targeting setFieldExcludedConnections(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mExcludedConnections = IDName.getGson().fromJson(value, type);
    return this;
  }
  public List<IDName> getFieldExcludedCustomAudiences() {
    return mExcludedCustomAudiences;
  }

  public Targeting setFieldExcludedCustomAudiences(List<IDName> value) {
    this.mExcludedCustomAudiences = value;
    return this;
  }

  public Targeting setFieldExcludedCustomAudiences(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mExcludedCustomAudiences = IDName.getGson().fromJson(value, type);
    return this;
  }
  public List<String> getFieldExcludedDynamicAudienceIds() {
    return mExcludedDynamicAudienceIds;
  }

  public Targeting setFieldExcludedDynamicAudienceIds(List<String> value) {
    this.mExcludedDynamicAudienceIds = value;
    return this;
  }

  public List<TargetingDynamicRule> getFieldExcludedEngagementSpecs() {
    return mExcludedEngagementSpecs;
  }

  public Targeting setFieldExcludedEngagementSpecs(List<TargetingDynamicRule> value) {
    this.mExcludedEngagementSpecs = value;
    return this;
  }

  public Targeting setFieldExcludedEngagementSpecs(String value) {
    Type type = new TypeToken<List<TargetingDynamicRule>>(){}.getType();
    this.mExcludedEngagementSpecs = TargetingDynamicRule.getGson().fromJson(value, type);
    return this;
  }
  public TargetingGeoLocation getFieldExcludedGeoLocations() {
    return mExcludedGeoLocations;
  }

  public Targeting setFieldExcludedGeoLocations(TargetingGeoLocation value) {
    this.mExcludedGeoLocations = value;
    return this;
  }

  public Targeting setFieldExcludedGeoLocations(String value) {
    Type type = new TypeToken<TargetingGeoLocation>(){}.getType();
    this.mExcludedGeoLocations = TargetingGeoLocation.getGson().fromJson(value, type);
    return this;
  }
  public List<String> getFieldExcludedMobileDeviceModel() {
    return mExcludedMobileDeviceModel;
  }

  public Targeting setFieldExcludedMobileDeviceModel(List<String> value) {
    this.mExcludedMobileDeviceModel = value;
    return this;
  }

  public List<TargetingProductAudienceSpec> getFieldExcludedProductAudienceSpecs() {
    return mExcludedProductAudienceSpecs;
  }

  public Targeting setFieldExcludedProductAudienceSpecs(List<TargetingProductAudienceSpec> value) {
    this.mExcludedProductAudienceSpecs = value;
    return this;
  }

  public Targeting setFieldExcludedProductAudienceSpecs(String value) {
    Type type = new TypeToken<List<TargetingProductAudienceSpec>>(){}.getType();
    this.mExcludedProductAudienceSpecs = TargetingProductAudienceSpec.getGson().fromJson(value, type);
    return this;
  }
  public List<String> getFieldExcludedPublisherCategories() {
    return mExcludedPublisherCategories;
  }

  public Targeting setFieldExcludedPublisherCategories(List<String> value) {
    this.mExcludedPublisherCategories = value;
    return this;
  }

  public List<String> getFieldExcludedPublisherListIds() {
    return mExcludedPublisherListIds;
  }

  public Targeting setFieldExcludedPublisherListIds(List<String> value) {
    this.mExcludedPublisherListIds = value;
    return this;
  }

  public List<String> getFieldExcludedUserDevice() {
    return mExcludedUserDevice;
  }

  public Targeting setFieldExcludedUserDevice(List<String> value) {
    this.mExcludedUserDevice = value;
    return this;
  }

  public FlexibleTargeting getFieldExclusions() {
    return mExclusions;
  }

  public Targeting setFieldExclusions(FlexibleTargeting value) {
    this.mExclusions = value;
    return this;
  }

  public Targeting setFieldExclusions(String value) {
    Type type = new TypeToken<FlexibleTargeting>(){}.getType();
    this.mExclusions = FlexibleTargeting.getGson().fromJson(value, type);
    return this;
  }
  public List<String> getFieldFacebookPositions() {
    return mFacebookPositions;
  }

  public Targeting setFieldFacebookPositions(List<String> value) {
    this.mFacebookPositions = value;
    return this;
  }

  public List<IDName> getFieldFamilyStatuses() {
    return mFamilyStatuses;
  }

  public Targeting setFieldFamilyStatuses(List<IDName> value) {
    this.mFamilyStatuses = value;
    return this;
  }

  public Targeting setFieldFamilyStatuses(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mFamilyStatuses = IDName.getGson().fromJson(value, type);
    return this;
  }
  public String getFieldFbDealId() {
    return mFbDealId;
  }

  public Targeting setFieldFbDealId(String value) {
    this.mFbDealId = value;
    return this;
  }

  public List<FlexibleTargeting> getFieldFlexibleSpec() {
    return mFlexibleSpec;
  }

  public Targeting setFieldFlexibleSpec(List<FlexibleTargeting> value) {
    this.mFlexibleSpec = value;
    return this;
  }

  public Targeting setFieldFlexibleSpec(String value) {
    Type type = new TypeToken<List<FlexibleTargeting>>(){}.getType();
    this.mFlexibleSpec = FlexibleTargeting.getGson().fromJson(value, type);
    return this;
  }
  public List<IDName> getFieldFriendsOfConnections() {
    return mFriendsOfConnections;
  }

  public Targeting setFieldFriendsOfConnections(List<IDName> value) {
    this.mFriendsOfConnections = value;
    return this;
  }

  public Targeting setFieldFriendsOfConnections(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mFriendsOfConnections = IDName.getGson().fromJson(value, type);
    return this;
  }
  public List<Long> getFieldGenders() {
    return mGenders;
  }

  public Targeting setFieldGenders(List<Long> value) {
    this.mGenders = value;
    return this;
  }

  public List<IDName> getFieldGeneration() {
    return mGeneration;
  }

  public Targeting setFieldGeneration(List<IDName> value) {
    this.mGeneration = value;
    return this;
  }

  public Targeting setFieldGeneration(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mGeneration = IDName.getGson().fromJson(value, type);
    return this;
  }
  public TargetingGeoLocation getFieldGeoLocations() {
    return mGeoLocations;
  }

  public Targeting setFieldGeoLocations(TargetingGeoLocation value) {
    this.mGeoLocations = value;
    return this;
  }

  public Targeting setFieldGeoLocations(String value) {
    Type type = new TypeToken<TargetingGeoLocation>(){}.getType();
    this.mGeoLocations = TargetingGeoLocation.getGson().fromJson(value, type);
    return this;
  }
  public List<IDName> getFieldHomeOwnership() {
    return mHomeOwnership;
  }

  public Targeting setFieldHomeOwnership(List<IDName> value) {
    this.mHomeOwnership = value;
    return this;
  }

  public Targeting setFieldHomeOwnership(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mHomeOwnership = IDName.getGson().fromJson(value, type);
    return this;
  }
  public List<IDName> getFieldHomeType() {
    return mHomeType;
  }

  public Targeting setFieldHomeType(List<IDName> value) {
    this.mHomeType = value;
    return this;
  }

  public Targeting setFieldHomeType(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mHomeType = IDName.getGson().fromJson(value, type);
    return this;
  }
  public List<IDName> getFieldHomeValue() {
    return mHomeValue;
  }

  public Targeting setFieldHomeValue(List<IDName> value) {
    this.mHomeValue = value;
    return this;
  }

  public Targeting setFieldHomeValue(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mHomeValue = IDName.getGson().fromJson(value, type);
    return this;
  }
  public List<IDName> getFieldHouseholdComposition() {
    return mHouseholdComposition;
  }

  public Targeting setFieldHouseholdComposition(List<IDName> value) {
    this.mHouseholdComposition = value;
    return this;
  }

  public Targeting setFieldHouseholdComposition(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mHouseholdComposition = IDName.getGson().fromJson(value, type);
    return this;
  }
  public List<IDName> getFieldIncome() {
    return mIncome;
  }

  public Targeting setFieldIncome(List<IDName> value) {
    this.mIncome = value;
    return this;
  }

  public Targeting setFieldIncome(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mIncome = IDName.getGson().fromJson(value, type);
    return this;
  }
  public List<IDName> getFieldIndustries() {
    return mIndustries;
  }

  public Targeting setFieldIndustries(List<IDName> value) {
    this.mIndustries = value;
    return this;
  }

  public Targeting setFieldIndustries(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mIndustries = IDName.getGson().fromJson(value, type);
    return this;
  }
  public List<String> getFieldInstagramPositions() {
    return mInstagramPositions;
  }

  public Targeting setFieldInstagramPositions(List<String> value) {
    this.mInstagramPositions = value;
    return this;
  }

  public List<String> getFieldInstreamVideoSponsorshipPlacements() {
    return mInstreamVideoSponsorshipPlacements;
  }

  public Targeting setFieldInstreamVideoSponsorshipPlacements(List<String> value) {
    this.mInstreamVideoSponsorshipPlacements = value;
    return this;
  }

  public List<Long> getFieldInterestedIn() {
    return mInterestedIn;
  }

  public Targeting setFieldInterestedIn(List<Long> value) {
    this.mInterestedIn = value;
    return this;
  }

  public List<IDName> getFieldInterests() {
    return mInterests;
  }

  public Targeting setFieldInterests(List<IDName> value) {
    this.mInterests = value;
    return this;
  }

  public Targeting setFieldInterests(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mInterests = IDName.getGson().fromJson(value, type);
    return this;
  }
  public Boolean getFieldIsWhatsappDestinationAd() {
    return mIsWhatsappDestinationAd;
  }

  public Targeting setFieldIsWhatsappDestinationAd(Boolean value) {
    this.mIsWhatsappDestinationAd = value;
    return this;
  }

  public List<String> getFieldKeywords() {
    return mKeywords;
  }

  public Targeting setFieldKeywords(List<String> value) {
    this.mKeywords = value;
    return this;
  }

  public List<IDName> getFieldLifeEvents() {
    return mLifeEvents;
  }

  public Targeting setFieldLifeEvents(List<IDName> value) {
    this.mLifeEvents = value;
    return this;
  }

  public Targeting setFieldLifeEvents(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mLifeEvents = IDName.getGson().fromJson(value, type);
    return this;
  }
  public List<Long> getFieldLocales() {
    return mLocales;
  }

  public Targeting setFieldLocales(List<Long> value) {
    this.mLocales = value;
    return this;
  }

  public List<String> getFieldMessengerPositions() {
    return mMessengerPositions;
  }

  public Targeting setFieldMessengerPositions(List<String> value) {
    this.mMessengerPositions = value;
    return this;
  }

  public List<IDName> getFieldMoms() {
    return mMoms;
  }

  public Targeting setFieldMoms(List<IDName> value) {
    this.mMoms = value;
    return this;
  }

  public Targeting setFieldMoms(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mMoms = IDName.getGson().fromJson(value, type);
    return this;
  }
  public List<IDName> getFieldNetWorth() {
    return mNetWorth;
  }

  public Targeting setFieldNetWorth(List<IDName> value) {
    this.mNetWorth = value;
    return this;
  }

  public Targeting setFieldNetWorth(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mNetWorth = IDName.getGson().fromJson(value, type);
    return this;
  }
  public List<IDName> getFieldOfficeType() {
    return mOfficeType;
  }

  public Targeting setFieldOfficeType(List<IDName> value) {
    this.mOfficeType = value;
    return this;
  }

  public Targeting setFieldOfficeType(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mOfficeType = IDName.getGson().fromJson(value, type);
    return this;
  }
  public List<String> getFieldPlacePageSetIds() {
    return mPlacePageSetIds;
  }

  public Targeting setFieldPlacePageSetIds(List<String> value) {
    this.mPlacePageSetIds = value;
    return this;
  }

  public List<Long> getFieldPoliticalViews() {
    return mPoliticalViews;
  }

  public Targeting setFieldPoliticalViews(List<Long> value) {
    this.mPoliticalViews = value;
    return this;
  }

  public List<IDName> getFieldPolitics() {
    return mPolitics;
  }

  public Targeting setFieldPolitics(List<IDName> value) {
    this.mPolitics = value;
    return this;
  }

  public Targeting setFieldPolitics(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mPolitics = IDName.getGson().fromJson(value, type);
    return this;
  }
  public List<TargetingProductAudienceSpec> getFieldProductAudienceSpecs() {
    return mProductAudienceSpecs;
  }

  public Targeting setFieldProductAudienceSpecs(List<TargetingProductAudienceSpec> value) {
    this.mProductAudienceSpecs = value;
    return this;
  }

  public Targeting setFieldProductAudienceSpecs(String value) {
    Type type = new TypeToken<List<TargetingProductAudienceSpec>>(){}.getType();
    this.mProductAudienceSpecs = TargetingProductAudienceSpec.getGson().fromJson(value, type);
    return this;
  }
  public TargetingProspectingAudience getFieldProspectingAudience() {
    return mProspectingAudience;
  }

  public Targeting setFieldProspectingAudience(TargetingProspectingAudience value) {
    this.mProspectingAudience = value;
    return this;
  }

  public Targeting setFieldProspectingAudience(String value) {
    Type type = new TypeToken<TargetingProspectingAudience>(){}.getType();
    this.mProspectingAudience = TargetingProspectingAudience.getGson().fromJson(value, type);
    return this;
  }
  public List<String> getFieldPublisherPlatforms() {
    return mPublisherPlatforms;
  }

  public Targeting setFieldPublisherPlatforms(List<String> value) {
    this.mPublisherPlatforms = value;
    return this;
  }

  public List<String> getFieldPublisherVisibilityCategories() {
    return mPublisherVisibilityCategories;
  }

  public Targeting setFieldPublisherVisibilityCategories(List<String> value) {
    this.mPublisherVisibilityCategories = value;
    return this;
  }

  public String getFieldRadius() {
    return mRadius;
  }

  public Targeting setFieldRadius(String value) {
    this.mRadius = value;
    return this;
  }

  public List<IDName> getFieldRegions() {
    return mRegions;
  }

  public Targeting setFieldRegions(List<IDName> value) {
    this.mRegions = value;
    return this;
  }

  public Targeting setFieldRegions(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mRegions = IDName.getGson().fromJson(value, type);
    return this;
  }
  public List<Long> getFieldRelationshipStatuses() {
    return mRelationshipStatuses;
  }

  public Targeting setFieldRelationshipStatuses(List<Long> value) {
    this.mRelationshipStatuses = value;
    return this;
  }

  public List<String> getFieldSiteCategory() {
    return mSiteCategory;
  }

  public Targeting setFieldSiteCategory(List<String> value) {
    this.mSiteCategory = value;
    return this;
  }

  public String getFieldTargetingOptimization() {
    return mTargetingOptimization;
  }

  public Targeting setFieldTargetingOptimization(String value) {
    this.mTargetingOptimization = value;
    return this;
  }

  public List<IDName> getFieldUserAdclusters() {
    return mUserAdclusters;
  }

  public Targeting setFieldUserAdclusters(List<IDName> value) {
    this.mUserAdclusters = value;
    return this;
  }

  public Targeting setFieldUserAdclusters(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mUserAdclusters = IDName.getGson().fromJson(value, type);
    return this;
  }
  public List<String> getFieldUserDevice() {
    return mUserDevice;
  }

  public Targeting setFieldUserDevice(List<String> value) {
    this.mUserDevice = value;
    return this;
  }

  public List<Long> getFieldUserEvent() {
    return mUserEvent;
  }

  public Targeting setFieldUserEvent(List<Long> value) {
    this.mUserEvent = value;
    return this;
  }

  public List<String> getFieldUserOs() {
    return mUserOs;
  }

  public Targeting setFieldUserOs(List<String> value) {
    this.mUserOs = value;
    return this;
  }

  public List<String> getFieldWirelessCarrier() {
    return mWirelessCarrier;
  }

  public Targeting setFieldWirelessCarrier(List<String> value) {
    this.mWirelessCarrier = value;
    return this;
  }

  public List<IDName> getFieldWorkEmployers() {
    return mWorkEmployers;
  }

  public Targeting setFieldWorkEmployers(List<IDName> value) {
    this.mWorkEmployers = value;
    return this;
  }

  public Targeting setFieldWorkEmployers(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mWorkEmployers = IDName.getGson().fromJson(value, type);
    return this;
  }
  public List<IDName> getFieldWorkPositions() {
    return mWorkPositions;
  }

  public Targeting setFieldWorkPositions(List<IDName> value) {
    this.mWorkPositions = value;
    return this;
  }

  public Targeting setFieldWorkPositions(String value) {
    Type type = new TypeToken<List<IDName>>(){}.getType();
    this.mWorkPositions = IDName.getGson().fromJson(value, type);
    return this;
  }
  public List<String> getFieldZips() {
    return mZips;
  }

  public Targeting setFieldZips(List<String> value) {
    this.mZips = value;
    return this;
  }



  public static enum EnumDevicePlatforms {
      @SerializedName(""connected_tv"")
      VALUE_CONNECTED_TV(""connected_tv""),
      @SerializedName(""desktop"")
      VALUE_DESKTOP(""desktop""),
      @SerializedName(""mobile"")
      VALUE_MOBILE(""mobile""),
      NULL(null);

      private String value;

      private EnumDevicePlatforms(String value) {
        this.value = value;
      }

      @Override
      public String toString() {
        return value;
      }
  }

  public static enum EnumEffectiveDevicePlatforms {
      @SerializedName(""connected_tv"")
      VALUE_CONNECTED_TV(""connected_tv""),
      @SerializedName(""desktop"")
      VALUE_DESKTOP(""desktop""),
      @SerializedName(""mobile"")
      VALUE_MOBILE(""mobile""),
      NULL(null);

      private String value;

      private EnumEffectiveDevicePlatforms(String value) {
        this.value = value;
      }

      @Override
      public String toString() {
        return value;
      }
  }


  synchronized /*package*/ static Gson getGson() {
    if (gson != null) {
      return gson;
    } else {
      gson = new GsonBuilder()
        .excludeFieldsWithModifiers(Modifier.STATIC)
        .excludeFieldsWithModifiers(Modifier.PROTECTED)
        .disableHtmlEscaping()
        .create();
    }
    return gson;
  }

  public Targeting copyFrom(Targeting instance) {
    this.mAdgroupId = instance.mAdgroupId;
    this.mAgeMax = instance.mAgeMax;
    this.mAgeMin = instance.mAgeMin;
    this.mAlternateAutoTargetingOption = instance.mAlternateAutoTargetingOption;
    this.mAppInstallState = instance.mAppInstallState;
    this.mAudienceNetworkPositions = instance.mAudienceNetworkPositions;
    this.mBehaviors = instance.mBehaviors;
    this.mBrandSafetyContentFilterLevels = instance.mBrandSafetyContentFilterLevels;
    this.mBrandSafetyContentSeverityLevels = instance.mBrandSafetyContentSeverityLevels;
    this.mCatalogBasedTargeting = instance.mCatalogBasedTargeting;
    this.mCities = instance.mCities;
    this.mCollegeYears = instance.mCollegeYears;
    this.mConnections = instance.mConnections;
    this.mContextualTargetingCategories = instance.mContextualTargetingCategories;
    this.mCountries = instance.mCountries;
    this.mCountry = instance.mCountry;
    this.mCountryGroups = instance.mCountryGroups;
    this.mCustomAudiences = instance.mCustomAudiences;
    this.mDevicePlatforms = instance.mDevicePlatforms;
    this.mDirectInstallDevices = instance.mDirectInstallDevices;
    this.mDynamicAudienceIds = instance.mDynamicAudienceIds;
    this.mEducationMajors = instance.mEducationMajors;
    this.mEducationSchools = instance.mEducationSchools;
    this.mEducationStatuses = instance.mEducationStatuses;
    this.mEffectiveAudienceNetworkPositions = instance.mEffectiveAudienceNetworkPositions;
    this.mEffectiveDevicePlatforms = instance.mEffectiveDevicePlatforms;
    this.mEffectiveFacebookPositions = instance.mEffectiveFacebookPositions;
    this.mEffectiveInstagramPositions = instance.mEffectiveInstagramPositions;
    this.mEffectiveMessengerPositions = instance.mEffectiveMessengerPositions;
    this.mEffectivePublisherPlatforms = instance.mEffectivePublisherPlatforms;
    this.mEngagementSpecs = instance.mEngagementSpecs;
    this.mEthnicAffinity = instance.mEthnicAffinity;
    this.mExcludeReachedSince = instance.mExcludeReachedSince;
    this.mExcludedConnections = instance.mExcludedConnections;
    this.mExcludedCustomAudiences = instance.mExcludedCustomAudiences;
    this.mExcludedDynamicAudienceIds = instance.mExcludedDynamicAudienceIds;
    this.mExcludedEngagementSpecs = instance.mExcludedEngagementSpecs;
    this.mExcludedGeoLocations = instance.mExcludedGeoLocations;
    this.mExcludedMobileDeviceModel = instance.mExcludedMobileDeviceModel;
    this.mExcludedProductAudienceSpecs = instance.mExcludedProductAudienceSpecs;
    this.mExcludedPublisherCategories = instance.mExcludedPublisherCategories;
    this.mExcludedPublisherListIds = instance.mExcludedPublisherListIds;
    this.mExcludedUserDevice = instance.mExcludedUserDevice;
    this.mExclusions = instance.mExclusions;
    this.mFacebookPositions = instance.mFacebookPositions;
    this.mFamilyStatuses = instance.mFamilyStatuses;
    this.mFbDealId = instance.mFbDealId;
    this.mFlexibleSpec = instance.mFlexibleSpec;
    this.mFriendsOfConnections = instance.mFriendsOfConnections;
    this.mGenders = instance.mGenders;
    this.mGeneration = instance.mGeneration;
    this.mGeoLocations = instance.mGeoLocations;
    this.mHomeOwnership = instance.mHomeOwnership;
    this.mHomeType = instance.mHomeType;
    this.mHomeValue = instance.mHomeValue;
    this.mHouseholdComposition = instance.mHouseholdComposition;
    this.mIncome = instance.mIncome;
    this.mIndustries = instance.mIndustries;
    this.mInstagramPositions = instance.mInstagramPositions;
    this.mInstreamVideoSponsorshipPlacements = instance.mInstreamVideoSponsorshipPlacements;
    this.mInterestedIn = instance.mInterestedIn;
    this.mInterests = instance.mInterests;
    this.mIsWhatsappDestinationAd = instance.mIsWhatsappDestinationAd;
    this.mKeywords = instance.mKeywords;
    this.mLifeEvents = instance.mLifeEvents;
    this.mLocales = instance.mLocales;
    this.mMessengerPositions = instance.mMessengerPositions;
    this.mMoms = instance.mMoms;
    this.mNetWorth = instance.mNetWorth;
    this.mOfficeType = instance.mOfficeType;
    this.mPlacePageSetIds = instance.mPlacePageSetIds;
    this.mPoliticalViews = instance.mPoliticalViews;
    this.mPolitics = instance.mPolitics;
    this.mProductAudienceSpecs = instance.mProductAudienceSpecs;
    this.mProspectingAudience = instance.mProspectingAudience;
    this.mPublisherPlatforms = instance.mPublisherPlatforms;
    this.mPublisherVisibilityCategories = instance.mPublisherVisibilityCategories;
    this.mRadius = instance.mRadius;
    this.mRegions = instance.mRegions;
    this.mRelationshipStatuses = instance.mRelationshipStatuses;
    this.mSiteCategory = instance.mSiteCategory;
    this.mTargetingOptimization = instance.mTargetingOptimization;
    this.mUserAdclusters = instance.mUserAdclusters;
    this.mUserDevice = instance.mUserDevice;
    this.mUserEvent = instance.mUserEvent;
    this.mUserOs = instance.mUserOs;
    this.mWirelessCarrier = instance.mWirelessCarrier;
    this.mWorkEmployers = instance.mWorkEmployers;
    this.mWorkPositions = instance.mWorkPositions;
    this.mZips = instance.mZips;
    this.context = instance.context;
    this.rawValue = instance.rawValue;
    return this;
  }

  public static APIRequest.ResponseParser<Targeting> getParser() {
    return new APIRequest.ResponseParser<Targeting>() {
      public APINodeList<Targeting> parseResponse(String response, APIContext context, APIRequest<Targeting> request, String header) throws MalformedResponseException {
        return Targeting.parseResponse(response, context, request, header);
      }
    };
  }
}
",data class
512,"@XmlRootElement(name=""mqtt"")
@XmlAccessorType(XmlAccessType.FIELD)
public class MqttDTO extends ProtocolDTO {

    @XmlAttribute(name=""max_message_length"")
    public Integer max_message_length;

    @XmlElementRef
    public List<ProtocolFilterDTO> protocol_filters = new ArrayList<ProtocolFilterDTO>();

    @XmlAttribute(name=""queue_prefix"")
    public String queue_prefix;

    @XmlAttribute(name=""path_separator"")
    public String path_separator;

    @XmlAttribute(name=""any_child_wildcard"")
    public String any_child_wildcard;

    @XmlAttribute(name=""any_descendant_wildcard"")
    public String any_descendant_wildcard;

    @XmlAttribute(name=""regex_wildcard_start"")
    public String regex_wildcard_start;

    @XmlAttribute(name=""regex_wildcard_end"")
    public String regex_wildcard_end;

    @XmlAttribute(name=""part_pattern"")
    public String part_pattern;

    @XmlAttribute(name=""die_delay"")
    public Long die_delay;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;

        MqttDTO mqttDTO = (MqttDTO) o;

        if (any_child_wildcard != null ? !any_child_wildcard.equals(mqttDTO.any_child_wildcard) : mqttDTO.any_child_wildcard != null)
            return false;
        if (any_descendant_wildcard != null ? !any_descendant_wildcard.equals(mqttDTO.any_descendant_wildcard) : mqttDTO.any_descendant_wildcard != null)
            return false;
        if (max_message_length != null ? !max_message_length.equals(mqttDTO.max_message_length) : mqttDTO.max_message_length != null)
            return false;
        if (path_separator != null ? !path_separator.equals(mqttDTO.path_separator) : mqttDTO.path_separator != null)
            return false;
        if (protocol_filters != null ? !protocol_filters.equals(mqttDTO.protocol_filters) : mqttDTO.protocol_filters != null)
            return false;
        if (queue_prefix != null ? !queue_prefix.equals(mqttDTO.queue_prefix) : mqttDTO.queue_prefix != null)
            return false;
        if (regex_wildcard_end != null ? !regex_wildcard_end.equals(mqttDTO.regex_wildcard_end) : mqttDTO.regex_wildcard_end != null)
            return false;
        if (regex_wildcard_start != null ? !regex_wildcard_start.equals(mqttDTO.regex_wildcard_start) : mqttDTO.regex_wildcard_start != null)
            return false;
        if (part_pattern != null ? !part_pattern.equals(mqttDTO.part_pattern) : mqttDTO.part_pattern != null)
            return false;

        return true;
    }

    @Override
    public int hashCode() {
        int result = super.hashCode();
        result = 31 * result + (max_message_length != null ? max_message_length.hashCode() : 0);
        result = 31 * result + (protocol_filters != null ? protocol_filters.hashCode() : 0);
        result = 31 * result + (queue_prefix != null ? queue_prefix.hashCode() : 0);
        result = 31 * result + (part_pattern != null ? part_pattern.hashCode() : 0);
        result = 31 * result + (path_separator != null ? path_separator.hashCode() : 0);
        result = 31 * result + (any_child_wildcard != null ? any_child_wildcard.hashCode() : 0);
        result = 31 * result + (any_descendant_wildcard != null ? any_descendant_wildcard.hashCode() : 0);
        result = 31 * result + (regex_wildcard_start != null ? regex_wildcard_start.hashCode() : 0);
        result = 31 * result + (regex_wildcard_end != null ? regex_wildcard_end.hashCode() : 0);
        return result;
    }
}
",data class
29,"@XmlRegistry
public class ObjectFactory {

  /**
   * Create an instance of {@link LWM2M }
   * 
   */
  public LWM2M createLWM2M() {
    return new LWM2M();
  }

  /**
   * Create an instance of {@link LWM2M.Object }
   * 
   */
  public LWM2M.Object createLWM2MObject() {
    return new LWM2M.Object();
  }

  /**
   * Create an instance of {@link LWM2M.Object.Resources }
   * 
   */
  public LWM2M.Object.Resources createLWM2MObjectResources() {
    return new LWM2M.Object.Resources();
  }

  /**
   * Create an instance of {@link LWM2M.Object.Resources.Item }
   * 
   */
  public LWM2M.Object.Resources.Item createLWM2MObjectResourcesItem() {
    return new LWM2M.Object.Resources.Item();
  }

}
",data class
1150,"public class TezClientUtils {

  private static Log LOG = LogFactory.getLog(TezClientUtils.class);
  private static final int UTF8_CHUNK_SIZE = 16 * 1024;

  /**
   * Setup LocalResource map for Tez jars based on provided Configuration
   * 
   * @param conf
   *          Configuration to use to access Tez jars' locations
   * @param credentials
   *          a credentials instance into which tokens for the Tez local
   *          resources will be populated
   * @return Map of LocalResources to use when launching Tez AM
   * @throws IOException
   */
  static Map<String, LocalResource> setupTezJarsLocalResources(
      TezConfiguration conf, Credentials credentials)
      throws IOException {
    Preconditions.checkNotNull(credentials, ""A non-null credentials object should be specified"");
    Map<String, LocalResource> tezJarResources = new HashMap<String, LocalResource>();

    if (conf.getBoolean(TezConfiguration.TEZ_IGNORE_LIB_URIS, false)){
      LOG.info(""Ignoring '"" + TezConfiguration.TEZ_LIB_URIS + ""' since  '"" + 
            TezConfiguration.TEZ_IGNORE_LIB_URIS + ""' is set to true"");
    } else {
      // Add tez jars to local resource
      String[] tezJarUris = conf.getStrings(TezConfiguration.TEZ_LIB_URIS);
        
      if (tezJarUris == null || tezJarUris.length == 0) {
        throw new TezUncheckedException(""Invalid configuration of tez jars""
            + "", "" + TezConfiguration.TEZ_LIB_URIS
            + "" is not defined in the configurartion"");
      }
     
      List<Path> tezJarPaths = Lists.newArrayListWithCapacity(tezJarUris.length);

      for (String tezJarUri : tezJarUris) {
        URI uri;
        try {
          uri = new URI(tezJarUri.trim());
        } catch (URISyntaxException e) {
          String message = ""Invalid URI defined in configuration for""
              + "" location of TEZ jars. providedURI="" + tezJarUri;
          LOG.error(message);
          throw new TezUncheckedException(message, e);
        }
        if (!uri.isAbsolute()) {
          String message = ""Non-absolute URI defined in configuration for""
              + "" location of TEZ jars. providedURI="" + tezJarUri;
          LOG.error(message);
          throw new TezUncheckedException(message);
        }
        Path p = new Path(uri);
        FileSystem pathfs = p.getFileSystem(conf);
        p = pathfs.makeQualified(p);
        tezJarPaths.add(p);
        RemoteIterator<LocatedFileStatus> iter = pathfs.listFiles(p, false);
        while (iter.hasNext()) {
          LocatedFileStatus fStatus = iter.next();
          String rsrcName = fStatus.getPath().getName();
          // FIXME currently not checking for duplicates due to quirks
          // in assembly generation
          if (tezJarResources.containsKey(rsrcName)) {
            String message = ""Duplicate resource found""
                + "", resourceName="" + rsrcName
                + "", existingPath="" +
                tezJarResources.get(rsrcName).getResource().toString()
                + "", newPath="" + fStatus.getPath();
            LOG.warn(message);
            // throw new TezUncheckedException(message);
          }
          tezJarResources.put(rsrcName,
              LocalResource.newInstance(
                  ConverterUtils.getYarnUrlFromPath(fStatus.getPath()),
                  LocalResourceType.FILE,
                  LocalResourceVisibility.PUBLIC,
                  fStatus.getLen(),
                  fStatus.getModificationTime()));
        }
      }
      
      if (tezJarResources.isEmpty()) {
        throw new TezUncheckedException(
            ""No files found in locations specified in ""
                + TezConfiguration.TEZ_LIB_URIS + "" . Locations: ""
                + StringUtils.join(tezJarUris, ','));
      } else {
        // Obtain credentials.
        TokenCache.obtainTokensForFileSystems(credentials,
            tezJarPaths.toArray(new Path[tezJarPaths.size()]), conf);
      }
    }
   
    return tezJarResources;
  }

  static void processTezLocalCredentialsFile(Credentials credentials, Configuration conf)
      throws IOException {
    String path = conf.get(TezJobConfig.TEZ_CREDENTIALS_PATH);
    if (path == null) {
      return;
    } else {
      TokenCache.mergeBinaryTokens(credentials, conf, path);
    }
  }

  /**
   * Verify or create the Staging area directory on the configured Filesystem
   * @param stagingArea Staging area directory path
   * @return the FileSytem for the staging area directory
   * @throws IOException
   */
  public static FileSystem ensureStagingDirExists(Configuration conf,
      Path stagingArea)
      throws IOException {
    FileSystem fs = stagingArea.getFileSystem(conf);
    String realUser;
    String currentUser;
    UserGroupInformation ugi = UserGroupInformation.getLoginUser();
    realUser = ugi.getShortUserName();
    currentUser = UserGroupInformation.getCurrentUser().getShortUserName();
    if (fs.exists(stagingArea)) {
      FileStatus fsStatus = fs.getFileStatus(stagingArea);
      String owner = fsStatus.getOwner();
      if (!(owner.equals(currentUser) || owner.equals(realUser))) {
        throw new IOException(""The ownership on the staging directory ""
            + stagingArea + "" is not as expected. "" + ""It is owned by "" + owner
            + "". The directory must "" + ""be owned by the submitter ""
            + currentUser + "" or "" + ""by "" + realUser);
      }
      if (!fsStatus.getPermission().equals(TezCommonUtils.TEZ_AM_DIR_PERMISSION)) {
        LOG.info(""Permissions on staging directory "" + stagingArea + "" are ""
            + ""incorrect: "" + fsStatus.getPermission()
            + "". Fixing permissions "" + ""to correct value ""
            + TezCommonUtils.TEZ_AM_DIR_PERMISSION);
        fs.setPermission(stagingArea, TezCommonUtils.TEZ_AM_DIR_PERMISSION);
      }
    } else {
      TezCommonUtils.mkDirForAM(fs, stagingArea);
    }
    return fs;
  }

  /**
   * Obtains tokens for the DAG based on the list of URIs setup in the DAG. The
   * fetched credentials are populated back into the DAG and can be retrieved
   * via dag.getCredentials
   * 
   * @param dag
   *          the dag for which credentials need to be setup
   * @param sessionCredentials
   *          session credentials which have already been obtained, and will be
   *          required for the DAG
   * @param conf
   * @throws IOException
   */
  @Private
  static void setupDAGCredentials(DAG dag, Credentials sessionCredentials,
      Configuration conf) throws IOException {

    Preconditions.checkNotNull(sessionCredentials);
    LogUtils.logCredentials(LOG, sessionCredentials, ""session"");

    Credentials dagCredentials = dag.getCredentials();
    if (dagCredentials == null) {
      dagCredentials = new Credentials();
      dag.setCredentials(dagCredentials);
    }
    // All session creds are required for the DAG.
    dagCredentials.mergeAll(sessionCredentials);
    
    // Add additional credentials based on any URIs that the user may have specified.
    
    // Obtain Credentials for any paths that the user may have configured.
    Collection<URI> uris = dag.getURIsForCredentials();
    if (uris != null && !uris.isEmpty()) {
      Iterator<Path> pathIter = Iterators.transform(uris.iterator(), new Function<URI, Path>() {
        @Override
        public Path apply(URI input) {
          return new Path(input);
        }
      });

      Path[] paths = Iterators.toArray(pathIter, Path.class);
      TokenCache.obtainTokensForFileSystems(dagCredentials, paths, conf);
    }

    // Obtain Credentials for the local resources configured on the DAG
    try {
      Set<Path> lrPaths = new HashSet<Path>();
      for (Vertex v: dag.getVertices()) {
        for (LocalResource lr: v.getTaskLocalFiles().values()) {
          lrPaths.add(ConverterUtils.getPathFromYarnURL(lr.getResource()));
        }
      }

      Path[] paths = lrPaths.toArray(new Path[lrPaths.size()]);
      TokenCache.obtainTokensForFileSystems(dagCredentials, paths, conf);

    } catch (URISyntaxException e) {
      throw new IOException(e);
    }
  }

  /**
   * Create an ApplicationSubmissionContext to launch a Tez AM
   * @param conf TezConfiguration
   * @param appId Application Id
   * @param dag DAG to be submitted
   * @param amName Name for the application
   * @param amConfig AM Configuration
   * @param tezJarResources Resources to be used by the AM
   * @param sessionCreds the credential object which will be populated with session specific
   * @return an ApplicationSubmissionContext to launch a Tez AM
   * @throws IOException
   * @throws YarnException
   */
  static ApplicationSubmissionContext createApplicationSubmissionContext(
      TezConfiguration conf, ApplicationId appId, DAG dag, String amName,
      AMConfiguration amConfig, Map<String, LocalResource> tezJarResources,
      Credentials sessionCreds)
          throws IOException, YarnException{

    Preconditions.checkNotNull(sessionCreds);

    FileSystem fs = TezClientUtils.ensureStagingDirExists(conf,
        TezCommonUtils.getTezBaseStagingPath(conf));
    String strAppId = appId.toString();
    Path tezSysStagingPath = TezCommonUtils.createTezSystemStagingPath(conf, strAppId);
    Path binaryConfPath = TezCommonUtils.getTezConfStagingPath(tezSysStagingPath);
    binaryConfPath = fs.makeQualified(binaryConfPath);

    // Setup resource requirements
    Resource capability = Records.newRecord(Resource.class);
    capability.setMemory(
        amConfig.getTezConfiguration().getInt(TezConfiguration.TEZ_AM_RESOURCE_MEMORY_MB,
            TezConfiguration.TEZ_AM_RESOURCE_MEMORY_MB_DEFAULT));
    capability.setVirtualCores(
        amConfig.getTezConfiguration().getInt(TezConfiguration.TEZ_AM_RESOURCE_CPU_VCORES,
            TezConfiguration.TEZ_AM_RESOURCE_CPU_VCORES_DEFAULT));
    if (LOG.isDebugEnabled()) {
      LOG.debug(""AppMaster capability = "" + capability);
    }

    // Setup required Credentials for the AM launch. DAG specific credentials
    // are handled separately.
    ByteBuffer securityTokens = null;
    // Setup security tokens
    Credentials amLaunchCredentials = new Credentials();
    if (amConfig.getCredentials() != null) {
      amLaunchCredentials.addAll(amConfig.getCredentials());
    }

    // Add Staging dir creds to the list of session credentials.
    TokenCache.obtainTokensForFileSystems(sessionCreds, new Path[] {binaryConfPath}, conf);

    // Add session specific credentials to the AM credentials.
    amLaunchCredentials.mergeAll(sessionCreds);

    DataOutputBuffer dob = new DataOutputBuffer();
    amLaunchCredentials.writeTokenStorageToStream(dob);
    securityTokens = ByteBuffer.wrap(dob.getData(), 0, dob.getLength());

    // Need to set credentials based on DAG and the URIs which have been set for the DAG.

    if (dag != null) {
      setupDAGCredentials(dag, sessionCreds, conf);
    }

    // Setup the command to run the AM
    List<String> vargs = new ArrayList<String>(8);
    vargs.add(Environment.JAVA_HOME.$() + ""/bin/java"");

    String amOpts = amConfig.getTezConfiguration().get(
        TezConfiguration.TEZ_AM_LAUNCH_CMD_OPTS,
        TezConfiguration.TEZ_AM_LAUNCH_CMD_OPTS_DEFAULT);
    amOpts = maybeAddDefaultMemoryJavaOpts(amOpts, capability,
        amConfig.getTezConfiguration().getDouble(TezConfiguration.TEZ_CONTAINER_MAX_JAVA_HEAP_FRACTION,
            TezConfiguration.TEZ_CONTAINER_MAX_JAVA_HEAP_FRACTION_DEFAULT));
    vargs.add(amOpts);

    String amLogLevel = amConfig.getTezConfiguration().get(
        TezConfiguration.TEZ_AM_LOG_LEVEL,
        TezConfiguration.TEZ_AM_LOG_LEVEL_DEFAULT);
    maybeAddDefaultLoggingJavaOpts(amLogLevel, vargs);

    // FIX sun bug mentioned in TEZ-327
    vargs.add(""-Dsun.nio.ch.bugLevel=''"");

    vargs.add(TezConfiguration.TEZ_APPLICATION_MASTER_CLASS);
    if (dag == null) {
      vargs.add(""--"" + TezConstants.TEZ_SESSION_MODE_CLI_OPTION);
    }

    vargs.add(""1>"" + ApplicationConstants.LOG_DIR_EXPANSION_VAR +
        File.separator + ApplicationConstants.STDOUT);
    vargs.add(""2>"" + ApplicationConstants.LOG_DIR_EXPANSION_VAR +
        File.separator + ApplicationConstants.STDERR);


    Vector<String> vargsFinal = new Vector<String>(8);
    // Final command
    StringBuilder mergedCommand = new StringBuilder();
    for (CharSequence str : vargs) {
      mergedCommand.append(str).append("" "");
    }
    vargsFinal.add(mergedCommand.toString());

    if (LOG.isDebugEnabled()) {
      LOG.debug(""Command to launch container for ApplicationMaster is : ""
          + mergedCommand);
    }

    Map<String, String> environment = new TreeMap<String, String>();
    TezYARNUtils.setupDefaultEnv(environment, conf, TezConfiguration.TEZ_AM_LAUNCH_ENV,
        TezConfiguration.TEZ_AM_LAUNCH_ENV_DEFAULT);
    
    // finally apply env set in the code. This could potentially be removed in
    // TEZ-692
    if (amConfig.getEnv() != null) {
      for (Map.Entry<String, String> entry : amConfig.getEnv().entrySet()) {
        TezYARNUtils.addToEnvironment(environment, entry.getKey(),
            entry.getValue(), File.pathSeparator);
      }
    }
    
    Map<String, LocalResource> localResources =
        new TreeMap<String, LocalResource>();

    // Not fetching credentials for AMLocalResources. Expect this to be provided via AMCredentials.
    if (amConfig.getLocalResources() != null) {
      localResources.putAll(amConfig.getLocalResources());
    }
    localResources.putAll(tezJarResources);

    // emit conf as PB file
    Configuration finalTezConf = createFinalTezConfForApp(conf,
      amConfig.getTezConfiguration());
    
    FSDataOutputStream amConfPBOutBinaryStream = null;
    try {
      ConfigurationProto.Builder confProtoBuilder =
          ConfigurationProto.newBuilder();
      Iterator<Entry<String, String>> iter = finalTezConf.iterator();
      while (iter.hasNext()) {
        Entry<String, String> entry = iter.next();
        PlanKeyValuePair.Builder kvp = PlanKeyValuePair.newBuilder();
        kvp.setKey(entry.getKey());
        kvp.setValue(entry.getValue());
        confProtoBuilder.addConfKeyValues(kvp);
      }
      //binary output
      amConfPBOutBinaryStream = TezCommonUtils.createFileForAM(fs, binaryConfPath);
      confProtoBuilder.build().writeTo(amConfPBOutBinaryStream);
    } finally {
      if(amConfPBOutBinaryStream != null){
        amConfPBOutBinaryStream.close();
      }
    }

    LocalResource binaryConfLRsrc =
        TezClientUtils.createLocalResource(fs,
            binaryConfPath, LocalResourceType.FILE,
            LocalResourceVisibility.APPLICATION);
    localResources.put(TezConfiguration.TEZ_PB_BINARY_CONF_NAME,
        binaryConfLRsrc);

    // Create Session Jars definition to be sent to AM as a local resource
    Path sessionJarsPath = TezCommonUtils.getTezSessionJarStagingPath(tezSysStagingPath);
    FSDataOutputStream sessionJarsPBOutStream = null;
    try {
      Map<String, LocalResource> sessionJars =
        new HashMap<String, LocalResource>(tezJarResources.size() + 1);
      sessionJars.putAll(tezJarResources);
      sessionJars.put(TezConfiguration.TEZ_PB_BINARY_CONF_NAME,
        binaryConfLRsrc);
      DAGProtos.PlanLocalResourcesProto proto =
        DagTypeConverters.convertFromLocalResources(sessionJars);
      sessionJarsPBOutStream = TezCommonUtils.createFileForAM(fs, sessionJarsPath);
      proto.writeDelimitedTo(sessionJarsPBOutStream);
      
      // Write out the initial list of resources which will be available in the AM
      DAGProtos.PlanLocalResourcesProto amResourceProto;
      if (amConfig.getLocalResources() != null && !amConfig.getLocalResources().isEmpty()) {
        amResourceProto = DagTypeConverters.convertFromLocalResources(localResources);
      } else {
        amResourceProto = DAGProtos.PlanLocalResourcesProto.getDefaultInstance(); 
      }
      amResourceProto.writeDelimitedTo(sessionJarsPBOutStream);
    } finally {
      if (sessionJarsPBOutStream != null) {
        sessionJarsPBOutStream.close();
      }
    }

    LocalResource sessionJarsPBLRsrc =
      TezClientUtils.createLocalResource(fs,
        sessionJarsPath, LocalResourceType.FILE,
        LocalResourceVisibility.APPLICATION);
    localResources.put(
      TezConfiguration.TEZ_SESSION_LOCAL_RESOURCES_PB_FILE_NAME,
      sessionJarsPBLRsrc);

    if(dag != null) {

      for (Vertex v : dag.getVertices()) {
        if (tezJarResources != null) {
          v.getTaskLocalFiles().putAll(tezJarResources);
        }
        v.getTaskLocalFiles().put(TezConfiguration.TEZ_PB_BINARY_CONF_NAME,
            binaryConfLRsrc);

        Map<String, String> taskEnv = v.getTaskEnvironment();
        TezYARNUtils.setupDefaultEnv(taskEnv, conf,
            TezConfiguration.TEZ_TASK_LAUNCH_ENV,
            TezConfiguration.TEZ_TASK_LAUNCH_ENV_DEFAULT);

        TezClientUtils.setDefaultLaunchCmdOpts(v, amConfig.getTezConfiguration());
      }

      // emit protobuf DAG file style
      Path binaryPath = TezCommonUtils.getTezBinPlanStagingPath(tezSysStagingPath);
      if (LOG.isDebugEnabled()) {
        LOG.debug(""Stage directory information for AppId :"" + appId + "" tezSysStagingPath :""
            + tezSysStagingPath + "" binaryConfPath :"" + binaryConfPath + "" sessionJarsPath :""
            + sessionJarsPath + "" binaryPlanPath :"" + binaryPath);
      }
      amConfig.getTezConfiguration().set(TezConfiguration.TEZ_AM_PLAN_REMOTE_PATH,
          binaryPath.toUri().toString());

      DAGPlan dagPB = dag.createDag(null);

      FSDataOutputStream dagPBOutBinaryStream = null;

      try {
        //binary output
        dagPBOutBinaryStream = TezCommonUtils.createFileForAM(fs, binaryPath);
        dagPB.writeTo(dagPBOutBinaryStream);
      } finally {
        if(dagPBOutBinaryStream != null){
          dagPBOutBinaryStream.close();
        }
      }

      localResources.put(TezConfiguration.TEZ_PB_PLAN_BINARY_NAME,
        TezClientUtils.createLocalResource(fs,
          binaryPath, LocalResourceType.FILE,
          LocalResourceVisibility.APPLICATION));

      if (Level.DEBUG.isGreaterOrEqual(Level.toLevel(amLogLevel))) {
        Path textPath = localizeDagPlanAsText(dagPB, fs, amConfig, strAppId, tezSysStagingPath);
        localResources.put(TezConfiguration.TEZ_PB_PLAN_TEXT_NAME,
            TezClientUtils.createLocalResource(fs,
                textPath, LocalResourceType.FILE,
                LocalResourceVisibility.APPLICATION));
      }
    }
    Map<ApplicationAccessType, String> acls
        = new HashMap<ApplicationAccessType, String>();

    // Setup ContainerLaunchContext for AM container
    ContainerLaunchContext amContainer =
        ContainerLaunchContext.newInstance(localResources, environment,
            vargsFinal, null, securityTokens, acls);

    // Set up the ApplicationSubmissionContext
    ApplicationSubmissionContext appContext = Records
        .newRecord(ApplicationSubmissionContext.class);

    appContext.setApplicationType(TezConfiguration.TEZ_APPLICATION_TYPE);
    appContext.setApplicationId(appId);
    appContext.setResource(capability);
    if (amConfig.getQueueName() != null) {
      appContext.setQueue(amConfig.getQueueName());
    }
    appContext.setApplicationName(amName);
    appContext.setCancelTokensWhenComplete(amConfig.getTezConfiguration().getBoolean(
        TezConfiguration.TEZ_AM_CANCEL_DELEGATION_TOKEN,
        TezConfiguration.TEZ_AM_CANCEL_DELEGATION_TOKEN_DEFAULT));
    appContext.setAMContainerSpec(amContainer);
    
    appContext.setMaxAppAttempts(
      finalTezConf.getInt(TezConfiguration.TEZ_AM_MAX_APP_ATTEMPTS,
        TezConfiguration.TEZ_AM_MAX_APP_ATTEMPTS_DEFAULT));

    return appContext;

  }
  
  
  static void maybeAddDefaultLoggingJavaOpts(String logLevel, List<String> vargs) {
    if (vargs != null && !vargs.isEmpty()) {
      for (String arg : vargs) {
        if (arg.contains(TezConfiguration.TEZ_ROOT_LOGGER_NAME)) {
          return ;
        }
      }
    }
    TezClientUtils.addLog4jSystemProperties(logLevel, vargs);
  }
  
  static String maybeAddDefaultLoggingJavaOpts(String logLevel, String javaOpts) {
    List<String> vargs = new ArrayList<String>(5);
    if (javaOpts != null) {
      vargs.add(javaOpts);
    } else {
      vargs.add("""");
    }
    maybeAddDefaultLoggingJavaOpts(logLevel, vargs);
    if (vargs.size() == 1) {
      return vargs.get(0);
    }
    return StringUtils.join(vargs, "" "").trim();
  }
  
  static void setDefaultLaunchCmdOpts(Vertex v, TezConfiguration conf) {
    String vOpts = v.getTaskLaunchCmdOpts();
    String vConfigOpts = conf.get(TezConfiguration.TEZ_TASK_LAUNCH_CMD_OPTS,
        TezConfiguration.TEZ_TASK_LAUNCH_CMD_OPTS_DEFAULT);
    if (vConfigOpts != null && vConfigOpts.length() > 0) {
      vOpts += ("" "" + vConfigOpts);
    }
    
    vOpts = maybeAddDefaultLoggingJavaOpts(conf.get(
        TezConfiguration.TEZ_TASK_LOG_LEVEL,
        TezConfiguration.TEZ_TASK_LOG_LEVEL_DEFAULT), vOpts);
    v.setTaskLaunchCmdOpts(vOpts);
  }

  @Private
  @VisibleForTesting
  public static void addLog4jSystemProperties(String logLevel,
      List<String> vargs) {
    vargs.add(""-Dlog4j.configuration=""
        + TezConfiguration.TEZ_CONTAINER_LOG4J_PROPERTIES_FILE);
    vargs.add(""-D"" + YarnConfiguration.YARN_APP_CONTAINER_LOG_DIR + ""=""
        + ApplicationConstants.LOG_DIR_EXPANSION_VAR);
    vargs.add(""-D"" + TezConfiguration.TEZ_ROOT_LOGGER_NAME + ""="" + logLevel
        + "","" + TezConfiguration.TEZ_CONTAINER_LOGGER_NAME);
  }

  static Configuration createFinalTezConfForApp(TezConfiguration tezConf,
      TezConfiguration amConf) {
    Configuration conf = new Configuration(false);
    conf.setQuietMode(true);

    assert tezConf != null;
    assert amConf != null;

    Entry<String, String> entry;
    Iterator<Entry<String, String>> iter = tezConf.iterator();
    while (iter.hasNext()) {
      entry = iter.next();
      // Copy all tez config parameters.
      if (entry.getKey().startsWith(TezConfiguration.TEZ_PREFIX)) {
        conf.set(entry.getKey(), entry.getValue());
        if (LOG.isDebugEnabled()) {
          LOG.debug(""Adding tez dag am parameter from conf: "" + entry.getKey()
            + "", with value: "" + entry.getValue());
        }
      }
    }

    iter = amConf.iterator();
    while (iter.hasNext()) {
      entry = iter.next();
      // Copy all tez config parameters.
      if (entry.getKey().startsWith(TezConfiguration.TEZ_PREFIX)) {
        conf.set(entry.getKey(), entry.getValue());
        if (LOG.isDebugEnabled()) {
          LOG.debug(""Adding tez dag am parameter from amConf: "" + entry.getKey()
              + "", with value: "" + entry.getValue());
        }
      }
    }
    return conf;
  }

  /**
   * Helper function to create a YARN LocalResource
   * @param fs FileSystem object
   * @param p Path of resource to localize
   * @param type LocalResource Type
   * @return a YARN LocalResource for the given Path
   * @throws IOException
   */
  static LocalResource createLocalResource(FileSystem fs, Path p,
      LocalResourceType type,
      LocalResourceVisibility visibility) throws IOException {
    LocalResource rsrc = Records.newRecord(LocalResource.class);
    FileStatus rsrcStat = fs.getFileStatus(p);
    rsrc.setResource(ConverterUtils.getYarnUrlFromPath(fs.resolvePath(rsrcStat
        .getPath())));
    rsrc.setSize(rsrcStat.getLen());
    rsrc.setTimestamp(rsrcStat.getModificationTime());
    rsrc.setType(type);
    rsrc.setVisibility(visibility);
    return rsrc;
  }

  private static Path localizeDagPlanAsText(DAGPlan dagPB, FileSystem fs, AMConfiguration amConfig,
      String strAppId, Path tezSysStagingPath) throws IOException {
    Path textPath = TezCommonUtils.getTezTextPlanStagingPath(tezSysStagingPath);
    FSDataOutputStream dagPBOutTextStream = null;
    try {
      dagPBOutTextStream = TezCommonUtils.createFileForAM(fs, textPath);
      String dagPBStr = dagPB.toString();
      int dagPBStrLen = dagPBStr.length();
      if (dagPBStrLen <= UTF8_CHUNK_SIZE) {
        dagPBOutTextStream.writeUTF(dagPBStr);
      } else {
        int startIndex = 0;
        while (startIndex < dagPBStrLen) {
          int endIndex = startIndex + UTF8_CHUNK_SIZE;
          if (endIndex > dagPBStrLen) {
            endIndex = dagPBStrLen;
          }
          dagPBOutTextStream.writeUTF(dagPBStr.substring(startIndex, endIndex));
          startIndex += UTF8_CHUNK_SIZE;
        }
      }
    } finally {
      if (dagPBOutTextStream != null) {
        dagPBOutTextStream.close();
      }
    }
    return textPath;
  }

  static DAGClientAMProtocolBlockingPB getSessionAMProxy(YarnClient yarnClient,
      Configuration conf,
      ApplicationId applicationId) throws TezException, IOException {
    ApplicationReport appReport;
    try {
      appReport = yarnClient.getApplicationReport(
          applicationId);

      if(appReport == null) {
        throw new TezUncheckedException(""Could not retrieve application report""
            + "" from YARN, applicationId="" + applicationId);
      }
      YarnApplicationState appState = appReport.getYarnApplicationState();
      if(appState != YarnApplicationState.RUNNING) {
        if (appState == YarnApplicationState.FINISHED
            || appState == YarnApplicationState.KILLED
            || appState == YarnApplicationState.FAILED) {
          throw new SessionNotRunning(""Application not running""
              + "", applicationId="" + applicationId
              + "", yarnApplicationState="" + appReport.getYarnApplicationState()
              + "", finalApplicationStatus=""
              + appReport.getFinalApplicationStatus()
              + "", trackingUrl="" + appReport.getTrackingUrl());
        }
        return null;
      }
    } catch (YarnException e) {
      throw new TezException(e);
    }
    return getAMProxy(conf, appReport.getHost(),
        appReport.getRpcPort(), appReport.getClientToAMToken());
  }

  @Private
  public static DAGClientAMProtocolBlockingPB getAMProxy(final Configuration conf, String amHost,
      int amRpcPort, org.apache.hadoop.yarn.api.records.Token clientToAMToken) throws IOException {

    final InetSocketAddress serviceAddr = new InetSocketAddress(amHost, amRpcPort);
    UserGroupInformation userUgi = UserGroupInformation.createRemoteUser(UserGroupInformation
        .getCurrentUser().getUserName());
    if (clientToAMToken != null) {
      Token<ClientToAMTokenIdentifier> token = ConverterUtils.convertFromYarn(clientToAMToken,
          serviceAddr);
      userUgi.addToken(token);
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(""Connecting to Tez AM at "" + serviceAddr);
    }
    DAGClientAMProtocolBlockingPB proxy = null;
    try {
      proxy = userUgi.doAs(new PrivilegedExceptionAction<DAGClientAMProtocolBlockingPB>() {
        @Override
        public DAGClientAMProtocolBlockingPB run() throws IOException {
          RPC.setProtocolEngine(conf, DAGClientAMProtocolBlockingPB.class, ProtobufRpcEngine.class);
          return (DAGClientAMProtocolBlockingPB) RPC.getProxy(DAGClientAMProtocolBlockingPB.class,
              0, serviceAddr, conf);
        }
      });
    } catch (InterruptedException e) {
      throw new IOException(""Failed to connect to AM"", e);
    }
    return proxy;
  }

  @Private
  public static void createSessionToken(String tokenIdentifier,
      JobTokenSecretManager jobTokenSecretManager,
      Credentials credentials) {
    JobTokenIdentifier identifier = new JobTokenIdentifier(new Text(
        tokenIdentifier));
    Token<JobTokenIdentifier> sessionToken = new Token<JobTokenIdentifier>(identifier,
        jobTokenSecretManager);
    sessionToken.setService(identifier.getJobId());
    TokenCache.setSessionToken(sessionToken, credentials);
  }

  /**
   * Add computed Xmx value to java opts if both -Xms and -Xmx are not specified
   * @param javaOpts Current java opts
   * @param resource Resource capability based on which java opts will be computed
   * @param maxHeapFactor Factor to size Xmx ( valid range is 0.0 < x < 1.0)
   * @return Modified java opts with computed Xmx value
   */
  public static String maybeAddDefaultMemoryJavaOpts(String javaOpts, Resource resource,
      double maxHeapFactor) {
    if ((javaOpts != null && !javaOpts.isEmpty()
          && (javaOpts.contains(""-Xmx"") || javaOpts.contains(""-Xms"")))
        || (resource.getMemory() <= 0)) {
      return javaOpts;
    }
    if (maxHeapFactor <= 0 || maxHeapFactor >= 1) {
      return javaOpts;
    }
    int maxMemory = (int)(resource.getMemory() * maxHeapFactor);
    maxMemory = maxMemory <= 0 ? 1 : maxMemory;

    return "" -Xmx"" + maxMemory + ""m ""
        + ( javaOpts != null ? javaOpts : """");
  }

}
",blob
597,"  public static IndexFailurePolicy getFailurePolicy(RegionCoprocessorEnvironment env)
      throws IOException {
    Configuration conf = env.getConfiguration();
    try {
      IndexFailurePolicy committer =
          conf.getClass(INDEX_FAILURE_POLICY_CONF_KEY, PhoenixIndexFailurePolicy.class,
            IndexFailurePolicy.class).newInstance();
      return committer;
    } catch (InstantiationException e) {
      throw new IOException(e);
    } catch (IllegalAccessException e) {
      throw new IOException(e);
    }
  }
",feature envy
134,"public class HDFSTextLineReader {
    private static final int DEFAULT_BUFFER_SIZE = 32 * 1024;
    private int bufferSize = DEFAULT_BUFFER_SIZE;
    private FSDataInputStream reader;

    private byte[] buffer;
    // the number of bytes of real data in the buffer
    private int bufferLength = 0;
    // the current position in the buffer
    private int bufferPosn = 0;

    private long currentFilePos = 0L;

    private static final byte CR = '\r';
    private static final byte LF = '\n';

    public static final String KEY_BUFFER_SIZE = ""io.file.buffer.size"";

    /**
     * Create a line reader that reads from the given stream using the
     * default buffer-size (32k).
     *
     * @param in
     *            The input stream
     * @throws IOException
     */
    public HDFSTextLineReader(FSDataInputStream in) throws IOException {
        this(in, DEFAULT_BUFFER_SIZE);
    }

    /**
     * Create a line reader that reads from the given stream using the
     * given buffer-size.
     *
     * @param in
     *            The input stream
     * @param bufferSize
     *            Size of the read buffer
     * @throws IOException
     */
    public HDFSTextLineReader(FSDataInputStream in, int bufferSize) throws IOException {
        this.reader = in;
        this.bufferSize = bufferSize;
        this.buffer = new byte[this.bufferSize];
        currentFilePos = in.getPos();
    }

    public HDFSTextLineReader() throws IOException {
        this.bufferSize = DEFAULT_BUFFER_SIZE;
        this.buffer = new byte[this.bufferSize];
    }

    /**
     * Create a line reader that reads from the given stream using the <code>io.file.buffer.size</code> specified in the given <code>Configuration</code>.
     *
     * @param in
     *            input stream
     * @param conf
     *            configuration
     * @throws IOException
     */
    public HDFSTextLineReader(FSDataInputStream in, Configuration conf) throws IOException {
        this(in, conf.getInt(KEY_BUFFER_SIZE, DEFAULT_BUFFER_SIZE));
    }

    /**
     * Read one line from the InputStream into the given Text. A line
     * can be terminated by one of the following: '\n' (LF) , '\r' (CR),
     * or '\r\n' (CR+LF). EOF also terminates an otherwise unterminated
     * line.
     *
     * @param str
     *            the object to store the given line (without newline)
     * @param maxLineLength
     *            the maximum number of bytes to store into str;
     *            the rest of the line is silently discarded.
     * @param maxBytesToConsume
     *            the maximum number of bytes to consume
     *            in this call. This is only a hint, because if the line cross
     *            this threshold, we allow it to happen. It can overshoot
     *            potentially by as much as one buffer length.
     * @return the number of bytes read including the (longest) newline
     *         found.
     * @throws IOException
     *             if the underlying stream throws
     */
    public int readLine(Text str, int maxLineLength, int maxBytesToConsume) throws IOException {
        /* We're reading data from in, but the head of the stream may be
         * already buffered in buffer, so we have several cases:
         * 1. No newline characters are in the buffer, so we need to copy
         *    everything and read another buffer from the stream.
         * 2. An unambiguously terminated line is in buffer, so we just
         *    copy to str.
         * 3. Ambiguously terminated line is in buffer, i.e. buffer ends
         *    in CR.  In this case we copy everything up to CR to str, but
         *    we also need to see what follows CR: if it's LF, then we
         *    need consume LF as well, so next call to readLine will read
         *    from after that.
         * We use a flag prevCharCR to signal if previous character was CR
         * and, if it happens to be at the end of the buffer, delay
         * consuming it until we have a chance to look at the char that
         * follows.
         */
        str.clear();
        int txtLength = 0; //tracks str.getLength(), as an optimization
        int newlineLength = 0; //length of terminating newline
        boolean prevCharCR = false; //true of prev char was CR
        long bytesConsumed = 0;
        do {
            int startPosn = bufferPosn; //starting from where we left off the last time
            if (bufferPosn >= bufferLength) {
                startPosn = bufferPosn = 0;
                if (prevCharCR)
                    ++bytesConsumed; //account for CR from previous read
                bufferLength = reader.read(buffer);
                if (bufferLength <= 0)
                    break; // EOF
            }
            for (; bufferPosn < bufferLength; ++bufferPosn) { //search for newline
                if (buffer[bufferPosn] == LF) {
                    newlineLength = (prevCharCR) ? 2 : 1;
                    ++bufferPosn; // at next invocation proceed from following byte
                    break;
                }
                if (prevCharCR) { //CR + notLF, we are at notLF
                    newlineLength = 1;
                    break;
                }
                prevCharCR = (buffer[bufferPosn] == CR);
            }
            int readLength = bufferPosn - startPosn;
            if (prevCharCR && newlineLength == 0)
                --readLength; //CR at the end of the buffer
            bytesConsumed += readLength;
            int appendLength = readLength - newlineLength;
            if (appendLength > maxLineLength - txtLength) {
                appendLength = maxLineLength - txtLength;
            }
            if (appendLength > 0) {
                str.append(buffer, startPosn, appendLength);
                txtLength += appendLength;
            }
        } while (newlineLength == 0 && bytesConsumed < maxBytesToConsume);

        if (bytesConsumed > Integer.MAX_VALUE)
            throw new IOException(""Too many bytes before newline: "" + bytesConsumed);
        currentFilePos = reader.getPos() - bufferLength + bufferPosn;
        return (int) bytesConsumed;
    }

    /**
     * Read from the InputStream into the given Text.
     *
     * @param str
     *            the object to store the given line
     * @param maxLineLength
     *            the maximum number of bytes to store into str.
     * @return the number of bytes read including the newline
     * @throws IOException
     *             if the underlying stream throws
     */
    public int readLine(Text str, int maxLineLength) throws IOException {
        return readLine(str, maxLineLength, Integer.MAX_VALUE);
    }

    /**
     * Read from the InputStream into the given Text.
     *
     * @param str
     *            the object to store the given line
     * @return the number of bytes read including the newline
     * @throws IOException
     *             if the underlying stream throws
     */
    public int readLine(Text str) throws IOException {
        return readLine(str, Integer.MAX_VALUE, Integer.MAX_VALUE);
    }

    public void seek(long desired) throws IOException {
        if (reader.getPos() <= desired || currentFilePos > desired) {
            // desired position is ahead of stream or before the current position, seek to position
            reader.seek(desired);
            bufferLength = 0;
            bufferPosn = 0;
            currentFilePos = desired;
        } else if (currentFilePos < desired) {
            // desired position is in the buffer
            int difference = (int) (desired - currentFilePos);
            bufferPosn += difference;
            currentFilePos = desired;
        }
    }

    public FSDataInputStream getReader() {
        return reader;
    }

    public void resetReader(FSDataInputStream reader) throws IOException {
        this.reader = reader;
        bufferLength = 0;
        bufferPosn = 0;
        currentFilePos = reader.getPos();
    }

    public void close() throws IOException {
        reader.close();
    }
}
",blob
1208,"public class TextAndButtonSection extends Section
{

	public TextAndButtonSection( String labelText, Composite parent,
			boolean isFormStyle )
	{
		super( labelText, parent, isFormStyle );
	}

	protected int width = -1;

	protected boolean fillText = false;

	protected TextPropertyDescriptor textField;

	public void createSection( )
	{
		if ( selectList == null )
			selectList = new ArrayList( );
		getLabelControl( parent );
		getTextControl( parent );
		getButtonControl( parent );
		getGridPlaceholder( parent );
	}

	public void layout( )
	{
		GridData gd = (GridData) textField.getControl( ).getLayoutData( );
		if ( getLayoutNum( ) > 0 )
			gd.horizontalSpan = getLayoutNum( ) - 2 - placeholder;
		else
			gd.horizontalSpan = ( (GridLayout) parent.getLayout( ) ).numColumns
					- 2
					- placeholder;
		if ( width > -1 )
		{
			gd.widthHint = width;
			gd.grabExcessHorizontalSpace = false;
		}
		else
			gd.grabExcessHorizontalSpace = fillText;

		gd = (GridData) button.getLayoutData( );

		if ( buttonWidth > -1 )
		{
			if ( !isComputeSize )
				gd.widthHint = Math.max( button.computeSize( -1, -1 ).x,
						buttonWidth );
			else
				gd.widthHint = button.computeSize( -1, -1 ).x;
		}
	}

	public TextPropertyDescriptor getTextControl( )
	{
		return textField;
	}

	protected TextPropertyDescriptor getTextControl( Composite parent )
	{
		if ( textField == null )
		{
			textField = DescriptorToolkit.createTextPropertyDescriptor( true );
			if ( getProvider( ) != null )
				textField.setDescriptorProvider( getProvider( ) );
			textField.createControl( parent );
			textField.getControl( ).setLayoutData( new GridData( ) );
			textField.getControl( ).addDisposeListener( new DisposeListener( ) {

				public void widgetDisposed( DisposeEvent event )
				{
					textField = null;
				}
			} );
		}
		else
		{
			checkParent( textField.getControl( ), parent );
		}
		return textField;
	}

	protected Button button;

	public Button getButtonControl( )
	{
		return button;
	}

	protected Button getButtonControl( Composite parent )
	{
		if ( button == null )
		{
			button = FormWidgetFactory.getInstance( ).createButton( parent,
					SWT.PUSH,
					isFormStyle );
			button.setFont( parent.getFont( ) );

			button.setLayoutData( new GridData( ) );
			String text = getButtonText( );
			if ( text != null )
			{
				button.setText( text );
			}

			text = getButtonTooltipText( );
			if ( text != null )
			{
				button.setToolTipText( text );
			}

			button.addDisposeListener( new DisposeListener( ) {

				public void widgetDisposed( DisposeEvent event )
				{
					button = null;
				}
			} );

			if ( !selectList.isEmpty( ) )
				button.addSelectionListener( (SelectionListener) selectList.get( 0 ) );
			else
			{
				SelectionListener listener = new SelectionAdapter( ) {

					public void widgetSelected( SelectionEvent e )
					{
						onClickButton( );
					}
				};
				selectList.add( listener );
			}

		}
		else
		{
			checkParent( button, parent );
		}
		return button;
	}

	private String buttonText;

	IDescriptorProvider provider;

	public IDescriptorProvider getProvider( )
	{
		return provider;
	}

	public void setProvider( IDescriptorProvider provider )
	{
		this.provider = provider;
		if ( textField != null )
			textField.setDescriptorProvider( provider );
	}

	protected List selectList = new ArrayList( );

	/**
	 * if use this method , you couldn't use the onClickButton method.
	 */
	public void addSelectionListener( SelectionListener listener )
	{
		if ( !selectList.contains( listener ) )
		{
			if ( !selectList.isEmpty( ) )
				removeSelectionListener( (SelectionListener) selectList.get( 0 ) );
			selectList.add( listener );
			if ( button != null )
				button.addSelectionListener( listener );
		}
	}

	public void removeSelectionListener( SelectionListener listener )
	{
		if ( selectList.contains( listener ) )
		{
			selectList.remove( listener );
			if ( button != null )
				button.removeSelectionListener( listener );
		}
	}

	protected void onClickButton( )
	{
	};

	public void forceFocus( )
	{
		textField.getControl( ).forceFocus( );
	}

	public void setInput( Object input )
	{
		textField.setInput( input );
	}

	public void load( )
	{
		if ( textField != null && !textField.getControl( ).isDisposed( ) )
			textField.load( );
		if ( button != null && !button.isDisposed( ) )
			button.setEnabled( !isReadOnly( ) );
	}

	protected int buttonWidth = 60;

	public void setButtonWidth( int buttonWidth )
	{
		this.buttonWidth = buttonWidth;
		if ( button != null )
		{
			GridData data = new GridData( );
			data.widthHint = Math.max( button.computeSize( -1, -1 ).x,
					buttonWidth );;
			data.grabExcessHorizontalSpace = false;
			button.setLayoutData( data );
		}
	}

	protected boolean isComputeSize = false;

	public int getWidth( )
	{
		return width;
	}

	public void setWidth( int width )
	{
		this.width = width;
	}

	public int getButtonWidth( )
	{
		return buttonWidth;
	}

	private String oldValue;

	public void setStringValue( String value )
	{
		if ( textField != null )
		{
			if ( value == null )
			{
				value = """";//$NON-NLS-1$
			}
			oldValue = textField.getText( );
			if ( !oldValue.equals( value ) )
			{
				textField.setText( value );
			}
		}
	}

	public boolean isFillText( )
	{
		return fillText;
	}

	public void setFillText( boolean fillText )
	{
		this.fillText = fillText;
	}

	public void setHidden( boolean isHidden )
	{
		if ( displayLabel != null )
			WidgetUtil.setExcludeGridData( displayLabel, isHidden );
		if ( textField != null )
			textField.setHidden( isHidden );
		if ( button != null )
			WidgetUtil.setExcludeGridData( button, isHidden );
		if ( placeholderLabel != null )
			WidgetUtil.setExcludeGridData( placeholderLabel, isHidden );
	}

	public void setVisible( boolean isVisible )
	{
		if ( displayLabel != null )
			displayLabel.setVisible( isVisible );
		if ( textField != null )
			textField.setVisible( isVisible );
		if ( button != null )
			button.setVisible( isVisible );
		if ( placeholderLabel != null )
			placeholderLabel.setVisible( isVisible );
	}

	private String buttonTooltipText;

	public void setButtonTooltipText( String string )
	{
		this.buttonTooltipText = string;
		if ( button != null )
			button.setText( buttonTooltipText );

	}

	public String getButtonText( )
	{
		return buttonText;
	}

	public void setButtonText( String buttonText )
	{
		this.buttonText = buttonText;
		if ( button != null )
			button.setText( buttonText );
	}

	public String getButtonTooltipText( )
	{
		return buttonTooltipText;
	}

	public boolean buttonIsComputeSize( )
	{
		return isComputeSize;
	}

	public void setButtonIsComputeSize( boolean isComputeSize )
	{
		this.isComputeSize = isComputeSize;
	}

}
",data class
1461,"public class TfsGitTreeEntriesJson {
    private final String objectId;
    private final List<TfsGitTreeEntryJson> treeEntries;
    private final int size;

    @JsonCreator
    public TfsGitTreeEntriesJson(
        @JsonProperty(""objectId"") final String objectId,
        @JsonProperty(""treeEntries"") final List<TfsGitTreeEntryJson> treeEntries,
        @JsonProperty(""size"") final int size) throws JsonProcessingException {
        this.objectId = objectId;
        this.treeEntries = treeEntries;
        this.size = size;
    }

    public String getObjectId() {
        return objectId;
    }

    public List<TfsGitTreeEntryJson> getTreeEntries() {
        return treeEntries;
    }

    public int getSize() {
        return size;
    }
}
",data class
759,"    protected SQLBuffer toBulkOperation(ClassMapping mapping, Select sel,
        JDBCStore store, Object[] params, Map updateParams) {
        SQLBuffer sql = new SQLBuffer(this);
        if (updateParams == null) {
          if (requiresTargetForDelete) {
            sql.append(""DELETE "");
            SQLBuffer deleteTargets = getDeleteTargets(sel);
            sql.append(deleteTargets);
            sql.append("" FROM "");
          } else {
            sql.append(""DELETE FROM "");
          }
        }
        else
            sql.append(""UPDATE "");
        sel.addJoinClassConditions();

        // if there is only a single table in the select, then we can
        // just issue a single DELETE FROM TABLE WHERE <conditions>
        // statement; otherwise, since SQL doesn't allow deleting
        // from one of a multi-table select, we need to issue a subselect
        // like DELETE FROM TABLE WHERE EXISTS
        // (SELECT 1 FROM TABLE t0 WHERE t0.ID = TABLE.ID); also, some
        // databases do not allow aliases in delete statements, which
        // also causes us to use a subselect
        Collection<String> selectedTables = getSelectTableAliases(sel);
        if (selectedTables.size() == 1 && supportsSubselect
            && allowsAliasInBulkClause) {
            SQLBuffer from;
            if (sel.getFromSelect() != null)
                from = getFromSelect(sel, false);
            else
                from = getFrom(sel, false);

            sql.append(from);
            appendUpdates(sel, store, sql, params, updateParams,
                allowsAliasInBulkClause);

            SQLBuffer where = sel.getWhere();
            if (where != null && !where.isEmpty()) {
                sql.append("" WHERE "");
                sql.append(where);
            }
            return sql;
        }

        Table table = mapping.getTable();
        String tableName = getFullName(table, false);

        // only use a  subselect if the where is not empty; otherwise
        // an unqualified delete or update will work
        if (sel.getWhere() == null || sel.getWhere().isEmpty()) {
            sql.append(tableName);
            appendUpdates(sel, store, sql, params, updateParams, false);
            return sql;
        }

        // we need to use a subselect if we are to bulk delete where
        // the select includes multiple tables; if the database
        // doesn't support it, then we need to signal this by returning null
        if (!supportsSubselect || !supportsCorrelatedSubselect)
            return null;

        Column[] pks = mapping.getPrimaryKeyColumns();
        sel.clearSelects();
        sel.setDistinct(true);

        // if we have only a single PK, we can use a non-correlated
        // subquery (using an IN statement), which is much faster than
        // a correlated subquery (since a correlated subquery needs
        // to be executed once for each row in the table)
        if (pks.length == 1) {
            sel.select(pks[0]);
            sql.append(tableName);
            appendUpdates(sel, store, sql, params, updateParams, false);
            sql.append("" WHERE "").
                append(pks[0]).append("" IN ("").
                append(sel.toSelect(false, null)).append("")"");
        } else {
            sel.clearSelects();
            sel.setDistinct(false);

            // since the select is using a correlated subquery, we
            // only need to select a bogus virtual column
            sel.select(""1"", null);

            // add in the joins to the table
            Column[] cols = table.getPrimaryKey().getColumns();
            SQLBuffer buf = new SQLBuffer(this);
            buf.append(""("");
            for (int i = 0; i < cols.length; i++) {
                if (i > 0)
                    buf.append("" AND "");

                // add in ""t0.PK = MYTABLE.PK""
                buf.append(sel.getColumnAlias(cols[i])).append("" = "").
                    append(table).append(catalogSeparator).append(cols[i]);
            }
            buf.append("")"");
            sel.where(buf, null);

            sql.append(tableName);
            appendUpdates(sel, store, sql, params, updateParams, false);
            sql.append("" WHERE EXISTS ("").
                append(sel.toSelect(false, null)).append("")"");
        }
        return sql;
    }
",long method
1482,"    @Override
    public RelOptCost getCost(HiveJoin join) {
      final RelMetadataQuery mq = join.getCluster().getMetadataQuery();
      // 1. Sum of input cardinalities
      final Double leftRCount = mq.getRowCount(join.getLeft());
      final Double rightRCount = mq.getRowCount(join.getRight());
      if (leftRCount == null || rightRCount == null) {
        return null;
      }
      final double rCount = leftRCount + rightRCount;
      // 2. CPU cost = HashTable  construction  cost  +
      //               join cost
      ImmutableList<Double> cardinalities = new ImmutableList.Builder<Double>().
              add(leftRCount).
              add(rightRCount).
              build();
      ImmutableBitSet.Builder streamingBuilder = ImmutableBitSet.builder();
      switch (join.getStreamingSide()) {
        case LEFT_RELATION:
          streamingBuilder.set(0);
          break;
        case RIGHT_RELATION:
          streamingBuilder.set(1);
          break;
        default:
          return null;
      }
      ImmutableBitSet streaming = streamingBuilder.build();
      final double cpuCost = algoUtils.computeBucketMapJoinCPUCost(cardinalities, streaming);
      // 3. IO cost = cost of transferring small tables to join node *
      //              degree of parallelism
      final Double leftRAverageSize = mq.getAverageRowSize(join.getLeft());
      final Double rightRAverageSize = mq.getAverageRowSize(join.getRight());
      if (leftRAverageSize == null || rightRAverageSize == null) {
        return null;
      }
      ImmutableList<Pair<Double,Double>> relationInfos = new ImmutableList.Builder<Pair<Double,Double>>().
              add(new Pair<Double,Double>(leftRCount,leftRAverageSize)).
              add(new Pair<Double,Double>(rightRCount,rightRAverageSize)).
              build();
      //TODO: No Of buckets is not same as no of splits
      JoinAlgorithm oldAlgo = join.getJoinAlgorithm();
      join.setJoinAlgorithm(TezBucketJoinAlgorithm.INSTANCE);
      final int parallelism = mq.splitCount(join) == null
              ? 1 : mq.splitCount(join);
      join.setJoinAlgorithm(oldAlgo);

      final double ioCost = algoUtils.computeBucketMapJoinIOCost(relationInfos, streaming, parallelism);
      // 4. Result
      return HiveCost.FACTORY.makeCost(rCount, cpuCost, ioCost);
    }
",long method
234,"	static boolean evaluateImpl(Object o1, Object o2) {
		// TODO: maybe we need a comparison ""strategy"" here, instead of
		// a switch of all possible cases? ... there were other requests for
		// more relaxed type-unsafe comparison (e.g. numbers to strings)

		if (o1 == null && o2 == null) {
			return true;
		} else if (o1 != null) {
			// Per CAY-419 we perform 'in' comparison if one object is a list, and other is not
			if (o2 instanceof Collection) {
				for (Object element : ((Collection<?>) o2)) {
					if (element != null && Evaluator.evaluator(element).eq(element, o1)) {
						return true;
					}
				}
				return false;
			}

			return Evaluator.evaluator(o1).eq(o1, o2);
		}
		return false;
	}
",feature envy
568,"public class Capability implements IConvertible {
    private String virtualCores;

    private String memorySize;

    private String memory;

    public String getVirtualCores() {
        return virtualCores;
    }

    public void setVirtualCores(String virtualCores) {
        this.virtualCores = virtualCores;
    }

    public String getMemorySize() {
        return memorySize;
    }

    public void setMemorySize(String memorySize) {
        this.memorySize = memorySize;
    }

    public String getMemory() {
        return memory;
    }

    public void setMemory(String memory) {
        this.memory = memory;
    }
}
",data class
1080,"public class ModuleOptionsReferenceDoc {

	/**
	 * Matches ""//^<type>.<name>"" exactly.
	 */
	private static final Pattern FENCE_START_REGEX = Pattern.compile(""^//\\^([^.]+)\\.([^.]+)$"");

	private ModuleRegistry moduleRegistry = new ResourceModuleRegistry(""file:./modules"");

	private ModuleOptionsMetadataResolver moduleOptionsMetadataResolver = new DefaultModuleOptionsMetadataResolver();

	private ResourcePatternResolver resourcePatternResolver = new PathMatchingResourcePatternResolver();

	public static void main(String... paths) throws IOException {
		ModuleOptionsReferenceDoc runner = new ModuleOptionsReferenceDoc();
		for (String path : paths) {
			runner.updateSingleFile(path);
		}
	}

	private void updateSingleFile(String path) throws IOException {
		File originalFile = new File(path);
		Assert.isTrue(originalFile.exists() && !originalFile.isDirectory(),
				String.format(""'%s' does not exist or points to a directory"", originalFile.getAbsolutePath()));

		File backup = new File(originalFile.getAbsolutePath() + "".backup"");
		originalFile.renameTo(backup);
		BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(backup), ""UTF-8""));

		PrintStream out = new PrintStream(new FileOutputStream(originalFile), false, ""UTF-8"");

		ModuleType type = null;
		String name = null;
		int openingLineNumber = 0;
		int ln = 1;
		for (String line = reader.readLine(); line != null; line = reader.readLine(), ln++) {
			Matcher startMatcher = FENCE_START_REGEX.matcher(line);
			if (startMatcher.matches()) {
				checkPreviousTagHasBeenClosed(originalFile, backup, out, type, name, openingLineNumber);
				type = ModuleType.valueOf(startMatcher.group(1));
				name = startMatcher.group(2);
				openingLineNumber = ln;
				out.println(line);
			}
			else if (type != null && line.equals(String.format(""//$%s.%s"", type, name))) {
				generateWarning(out, name, type);
				generateAsciidoc(out, name, type);
				type = null;
				name = null;
				out.println(line);
			}
			else if (type == null) {
				out.println(line);
			}
		}
		checkPreviousTagHasBeenClosed(originalFile, backup, out, type, name, openingLineNumber);

		out.close();
		reader.close();

		backup.delete();

	}

	private void checkPreviousTagHasBeenClosed(File originalFile, File backup, PrintStream out, ModuleType type,
			String name, int openingLineNumber) {
		if (type != null) {
			out.close();
			originalFile.delete();
			backup.renameTo(originalFile);
			throw new IllegalStateException(String.format(
					""In %s, found '//^%s.%s' @line %d with no matching '//$%2$s.%3$s'"",
					originalFile.getAbsolutePath(), type, name, openingLineNumber));
		}
	}

	private void generateWarning(PrintStream out, String name, ModuleType type) {
		out.format(""// DO NOT MODIFY THE LINES BELOW UNTIL THE CLOSING '//$%s.%s' TAG%n"", type, name);
		out.format(""// THIS SNIPPET HAS BEEN GENERATED BY %s AND MANUAL EDITS WILL BE LOST%n"",
				ModuleOptionsReferenceDoc.class.getSimpleName());
	}

	private void generateAsciidoc(PrintStream out, String name, ModuleType type)
			throws IOException {
		ModuleDefinition def = moduleRegistry.findDefinition(name, type);
		ModuleOptionsMetadata moduleOptionsMetadata = moduleOptionsMetadataResolver.resolve(def);

		Resource moduleLoc = resourcePatternResolver.getResource(((SimpleModuleDefinition) def).getLocation());
		ClassLoader moduleClassLoader = ModuleUtils.createModuleDiscoveryClassLoader(moduleLoc, ModuleOptionsReferenceDoc.class.getClassLoader());
		if (!moduleOptionsMetadata.iterator().hasNext()) {
			out.format(""The **%s** %s has no particular option (in addition to options shared by all modules)%n%n"",
					pt(def.getName()), pt(def.getType()));
			return;
		}

		out.format(""The **%s** %s has the following options:%n%n"", pt(def.getName()), pt(def.getType()));
		List<ModuleOption> options = new ArrayList<ModuleOption>();
		for (ModuleOption mo : moduleOptionsMetadata) {
			options.add(mo);
		}
		Collections.sort(options, new Comparator<ModuleOption>() {

			@Override
			public int compare(ModuleOption o1, ModuleOption o2) {
				return o1.getName().compareTo(o2.getName());
			}
		});

		for (ModuleOption mo : options) {
			String prettyDefault = prettifyDefaultValue(mo);
			String maybeEnumHint = generateEnumValues(mo, moduleClassLoader);
			out.format(""%s:: %s *(%s, %s%s)*%n"", pt(mo.getName()), pt(mo.getDescription()),
					pt(shortClassName(mo.getType())),
					prettyDefault, maybeEnumHint);
		}
	}

	private String shortClassName(String fqName) {
		int lastDot = fqName.lastIndexOf('.');
		return lastDot >= 0 ? fqName.substring(lastDot + 1) : fqName;
	}


	/**
	 * When the type of an option is an enum, document all possible values
	 */
	private String generateEnumValues(ModuleOption mo, ClassLoader moduleClassLoader) {
		// Attempt to convert back to com.acme.Foo$Bar form
		String canonical = mo.getType();
		String system = canonical.replaceAll(""(.*\\p{Upper}[^\\.]*)\\.(\\p{Upper}.*)"", ""$1\\$$2"");
		Class<?> clazz = null;
		try {
			clazz = Class.forName(system, false, moduleClassLoader);
		}
		catch (ClassNotFoundException e) {
			return """";
		}
		if (Enum.class.isAssignableFrom(clazz)) {
			String values = StringUtils.arrayToCommaDelimitedString(clazz.getEnumConstants());
			return String.format("", possible values: `%s`"", values);
		}
		else
			return """";
	}

	private String prettifyDefaultValue(ModuleOption mo) {
		if (mo.getDefaultValue() == null) {
			return ""no default"";
		}
		String result = stringify(mo.getDefaultValue());
		result = result.replace(ModulePlaceholders.XD_STREAM_NAME, ""<stream name>"");
		result = result.replace(ModulePlaceholders.XD_JOB_NAME, ""<job name>"");
		return ""default: `"" + result + ""`"";
	}

	private String stringify(Object element) {
		Class<?> clazz = element.getClass();
		if (clazz == byte[].class) {
			return Arrays.toString((byte[]) element);
		}
		else if (clazz == short[].class) {
			return Arrays.toString((short[]) element);
		}
		else if (clazz == int[].class) {
			return Arrays.toString((int[]) element);
		}
		else if (clazz == long[].class) {
			return Arrays.toString((long[]) element);
		}
		else if (clazz == char[].class) {
			return Arrays.toString((char[]) element);
		}
		else if (clazz == float[].class) {
			return Arrays.toString((float[]) element);
		}
		else if (clazz == double[].class) {
			return Arrays.toString((double[]) element);
		}
		else if (clazz == boolean[].class) {
			return Arrays.toString((boolean[]) element);
		}
		else if (element instanceof Object[]) {
			return Arrays.deepToString((Object[]) element);
		}
		else {
			return element.toString();
		}
	}

	/**
	 * Return an asciidoc passthrough version of some text, in case the original text contains characters
	 * that would be (mis)interpreted by asciidoc.
	 */
	private String pt(Object original) {
		return ""$$"" + original + ""$$"";
	}


}
",blob
1483,"    @Override
    public RelOptCost getCost(HiveJoin join) {
      final RelMetadataQuery mq = join.getCluster().getMetadataQuery();
      // 1. Sum of input cardinalities
      final Double leftRCount = mq.getRowCount(join.getLeft());
      final Double rightRCount = mq.getRowCount(join.getRight());
      if (leftRCount == null || rightRCount == null) {
        return null;
      }
      final double rCount = leftRCount + rightRCount;
      // 2. CPU cost = HashTable  construction  cost  +
      //               join cost
      ImmutableList<Double> cardinalities = new ImmutableList.Builder<Double>().
              add(leftRCount).
              add(rightRCount).
              build();
      ImmutableBitSet.Builder streamingBuilder = ImmutableBitSet.builder();
      switch (join.getStreamingSide()) {
        case LEFT_RELATION:
          streamingBuilder.set(0);
          break;
        case RIGHT_RELATION:
          streamingBuilder.set(1);
          break;
        default:
          return null;
      }
      ImmutableBitSet streaming = streamingBuilder.build();
      final double cpuCost = algoUtils.computeBucketMapJoinCPUCost(cardinalities, streaming);
      // 3. IO cost = cost of transferring small tables to join node *
      //              degree of parallelism
      final Double leftRAverageSize = mq.getAverageRowSize(join.getLeft());
      final Double rightRAverageSize = mq.getAverageRowSize(join.getRight());
      if (leftRAverageSize == null || rightRAverageSize == null) {
        return null;
      }
      ImmutableList<Pair<Double,Double>> relationInfos = new ImmutableList.Builder<Pair<Double,Double>>().
              add(new Pair<Double,Double>(leftRCount,leftRAverageSize)).
              add(new Pair<Double,Double>(rightRCount,rightRAverageSize)).
              build();
      //TODO: No Of buckets is not same as no of splits
      JoinAlgorithm oldAlgo = join.getJoinAlgorithm();
      join.setJoinAlgorithm(TezBucketJoinAlgorithm.INSTANCE);
      final int parallelism = mq.splitCount(join) == null
              ? 1 : mq.splitCount(join);
      join.setJoinAlgorithm(oldAlgo);

      final double ioCost = algoUtils.computeBucketMapJoinIOCost(relationInfos, streaming, parallelism);
      // 4. Result
      return HiveCost.FACTORY.makeCost(rCount, cpuCost, ioCost);
    }
",feature envy
602,"    private ApplicationDTO buildApplicationDTO(
        ApplicationRuntimeInformation ari) {

        ApplicationDTO applicationDTO = new ApplicationDTO(){};

        applicationDTO.name = getServiceName(
            ari._cachingServiceReference::getProperty);
        applicationDTO.base = _whiteboard.getApplicationBase(
            ari._cachingServiceReference::getProperty);
        applicationDTO.serviceId =
            (Long)ari._cachingServiceReference.getProperty(""service.id"");

        applicationDTO.resourceDTOs = getApplicationEndpointsStream(
            applicationDTO.name).toArray(
                ResourceDTO[]::new
            );

        applicationDTO.extensionDTOs = getApplicationExtensionsStream(
            applicationDTO.name).toArray(
                ExtensionDTO[]::new
            );

        Map<String, Set<ExtensionDTO>> nameBoundExtensions =
            new HashMap<>();

        Map<ExtensionDTO, Set<ResourceDTO>> extensionResources =
            new HashMap<>();

        for (ExtensionDTO extensionDTO : applicationDTO.extensionDTOs) {
            if (extensionDTO.nameBindings == null) {
                continue;
            }

            for (String nameBinding : extensionDTO.nameBindings) {
                Set<ExtensionDTO> extensionDTOS =
                    nameBoundExtensions.computeIfAbsent(
                        nameBinding,
                        __ -> new HashSet<>()
                );

                extensionDTOS.add(extensionDTO);
            }
        }

        for (ResourceDTO resourceDTO : applicationDTO.resourceDTOs) {
            for (ResourceMethodInfoDTO resourceMethodInfo :
                resourceDTO.resourceMethods) {

                if (resourceMethodInfo.nameBindings == null) {
                    continue;
                }

                for (String nameBinding : resourceMethodInfo.nameBindings) {
                    Set<ExtensionDTO> extensionDTOS = nameBoundExtensions.get(
                        nameBinding);

                    if (extensionDTOS != null) {
                        for (ExtensionDTO extensionDTO : extensionDTOS) {
                            Set<ResourceDTO> resourceDTOS =
                                extensionResources.computeIfAbsent(
                                    extensionDTO, __ -> new HashSet<>());

                            resourceDTOS.add(resourceDTO);
                        }
                    }
                }
            }
        }

        extensionResources.forEach(
            (extensionDTO, resourceDTOS) ->
                extensionDTO.filteredByName = resourceDTOS.toArray(
                    new ResourceDTO[0])
        );

        CxfJaxrsServiceRegistrator cxfJaxRsServiceRegistrator =
            ari._cxfJaxRsServiceRegistrator;

        Bus bus = cxfJaxRsServiceRegistrator.getBus();
        Iterable<Class<?>> resourceClasses =
            cxfJaxRsServiceRegistrator.getStaticResourceClasses();

        ArrayList<ResourceMethodInfoDTO> resourceMethodInfoDTOS =
            new ArrayList<>();

        for (Class<?> resourceClass : resourceClasses) {
            resourceMethodInfoDTOS.addAll(
                ClassIntrospector.getResourceMethodInfos(resourceClass, bus));
        }

        applicationDTO.resourceMethods = resourceMethodInfoDTOS.toArray(
            new ResourceMethodInfoDTO[0]);

        return applicationDTO;
    }
",long method
1094,"@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = ""serialization-registration-type"",
    namespace = ""http://geode.apache.org/schema/cache"",
    propOrder = {""serializers"", ""instantiators""})
@Experimental
public class SerializationRegistrationType {

  @XmlElement(name = ""serializer"", namespace = ""http://geode.apache.org/schema/cache"")
  protected List<Serializer> serializers;
  @XmlElement(name = ""instantiator"", namespace = ""http://geode.apache.org/schema/cache"")
  protected List<Instantiator> instantiators;

  /**
   * Gets the value of the serializer property.
   *
   * <p>
   * This accessor method returns a reference to the live list,
   * not a snapshot. Therefore any modification you make to the
   * returned list will be present inside the JAXB object.
   * This is why there is not a <CODE>set</CODE> method for the serializer property.
   *
   * <p>
   * For example, to add a new item, do as follows:
   *
   * <pre>
   * getSerializer().add(newItem);
   * </pre>
   *
   *
   * <p>
   * Objects of the following type(s) are allowed in the list
   * {@link SerializationRegistrationType.Serializer }
   *
   *
   */
  public List<Serializer> getSerializers() {
    if (serializers == null) {
      serializers = new ArrayList<Serializer>();
    }
    return this.serializers;
  }

  /**
   * Gets the value of the instantiator property.
   *
   * <p>
   * This accessor method returns a reference to the live list,
   * not a snapshot. Therefore any modification you make to the
   * returned list will be present inside the JAXB object.
   * This is why there is not a <CODE>set</CODE> method for the instantiator property.
   *
   * <p>
   * For example, to add a new item, do as follows:
   *
   * <pre>
   * getInstantiator().add(newItem);
   * </pre>
   *
   *
   * <p>
   * Objects of the following type(s) are allowed in the list
   * {@link SerializationRegistrationType.Instantiator }
   *
   *
   */
  public List<Instantiator> getInstantiators() {
    if (instantiators == null) {
      instantiators = new ArrayList<Instantiator>();
    }
    return this.instantiators;
  }


  /**
   * <p>
   * Java class for anonymous complex type.
   *
   * <p>
   * The following schema fragment specifies the expected content contained within this class.
   *
   * <pre>
   * &lt;complexType>
   *   &lt;complexContent>
   *     &lt;restriction base=""{http://www.w3.org/2001/XMLSchema}anyType"">
   *       &lt;sequence>
   *         &lt;element name=""class-name"" type=""{http://geode.apache.org/schema/cache}class-name-type""/>
   *       &lt;/sequence>
   *       &lt;attribute name=""id"" use=""required"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
   *     &lt;/restriction>
   *   &lt;/complexContent>
   * &lt;/complexType>
   * </pre>
   *
   *
   */
  @XmlAccessorType(XmlAccessType.FIELD)
  @XmlType(name = """", propOrder = {""className""})
  public static class Instantiator {

    @XmlElement(name = ""class-name"", namespace = ""http://geode.apache.org/schema/cache"",
        required = true)
    protected String className;
    @XmlAttribute(name = ""id"", required = true)
    protected String id;

    /**
     * Gets the value of the className property.
     *
     * possible object is
     * {@link String }
     *
     */
    public String getClassName() {
      return className;
    }

    /**
     * Sets the value of the className property.
     *
     * allowed object is
     * {@link String }
     *
     */
    public void setClassName(String value) {
      this.className = value;
    }

    /**
     * Gets the value of the id property.
     *
     * possible object is
     * {@link String }
     *
     */
    public String getId() {
      return id;
    }

    /**
     * Sets the value of the id property.
     *
     * allowed object is
     * {@link String }
     *
     */
    public void setId(String value) {
      this.id = value;
    }

  }


  /**
   * <p>
   * Java class for anonymous complex type.
   *
   * <p>
   * The following schema fragment specifies the expected content contained within this class.
   *
   * <pre>
   * &lt;complexType>
   *   &lt;complexContent>
   *     &lt;restriction base=""{http://www.w3.org/2001/XMLSchema}anyType"">
   *       &lt;sequence>
   *         &lt;element name=""class-name"" type=""{http://geode.apache.org/schema/cache}class-name-type""/>
   *       &lt;/sequence>
   *     &lt;/restriction>
   *   &lt;/complexContent>
   * &lt;/complexType>
   * </pre>
   *
   *
   */
  @XmlAccessorType(XmlAccessType.FIELD)
  @XmlType(name = """", propOrder = {""className""})
  public static class Serializer {

    @XmlElement(name = ""class-name"", namespace = ""http://geode.apache.org/schema/cache"",
        required = true)
    protected String className;

    /**
     * Gets the value of the className property.
     *
     * possible object is
     * {@link String }
     *
     */
    public String getClassName() {
      return className;
    }

    /**
     * Sets the value of the className property.
     *
     * allowed object is
     * {@link String }
     *
     */
    public void setClassName(String value) {
      this.className = value;
    }

  }

}
",blob
1457,"public abstract class BinaryExpression implements Expression {
    protected Expression left;
    protected Expression right;

    public BinaryExpression(Expression left, Expression right) {
        this.left = left;
        this.right = right;
    }

    public Expression getLeft() {
        return left;
    }

    public Expression getRight() {
        return right;
    }


    /**
     * @see java.lang.Object#toString()
     */
    public String toString() {
        return ""("" + left.toString() + "" "" + getExpressionSymbol() + "" "" + right.toString() + "")"";
    }

    /**
     * TODO: more efficient hashCode()
     *
     * @see java.lang.Object#hashCode()
     */
    public int hashCode() {
        return toString().hashCode();
    }

    /**
     * TODO: more efficient hashCode()
     *
     * @see java.lang.Object#equals(java.lang.Object)
     */
    public boolean equals(Object o) {

        if (o == null || !this.getClass().equals(o.getClass())) {
            return false;
        }
        return toString().equals(o.toString());

    }

    /**
     * Returns the symbol that represents this binary expression.  For example, addition is
     * represented by ""+""
     *
     * @return
     */
    public abstract String getExpressionSymbol();

    /**
     * @param expression
     */
    public void setRight(Expression expression) {
        right = expression;
    }

    /**
     * @param expression
     */
    public void setLeft(Expression expression) {
        left = expression;
    }
    
}
",data class
559,"    public WeightedAshwoodEntitySorter() {
        this.weightedDbEntityComparator = new WeightedDbEntityComparator();
        this.weightedObjEntityComparator = new WeightedObjEntityComparator();
        this.entityWeights = Collections.emptyMap();
    }
",feature envy
345,"    private static class ProxiedNiFiClient implements NiFiClient {

        private final String proxiedEntity;
        private final NiFiClient wrappedClient;

        public ProxiedNiFiClient(final NiFiClient wrappedClient, final String proxiedEntity) {
            this.proxiedEntity = proxiedEntity;
            this.wrappedClient = wrappedClient;
        }

        @Override
        public ControllerClient getControllerClient() {
            return wrappedClient.getControllerClientForProxiedEntities(proxiedEntity);
        }

        @Override
        public ControllerClient getControllerClientForProxiedEntities(String... proxiedEntity) {
            return wrappedClient.getControllerClientForProxiedEntities(proxiedEntity);
        }

        @Override
        public ControllerClient getControllerClientForToken(String token) {
            return wrappedClient.getControllerClientForToken(token);
        }

        @Override
        public FlowClient getFlowClient() {
            return wrappedClient.getFlowClientForProxiedEntities(proxiedEntity);
        }

        @Override
        public FlowClient getFlowClientForProxiedEntities(String... proxiedEntity) {
            return wrappedClient.getFlowClientForProxiedEntities(proxiedEntity);
        }

        @Override
        public FlowClient getFlowClientForToken(String token) {
            return wrappedClient.getFlowClientForToken(token);
        }

        @Override
        public ProcessGroupClient getProcessGroupClient() {
            return wrappedClient.getProcessGroupClientForProxiedEntities(proxiedEntity);
        }

        @Override
        public ProcessGroupClient getProcessGroupClientForProxiedEntities(String... proxiedEntity) {
            return wrappedClient.getProcessGroupClientForProxiedEntities(proxiedEntity);
        }

        @Override
        public ProcessGroupClient getProcessGroupClientForToken(String token) {
            return wrappedClient.getProcessGroupClientForToken(token);
        }

        @Override
        public VersionsClient getVersionsClient() {
            return wrappedClient.getVersionsClientForProxiedEntities(proxiedEntity);
        }

        @Override
        public VersionsClient getVersionsClientForProxiedEntities(String... proxiedEntity) {
            return wrappedClient.getVersionsClientForProxiedEntities(proxiedEntity);
        }

        @Override
        public VersionsClient getVersionsClientForToken(String token) {
            return wrappedClient.getVersionsClientForToken(token);
        }

        @Override
        public void close() throws IOException {
            wrappedClient.close();
        }
    }
",data class
1234,"    @Override public Iterator<Row> getRows(Session ses, SearchRow first, SearchRow last) {
        List<Row> rows = new ArrayList<>();

        Collection<ClusterNode> nodes;

        SqlSystemViewColumnCondition idCond = conditionForColumn(""NODE_ID"", first, last);

        if (idCond.isEquality()) {
            try {
                UUID nodeId = uuidFromValue(idCond.valueForEquality());

                ClusterNode node = nodeId == null ? null : ctx.discovery().node(nodeId);

                if (node != null)
                    nodes = Collections.singleton(node);
                else
                    nodes = Collections.emptySet();
            }
            catch (Exception e) {
                nodes = Collections.emptySet();
            }
        }
        else
            nodes = F.concat(false, ctx.discovery().allNodes(), ctx.discovery().daemonNodes());

        for (ClusterNode node : nodes) {
            if (node != null) {
                ClusterMetrics metrics = node.metrics();

                rows.add(
                    createRow(
                        ses,
                        node.id(),
                        valueTimestampFromMillis(metrics.getLastUpdateTime()),
                        metrics.getMaximumActiveJobs(),
                        metrics.getCurrentActiveJobs(),
                        metrics.getAverageActiveJobs(),
                        metrics.getMaximumWaitingJobs(),
                        metrics.getCurrentWaitingJobs(),
                        metrics.getAverageWaitingJobs(),
                        metrics.getMaximumRejectedJobs(),
                        metrics.getCurrentRejectedJobs(),
                        metrics.getAverageRejectedJobs(),
                        metrics.getTotalRejectedJobs(),
                        metrics.getMaximumCancelledJobs(),
                        metrics.getCurrentCancelledJobs(),
                        metrics.getAverageCancelledJobs(),
                        metrics.getTotalCancelledJobs(),
                        metrics.getMaximumJobWaitTime(),
                        metrics.getCurrentJobWaitTime(),
                        (long)metrics.getAverageJobWaitTime(),
                        metrics.getMaximumJobExecuteTime(),
                        metrics.getCurrentJobExecuteTime(),
                        (long)metrics.getAverageJobExecuteTime(),
                        metrics.getTotalJobsExecutionTime(),
                        metrics.getTotalExecutedJobs(),
                        metrics.getTotalExecutedTasks(),
                        metrics.getTotalBusyTime(),
                        metrics.getTotalIdleTime(),
                        metrics.getCurrentIdleTime(),
                        metrics.getBusyTimePercentage(),
                        metrics.getIdleTimePercentage(),
                        metrics.getTotalCpus(),
                        metrics.getCurrentCpuLoad(),
                        metrics.getAverageCpuLoad(),
                        metrics.getCurrentGcCpuLoad(),
                        metrics.getHeapMemoryInitialized(),
                        metrics.getHeapMemoryUsed(),
                        metrics.getHeapMemoryCommitted(),
                        metrics.getHeapMemoryMaximum(),
                        metrics.getHeapMemoryTotal(),
                        metrics.getNonHeapMemoryInitialized(),
                        metrics.getNonHeapMemoryUsed(),
                        metrics.getNonHeapMemoryCommitted(),
                        metrics.getNonHeapMemoryMaximum(),
                        metrics.getNonHeapMemoryTotal(),
                        metrics.getUpTime(),
                        valueTimestampFromMillis(metrics.getStartTime()),
                        valueTimestampFromMillis(metrics.getNodeStartTime()),
                        metrics.getLastDataVersion(),
                        metrics.getCurrentThreadCount(),
                        metrics.getMaximumThreadCount(),
                        metrics.getTotalStartedThreadCount(),
                        metrics.getCurrentDaemonThreadCount(),
                        metrics.getSentMessagesCount(),
                        metrics.getSentBytesCount(),
                        metrics.getReceivedMessagesCount(),
                        metrics.getReceivedBytesCount(),
                        metrics.getOutboundMessagesQueueSize()
                    )
                );
            }
        }

        return rows.iterator();
    }
",long method
921,"public class LoopedModelImpl extends MinimalEObjectImpl.Container implements LoopedModel
{
  /**
   * The cached value of the '{@link #getVisibility() <em>Visibility</em>}' attribute list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getVisibility()
   * @generated
   * @ordered
   */
  protected EList<String> visibility;

  /**
   * The cached value of the '{@link #getStatic() <em>Static</em>}' attribute list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getStatic()
   * @generated
   * @ordered
   */
  protected EList<String> static_;

  /**
   * The cached value of the '{@link #getSynchronized() <em>Synchronized</em>}' attribute list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getSynchronized()
   * @generated
   * @ordered
   */
  protected EList<String> synchronized_;

  /**
   * The cached value of the '{@link #getAbstract() <em>Abstract</em>}' attribute list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getAbstract()
   * @generated
   * @ordered
   */
  protected EList<String> abstract_;

  /**
   * The cached value of the '{@link #getFinal() <em>Final</em>}' attribute list.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getFinal()
   * @generated
   * @ordered
   */
  protected EList<String> final_;

  /**
   * The default value of the '{@link #getName() <em>Name</em>}' attribute.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getName()
   * @generated
   * @ordered
   */
  protected static final String NAME_EDEFAULT = null;

  /**
   * The cached value of the '{@link #getName() <em>Name</em>}' attribute.
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @see #getName()
   * @generated
   * @ordered
   */
  protected String name = NAME_EDEFAULT;

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  protected LoopedModelImpl()
  {
    super();
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  protected EClass eStaticClass()
  {
    return UnorderedGroupsTestPackage.Literals.LOOPED_MODEL;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EList<String> getVisibility()
  {
    if (visibility == null)
    {
      visibility = new EDataTypeEList<String>(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY);
    }
    return visibility;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EList<String> getStatic()
  {
    if (static_ == null)
    {
      static_ = new EDataTypeEList<String>(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC);
    }
    return static_;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EList<String> getSynchronized()
  {
    if (synchronized_ == null)
    {
      synchronized_ = new EDataTypeEList<String>(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED);
    }
    return synchronized_;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EList<String> getAbstract()
  {
    if (abstract_ == null)
    {
      abstract_ = new EDataTypeEList<String>(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT);
    }
    return abstract_;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public EList<String> getFinal()
  {
    if (final_ == null)
    {
      final_ = new EDataTypeEList<String>(String.class, this, UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL);
    }
    return final_;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public String getName()
  {
    return name;
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  public void setName(String newName)
  {
    String oldName = name;
    name = newName;
    if (eNotificationRequired())
      eNotify(new ENotificationImpl(this, Notification.SET, UnorderedGroupsTestPackage.LOOPED_MODEL__NAME, oldName, name));
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public Object eGet(int featureID, boolean resolve, boolean coreType)
  {
    switch (featureID)
    {
      case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:
        return getVisibility();
      case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:
        return getStatic();
      case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:
        return getSynchronized();
      case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:
        return getAbstract();
      case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:
        return getFinal();
      case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:
        return getName();
    }
    return super.eGet(featureID, resolve, coreType);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @SuppressWarnings(""unchecked"")
  @Override
  public void eSet(int featureID, Object newValue)
  {
    switch (featureID)
    {
      case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:
        getVisibility().clear();
        getVisibility().addAll((Collection<? extends String>)newValue);
        return;
      case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:
        getStatic().clear();
        getStatic().addAll((Collection<? extends String>)newValue);
        return;
      case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:
        getSynchronized().clear();
        getSynchronized().addAll((Collection<? extends String>)newValue);
        return;
      case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:
        getAbstract().clear();
        getAbstract().addAll((Collection<? extends String>)newValue);
        return;
      case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:
        getFinal().clear();
        getFinal().addAll((Collection<? extends String>)newValue);
        return;
      case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:
        setName((String)newValue);
        return;
    }
    super.eSet(featureID, newValue);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public void eUnset(int featureID)
  {
    switch (featureID)
    {
      case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:
        getVisibility().clear();
        return;
      case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:
        getStatic().clear();
        return;
      case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:
        getSynchronized().clear();
        return;
      case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:
        getAbstract().clear();
        return;
      case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:
        getFinal().clear();
        return;
      case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:
        setName(NAME_EDEFAULT);
        return;
    }
    super.eUnset(featureID);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public boolean eIsSet(int featureID)
  {
    switch (featureID)
    {
      case UnorderedGroupsTestPackage.LOOPED_MODEL__VISIBILITY:
        return visibility != null && !visibility.isEmpty();
      case UnorderedGroupsTestPackage.LOOPED_MODEL__STATIC:
        return static_ != null && !static_.isEmpty();
      case UnorderedGroupsTestPackage.LOOPED_MODEL__SYNCHRONIZED:
        return synchronized_ != null && !synchronized_.isEmpty();
      case UnorderedGroupsTestPackage.LOOPED_MODEL__ABSTRACT:
        return abstract_ != null && !abstract_.isEmpty();
      case UnorderedGroupsTestPackage.LOOPED_MODEL__FINAL:
        return final_ != null && !final_.isEmpty();
      case UnorderedGroupsTestPackage.LOOPED_MODEL__NAME:
        return NAME_EDEFAULT == null ? name != null : !NAME_EDEFAULT.equals(name);
    }
    return super.eIsSet(featureID);
  }

  /**
   * <!-- begin-user-doc -->
   * <!-- end-user-doc -->
   * @generated
   */
  @Override
  public String toString()
  {
    if (eIsProxy()) return super.toString();

    StringBuffer result = new StringBuffer(super.toString());
    result.append("" (visibility: "");
    result.append(visibility);
    result.append("", static: "");
    result.append(static_);
    result.append("", synchronized: "");
    result.append(synchronized_);
    result.append("", abstract: "");
    result.append(abstract_);
    result.append("", final: "");
    result.append(final_);
    result.append("", name: "");
    result.append(name);
    result.append(')');
    return result.toString();
  }

} //LoopedModelImpl
",blob
835,"public abstract class AbstractAzureMojo extends AbstractMojo implements TelemetryConfiguration, AuthConfiguration {
    public static final String PLUGIN_NAME_KEY = ""pluginName"";
    public static final String PLUGIN_VERSION_KEY = ""pluginVersion"";
    public static final String INSTALLATION_ID_KEY = ""installationId"";
    public static final String SESSION_ID_KEY = ""sessionId"";
    public static final String SUBSCRIPTION_ID_KEY = ""subscriptionId"";
    public static final String AUTH_TYPE = ""authType"";
    public static final String TELEMETRY_NOT_ALLOWED = ""TelemetryNotAllowed"";
    public static final String INIT_FAILURE = ""InitFailure"";
    public static final String AZURE_INIT_FAIL = ""Failed to authenticate with Azure. Please check your configuration."";
    public static final String FAILURE_REASON = ""failureReason"";
    private static final String CONFIGURATION_PATH = Paths.get(System.getProperty(""user.home""),
        "".azure"", ""mavenplugins.properties"").toString();
    private static final String FIRST_RUN_KEY = ""first.run"";
    private static final String PRIVACY_STATEMENT = ""\nData/Telemetry\n"" +
        ""---------\n"" +
        ""This project collects usage data and sends it to Microsoft to help improve our products and services.\n"" +
        ""Read Microsoft's privacy statement to learn more: https://privacy.microsoft.com/en-us/privacystatement."" +
        ""\n\nYou can change your telemetry configuration through 'allowTelemetry' property.\n"" +
        ""For more information, please go to https://aka.ms/azure-maven-config.\n"";

    //region Properties

    @Parameter(defaultValue = ""${project}"", readonly = true, required = true)
    protected MavenProject project;

    @Parameter(defaultValue = ""${session}"", readonly = true, required = true)
    protected MavenSession session;

    @Parameter(defaultValue = ""${project.build.directory}"", readonly = true, required = true)
    protected File buildDirectory;

    @Parameter(defaultValue = ""${plugin}"", readonly = true, required = true)
    protected PluginDescriptor plugin;

    /**
     * The system settings for Maven. This is the instance resulting from
     * merging global and user-level settings files.
     */
    @Parameter(defaultValue = ""${settings}"", readonly = true, required = true)
    protected Settings settings;

    @Component(role = MavenResourcesFiltering.class, hint = ""default"")
    protected MavenResourcesFiltering mavenResourcesFiltering;

    /**
     * Authentication setting for Azure Management API.<br/>
     * Below are the supported sub-elements within {@code <authentication>}. You can use one of them to authenticate
     * with azure<br/>
     * {@code <serverId>} specifies the credentials of your Azure service principal, by referencing a server definition
     * in Maven's settings.xml<br/>
     * {@code <file>} specifies the absolute path of your authentication file for Azure.
     *
     * @since 0.1.0
     */
    @Parameter
    protected AuthenticationSetting authentication;

    /**
     * Azure subscription Id. You only need to specify it when:
     * <ul>
     * <li>you are using authentication file</li>
     * <li>there are more than one subscription in the authentication file</li>
     * </ul>
     *
     * @since 0.1.0
     */
    @Parameter
    protected String subscriptionId = """";

    /**
     * Boolean flag to turn on/off telemetry within current Maven plugin.
     *
     * @since 0.1.0
     */
    @Parameter(property = ""allowTelemetry"", defaultValue = ""true"")
    protected boolean allowTelemetry;

    /**
     * Boolean flag to control whether throwing exception from current Maven plugin when meeting any error.<br/>
     * If set to true, the exception from current Maven plugin will fail the current Maven run.
     *
     * @since 0.1.0
     */
    @Parameter(property = ""failsOnError"", defaultValue = ""true"")
    protected boolean failsOnError;

    /**
     * Use a HTTP proxy host for the Azure Auth Client
     */
    @Parameter(property = ""httpProxyHost"", readonly = false, required = false)
    protected String httpProxyHost;

    /**
     * Use a HTTP proxy port for the Azure Auth Client
     */
    @Parameter(property = ""httpProxyPort"", defaultValue = ""80"")
    protected int httpProxyPort;

    private AzureAuthHelper azureAuthHelper = new AzureAuthHelper(this);

    private Azure azure;

    private TelemetryProxy telemetryProxy;

    private String sessionId = UUID.randomUUID().toString();

    private String installationId = GetHashMac.getHashMac();

    //endregion

    //region Getter

    public MavenProject getProject() {
        return project;
    }

    public MavenSession getSession() {
        return session;
    }

    public String getBuildDirectoryAbsolutePath() {
        return buildDirectory.getAbsolutePath();
    }

    public MavenResourcesFiltering getMavenResourcesFiltering() {
        return mavenResourcesFiltering;
    }

    public Settings getSettings() {
        return settings;
    }

    public AuthenticationSetting getAuthenticationSetting() {
        return authentication;
    }

    public String getSubscriptionId() {
        return subscriptionId;
    }

    public boolean isTelemetryAllowed() {
        return allowTelemetry;
    }

    public boolean isFailingOnError() {
        return failsOnError;
    }

    public String getSessionId() {
        return sessionId;
    }

    public String getInstallationId() {
        return installationId == null ? """" : installationId;
    }

    public String getPluginName() {
        return plugin.getArtifactId();
    }

    public String getPluginVersion() {
        return plugin.getVersion();
    }

    public String getUserAgent() {
        return isTelemetryAllowed() ? String.format(""%s/%s %s:%s %s:%s"", getPluginName(), getPluginVersion(),
                        INSTALLATION_ID_KEY, getInstallationId(), SESSION_ID_KEY, getSessionId())
                : String.format(""%s/%s"", getPluginName(), getPluginVersion());
    }

    public String getHttpProxyHost() {
        return httpProxyHost;
    }  
    
    public int getHttpProxyPort() {
        return httpProxyPort;
    } 

    public Azure getAzureClient() throws AzureAuthFailureException {
        if (azure == null) {
            azure = azureAuthHelper.getAzureClient();
            if (azure == null) {
                getTelemetryProxy().trackEvent(INIT_FAILURE);
                throw new AzureAuthFailureException(AZURE_INIT_FAIL);
            } else {
                // Repopulate subscriptionId in case it is not configured.
                getTelemetryProxy().addDefaultProperty(SUBSCRIPTION_ID_KEY, azure.subscriptionId());
            }
        }
        return azure;
    }

    public TelemetryProxy getTelemetryProxy() {
        if (telemetryProxy == null) {
            initTelemetry();
        }
        return telemetryProxy;
    }

    protected void initTelemetry() {
        telemetryProxy = new AppInsightsProxy(this);
        if (!isTelemetryAllowed()) {
            telemetryProxy.trackEvent(TELEMETRY_NOT_ALLOWED);
            telemetryProxy.disable();
        }
    }

    //endregion

    //region Telemetry Configuration Interface

    public Map<String, String> getTelemetryProperties() {
        final Map<String, String> map = new HashMap<>();
        map.put(INSTALLATION_ID_KEY, getInstallationId());
        map.put(PLUGIN_NAME_KEY, getPluginName());
        map.put(PLUGIN_VERSION_KEY, getPluginVersion());
        map.put(SUBSCRIPTION_ID_KEY, getSubscriptionId());
        map.put(SESSION_ID_KEY, getSessionId());
        map.put(AUTH_TYPE, getAuthType());
        return map;
    }

    // TODO:
    // Add AuthType ENUM and move to AzureAuthHelper.
    public String getAuthType() {
        final AuthenticationSetting authSetting = getAuthenticationSetting();
        if (authSetting == null) {
            return ""AzureCLI"";
        }
        if (StringUtils.isNotEmpty(authSetting.getServerId())) {
            return ""ServerId"";
        }
        if (authSetting.getFile() != null) {
            return ""AuthFile"";
        }
        return ""Unknown"";
    }

    //endregion

    //region Entry Point

    @Override
    public void execute() throws MojoExecutionException {
        try {
            // Work around for Application Insights Java SDK:
            // Sometimes, NoClassDefFoundError will be thrown even after Maven build is completed successfully.
            // An issue has been filed at https://github.com/Microsoft/ApplicationInsights-Java/issues/416
            // Before this issue is fixed, set default uncaught exception handler for all threads as work around.
            Thread.setDefaultUncaughtExceptionHandler(new DefaultUncaughtExceptionHandler());

            final Properties prop = new Properties();
            if (isFirstRun(prop)) {
                infoWithMultipleLines(PRIVACY_STATEMENT);
                updateConfigurationFile(prop);
            }

            if (isSkipMojo()) {
                info(""Skip execution."");
                trackMojoSkip();
            } else {
                trackMojoStart();

                doExecute();

                trackMojoSuccess();
            }
        } catch (Exception e) {
            handleException(e);
        } finally {
            // When maven goal executes too quick, The HTTPClient of AI SDK may not fully initialized and will step
            // into endless loop when close, we need to call it in main thread.
            // Refer here for detail codes: https://github.com/Microsoft/ApplicationInsights-Java/blob/master/core/src
            // /main/java/com/microsoft/applicationinsights/internal/channel/common/ApacheSender43.java#L103
            ApacheSenderFactory.INSTANCE.create().close();
        }
    }

    /**
     * Sub-class can override this method to decide whether skip execution.
     *
     * @return Boolean to indicate whether skip execution.
     */
    protected boolean isSkipMojo() {
        return false;
    }

    /**
     * Entry point of sub-class. Sub-class should implement this method to do real work.
     *
     * @throws Exception
     */
    protected abstract void doExecute() throws Exception;

    //endregion

    //region Telemetry

    protected void trackMojoSkip() {
        getTelemetryProxy().trackEvent(this.getClass().getSimpleName() + "".skip"");
    }

    protected void trackMojoStart() {
        getTelemetryProxy().trackEvent(this.getClass().getSimpleName() + "".start"");
    }

    protected void trackMojoSuccess() {
        getTelemetryProxy().trackEvent(this.getClass().getSimpleName() + "".success"");
    }

    protected void trackMojoFailure(final String message) {
        final HashMap<String, String> failureReason = new HashMap<>();
        failureReason.put(FAILURE_REASON, message);
        getTelemetryProxy().trackEvent(this.getClass().getSimpleName() + "".failure"", failureReason);
    }

    //endregion

    //region Helper methods

    protected void handleException(final Exception exception) throws MojoExecutionException {
        String message = exception.getMessage();
        if (StringUtils.isEmpty(message)) {
            message = exception.toString();
        }
        trackMojoFailure(message);

        if (isFailingOnError()) {
            throw new MojoExecutionException(message, exception);
        } else {
            error(message);
        }
    }

    private boolean isFirstRun(Properties prop) {
        try {
            final File configurationFile = new File(CONFIGURATION_PATH);
            if (configurationFile.exists()) {
                try (InputStream input = new FileInputStream(CONFIGURATION_PATH)) {
                    prop.load(input);
                    final String firstRunValue = prop.getProperty(FIRST_RUN_KEY);
                    if (firstRunValue != null && !firstRunValue.isEmpty() && firstRunValue.equalsIgnoreCase(""false"")) {
                        return false;
                    }
                }
            } else {
                configurationFile.getParentFile().mkdirs();
                configurationFile.createNewFile();
            }
        } catch (Exception e) {
            // catch exceptions here to avoid blocking mojo execution.
            debug(e.getMessage());
        }
        return true;
    }

    private void updateConfigurationFile(Properties prop) {
        try (OutputStream output = new FileOutputStream(CONFIGURATION_PATH)) {
            prop.setProperty(FIRST_RUN_KEY, ""false"");
            prop.store(output, ""Azure Maven Plugin configurations"");
        } catch (Exception e) {
            // catch exceptions here to avoid blocking mojo execution.
            debug(e.getMessage());
        }
    }

    protected class DefaultUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler {
        @Override
        public void uncaughtException(Thread t, Throwable e) {
            debug(""uncaughtException: "" + e);
        }
    }

    //endregion

    //region Logging

    public void debug(final String message) {
        getLog().debug(message);
    }

    public void info(final String message) {
        getLog().info(message);
    }

    public void infoWithMultipleLines(final String messages) {
        final String[] messageArray = messages.split(""\\n"");
        for (final String line : messageArray) {
            getLog().info(line);
        }
    }

    public void warning(final String message) {
        getLog().warn(message);
    }

    public void error(final String message) {
        getLog().error(message);
    }

    //endregion
}
",blob
275,"@SuppressWarnings(""serial"")
public class InvalidStateTransitionException extends Exception {

  private Enum<?> currentState;
  private Enum<?> event;

  public InvalidStateTransitionException(Enum<?> currentState, Enum<?> event) {
    super(""Invalid event: "" + event + "" at "" + currentState);
    this.currentState = currentState;
    this.event = event;
  }

  public Enum<?> getCurrentState() {
    return currentState;
  }

  public Enum<?> getEvent() {
    return event;
  }

}
",data class
1002,"		@Override
		@Nullable
		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
			// Invocation on EntityManager interface coming in...

			if (method.getName().equals(""equals"")) {
				// Only consider equal when proxies are identical.
				return (proxy == args[0]);
			}
			else if (method.getName().equals(""hashCode"")) {
				// Use hashCode of EntityManager proxy.
				return hashCode();
			}
			else if (method.getName().equals(""toString"")) {
				// Deliver toString without touching a target EntityManager.
				return ""Shared EntityManager proxy for target factory ["" + this.targetFactory + ""]"";
			}
			else if (method.getName().equals(""getEntityManagerFactory"")) {
				// JPA 2.0: return EntityManagerFactory without creating an EntityManager.
				return this.targetFactory;
			}
			else if (method.getName().equals(""getCriteriaBuilder"") || method.getName().equals(""getMetamodel"")) {
				// JPA 2.0: return EntityManagerFactory's CriteriaBuilder/Metamodel (avoid creation of EntityManager)
				try {
					return EntityManagerFactory.class.getMethod(method.getName()).invoke(this.targetFactory);
				}
				catch (InvocationTargetException ex) {
					throw ex.getTargetException();
				}
			}
			else if (method.getName().equals(""unwrap"")) {
				// JPA 2.0: handle unwrap method - could be a proxy match.
				Class<?> targetClass = (Class<?>) args[0];
				if (targetClass != null && targetClass.isInstance(proxy)) {
					return proxy;
				}
			}
			else if (method.getName().equals(""isOpen"")) {
				// Handle isOpen method: always return true.
				return true;
			}
			else if (method.getName().equals(""close"")) {
				// Handle close method: suppress, not valid.
				return null;
			}
			else if (method.getName().equals(""getTransaction"")) {
				throw new IllegalStateException(
						""Not allowed to create transaction on shared EntityManager - "" +
						""use Spring transactions or EJB CMT instead"");
			}

			// Determine current EntityManager: either the transactional one
			// managed by the factory or a temporary one for the given invocation.
			EntityManager target = EntityManagerFactoryUtils.doGetTransactionalEntityManager(
					this.targetFactory, this.properties, this.synchronizedWithTransaction);

			if (method.getName().equals(""getTargetEntityManager"")) {
				// Handle EntityManagerProxy interface.
				if (target == null) {
					throw new IllegalStateException(""No transactional EntityManager available"");
				}
				return target;
			}
			else if (method.getName().equals(""unwrap"")) {
				Class<?> targetClass = (Class<?>) args[0];
				if (targetClass == null) {
					return (target != null ? target : proxy);
				}
				// We need a transactional target now.
				if (target == null) {
					throw new IllegalStateException(""No transactional EntityManager available"");
				}
				// Still perform unwrap call on target EntityManager.
			}
			else if (transactionRequiringMethods.contains(method.getName())) {
				// We need a transactional target now, according to the JPA spec.
				// Otherwise, the operation would get accepted but remain unflushed...
				if (target == null || (!TransactionSynchronizationManager.isActualTransactionActive() &&
						!target.getTransaction().isActive())) {
					throw new TransactionRequiredException(""No EntityManager with actual transaction available "" +
							""for current thread - cannot reliably process '"" + method.getName() + ""' call"");
				}
			}

			// Regular EntityManager operations.
			boolean isNewEm = false;
			if (target == null) {
				logger.debug(""Creating new EntityManager for shared EntityManager invocation"");
				target = (!CollectionUtils.isEmpty(this.properties) ?
						this.targetFactory.createEntityManager(this.properties) :
						this.targetFactory.createEntityManager());
				isNewEm = true;
			}

			// Invoke method on current EntityManager.
			try {
				Object result = method.invoke(target, args);
				if (result instanceof Query) {
					Query query = (Query) result;
					if (isNewEm) {
						Class<?>[] ifcs = ClassUtils.getAllInterfacesForClass(query.getClass(), this.proxyClassLoader);
						result = Proxy.newProxyInstance(this.proxyClassLoader, ifcs,
								new DeferredQueryInvocationHandler(query, target));
						isNewEm = false;
					}
					else {
						EntityManagerFactoryUtils.applyTransactionTimeout(query, this.targetFactory);
					}
				}
				return result;
			}
			catch (InvocationTargetException ex) {
				throw ex.getTargetException();
			}
			finally {
				if (isNewEm) {
					EntityManagerFactoryUtils.closeEntityManager(target);
				}
			}
		}
",long method
506,"public class MainActivity extends Activity {
  private static final String TAG  = MainActivity.class.getSimpleName();
  private static final int REQUEST_ENABLE_BT = 0;
  private static final int REQUEST_LOCATION = 1;
  private static final String NEARBY_BEACONS_FRAGMENT_TAG = ""NearbyBeaconsFragmentTag"";
  private static final String SETTINGS_FRAGMENT_TAG = ""SettingsFragmentTag"";
  private static final String BLOCKED_URLS_FRAGMENT_TAG = ""BlockedUrlsFragmentTag"";
  private static final String ABOUT_FRAGMENT_TAG = ""AboutFragmentTag"";
  private static final String DEMOS_FRAGMENT_TAG = ""DemosFragmentTag"";

  @Override
  protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    Utils.setSharedPreferencesDefaultValues(this);
    PermissionCheck.getInstance().setCheckingPermissions(false);
  }

  @Override
  public boolean onCreateOptionsMenu(Menu menu) {
    // Inflate the menu; this adds items to the action bar if it is present.
    getMenuInflater().inflate(R.menu.main, menu);
    return true;
  }

  /**
   * Called when a menu item is tapped.
   */
  @Override
  public boolean onOptionsItemSelected(MenuItem item) {
    switch (item.getItemId()) {
      // If the about menu item was selected
      case R.id.action_about:
        showAboutFragment();
        return true;
      // If the settings menu item was selected
      case R.id.action_settings:
        showSettingsFragment();
        return true;
      case R.id.block_settings:
        showBlockedFragment();
        return true;
      case R.id.action_demos:
        showDemosFragment();
        return true;
      // If the action bar up button was pressed
      case android.R.id.home:
        getFragmentManager().popBackStack();
        getActionBar().setDisplayHomeAsUpEnabled(false);
    }
    return super.onOptionsItemSelected(item);
  }

  /**
   * Ensures Bluetooth is available on the beacon and it is enabled. If not,
   * displays a dialog requesting user permission to enable Bluetooth.
   */
  private void checkPermissions(BluetoothAdapter bluetoothAdapter) {
    // Acquire lock
    PermissionCheck.getInstance().setCheckingPermissions(true);
    if (!bluetoothAdapter.isEnabled()) {
      Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
      startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);
      return;
    }
    ensureLocationPermissionIsEnabled();
  }

  @Override
  protected void onActivityResult (int requestCode, int resultCode, Intent data) {
    Log.d(TAG, ""onActivityResult"");
    if (requestCode == REQUEST_ENABLE_BT && resultCode == -1) {
      ensureLocationPermissionIsEnabled();
      return;
    }
    Toast.makeText(this, getString(R.string.bt_on), Toast.LENGTH_LONG).show();
    finish();
  }

  private void ensureLocationPermissionIsEnabled() {
    if (Build.VERSION.SDK_INT >= 23 && ContextCompat.checkSelfPermission(this,
        android.Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
      ActivityCompat.requestPermissions(this, new String[]{
          android.Manifest.permission.ACCESS_COARSE_LOCATION}, REQUEST_LOCATION);
      return;
    }
    PermissionCheck.getInstance().setCheckingPermissions(false);
    finishLoad();
  }

  @Override
  public void onRequestPermissionsResult(int requestCode,
      String permissions[], int[] grantResults) {
    switch (requestCode) {
      case REQUEST_LOCATION: {
        // If request is cancelled, the result arrays are empty.
        if (grantResults.length > 0
            && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
          PermissionCheck.getInstance().setCheckingPermissions(false);
        } else {
          Toast.makeText(getApplicationContext(),
              getString(R.string.loc_permission), Toast.LENGTH_LONG).show();
          finish();
        }
        break;
      }
      default:
    }
  }

  @Override
  protected void onResume() {
    super.onResume();
    // Lock to prevent onResume from running until all permissions are granted
    if (!PermissionCheck.getInstance().isCheckingPermissions()) {
      Log.d(TAG, ""resumed MainActivity"");
      BluetoothManager btManager = (BluetoothManager) getSystemService(BLUETOOTH_SERVICE);
      BluetoothAdapter btAdapter = btManager != null ? btManager.getAdapter() : null;
      if (btAdapter == null) {
        Toast.makeText(getApplicationContext(),
            R.string.error_bluetooth_support, Toast.LENGTH_LONG).show();
        finish();
        return;
      }
      if (Utils.checkIfUserHasOptedIn(this)) {
        Log.d(TAG, ""checkingPermissions"");
        checkPermissions(btAdapter);
      } else {
        // Show the oob activity
        Intent intent = new Intent(this, OobActivity.class);
        startActivity(intent);
      }
    }
  }

  private void finishLoad() {
    Intent intent = new Intent(this, ScreenListenerService.class);
    startService(intent);
    NearbyBeaconsFragment nearbyBeaconsFragment =
        (NearbyBeaconsFragment) getFragmentManager().findFragmentByTag(NEARBY_BEACONS_FRAGMENT_TAG);
    if (nearbyBeaconsFragment != null) {
      nearbyBeaconsFragment.restartScan();
    } else {
      showFragment(new NearbyBeaconsFragment(), NEARBY_BEACONS_FRAGMENT_TAG, false);
    }
  }

  /**
   * Show the fragment to configure the app.
   */
  private void showSettingsFragment() {
    showFragment(new SettingsFragment(), SETTINGS_FRAGMENT_TAG, true);
  }

  /**
   * Show the fragment displaying information about this application.
   */
  private void showAboutFragment() {
    showFragment(new AboutFragment(), ABOUT_FRAGMENT_TAG, true);
  }

  /**
   * Show the fragment displaying the blocked URLs.
   */
  private void showBlockedFragment() {
    showFragment(new BlockedFragment(), BLOCKED_URLS_FRAGMENT_TAG, true);
  }

  /**
   * Show the fragment displaying the demos.
   */
  private void showDemosFragment() {
    showFragment(new DemosFragment(), DEMOS_FRAGMENT_TAG, true);
  }

  @SuppressLint(""CommitTransaction"")
  private void showFragment(Fragment newFragment, String fragmentTag, boolean addToBackStack) {
    FragmentTransaction transaction = getFragmentManager().beginTransaction()
        .setCustomAnimations(
            R.animator.fade_in_and_slide_up_fragment,
            R.animator.fade_out_fragment,
            R.animator.fade_in_activity,
            R.animator.fade_out_fragment)
        .replace(R.id.main_activity_container, newFragment, fragmentTag);
    if (addToBackStack) {
      transaction.addToBackStack(null);
    }
    transaction.commit();
  }
}
",blob
557,"    private Collection<MavenProject> getAggregatedProjects()
    {
        Map<Path, MavenProject> reactorProjectsMap = new HashMap<>();
        for ( MavenProject reactorProject : this.reactorProjects )
        {
            reactorProjectsMap.put( reactorProject.getBasedir().toPath(), reactorProject );
        }

        return modulesForAggregatedProject( project, reactorProjectsMap );
    }
",feature envy
595,"    private class ClientSelectDeleteMutationPlan implements MutationPlan {
        private final StatementContext context;
        private final TableRef targetTableRef;
        private final QueryPlan dataPlan;
        private final QueryPlan bestPlan;
        private final boolean hasPreOrPostProcessing;
        private final DeletingParallelIteratorFactory parallelIteratorFactory;
        private final List<TableRef> otherTableRefs;
        private final TableRef projectedTableRef;
        private final int maxSize;
        private final int maxSizeBytes;
        private final PhoenixConnection connection;

        public ClientSelectDeleteMutationPlan(TableRef targetTableRef, QueryPlan dataPlan, QueryPlan bestPlan,
                                              boolean hasPreOrPostProcessing,
                                              DeletingParallelIteratorFactory parallelIteratorFactory,
                                              List<TableRef> otherTableRefs, TableRef projectedTableRef, int maxSize,
                                              int maxSizeBytes, PhoenixConnection connection) {
            this.context = bestPlan.getContext();
            this.targetTableRef = targetTableRef;
            this.dataPlan = dataPlan;
            this.bestPlan = bestPlan;
            this.hasPreOrPostProcessing = hasPreOrPostProcessing;
            this.parallelIteratorFactory = parallelIteratorFactory;
            this.otherTableRefs = otherTableRefs;
            this.projectedTableRef = projectedTableRef;
            this.maxSize = maxSize;
            this.maxSizeBytes = maxSizeBytes;
            this.connection = connection;
        }

        @Override
        public ParameterMetaData getParameterMetaData() {
            return context.getBindManager().getParameterMetaData();
        }

        @Override
        public StatementContext getContext() {
            return context;
        }

        @Override
        public TableRef getTargetRef() {
            return targetTableRef;
        }

        @Override
        public Set<TableRef> getSourceRefs() {
            return dataPlan.getSourceRefs();
        }

        @Override
        public Operation getOperation() {
          return operation;
        }

        @Override
        public MutationState execute() throws SQLException {
            ResultIterator iterator = bestPlan.iterator();
            try {
                // If we're not doing any pre or post processing, we can produce the delete mutations directly
                // in the parallel threads executed for the scan
                if (!hasPreOrPostProcessing) {
                    Tuple tuple;
                    long totalRowCount = 0;
                    if (parallelIteratorFactory != null) {
                        parallelIteratorFactory.setQueryPlan(bestPlan);
                        parallelIteratorFactory.setOtherTableRefs(otherTableRefs);
                        parallelIteratorFactory.setProjectedTableRef(projectedTableRef);
                    }
                    while ((tuple=iterator.next()) != null) {// Runs query
                        Cell kv = tuple.getValue(0);
                        totalRowCount += PLong.INSTANCE.getCodec().decodeLong(kv.getValueArray(), kv.getValueOffset(), SortOrder.getDefault());
                    }
                    // Return total number of rows that have been deleted from the table. In the case of auto commit being off
                    // the mutations will all be in the mutation state of the current connection. We need to divide by the
                    // total number of tables we updated as otherwise the client will get an inflated result.
                    int totalTablesUpdateClientSide = 1; // data table is always updated
                    PTable bestTable = bestPlan.getTableRef().getTable();
                    // global immutable tables are also updated client side (but don't double count the data table)
                    if (bestPlan != dataPlan && isMaintainedOnClient(bestTable)) {
                        totalTablesUpdateClientSide++;
                    }
                    for (TableRef otherTableRef : otherTableRefs) {
                        PTable otherTable = otherTableRef.getTable();
                        // Don't double count the data table here (which morphs when it becomes a projected table, hence this check)
                        if (projectedTableRef != otherTableRef && isMaintainedOnClient(otherTable)) {
                            totalTablesUpdateClientSide++;
                        }
                    }
                    MutationState state = new MutationState(maxSize, maxSizeBytes, connection, totalRowCount/totalTablesUpdateClientSide);

                    // set the read metrics accumulated in the parent context so that it can be published when the mutations are committed.
                    state.setReadMetricQueue(context.getReadMetricsQueue());

                    return state;
                } else {
                    // Otherwise, we have to execute the query and produce the delete mutations in the single thread
                    // producing the query results.
                    return deleteRows(context, iterator, bestPlan, projectedTableRef, otherTableRefs);
                }
            } finally {
                iterator.close();
            }
        }

        @Override
        public ExplainPlan getExplainPlan() throws SQLException {
            List<String> queryPlanSteps =  bestPlan.getExplainPlan().getPlanSteps();
            List<String> planSteps = Lists.newArrayListWithExpectedSize(queryPlanSteps.size()+1);
            planSteps.add(""DELETE ROWS"");
            planSteps.addAll(queryPlanSteps);
            return new ExplainPlan(planSteps);
        }

        @Override
        public Long getEstimatedRowsToScan() throws SQLException {
            return bestPlan.getEstimatedRowsToScan();
        }

        @Override
        public Long getEstimatedBytesToScan() throws SQLException {
            return bestPlan.getEstimatedBytesToScan();
        }

        @Override
        public Long getEstimateInfoTimestamp() throws SQLException {
            return bestPlan.getEstimateInfoTimestamp();
        }

        @Override
        public QueryPlan getQueryPlan() {
            return bestPlan;
        }
    }
",blob
1166,"  @Override
  public java.lang.String toString() {
    java.lang.StringBuilder sb = new java.lang.StringBuilder(""SupervisorInfo("");
    boolean first = true;

    sb.append(""time_secs:"");
    sb.append(this.time_secs);
    first = false;
    if (!first) sb.append("", "");
    sb.append(""hostname:"");
    if (this.hostname == null) {
      sb.append(""null"");
    } else {
      sb.append(this.hostname);
    }
    first = false;
    if (is_set_assignment_id()) {
      if (!first) sb.append("", "");
      sb.append(""assignment_id:"");
      if (this.assignment_id == null) {
        sb.append(""null"");
      } else {
        sb.append(this.assignment_id);
      }
      first = false;
    }
    if (is_set_used_ports()) {
      if (!first) sb.append("", "");
      sb.append(""used_ports:"");
      if (this.used_ports == null) {
        sb.append(""null"");
      } else {
        sb.append(this.used_ports);
      }
      first = false;
    }
    if (is_set_meta()) {
      if (!first) sb.append("", "");
      sb.append(""meta:"");
      if (this.meta == null) {
        sb.append(""null"");
      } else {
        sb.append(this.meta);
      }
      first = false;
    }
    if (is_set_scheduler_meta()) {
      if (!first) sb.append("", "");
      sb.append(""scheduler_meta:"");
      if (this.scheduler_meta == null) {
        sb.append(""null"");
      } else {
        sb.append(this.scheduler_meta);
      }
      first = false;
    }
    if (is_set_uptime_secs()) {
      if (!first) sb.append("", "");
      sb.append(""uptime_secs:"");
      sb.append(this.uptime_secs);
      first = false;
    }
    if (is_set_version()) {
      if (!first) sb.append("", "");
      sb.append(""version:"");
      if (this.version == null) {
        sb.append(""null"");
      } else {
        sb.append(this.version);
      }
      first = false;
    }
    if (is_set_resources_map()) {
      if (!first) sb.append("", "");
      sb.append(""resources_map:"");
      if (this.resources_map == null) {
        sb.append(""null"");
      } else {
        sb.append(this.resources_map);
      }
      first = false;
    }
    if (is_set_server_port()) {
      if (!first) sb.append("", "");
      sb.append(""server_port:"");
      sb.append(this.server_port);
      first = false;
    }
    sb.append("")"");
    return sb.toString();
  }
",long method
856,"public class BaseScriptEvalUtil
{	
	private static Logger logger = Logger.getLogger( BaseScriptEvalUtil.class.getName( ) );
	
	/**
	 * No instance
	 */
	protected BaseScriptEvalUtil( )
	{
	}

	/**
	 * @param exprText
	 * @param value
	 * @return an instance of ExprTextAndValue
	 */
	public static ExprTextAndValue newExprInfo( Object value )
	{
		return ExprTextAndValue.newInstance( value );
	}
	
	/**
	 * Evaluates a conditional expression. A conditional expression comprises of
	 * a Javascript expression, an operator, and up to 2 operands (which are
	 * Javascript expressions themselves).<br>
	 * Both op1 and op2 will be encapsulated to ExprTextAndValue type to show
	 * specific message in case anything goes wrong, they are assumed not to be
	 * null as well.
	 * <p>
	 * The basic rule for comparison: obj will always be considered as the
	 * default data type,i.e. obj, op1 and op2 will be formatted to the superset
	 * of obj (or Double if obj is numeric)on the condition they are comparable.<br>
	 * e.g.<br>
	 * obj: Integer=>obj, op1 and op2 will be formatted to Double.<br>
	 * obj: Timestamp=>obj, op1 and op2 will be formatted to Date.<br>
	 * obj: Boolean=>obj and op1 will be formatted to Boolean.<br>
	 * obj: String=>obj, op1 and op2 will remain the same
	 * 
	 * @param obj
	 * @param operator
	 * @param Op1
	 * @param Op2
	 * @return
	 * @throws DataException
	 */
	public static Object evalConditionalExpr( Object obj, int operator,
			Object Op1, Object Op2 ) throws DataException
	{
		return evalConditionalExpr( obj, operator, Op1, Op2, null );
	}
	
	/**
	 * 
	 * @param obj
	 * @param operator
	 * @param Op1
	 * @param Op2
	 * @param compareHints the hints for comparison
	 * @return
	 * @throws DataException
	 */
	public static Object evalConditionalExpr( Object obj, int operator,
			Object Op1, Object Op2, BaseCompareHints compareHints )
			throws DataException
	{
		return evalConditionalExpr( obj, operator, new Object[]{
				Op1, Op2
		}, compareHints );
	}

	/**
	 * 
	 * @param obj
	 * @param operator
	 * @param ops
	 * @return
	 * @throws DataException
	 */
	public static Object evalConditionalExpr( Object obj, int operator,
			Object[] ops ) throws DataException
	{
		return evalConditionalExpr( obj, operator, ops, null );
	}

	/**
	 * 
	 * @param obj
	 * @param operator
	 * @param op1
	 * @param op2
	 * @return A Boolean result
	 * @throws DataException
	 */
	public static Object evalConditionalExpr( Object obj, int operator,
			Object[] ops, BaseCompareHints compareHints ) throws DataException
	{
		ExprTextAndValue[] opTextAndValue = new ExprTextAndValue[ops.length];
		for ( int i = 0; i < ops.length; i++ )
		{
			opTextAndValue[i] = createExprTextAndValueInstance( ops[i] );
		}
		
		Object resultObject = obj;
		Object[] resultOp = new Object[ops.length];
		for ( int i = 0; i < ops.length; i++ )
		{
			resultOp[i] = opTextAndValue[i].value;
			if ( operator != IConditionalExpression.OP_IN 
					&& operator != IConditionalExpression.OP_NOT_IN )
			{
				if ( opTextAndValue[i].value != null 
						&& opTextAndValue[i].value.getClass( ).isArray( ))
				{
					//For case multi-value type report parameter is involved in signle-value-required filters 
					
					//more than 1 values are provided for multi-value parameter
					if ( Array.getLength( opTextAndValue[i].value ) > 1 )
					{
						throw new DataException(
								ResourceConstants.BAD_COMPARE_SINGLE_WITH_MULITI, toStringForMultiValues( opTextAndValue[i].value ) );
					}
					//no or only one value is provided for multi-value parameter
					if ( Array.getLength( opTextAndValue[i].value ) == 0 )
					{
						resultOp[i] = null;
					}
					else if ( Array.getLength( opTextAndValue[i].value ) == 1 )
					{
						resultOp[i] = Array.get( opTextAndValue[i].value, 0 );
					}
					opTextAndValue[i].value = resultOp[i];
				}
			}
		}

		Object[] obArray = MiscUtil.isComparable( obj, operator, opTextAndValue );
		if ( obArray != null )
		{
			resultObject = obArray[0];
			for ( int i = 1; i < obArray.length; i++ )
			{
				resultOp[i - 1] = obArray[i];
			}
		}
		
		if ( logger.isLoggable( Level.FINER ) )
		{
			String logStr = """";
			for ( int i = 0; i < ops.length; i++ )
			{
				logStr += resultOp[i] == null
						? null
						: ( "", resultOp"" + i + ""="" + BaseLogUtil.toString( resultOp[i] ) );
			}
			logger.entering( BaseScriptEvalUtil.class.getName( ),
					""evalConditionalExpr"",
					""evalConditionalExpr() resultObject=""
							+ BaseLogUtil.toString( resultObject ) + "", operator=""
							+ operator + logStr );
		}
		boolean result = false;

		if ( compareHints != null
				&& IBaseDataSetDesign.NULLS_ORDERING_EXCLUDE_NULLS.equals( compareHints.getNullType( ) ) )
		{
			if ( resultObject == null )
				return false;
		}
		switch ( operator )
		{
			case IConditionalExpression.OP_EQ :
				result = compare( resultObject, resultOp[0], compareHints ) == 0;
				break;
			case IConditionalExpression.OP_NE :
				result = compare( resultObject, resultOp[0], compareHints ) != 0;
				break;
			case IConditionalExpression.OP_LT :
				result = compare( resultObject, resultOp[0], compareHints ) < 0;
				break;
			case IConditionalExpression.OP_LE :
				result = compare( resultObject, resultOp[0], compareHints ) <= 0;
				break;
			case IConditionalExpression.OP_GE :
				result = compare( resultObject, resultOp[0], compareHints ) >= 0;
				break;
			case IConditionalExpression.OP_GT :
				result = compare( resultObject, resultOp[0], compareHints ) > 0;
				break;
			case IConditionalExpression.OP_BETWEEN :
				result = between( resultObject,
						resultOp[0],
						resultOp[1],
						compareHints );
				break;
			case IConditionalExpression.OP_NOT_BETWEEN :
				result = !( between( resultObject,
						resultOp[0],
						resultOp[1],
						compareHints ) );
				break;
			case IConditionalExpression.OP_NULL :
				result = resultObject == null;
				break;
			case IConditionalExpression.OP_NOT_NULL :
				result = resultObject != null;
				break;
			case IConditionalExpression.OP_TRUE :
				result = isTrueOrFalse( resultObject, Boolean.TRUE );
				break;
			case IConditionalExpression.OP_FALSE :
				result = isTrueOrFalse( resultObject, Boolean.FALSE );
				break;
			case IConditionalExpression.OP_LIKE :
				result = like( resultObject, resultOp[0] );
				break;
			case IConditionalExpression.OP_NOT_LIKE :
				result = !like( resultObject, resultOp[0] );
				break;
				
			case IConditionalExpression.OP_TOP_N :
			case IConditionalExpression.OP_BOTTOM_N :
			case IConditionalExpression.OP_TOP_PERCENT :
			case IConditionalExpression.OP_BOTTOM_PERCENT :
				// Top/Bottom expressions are only available in filters for now; direct evaluation is not supported
				throw new DataException(
						ResourceConstants.UNSUPPORTTED_COND_OPERATOR, ""Top/Bottom(N) outside of row filters"" );
				
		/*
		 * case IConditionalExpression.OP_ANY : throw new DataException(
		 * ResourceConstants.UNSUPPORTTED_COND_OPERATOR, ""ANY"" );
		 */
			case IConditionalExpression.OP_MATCH :
				result = match( resultObject, resultOp[0] );
				break;
			case IConditionalExpression.OP_NOT_MATCH :
				result = !match( resultObject, resultOp[0] );
				break;
			case IConditionalExpression.OP_IN :
				result = in( resultObject, resultOp );
				break;
			case IConditionalExpression.OP_NOT_IN :
				result = !in( resultObject, resultOp );
				break;
			case IConditionalExpression.OP_JOINT :
				result = joint( resultObject, resultOp[0] );
				break;
			default :
				throw new DataException(
						ResourceConstants.UNSUPPORTTED_COND_OPERATOR, Integer.valueOf( operator) );
		}
		
		logger.exiting( BaseScriptEvalUtil.class.getName( ),
				""evalConditionalExpr"",
				 Boolean.valueOf( result ) );
		return Boolean.valueOf( result );
	}

	/**
	 * @param o1
	 * @return
	 */
	private static ExprTextAndValue createExprTextAndValueInstance( Object o )
	{
		ExprTextAndValue op;
		if(! (o instanceof ExprTextAndValue ))
			op = ExprTextAndValue.newInstance( o );
		else
			op = (ExprTextAndValue)o;
		return op;
	}

	/**
	 * Compare two value according to given comparator.
	 * @param obj1
	 * @param obj2
	 * @param comp
	 * @return
	 * @throws DataException
	 */
	public static int compare( Object obj1, Object obj2,
			BaseCompareHints compareHints ) throws DataException
	{
		if ( obj1 == null || obj2 == null )
		{
			return CompareNullValue( obj1, obj2, compareHints );
		}
		try
		{
			if ( MiscUtil.isSameType( obj1, obj2 ) )
			{
				if ( obj1 instanceof String )
				{
					if ( compareHints == null )
                        return ( (String)obj1 ).compareTo( (String)obj2 );
					return compareAsString( obj1, obj2, compareHints );
				}
				else if ( obj1 instanceof Boolean )
				{
					if ( obj1.equals( obj2 ) )
						return 0;

					Boolean bool = (Boolean) obj1;
					if ( bool.equals( Boolean.TRUE ) )
						return 1;
					else
						return -1;
				}
				else if ( obj1 instanceof Comparable )
				{
					return ( (Comparable) obj1 ).compareTo( obj2 );
				}
				else if ( obj1 instanceof Collection )
				{
					Collection o1 = (Collection) obj1;
					Collection o2 = (Collection) obj2;
					if ( o1.size( ) != o2.size( ) )
						return -1;
					Iterator it1 = o1.iterator( );
					Iterator it2 = o2.iterator( );
					while ( it1.hasNext( ) )
					{
						int result = compare( it1.next( ), it2.next( ) );
						if ( result != 0 )
							return result;
					}
					return 0;
				}
				// most judgements should end here
				else
				{
					return compareAsString( obj1, obj2, compareHints );
				}
			}
			else if ( MiscUtil.isBigDecimal( obj1 )
					|| MiscUtil.isBigDecimal( obj2 ) )
			{
				BigDecimal a = DataTypeUtil.toBigDecimal( obj1 );
				BigDecimal b = DataTypeUtil.toBigDecimal( obj2 );
				return a.compareTo( b );
			}
			else if ( MiscUtil.isNumericOrString( obj1 )
					&& MiscUtil.isNumericOrString( obj2 ) )
			{
				try
				{
					return DataTypeUtil.toDouble( obj1 )
							.compareTo( DataTypeUtil.toDouble( obj2 ) );
				}
				catch ( Exception e )
				{
					return compareAsString( obj1, obj2, compareHints );
				}
			}
			else if ( MiscUtil.isDateOrString( obj1 )
					&& MiscUtil.isDateOrString( obj2 ) )
			{
				try
				{
					return DataTypeUtil.toDate( obj1 )
							.compareTo( DataTypeUtil.toDate( obj2 ) );
				}
				catch ( Exception e )
				{
					return compareAsString( obj1, obj2, compareHints );
				}
			}
			else if ( MiscUtil.isBooleanOrString( obj1 )
					&& MiscUtil.isBooleanOrString( obj2 ) )
			{
				try
				{
					boolean b1 = DataTypeUtil.toBoolean( obj1 ).booleanValue( );
					boolean b2 = DataTypeUtil.toBoolean( obj2 ).booleanValue( );
					if ( b1 == b2 )
					{
						return 0;
					}
					else if ( b1 == false && b2 == true )
					{
						return -1;
					}
					else
					{
						return 1;
					}
				}
				catch ( Exception e )
				{
					return compareAsString( obj1, obj2, compareHints );
				}
			}
			else if ( obj1 instanceof String || obj2 instanceof String )
			{
				return compareAsString( obj1, obj2, compareHints );
			}
			else
				throw new DataException( ResourceConstants.BAD_COMPARE_EXPR,
						new Object[]{
								obj1, obj2
						} );
		}
		catch ( BirtException e )
		{
			throw DataException.wrap( e );
		}

	}
	
	private static String toStringForMultiValues( Object o )
	{
		if ( o == null )
		{
			return null;
		}
		if ( o.getClass( ).isArray( ) && Array.getLength( o ) > 1 )
		{
			StringBuilder buf = new StringBuilder( );
			buf.append(Array.get( o, 0 ));
			buf.append("", "");
			buf.append(Array.get( o, 1));
			buf.append( ""..."");
			return buf.toString( );
		}
		return o.toString( );
	}

	private static int CompareNullValue( Object obj1, Object obj2,
			BaseCompareHints compareHints )
	{
		if ( compareHints == null )
		{
			// all non-null values are greater than null value
			if ( obj1 == null && obj2 != null )
				return -1;
			else if ( obj1 != null && obj2 == null )
				return 1;
			else
				return 0;
		}
		else
		{
			String type = compareHints.getNullType( );
			if ( IBaseDataSetDesign.NULLS_ORDERING_NULLS_HIGHEST.equals( type ) )
			{
				// all non-null values are less than null value
				if ( obj1 == null && obj2 != null )
					return 1;
				else if ( obj1 != null && obj2 == null )
					return -1;
				else
					return 0;
			}
			else if ( IBaseDataSetDesign.NULLS_ORDERING_NULLS_LOWEST.equals( type ) )
			{
				// all non-null values are greater than null value
				if ( obj1 == null && obj2 != null )
					return -1;
				else if ( obj1 != null && obj2 == null )
					return 1;
				else
					return 0;
			}
			else
			{
				// all non-null values are greater than null value
				if ( obj1 == null && obj2 != null )
					return -1;
				else if ( obj1 != null && obj2 == null )
					return 1;
				else
					return 0;
			}
		}
	}

	private static int compareAsString( Object obj1, Object obj2,
			BaseCompareHints comp ) throws BirtException
	{
		return ( comp == null || comp.getComparator( ) == null )
				? DataTypeUtil.toString( obj1 )
						.compareTo( DataTypeUtil.toString( obj2 ) )
				: comp.getComparator( ).compare( DataTypeUtil.toString( obj1 ),
						DataTypeUtil.toString( obj2 ) );
	}

	/**
	 * Most objects should already be formatted to the same type by method
	 * formatToComparable at this point if neither of them is null. This method
	 * will therefore be terminated pretty soon except for calling from method
	 * between with weird parameters like obj:String, op1:Double and op2:Date.
	 * 
	 * @param obj1
	 * @param obj2
	 * @return -1,0 and 1 standing for <,= and > respectively
	 * @throws DataException
	 */
	public static int compare( Object obj1, Object obj2 ) throws DataException
	{
		return compare( obj1, obj2, null );
	}

	/**
	 * @param resultObject
	 * @param resultOp1
	 * @param resultOp2
	 * @return true if resultObject is between resultOp1 and resultOp2, false
	 *         otherwise
	 * @throws DataException
	 */
	private static boolean between( Object resultObject, Object resultOp1,
			Object resultOp2, BaseCompareHints compareHints ) throws DataException
	{
		return compare( resultObject, resultOp1, compareHints ) >= 0
				&& compare( resultObject, resultOp2, compareHints ) <= 0;
	}

	/**
	 * @param obj
	 * @param bln
	 * @return true if obj equals to bln, false otherwise
	 */
	private static boolean isTrueOrFalse( Object obj, Boolean bln )
	{
		if ( obj == null )
			return false;
		try
		{
			return DataTypeUtil.toBoolean( obj ).equals( bln );
		}
		catch ( BirtException e )
		{
			return false;
		}
	}
	// Pattern to determine if a Match operation uses Javascript regexp syntax
	private static Pattern s_JSReExprPattern;
	
	// Gets a matcher to determine if a match pattern string is of JavaScript syntax
	// The pattern matches string like ""/regexpr/gmi"", which is used in JavaScript to construct a RegExp object
	private static Matcher getJSReExprPatternMatcher( String patternStr )
	{
		if ( s_JSReExprPattern == null )
			s_JSReExprPattern = Pattern.compile(""^/(.*)/([a-zA-Z]*)$"");
		return s_JSReExprPattern.matcher( patternStr );
	}
	
	private static boolean match( Object source, Object pattern ) throws DataException
	{
		String sourceStr = null;
		try
		{
			sourceStr = (source == null)? """": DataTypeUtil.toLocaleNeutralString( source );
		}
		catch ( BirtException e1 )
		{
			throw new DataException( e1.getLocalizedMessage( ), e1 );
		}
		String patternStr;
		try
		{
			patternStr = ( pattern == null )? """" : DataTypeUtil.toLocaleNeutralString( pattern );
		}
		catch ( BirtException e1 )
		{
			throw new DataException( e1.getLocalizedMessage( ), e1 );
		}

		// Pattern can be one of the following:
		// (1)Java regular expression pattern
		// (2)JavaScript RegExp construction syntax: ""/RegExpr/[flags]"", where flags 
		// can be a combination of 'g', 'm', 'i'
		Matcher jsReExprMatcher = getJSReExprPatternMatcher( patternStr ); 
		int flags = 0;
		if ( jsReExprMatcher.matches() )
		{
			// This is a Javascript syntax
			// Get the flags; we only expect ""m"", ""i"", ""g""
			String flagStr = patternStr.substring( jsReExprMatcher.start(2), 
					jsReExprMatcher.end(2) );
			for ( int i = 0; i < flagStr.length(); i++)
			{
				switch ( flagStr.charAt(i) )
				{
					case 'm': flags |= Pattern.MULTILINE; break;
					case 'i': flags |= Pattern.CASE_INSENSITIVE; break;
					case 'g': break;			// this flag has no effect
						
					default:
						throw new DataException( ResourceConstants.MATCH_ERROR, patternStr );
				}
			}
			patternStr = patternStr.substring( jsReExprMatcher.start(1), 
					jsReExprMatcher.end(1) );
		}
		
		try
		{
			Matcher m = Pattern.compile( patternStr, flags ).matcher( sourceStr);
			return m.find(); 
		}
		catch ( PatternSyntaxException e )
		{
			throw new DataException( ResourceConstants.MATCH_ERROR, e, patternStr );
		}
	}

	/**
	 * @return true if obj1 matches the given pattern, false otherwise
	 * @throws DataException
	 */
	private static boolean like( Object source, Object pattern ) throws DataException
	{
		String sourceStr = null;
		try
		{
			sourceStr = (source == null)? """": DataTypeUtil.toLocaleNeutralString( source );
		}
		catch ( BirtException e1 )
		{
			throw new DataException( e1.getLocalizedMessage( ), e1 );
		}
		String patternStr;
		try
		{
			patternStr = ( pattern == null )? """" : DataTypeUtil.toLocaleNeutralString( pattern );
		}
		catch ( BirtException e1 )
		{
			throw new DataException( e1.getLocalizedMessage( ), e1 );
		}
	
		// As per Bugzilla 115940, LIKE operator's pattern syntax is SQL-like: it
		// recognizes '_' and '%'. Backslash '\' escapes the next character.
		
		// Construct a Java RegExp pattern based on input. We need to translate 
		// unescaped '%' to '.*', and '_' to '.'
		// Also need to escape any RegExp metacharacter in the source pattern.
		
		final String reservedChars = ""([{^$|)?*+."";
		int patternLen = patternStr.length();
		StringBuffer buffer = new StringBuffer( patternLen * 2 );
		
		for ( int i = 0; i < patternLen; i++)
		{
			char c = patternStr.charAt(i);
			if ( c == '\\' )
			{
				// Escape char; copy next character to new pattern if 
				// it is '\', '%' or '_'
				++i;
				if ( i < patternLen )
				{
					c = patternStr.charAt( i );
					if ( c == '%' || c == '_' )
						buffer.append( c );
					else if ( c == '\\' )
						buffer.append( ""\\\\"");		// Need to escape \
				}
				else
				{
					buffer.append( ""\\\\"" );  	// Leave last \ and escape it
				}
			}
			else if ( c == '%')
			{
				buffer.append("".*"");
			}
			else if ( c == '_')
			{
				buffer.append(""."");
			}
			else
			{
				// Copy this char to target, escape if it is a metacharacter
				if ( reservedChars.indexOf(c) >= 0 )
				{
					buffer.append('\\');
				}
				buffer.append(c);
			}
		}
		
		try
		{
			String newPatternStr = buffer.toString();
			Pattern p = Pattern.compile( newPatternStr );
			Matcher m = p.matcher( sourceStr.toString( ) );
			return m.matches( );
		}
		catch ( PatternSyntaxException e )
		{
			throw new DataException( ResourceConstants.MATCH_ERROR,  e, pattern );
		}
	}
	
	/**
	 * 
	 * @param resultObj
	 * @return
	 * @throws DataException
	 */
	private static boolean in( Object target, Object[] resultObj )
			throws DataException
	{
		if ( resultObj == null )
			return false;
		for ( int i = 0; i < resultObj.length; i++ )
		{
			if ( compare( target, resultObj[i] ) == 0 )
				return true;
		}
		return false;
	}
	
	/**
	 * 
	 * @param resultObj
	 * @return
	 * @throws DataException
	 */
	private static boolean joint( Object target, Object resultObj )
			throws DataException
	{
		if ( resultObj == null || target == null )
			return false;
		return !java.util.Collections.disjoint( Arrays.asList( target.toString( )
				.split( "","" )),
				Arrays.asList( resultObj.toString( ).split( "","" ) ) ) ;
	}

	/**
	 * Evaluates a IJSExpression or IConditionalExpression
	 * 
	 * @param expr
	 * @param cx
	 * @param scope
	 * @param source
	 * @param lineNo
	 * @return 
	 * @throws BirtException 
	 */
	public static Object evalExpr( IBaseExpression expr, ScriptContext cx,
			String source, int lineNo ) throws DataException
	{
		try
		{
			if ( logger.isLoggable( Level.FINER ) )
				logger.entering( BaseScriptEvalUtil.class.getName( ),
						""evalExpr"",
						""evalExpr() expr=""
								+ BaseLogUtil.toString( expr ) + "", source=""
								+ source + "", lineNo="" + lineNo );
			Object result;
			if ( expr == null )
			{
				result = null;
			}
			else if ( expr instanceof IConditionalExpression )
			{
				// If this is a prepared top(n)/bottom(n) expr, use its
				// evaluator
				Object handle = expr.getHandle( );
				if ( handle instanceof BaseNEvaluator )
				{
					result = Boolean.valueOf( ( (BaseNEvaluator) handle ).evaluate( cx,
							( (IDataScriptEngine) cx.getScriptEngine( IDataScriptEngine.ENGINE_NAME ) ).getJSScope( cx ) ) );
				}
				else
				{
					ConditionalExpression conditionalExpr = (ConditionalExpression) expr;
					Object expression = evalExpr( conditionalExpr.getExpression( ),
							cx,
							source,
							lineNo );
					if ( conditionalExpr.getOperand1( ) instanceof IExpressionCollection )
					{
						IExpressionCollection combinedExpr = (IExpressionCollection) ( (IConditionalExpression) expr ).getOperand1( );
						Object[] exprs = combinedExpr.getExpressions( )
								.toArray( );

						Object[] opValues = new Object[exprs.length];

						for ( int i = 0; i < opValues.length; i++ )
						{
							opValues[i] = evalExpr( (IBaseExpression) exprs[i],
									cx,
									source,
									lineNo );
						}
						result = evalConditionalExpr( expression,
								conditionalExpr.getOperator( ),
								MiscUtil.flatternMultipleValues( opValues ),
								null );
					}
					else
					{

						Object Op1 = evalExpr( MiscUtil.constructValidScriptExpression( (IScriptExpression) conditionalExpr.getOperand1( ) ),
								cx,
								source,
								lineNo );
						Object Op2 = evalExpr( MiscUtil.constructValidScriptExpression( (IScriptExpression) conditionalExpr.getOperand2( ) ),
								cx,
								source,
								lineNo );
						result = evalConditionalExpr( expression,
								conditionalExpr.getOperator( ),
								new Object[]{
										Op1, Op2
								},
								null );
					}
				}
			}
			else if ( expr instanceof ICollectionConditionalExpression )
			{
				Collection<IScriptExpression> testExpr = ((ICollectionConditionalExpression)expr).getExpr( );
				Collection<Collection<IScriptExpression>> operand = ((ICollectionConditionalExpression)expr).getOperand( );
				List<Object> testObj = new ArrayList<Object>( );
				boolean in = false;
				for( IScriptExpression se : testExpr )
				{
					testObj.add( evalExpr( se, cx, source, lineNo  ) );
				}
				for( Collection<IScriptExpression> op : operand )
				{
					List<Object> targetObj = new ArrayList<Object>( );
					for( IScriptExpression se : op )
					{
						if( se == null )
						{
							targetObj.add( null );
						}
						else
						{
							if( se.getHandle( )== null )
							{
								se.setHandle( evalExpr( se, cx, source, lineNo ) );
							}
							targetObj.add( se.getHandle( ) );
						}
					}
					if( compareIgnoreNull( testObj, targetObj ) == 0 )
					{
						in = Boolean.TRUE;
						break;
					}
				}
				result = ( ( (ICollectionConditionalExpression) expr ).getOperator( ) == ICollectionConditionalExpression.OP_IN )
						? in : ( !in );
			}
			else
			{
				IScriptExpression jsExpr = (IScriptExpression) expr;
				if( BaseExpression.constantId.equals( jsExpr.getScriptId( ) ) && jsExpr.getHandle( ) != null )
				{
					result = jsExpr.getHandle( );
				}
				else
				{
					if( BaseExpression.constantId.equals( jsExpr.getScriptId( ) ) )
					{
						result = jsExpr.getText( );
						jsExpr.setHandle( result );
					}
					else if ( jsExpr.getText( ) != null && jsExpr.getHandle( ) != null )
					{
						if ( jsExpr.getHandle( ) instanceof ICompiledScript )
						{
							result = cx.evaluate( (ICompiledScript) jsExpr.getHandle( ) );
						}
						else
						{
							result = ( (BaseCompiledExpression) jsExpr.getHandle( ) ).evaluate( cx,
									( (IDataScriptEngine) cx.getScriptEngine( IDataScriptEngine.ENGINE_NAME ) ).getJSScope( cx ) );
						}
					}
					else
					{
						result = evaluateJSAsExpr( cx,
								( (IDataScriptEngine) cx.getScriptEngine( IDataScriptEngine.ENGINE_NAME ) ).getJSScope( cx ),
								jsExpr.getText( ),
								source,
								lineNo );
					}
					
				}
			}
			
			if ( logger.isLoggable( Level.FINER ) )
				logger.exiting( BaseScriptEvalUtil.class.getName( ),
						""evalExpr"",
						result );
			return result;
		}
		catch ( BirtException e )
		{
			throw DataException.wrap( e );
		}

	}	
	
	public static int compareIgnoreNull( List<Object> valueList, List<Object> targetList ) throws DataException
	{
		for( int i = 0; i < valueList.size( ); i++ )
		{
			if( targetList.get( i ) == null )
				continue;
			int result = compare( valueList.get( i ), targetList.get( i ) ); 
			if(  result != 0 )
				return result;
		}
		return 0;
	}
	
	/**
	 * Evaluates a ROM script and converts the result type into one accepted by
	 * BIRT: Double (for all numeric types), java.util.Date, String, Boolean.
	 * Converts Javascript exception and script runtime exceptions to
	 * DataException
	 * 
	 * @param cx
	 * @param scope
	 * @param scriptText
	 * @param source
	 * @param lineNo
	 * @return
	 * @throws DataException
	 */
	public static Object evaluateJSAsExpr( ScriptContext cx, Scriptable scope,
			String scriptText, String source, int lineNo)
			throws DataException 
	{
		if ( logger.isLoggable( Level.FINER ) )
			logger.entering( BaseScriptEvalUtil.class.getName( ),
				""evaluateJSExpr"",
				""evaluateJSExpr() scriptText="" + scriptText 
				+ "", source="" + source 
				+ "", lineNo="" + lineNo);
		
		Object result;
		try
		{
			result = JavascriptEvalUtil.evaluateScript( Context.getCurrentContext( ), scope, scriptText, source, 0 );
		}
		catch ( BirtException e )
		{
			throw DataException.wrap( e );
		}
		return result;
	}
	
	
	/**
	 * Wrap the text and value of the operand
	 * 
	 */
	public static class ExprTextAndValue
	{
		Object value;

		/**
		 * 
		 * @param exprText
		 * @param value
		 * @return
		 */
		public static ExprTextAndValue newInstance(	Object value )
		{
			return new ExprTextAndValue( value );
		}

		/**
		 * 
		 * @param exprText
		 * @param value
		 */
		public ExprTextAndValue( Object value )
		{
			this.value = value;
		}
	}	
	
	/**
	 * Utility for miscellaneous use
	 * 
	 */
	private static class MiscUtil
	{
		/**
		 * 
		 * @param resultExpr
		 * @param resultOp1
		 * @return
		 */
		private static boolean isSameType( Object resultExpr, Object resultOp1 )
		{
			return resultExpr.getClass( ).equals( resultOp1.getClass( ) );
		}
		
		/**
		 * 
		 * @param result
		 * @return
		 */
		private static boolean isNumericOrString( Object result )
		{
			return ( result instanceof Number ) || ( result instanceof String );
		}
		/**
		 * 
		 * @param result
		 * @return
		 */
		private static boolean isBigDecimal( Object result )
		{
			return result instanceof BigDecimal;
		}

		/**
		 * 
		 * @param result
		 * @return
		 */
		private static boolean isDateOrString( Object result )
		{
			return ( result instanceof Date ) || ( result instanceof String );
		}
		
		/**
		 * 
		 * @param result
		 * @return
		 */
		private static boolean isBooleanOrString( Object result )
		{
			return ( result instanceof Boolean ) || ( result instanceof String );
		}
		
		/**
		 * 
		 * @param obj
		 * @param operator
		 * @param operands
		 * @return
		 */
		private static Object[] isComparable( Object obj, int operator,
				ExprTextAndValue[] operands )
		{
			if ( needFormat( obj, operator, operands ) )
				return formatToComparable( obj, operands );
			return null;
		}

		/**
		 * 
		 * @param obj
		 * @param operator
		 * @param ops
		 * @return
		 */
		private static boolean needFormat( Object obj, int operator,
				ExprTextAndValue[] ops )
		{
			if ( operator < IConditionalExpression.OP_EQ
					|| ( operator > IConditionalExpression.OP_NOT_BETWEEN && operator < IConditionalExpression.OP_IN )
					|| obj == null || ops.length == 0 || ops[0].value == null )
				return false;
			// op2.value can not be null either if it's a between method
			else if ( ( operator == IConditionalExpression.OP_BETWEEN || operator == IConditionalExpression.OP_NOT_BETWEEN ) &&
					ops.length < 2 )
				return false;

			return true;
		}
		
		/**
		 * To ease the methods compare and between. Exception with specific
		 * explanation will be thrown if anything goes wrong.
		 * 
		 * @param obj
		 * @param operands
		 * @return
		 */
		private static Object[] formatToComparable( Object obj,
				ExprTextAndValue[] operands )
		{
			Object[] obArray = new Object[operands.length + 1];
			obArray[0] = obj;
			for ( int i = 0; i < operands.length; i++ )
			{
				obArray[i + 1] = operands[i].value;
			}
			boolean isSameType = true;
			
			// obj will always be considered as the default data type
			// skip if op2.value!=null but is not same type as obj
			if ( isSameType( obj, obArray[1] ) )
			{
				for ( int i = 1; i < operands.length; i++ )
				{
					if ( obArray[i + 1] != null &&
							!isSameType( obj, obArray[i + 1] ) )
					{
						isSameType = false;
						break;
					}
				}
			}
			else
			{
				isSameType = false;
			}

			if ( isSameType )
				return obArray;
			else if ( obj instanceof Boolean )
				populateObArray( obArray[1], obArray );
			else
				populateObArray( obj, obArray );
			return obArray;
		}

		private static Object[] populateObArray( Object obj, Object[] obArray )
		{
			try
			{
				for ( int i = 0; i < obArray.length; i++ )
				{
					if( obArray[i] instanceof Object[] )
						return obArray;
				}
				if ( obj instanceof Number && !( obj instanceof BigDecimal ) )
				{
					for ( int i = 0; i < obArray.length; i++ )
					{
						obArray[i] = DataTypeUtil.toDouble( obArray[i] );
					}
				}
				else if ( obj instanceof java.sql.Date )
				{
					for ( int i = 0; i < obArray.length; i++ )
					{
						obArray[i] = DataTypeUtil.toSqlDate( obArray[i] );
					}
				}
				else if ( obj instanceof java.sql.Time )
				{
					for ( int i = 0; i < obArray.length; i++ )
					{
						obArray[i] = DataTypeUtil.toSqlTime( obArray[i] );
					}
				}
				else if ( obj instanceof Date )
				{
					for ( int i = 0; i < obArray.length; i++ )
					{
						obArray[i] = DataTypeUtil.toDate( obArray[i] );
					}
				}
			}
			catch ( BirtException e )
			{
				// If failed to convert to same date type for comparation,
				// simply convert them to String.
				try
				{
					makeObjectArrayStringArray( obArray );
				}
				catch ( BirtException e1 )
				{
					//should never reach here.
				}
			}
			// obArray will remain the same if obj is String rather than
			// Date,Number or Boolean
			return obArray;
		}

		/**
		 * 
		 * @param obArray
		 * @throws BirtException 
		 */
		private static void makeObjectArrayStringArray( Object[] obArray ) throws BirtException
		{
			for ( int i = 0; i < obArray.length; i++ )
			{
				if ( obArray[i] != null )
					obArray[i] = DataTypeUtil.toString( obArray[i] );
			}
		}
		
		/**
		 * @param ise
		 * @return
		 */
		private static IScriptExpression constructValidScriptExpression(
				IScriptExpression ise )
		{
			if( ise != null && BaseExpression.constantId.equals( ise.getScriptId( ) ) )
				return ise;
			
			return ise != null
					&& ise.getText( ) != null
					&& ise.getText( ).trim( ).length( ) > 0 ? ise
					: new ScriptExpression( ""null"" );
		}
		
		/**
		 * 
		 * @return
		 */
		private static Object[] flatternMultipleValues( Object[] values )
		{
			if ( values == null || values.length == 0 )
				return new Object[0];
			List flattern = new ArrayList( );
			for ( int i = 0; i < values.length; i++ )
			{
				if ( values[i] instanceof Object[] )
				{
					Object[] flatternObj = (Object[]) values[i];
					flattern.addAll( Arrays.asList( flatternMultipleValues( flatternObj ) ) );
				}
				else
				{
					flattern.add( values[i] );
				}
			}
			return flattern.toArray( );
		}
	}
}
",blob
872,"    protected void refreshInternal(Collection objs, OpCallbacks call) {
    	if (objs == null || objs.isEmpty())
    		return;
        List<Exception> exceps = null;
        try {
            // collect instances that need a refresh
            Collection<OpenJPAStateManager> load = null;
            StateManagerImpl sm;
            Object obj;
            for (Iterator<?> itr = objs.iterator(); itr.hasNext();) {
                obj = itr.next();
                if (obj == null)
                    continue;

                try {
                    sm = getStateManagerImpl(obj, true);
                    if ((processArgument(OpCallbacks.OP_REFRESH, obj, sm, call)
                        & OpCallbacks.ACT_RUN) == 0)
                        continue;

                    if (sm != null) {
                        if (sm.isDetached())
                            throw newDetachedException(obj, ""refresh"");
                        else if (sm.beforeRefresh(true)) {
                        	if (load == null)
                        		load = new ArrayList<>(objs.size());
                            load.add(sm);
                        }
                        int level = _fc.getReadLockLevel();
                        int timeout = _fc.getLockTimeout();
                        _lm.refreshLock(sm, level, timeout, null);
                        sm.readLocked(level, level);
                    } else if (assertPersistenceCapable(obj).pcIsDetached()
                        == Boolean.TRUE)
                        throw newDetachedException(obj, ""refresh"");
                } catch (OpenJPAException ke) {
                    exceps = add(exceps, ke);
                }
            }

            // refresh all
            if (load != null) {
                Collection<Object> failed = _store.loadAll(load, null,
                    StoreManager.FORCE_LOAD_REFRESH, _fc, null);
                if (failed != null && !failed.isEmpty())
                    exceps = add(exceps, newObjectNotFoundException(failed));

                // perform post-refresh transitions and make sure all fetch
                // group fields are loaded
                for (Iterator<OpenJPAStateManager> itr = load.iterator(); itr.hasNext();) {
                    sm = (StateManagerImpl) itr.next();
                    if (failed != null && failed.contains(sm.getId()))
                        continue;

                    try {
                        sm.afterRefresh();
                        sm.load(_fc, StateManagerImpl.LOAD_FGS, null, null,
                            false);
                    } catch (OpenJPAException ke) {
                        exceps = add(exceps, ke);
                    }
                }
            }

            // now invoke postRefresh on all the instances
            for (Iterator<?> itr = objs.iterator(); itr.hasNext();) {
                try {
                    sm = getStateManagerImpl(itr.next(), true);
                    if (sm != null && !sm.isDetached())
                        fireLifecycleEvent(sm.getManagedInstance(), null,
                            sm.getMetaData(), LifecycleEvent.AFTER_REFRESH);
                } catch (OpenJPAException ke) {
                    exceps = add(exceps, ke);
                }
            }
        } catch (OpenJPAException ke) {
            throw ke;
        } catch (RuntimeException re) {
            throw new GeneralException(re);
        }
        throwNestedExceptions(exceps, false);
    }
",long method
1257,"public class Parser {

    public static GetOrderReferenceDetailsResponseData getOrderReferenceDetails(ResponseData rawResponse) throws AmazonServiceException {
        final GetOrderReferenceDetailsResponse response = marshalXML(GetOrderReferenceDetailsResponse.class, rawResponse);
        return new GetOrderReferenceDetailsResponseData(response, rawResponse);
    }


    public static SetOrderReferenceDetailsResponseData setOrderReferenceDetails(ResponseData rawResponse) throws AmazonServiceException {
        final SetOrderReferenceDetailsResponse response = marshalXML(SetOrderReferenceDetailsResponse.class, rawResponse);
        return new SetOrderReferenceDetailsResponseData(response, rawResponse);
    }


    public static AuthorizeResponseData getAuthorizeData(ResponseData rawResponse) throws AmazonServiceException {
        final AuthorizeResponse response = marshalXML(AuthorizeResponse.class, rawResponse);
        return new AuthorizeResponseData(response, rawResponse);
    }

    public static GetAuthorizationDetailsResponseData getAuthorizationDetailsData(ResponseData rawResponse) throws AmazonServiceException {
        final GetAuthorizationDetailsResponse response = marshalXML(GetAuthorizationDetailsResponse.class, rawResponse);
        return new GetAuthorizationDetailsResponseData(response, rawResponse);
    }

    public static CaptureResponseData getCapture(ResponseData rawResponse) throws AmazonServiceException {
        final CaptureResponse response = marshalXML(CaptureResponse.class, rawResponse);
        return new CaptureResponseData(response, rawResponse);
    }

    public static GetCaptureDetailsResponseData getCaptureDetailsData(ResponseData rawResponse) throws AmazonServiceException {
        final GetCaptureDetailsResponse response = marshalXML(GetCaptureDetailsResponse.class, rawResponse);
        return new GetCaptureDetailsResponseData(response, rawResponse);
    }

    public static ConfirmOrderReferenceResponseData confirmOrderReference(ResponseData rawResponse) throws AmazonServiceException {
        final ConfirmOrderReferenceResponse response = marshalXML(ConfirmOrderReferenceResponse.class, rawResponse);
        return new ConfirmOrderReferenceResponseData(response, rawResponse);
    }

    public static CloseAuthorizationResponseData closeAuthorizationResponse(ResponseData rawResponse) throws AmazonServiceException {
        final CloseAuthorizationResponse response = marshalXML(CloseAuthorizationResponse.class, rawResponse);
        return new CloseAuthorizationResponseData(response, rawResponse);
    }

    public static CancelOrderReferenceResponseData getCancelOrderReference(ResponseData rawResponse) throws AmazonServiceException {
        final CancelOrderReferenceResponse response = marshalXML(CancelOrderReferenceResponse.class, rawResponse);
        return new CancelOrderReferenceResponseData(response, rawResponse);
    }

    public static CloseOrderReferenceResponseData getCloseOrderReference(ResponseData rawResponse) throws AmazonServiceException {
        final CloseOrderReferenceResponse response = marshalXML(CloseOrderReferenceResponse.class, rawResponse);
        return new CloseOrderReferenceResponseData(response, rawResponse);
    }

    public static RefundResponseData getRefundData(ResponseData rawResponse) throws AmazonServiceException {
        final RefundResponse response = marshalXML(RefundResponse.class, rawResponse);
        return new RefundResponseData(response, rawResponse);
    }

    public static GetRefundDetailsResponseData getRefundDetailsData(ResponseData rawResponse) throws AmazonServiceException {
        final GetRefundDetailsResponse response = marshalXML(GetRefundDetailsResponse.class, rawResponse);
        return new GetRefundDetailsResponseData(response, rawResponse);
    }

    public static GetBillingAgreementDetailsResponseData getBillingAgreementDetailsData(ResponseData rawResponse) throws AmazonServiceException {
        final GetBillingAgreementDetailsResponse response = marshalXML(GetBillingAgreementDetailsResponse.class, rawResponse);
        return new GetBillingAgreementDetailsResponseData(response, rawResponse);
    }

    public static SetBillingAgreementDetailsResponseData getSetBillingAgreementDetailsResponse(ResponseData rawResponse) throws AmazonServiceException {
        final SetBillingAgreementDetailsResponse response = marshalXML(SetBillingAgreementDetailsResponse.class, rawResponse);
        return new SetBillingAgreementDetailsResponseData(response, rawResponse);
    }

    public static ValidateBillingAgreementResponseData getValidateBillingAgreementResponse(ResponseData rawResponse) throws AmazonServiceException {
        final ValidateBillingAgreementResponse response = marshalXML(ValidateBillingAgreementResponse.class, rawResponse);
        return new ValidateBillingAgreementResponseData(response, rawResponse);
    }

    public static ConfirmBillingAgreementResponseData confirmBillingAgreementResponse(ResponseData rawResponse) throws AmazonServiceException {
        final ConfirmBillingAgreementResponse response = marshalXML(ConfirmBillingAgreementResponse.class, rawResponse);
        return new ConfirmBillingAgreementResponseData(response, rawResponse);
    }

    public static AuthorizeOnBillingAgreementResponseData getAuthorizeOnBillingAgreement(ResponseData rawResponse) throws AmazonServiceException {
        final AuthorizeOnBillingAgreementResponse response = marshalXML(AuthorizeOnBillingAgreementResponse.class, rawResponse);
        return new AuthorizeOnBillingAgreementResponseData(response, rawResponse);
    }

    public static CloseBillingAgreementResponseData closeBillingAgreementResponse(ResponseData rawResponse) throws AmazonServiceException {
        final CloseBillingAgreementResponse response = marshalXML(CloseBillingAgreementResponse.class, rawResponse);
        return new CloseBillingAgreementResponseData(response, rawResponse);
    }

    public static GetProviderCreditDetailsResponseData getGetProviderCreditDetails(ResponseData rawResponse) throws AmazonServiceException {
        final GetProviderCreditDetailsResponse response = marshalXML(GetProviderCreditDetailsResponse.class, rawResponse);
        return new GetProviderCreditDetailsResponseData(response, rawResponse);
    }

    public static GetProviderCreditReversalDetailsResponseData getProviderCreditReversalDetails(ResponseData rawResponse) throws AmazonServiceException {
        final GetProviderCreditReversalDetailsResponse response = marshalXML(GetProviderCreditReversalDetailsResponse.class, rawResponse);
        return new GetProviderCreditReversalDetailsResponseData(response, rawResponse);
    }

    public static ReverseProviderCreditResponseData getReverseProviderCreditResponseData(ResponseData rawResponse) throws AmazonServiceException {
        final ReverseProviderCreditResponse response = marshalXML(ReverseProviderCreditResponse.class, rawResponse);
        return new ReverseProviderCreditResponseData(response, rawResponse);
    }

    public static GetServiceStatusResponseData getServiceStatus(
                ResponseData rawResponse) throws AmazonServiceException {
        final GetServiceStatusResponse response = marshalXML(
                GetServiceStatusResponse.class, rawResponse);
        return new GetServiceStatusResponseData(response, rawResponse);
    }

    public static CreateOrderReferenceForIdResponseData createOrderReferenceForId(
                ResponseData rawResponse) throws AmazonServiceException {
        final CreateOrderReferenceForIdResponse response = marshalXML(
                CreateOrderReferenceForIdResponse.class, rawResponse);
        return new CreateOrderReferenceForIdResponseData(response, rawResponse);
    }

    public static ListOrderReferenceResponseData listOrderReference(ResponseData rawResponse) throws AmazonServiceException {
        final ListOrderReferenceResponse response = marshalXML(ListOrderReferenceResponse.class, rawResponse);
        return new ListOrderReferenceResponseData(response, rawResponse);
    }

    public static ListOrderReferenceByNextTokenResponseData listOrderReferenceByNextToken(ResponseData rawResponse) throws AmazonServiceException {
        final ListOrderReferenceByNextTokenResponse response = marshalXML(ListOrderReferenceByNextTokenResponse.class, rawResponse);
        return new ListOrderReferenceByNextTokenResponseData(response, rawResponse);
    }

    public static SetOrderAttributesResponseData setOrderAttributes(ResponseData rawResponse) throws AmazonServiceException {
        final SetOrderAttributesResponse response = marshalXML(SetOrderAttributesResponse.class, rawResponse);
        return new SetOrderAttributesResponseData(response, rawResponse);
    }

    public static GetMerchantAccountStatusResponseData getMerchantAccountStatus(ResponseData rawResponse) throws AmazonServiceException {
        final GetMerchantAccountStatusResponse response = marshalXML(GetMerchantAccountStatusResponse.class, rawResponse);
        return new GetMerchantAccountStatusResponseData(response, rawResponse);
    }

    public static <T> T marshalXML(Class<T> clazz, ResponseData rawResponse) throws AmazonServiceException  {
        try {
            if (rawResponse.getStatusCode() == 200) {
                T responseObject = null;
                final JAXBContext context = JAXBContext.newInstance(clazz);

                // Ignore the namespace only for marshalling purpose
                final String noNamespaceXML = rawResponse.toXML().replaceAll(
                        ""xmlns(?:.*?)?=\""http://mws.amazonservices.com/schema/OffAmazonPayments/2013-01-01\"""", """");
                final StringReader reader = new StringReader(noNamespaceXML);
                final Unmarshaller unmarshaller = context.createUnmarshaller();

                final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
                xmlInputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
                xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);
                final XMLStreamReader xmlStreamReader = xmlInputFactory.createXMLStreamReader(reader);
                responseObject = (T) unmarshaller.unmarshal(xmlStreamReader);

                return responseObject;
            } else {
                generateErrorException(rawResponse);
            }
        } catch (JAXBException e) {
            throw new AmazonClientException(rawResponse, ""Encountered marshalling error while marshalling data "" + rawResponse.toXML(), e);
        }
        catch (XMLStreamException e) {
            throw new AmazonClientException(rawResponse, ""Encountered marshalling error while marshalling data "" + rawResponse.toXML(), e);
        }

        return null;
    }

    public static void generateErrorException(ResponseData rawResponse) throws AmazonServiceException, JAXBException {
        final JAXBContext context = JAXBContext.newInstance(ErrorResponse.class);

        // Ignore the namespace only for marshalling purpose
        final String noNamespaceXML = rawResponse.toXML().replaceAll(
                ""xmlns(?:.*?)?=\""http://mws.amazonservices.com/schema/OffAmazonPayments/2013-01-01\"""", """");
        final StringReader reader = new StringReader(noNamespaceXML);
        final Unmarshaller unmarshaller = context.createUnmarshaller();

        final XMLInputFactory xmlInputFactory = XMLInputFactory.newInstance();
        xmlInputFactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
        xmlInputFactory.setProperty(XMLInputFactory.SUPPORT_DTD, false);
        try {
            final XMLStreamReader xmlStreamReader = xmlInputFactory.createXMLStreamReader(reader);
            final ErrorResponse result = (ErrorResponse) unmarshaller.unmarshal(xmlStreamReader);
            throw new AmazonServiceException(result, rawResponse);
        } catch (XMLStreamException e) {
            throw new AmazonClientException(rawResponse, ""Encountered marshalling error while marshalling data "" + rawResponse.toXML(), e);
        }
    }
}
",blob
1025,"@Component(""org.apache.usergrid.rest.management.organizations.applications.ApplicationResource"")
@Scope(""prototype"")
@Produces({
    MediaType.APPLICATION_JSON,
    ""application/javascript"",
    ""application/x-javascript"",
    ""text/ecmascript"",
    ""application/ecmascript"",
    ""text/jscript""
})
public class ApplicationResource extends AbstractContextResource {

    private static final Logger logger = LoggerFactory.getLogger(ApplicationResource.class);

    public static final String CONFIRM_APPLICATION_IDENTIFIER = ""confirm_application_identifier"";
    public static final String RESTORE_PASSWORD = ""restore_password"";

    //@Autowired
    //protected ExportService exportService;

    OrganizationInfo organization;
    UUID applicationId;
    ApplicationInfo application;

    @Autowired
    private SignInProviderFactory signInProviderFactory;


    public ApplicationResource() {
    }


    public ApplicationResource init( OrganizationInfo organization, UUID applicationId ) {
        this.organization = organization;
        this.applicationId = applicationId;
        return this;
    }


    public ApplicationResource init( OrganizationInfo organization, ApplicationInfo application ) {
        this.organization = organization;
        applicationId = application.getId();
        this.application = application;
        return this;
    }



    @RequireOrganizationAccess
    @GET
    @JSONP
    @Produces({MediaType.APPLICATION_JSON, ""application/javascript""})
    public ApiResponse getApplication(
            @Context UriInfo ui, @QueryParam(""callback"") @DefaultValue(""callback"") String callback )
        throws Exception {

        ApiResponse response = createApiResponse();
        ServiceManager sm = smf.getServiceManager( applicationId );
        response.setAction( ""get"" );
        response.setApplication( sm.getApplication() );
        response.setParams( ui.getQueryParameters() );
        response.setResults( management.getApplicationMetadata( applicationId ) );
        return response;
    }


    @RequireOrganizationAccess
    @GET
    @Path(""credentials"")
    @JSONP
    @Produces({MediaType.APPLICATION_JSON, ""application/javascript""})
    public ApiResponse getCredentials(
            @Context UriInfo ui, @QueryParam(""callback"") @DefaultValue(""callback"") String callback )
        throws Exception {

        ApiResponse response = createApiResponse();
        response.setAction(""get application client credentials"");

        ClientCredentialsInfo credentials =
                new ClientCredentialsInfo( management.getClientIdForApplication( applicationId ),
                        management.getClientSecretForApplication( applicationId ) );

        response.setCredentials( credentials );
        return response;
    }


    @RequireOrganizationAccess
    @POST
    @Path(""credentials"")
    @JSONP
    @Produces({MediaType.APPLICATION_JSON, ""application/javascript""})
    public ApiResponse generateCredentials( @Context UriInfo ui,
            @QueryParam(""callback"") @DefaultValue(""callback"") String callback )
        throws Exception {

        ApiResponse response = createApiResponse();
        response.setAction( ""generate application client credentials"" );

        ClientCredentialsInfo credentials =
                new ClientCredentialsInfo( management.getClientIdForApplication( applicationId ),
                        management.newClientSecretForApplication(applicationId) );

        response.setCredentials( credentials );
        return response;
    }

    @RequireOrganizationAccess
    @GET
    @JSONP
    @Path(""_size"")
    public ApiResponse getApplicationSize(
        @Context UriInfo ui, @QueryParam(""callback"") @DefaultValue(""callback"") String callback )
        throws Exception {

        ApiResponse response = createApiResponse();
        response.setAction( ""get application size for all entities"" );
        long size = management.getApplicationSize(this.applicationId);
        Map<String,Object> map = new HashMap<>();
        Map<String,Object> innerMap = new HashMap<>();
        Map<String,Object> sumMap = new HashMap<>();
        innerMap.put(""application"",size);
        sumMap.put(""size"",innerMap);
        map.put(""aggregation"", sumMap);
        response.setMetadata(map);
        return response;
    }

    @RequireOrganizationAccess
    @GET
    @JSONP
    @Path(""{collection_name}/_size"")
    public ApiResponse getCollectionSize(
        @Context UriInfo ui,
        @PathParam( ""collection_name"" ) String collection_name,
        @QueryParam(""callback"") @DefaultValue(""callback"") String callback )
        throws Exception {
        ApiResponse response = createApiResponse();
        response.setAction(""get collection size for all entities"");
        long size = management.getCollectionSize(this.applicationId, collection_name);
        Map<String,Object> map = new HashMap<>();
        Map<String,Object> sumMap = new HashMap<>();
        Map<String,Object> innerMap = new HashMap<>();
        innerMap.put(collection_name,size);
        sumMap.put(""size"",innerMap);
        map.put(""aggregation"",sumMap);
        response.setMetadata(map);
        return response;
    }

    @RequireOrganizationAccess
    @GET
    @JSONP
    @Path(""collections/_size"")
    public ApiResponse getEachCollectionSize(
        @Context UriInfo ui,
        @QueryParam(""callback"") @DefaultValue(""callback"") String callback )
        throws Exception {
        ApiResponse response = createApiResponse();
        response.setAction(""get collection size for all entities"");
        Map<String,Long> sizes = management.getEachCollectionSize(this.applicationId);
        Map<String,Object> map = new HashMap<>();
        Map<String,Object> sumMap = new HashMap<>();
        sumMap.put(""size"",sizes);
        map.put(""aggregation"",sumMap);
        response.setMetadata(map);
        return response;
    }

    @POST
    @Path(""sia-provider"")
    @Consumes(APPLICATION_JSON)
    @RequireOrganizationAccess
    @JSONP
    @Produces({MediaType.APPLICATION_JSON, ""application/javascript""})
    public ApiResponse configureProvider(
            @Context UriInfo ui,
            @QueryParam(""provider_key"") String siaProvider,
            Map<String, Object> json,
            @QueryParam(""callback"")
            @DefaultValue("""") String callback )
        throws Exception {

        ApiResponse response = createApiResponse();
        response.setAction( ""post signin provider configuration"" );

        Preconditions.checkArgument( siaProvider != null, ""Sign in provider required"" );

        SignInAsProvider signInAsProvider = null;
        if ( StringUtils.equalsIgnoreCase( siaProvider, ""facebook"" ) ) {
            signInAsProvider = signInProviderFactory.facebook(
                    smf.getServiceManager( applicationId ).getApplication() );
        }
        else if ( StringUtils.equalsIgnoreCase( siaProvider, ""pingident"" ) ) {
            signInAsProvider = signInProviderFactory.pingident(
                    smf.getServiceManager( applicationId ).getApplication() );
        }
        else if ( StringUtils.equalsIgnoreCase( siaProvider, ""foursquare"" ) ) {
            signInAsProvider = signInProviderFactory.foursquare(
                    smf.getServiceManager( applicationId ).getApplication() );
        }

        Preconditions.checkArgument( signInAsProvider != null,
                ""No signin provider found by that name: "" + siaProvider );

        signInAsProvider.saveToConfiguration( json );

        return response;
    }

//    @POST
//    @Path(""export"")
//    @Consumes(APPLICATION_JSON)
//    @RequireOrganizationAccess
//    public Response exportPostJson( @Context UriInfo ui,Map<String, Object> json,
//                                    @QueryParam(""callback"") @DefaultValue("""") String callback )
//            throws OAuthSystemException {
//
//        UsergridAwsCredentials uac = new UsergridAwsCredentials();
//
//        UUID jobUUID = null;
//        Map<String, String> uuidRet = new HashMap<String, String>();
//
//        Map<String,Object> properties;
//        Map<String, Object> storage_info;
//
//        try {
//            if((properties = ( Map<String, Object> )  json.get( ""properties"" )) == null){
//                throw new NullArgumentException(""Could not find 'properties'"");
//            }
//            storage_info = ( Map<String, Object> ) properties.get( ""storage_info"" );
//            String storage_provider = ( String ) properties.get( ""storage_provider"" );
//            if(storage_provider == null) {
//                throw new NullArgumentException( ""Could not find field 'storage_provider'"" );
//            }
//            if(storage_info == null) {
//                throw new NullArgumentException( ""Could not find field 'storage_info'"" );
//            }
//
//
//            String bucketName = ( String ) storage_info.get( ""bucket_location"" );
//            String accessId = ( String ) storage_info.get( ""s3_access_id"" );
//            String secretKey = ( String ) storage_info.get( ""s3_key"" );
//
//            if ( bucketName == null ) {
//                throw new NullArgumentException( ""Could not find field 'bucketName'"" );
//            }
//            if ( accessId == null ) {
//                throw new NullArgumentException( ""Could not find field 's3_access_id'"" );
//            }
//            if ( secretKey == null ) {
//
//                throw new NullArgumentException( ""Could not find field 's3_key'"" );
//            }
//
//            json.put(""organizationId"", organization.getUuid());
//            json.put( ""applicationId"",applicationId);
//
//            jobUUID = exportService.schedule( json );
//            uuidRet.put( ""Export Entity"", jobUUID.toString() );
//        }
//        catch ( NullArgumentException e ) {
//            return Response.status( SC_BAD_REQUEST )
//                .type( JSONPUtils.jsonMediaType( callback ) )
//                .entity( ServiceResource.wrapWithCallback( e.getMessage(), callback ) ).build();
//        }
//        catch ( Exception e ) {
//            // TODO: throw descriptive error message and or include on in the response
//            // TODO: fix below, it doesn't work if there is an exception.
//            // Make it look like the OauthResponse.
//            return Response.status( SC_INTERNAL_SERVER_ERROR )
//                .type( JSONPUtils.jsonMediaType( callback ) )
//                .entity( ServiceResource.wrapWithCallback( e.getMessage(), callback ) ).build();
//        }
//
//        return Response.status( SC_ACCEPTED ).entity( uuidRet ).build();
//    }
//
//    @POST
//    @Path(""collection/{collection_name}/export"")
//    @Consumes(APPLICATION_JSON)
//    @RequireOrganizationAccess
//    public Response exportPostJson( @Context UriInfo ui,
//            @PathParam( ""collection_name"" ) String collection_name ,Map<String, Object> json,
//            @QueryParam(""callback"") @DefaultValue("""") String callback )
//            throws OAuthSystemException {
//
//        UsergridAwsCredentials uac = new UsergridAwsCredentials();
//        UUID jobUUID = null;
//        String colExport = collection_name;
//        Map<String, String> uuidRet = new HashMap<String, String>();
//
//        Map<String,Object> properties;
//        Map<String, Object> storage_info;
//
//        try {
//            //checkJsonExportProperties(json);
//            if((properties = ( Map<String, Object> )  json.get( ""properties"" )) == null){
//                throw new NullArgumentException(""Could not find 'properties'"");
//            }
//            storage_info = ( Map<String, Object> ) properties.get( ""storage_info"" );
//            String storage_provider = ( String ) properties.get( ""storage_provider"" );
//            if(storage_provider == null) {
//                throw new NullArgumentException( ""Could not find field 'storage_provider'"" );
//            }
//            if(storage_info == null) {
//                throw new NullArgumentException( ""Could not find field 'storage_info'"" );
//            }
//
//            String bucketName = ( String ) storage_info.get( ""bucket_location"" );
//            String accessId = ( String ) storage_info.get( ""s3_access_id"" );
//            String secretKey = ( String ) storage_info.get( ""s3_key"" );
//
//            if ( accessId == null ) {
//                throw new NullArgumentException( ""Could not find field 's3_access_id'"" );
//            }
//            if ( secretKey == null ) {
//                throw new NullArgumentException( ""Could not find field 's3_key'"" );
//            }
//
//            if(bucketName == null) {
//                throw new NullArgumentException( ""Could not find field 'bucketName'"" );
//            }
//
//            json.put( ""organizationId"",organization.getUuid() );
//            json.put( ""applicationId"", applicationId);
//            json.put( ""collectionName"", colExport);
//
//            jobUUID = exportService.schedule( json );
//            uuidRet.put( ""Export Entity"", jobUUID.toString() );
//        }
//        catch ( NullArgumentException e ) {
//            return Response.status( SC_BAD_REQUEST )
//                .type( JSONPUtils.jsonMediaType( callback ) )
//                .entity( ServiceResource.wrapWithCallback( e.getMessage(), callback ) )
//                .build();
//        }
//        catch ( Exception e ) {
//
//            // TODO: throw descriptive error message and or include on in the response
//            // TODO: fix below, it doesn't work if there is an exception.
//            // Make it look like the OauthResponse.
//
//            OAuthResponse errorMsg = OAuthResponse.errorResponse( SC_INTERNAL_SERVER_ERROR )
//                .setErrorDescription( e.getMessage() )
//                .buildJSONMessage();
//
//            return Response.status( errorMsg.getResponseStatus() )
//                .type( JSONPUtils.jsonMediaType( callback ) )
//                .entity( ServiceResource.wrapWithCallback( errorMsg.getBody(), callback ) )
//                .build();
//        }
//
//        return Response.status( SC_ACCEPTED ).entity( uuidRet ).build();
//    }
//
//
//    @Path( ""imports"" )
//    public ImportsResource importGetJson( @Context UriInfo ui,
//                                          @QueryParam( ""callback"" ) @DefaultValue( """" ) String callback )
//        throws Exception {
//
//
//        return getSubResource( ImportsResource.class ).init( organization, application );
//    }

    @GET
    @Path(""/status"")
    public Response getStatus() {

        Map<String, Object> statusMap = new HashMap<String, Object>();

        EntityManager em = emf.getEntityManager( applicationId );
        if ( !emf.getIndexHealth().equals( Health.RED ) ) {
            statusMap.put(""message"", ""Index Health Status RED for application "" + applicationId );
            return Response.status( SC_INTERNAL_SERVER_ERROR ).entity( statusMap ).build();
        }

        try {
            if ( em.getApplication() == null ) {
                statusMap.put(""message"", ""Application "" + applicationId + "" not found"");
                return Response.status( SC_NOT_FOUND ).entity( statusMap ).build();
            }

        } catch (Exception ex) {
            statusMap.put(""message"", ""Error looking up application "" + applicationId );
            return Response.status( SC_INTERNAL_SERVER_ERROR ).entity( statusMap ).build();
        }

        return Response.status( SC_OK ).entity( null ).build();
    }



    /**
     * Put on application URL will restore application if it was deleted.
     */
    @PUT
    @RequireOrganizationAccess
    @JSONP
    @Produces({MediaType.APPLICATION_JSON, ""application/javascript""})
    public ApiResponse executePut(  @Context UriInfo ui, String body,
        @QueryParam(""callback"") @DefaultValue(""callback"") String callback ) throws Exception {

        if ( applicationId == null ) {
            throw new IllegalArgumentException(""Application ID not specified in request"");
        }

        ApplicationRestorePasswordService restorePasswordService = getApplicationRestorePasswordService();
        if (!SubjectUtils.isServiceAdmin()) {
            // require password if it exists
            String storedRestorePassword = restorePasswordService.getApplicationRestorePassword(applicationId);
            if (StringUtils.isNotEmpty(storedRestorePassword)) {
                // must have matching password as query parameter
                String suppliedRestorePassword = ui.getQueryParameters().getFirst(RESTORE_PASSWORD);
                if (!storedRestorePassword.equals(suppliedRestorePassword)) {
                    throw new IllegalArgumentException(""Application cannot be restored without application password"");
                }
            }
        }

        management.restoreApplication( applicationId );

        // not deleting password -- will be changed upon successful soft delete

        ApiResponse response = createApiResponse();
        response.setAction( ""restore"" );
        response.setApplication( emf.getEntityManager( applicationId ).getApplication() );
        response.setParams( ui.getQueryParameters() );

        return response;
    }


    /**
     * Caller MUST pass confirm_application_identifier that is either the UUID or the
     * name of the application to be deleted. Yes, this is redundant and intended to
     * be a protection measure to force caller to confirm that they want to do a delete.
     */
    @DELETE
    @RequireOrganizationAccess
    @JSONP
    @Produces({MediaType.APPLICATION_JSON, ""application/javascript""})
    public ApiResponse executeDelete(  @Context UriInfo ui,
        @QueryParam(""callback"") @DefaultValue(""callback"") String callback,
        @QueryParam(CONFIRM_APPLICATION_IDENTIFIER) String confirmApplicationIdentifier) throws Exception {

        if ( application == null && applicationId == null ) {
            throw new IllegalArgumentException(""Application ID not specified in request"");
        }

        // If the path uses name then expect name, otherwise if they use uuid then expect uuid.
        if (application == null) {
            if (!applicationId.toString().equals( confirmApplicationIdentifier )) {
                throw new IllegalArgumentException(
                    ""Cannot delete application without supplying correct application id."");
            }

        } else if (!application.getName().split( ""/"" )[1].equals( confirmApplicationIdentifier ) ) {
            throw new IllegalArgumentException(
                ""Cannot delete application without supplying correct application name"");
        }

        String restorePassword = null;
        ApplicationRestorePasswordService restorePasswordService = getApplicationRestorePasswordService();
        if (SubjectUtils.isServiceAdmin()) {
            restorePassword = ui.getQueryParameters().getFirst(RESTORE_PASSWORD);
            if (StringUtils.isNotEmpty(restorePassword)) {
                // save password, required for future undelete if not sysadmin
                restorePasswordService.setApplicationRestorePassword(applicationId, restorePassword);
            }
        }

        management.deleteApplication( applicationId );

        if (restorePassword == null) {
            // clear restore password
            restorePasswordService.removeApplicationRestorePassword(applicationId);
        }

        if (logger.isTraceEnabled()) {
            logger.trace(""ApplicationResource.delete() deleted appId = {}"", applicationId);
        }

        ApiResponse response = createApiResponse();
        response.setAction( ""delete"" );
        response.setApplication(emf.getEntityManager( applicationId ).getApplication());
        response.setParams(ui.getQueryParameters());

        if (logger.isTraceEnabled()) {
            logger.trace(""ApplicationResource.delete() sending response "");
        }

        return response;
    }

    private ApplicationRestorePasswordService getApplicationRestorePasswordService() {
        return injector.getInstance(ApplicationRestorePasswordService.class);
    }

}
",blob
235,"public class DefaultArtifact extends AbstractArtifact {

    public static Artifact newIvyArtifact(ModuleRevisionId mrid, Date pubDate) {
        return new DefaultArtifact(mrid, pubDate, ""ivy"", ""ivy"", ""xml"", true);
    }

    public static Artifact newPomArtifact(ModuleRevisionId mrid, Date pubDate) {
        return new DefaultArtifact(mrid, pubDate, mrid.getName(), ""pom"", ""pom"", true);
    }

    public static Artifact cloneWithAnotherExt(Artifact artifact, String newExt) {
        return cloneWithAnotherTypeAndExt(artifact, artifact.getType(), newExt);
    }

    public static Artifact cloneWithAnotherType(Artifact artifact, String newType) {
        return cloneWithAnotherTypeAndExt(artifact, newType, artifact.getExt());
    }

    public static Artifact cloneWithAnotherTypeAndExt(Artifact artifact, String newType,
            String newExt) {
        return new DefaultArtifact(ArtifactRevisionId.newInstance(artifact.getModuleRevisionId(),
            artifact.getName(), newType, newExt, artifact.getQualifiedExtraAttributes()),
                artifact.getPublicationDate(), artifact.getUrl(), artifact.isMetadata());
    }

    public static Artifact cloneWithAnotherName(Artifact artifact, String name) {
        return new DefaultArtifact(ArtifactRevisionId.newInstance(artifact.getModuleRevisionId(),
            name, artifact.getType(), artifact.getExt(), artifact.getQualifiedExtraAttributes()),
                artifact.getPublicationDate(), artifact.getUrl(), artifact.isMetadata());
    }

    public static Artifact cloneWithAnotherMrid(Artifact artifact, ModuleRevisionId mrid) {
        return new DefaultArtifact(ArtifactRevisionId.newInstance(mrid, artifact.getName(),
            artifact.getType(), artifact.getExt(), artifact.getQualifiedExtraAttributes()),
                artifact.getPublicationDate(), artifact.getUrl(), artifact.isMetadata());
    }

    private Date publicationDate;

    private ArtifactRevisionId arid;

    private URL url;

    private boolean isMetadata = false;

    public DefaultArtifact(ModuleRevisionId mrid, Date publicationDate, String name, String type,
            String ext) {
        this(mrid, publicationDate, name, type, ext, null, null);
    }

    public DefaultArtifact(ModuleRevisionId mrid, Date publicationDate, String name, String type,
            String ext, boolean isMetadata) {
        this(mrid, publicationDate, name, type, ext, null, null);
        this.isMetadata = isMetadata;
    }

    public DefaultArtifact(ModuleRevisionId mrid, Date publicationDate, String name, String type,
            String ext, Map<String, String> extraAttributes) {
        this(mrid, publicationDate, name, type, ext, null, extraAttributes);
    }

    public DefaultArtifact(ModuleRevisionId mrid, Date publicationDate, String name, String type,
            String ext, URL url, Map<String, String> extraAttributes) {
        this(ArtifactRevisionId.newInstance(mrid, name, type, ext, extraAttributes),
                publicationDate, url, false);
    }

    public DefaultArtifact(ArtifactRevisionId arid, Date publicationDate, URL url,
            boolean isMetadata) {
        if (arid == null) {
            throw new NullPointerException(""null arid not allowed"");
        }
        if (publicationDate == null) {
            publicationDate = new Date();
        }
        this.publicationDate = publicationDate;
        this.arid = arid;
        this.url = url;
        this.isMetadata = isMetadata;
    }

    public ModuleRevisionId getModuleRevisionId() {
        return arid.getModuleRevisionId();
    }

    public String getName() {
        return arid.getName();
    }

    public Date getPublicationDate() {
        return publicationDate;
    }

    public String getType() {
        return arid.getType();
    }

    public String getExt() {
        return arid.getExt();
    }

    public ArtifactRevisionId getId() {
        return arid;
    }

    public String[] getConfigurations() {
        return new String[0];
    }

    public URL getUrl() {
        return url;
    }

    public boolean isMetadata() {
        return isMetadata;
    }
}
",data class
1394,"public class ReportInstance extends AbstractDTOBase {

    private String id;
    private ReportStatusEnum status;
    private String url;
    private String ownerId;
    private Boolean hasDetailRows;
    private ZonedDateTime completionDate;
    private ZonedDateTime requestDate;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public ReportStatusEnum getStatus() {
        return status;
    }

    public void setStatus(ReportStatusEnum status) {
        this.status = status;
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public String getOwnerId() {
        return ownerId;
    }

    public void setOwnerId(String ownerId) {
        this.ownerId = ownerId;
    }

    public Boolean getHasDetailRows() {
        return hasDetailRows;
    }

    public void setHasDetailRows(Boolean hasDetailRows) {
        this.hasDetailRows = hasDetailRows;
    }

    public ZonedDateTime getCompletionDate() {
        return completionDate;
    }

    public void setCompletionDate(ZonedDateTime completionDate) {
        this.completionDate = completionDate;
    }

    public ZonedDateTime getRequestDate() {
        return requestDate;
    }

    public void setRequestDate(ZonedDateTime requestDate) {
        this.requestDate = requestDate;
    }
}
",data class
1337,"   public class Header {

      public String key;
      public String val;

      public Header(String key, String val) {
         this.key = key;
         this.val = val;
      }

      public String getEncodedKey() {
         return encode(key);
      }

      public String getEncodedValue() {
         return encode(val);
      }
   }
",data class
174,"    private static int[] getIntArray(String string) {
        if (string.equals(""[]"")) {
            return new int[]{};
        }
        string = string.substring(1, string.length() - 1);
        String[] splits = string.split("","");
        int[] array = new int[splits.length];
        for (int i = 0; i < splits.length; i++) {
            array[i] = Integer.parseInt(splits[i]);
        }
        return array;
    }
",long method
362,"public class ImmutableBitSet
    implements Iterable<Integer>, Serializable, Comparable<ImmutableBitSet> {
  /** Compares bit sets topologically, so that enclosing bit sets come first,
   * using natural ordering to break ties. */
  public static final Comparator<ImmutableBitSet> COMPARATOR = (o1, o2) -> {
    if (o1.equals(o2)) {
      return 0;
    }
    if (o1.contains(o2)) {
      return -1;
    }
    if (o2.contains(o1)) {
      return 1;
    }
    return o1.compareTo(o2);
  };

  public static final Ordering<ImmutableBitSet> ORDERING =
      Ordering.from(COMPARATOR);

  // BitSets are packed into arrays of ""words.""  Currently a word is
  // a long, which consists of 64 bits, requiring 6 address bits.
  // The choice of word size is determined purely by performance concerns.
  private static final int ADDRESS_BITS_PER_WORD = 6;
  private static final int BITS_PER_WORD = 1 << ADDRESS_BITS_PER_WORD;

  /* Used to shift left or right for a partial word mask */
  private static final long WORD_MASK = 0xffffffffffffffffL;

  private static final long[] EMPTY_LONGS = new long[0];

  private static final ImmutableBitSet EMPTY =
      new ImmutableBitSet(EMPTY_LONGS);

  @SuppressWarnings(""Guava"")
  @Deprecated // to be removed before 2.0
  public static final
      com.google.common.base.Function<? super BitSet, ImmutableBitSet>
      FROM_BIT_SET = ImmutableBitSet::fromBitSet;

  private final long[] words;

  /** Private constructor. Does not copy the array. */
  private ImmutableBitSet(long[] words) {
    this.words = words;
    assert words.length == 0
        ? words == EMPTY_LONGS
        : words[words.length - 1] != 0L;
  }

  /** Creates an ImmutableBitSet with no bits. */
  public static ImmutableBitSet of() {
    return EMPTY;
  }

  public static ImmutableBitSet of(int... bits) {
    int max = -1;
    for (int bit : bits) {
      max = Math.max(bit, max);
    }
    if (max == -1) {
      return EMPTY;
    }
    long[] words = new long[wordIndex(max) + 1];
    for (int bit : bits) {
      int wordIndex = wordIndex(bit);
      words[wordIndex] |= 1L << bit;
    }
    return new ImmutableBitSet(words);
  }

  public static ImmutableBitSet of(Iterable<Integer>  bits) {
    if (bits instanceof ImmutableBitSet) {
      return (ImmutableBitSet) bits;
    }
    int max = -1;
    for (int bit : bits) {
      max = Math.max(bit, max);
    }
    if (max == -1) {
      return EMPTY;
    }
    long[] words = new long[wordIndex(max) + 1];
    for (int bit : bits) {
      int wordIndex = wordIndex(bit);
      words[wordIndex] |= 1L << bit;
    }
    return new ImmutableBitSet(words);
  }

  /**
   * Creates an ImmutableBitSet with given bits set.
   *
   * <p>For example, <code>of(ImmutableIntList.of(0, 3))</code> returns a bit
   * set with bits {0, 3} set.
   *
   * @param bits Collection of bits to set
   * @return Bit set
   */
  public static ImmutableBitSet of(ImmutableIntList bits) {
    return builder().addAll(bits).build();
  }

  /**
   * Returns a new immutable bit set containing all the bits in the given long
   * array.
   *
   * <p>More precisely,
   *
   * <blockquote>{@code ImmutableBitSet.valueOf(longs).get(n)
   *   == ((longs[n/64] & (1L<<(n%64))) != 0)}</blockquote>
   *
   * <p>for all {@code n < 64 * longs.length}.
   *
   * <p>This method is equivalent to
   * {@code ImmutableBitSet.valueOf(LongBuffer.wrap(longs))}.
   *
   * @param longs a long array containing a little-endian representation
   *        of a sequence of bits to be used as the initial bits of the
   *        new bit set
   * @return a {@code ImmutableBitSet} containing all the bits in the long
   *         array
   */
  public static ImmutableBitSet valueOf(long... longs) {
    int n = longs.length;
    while (n > 0 && longs[n - 1] == 0) {
      --n;
    }
    if (n == 0) {
      return EMPTY;
    }
    return new ImmutableBitSet(Arrays.copyOf(longs, n));
  }

  /**
   * Returns a new immutable bit set containing all the bits in the given long
   * buffer.
   */
  public static ImmutableBitSet valueOf(LongBuffer longs) {
    longs = longs.slice();
    int n = longs.remaining();
    while (n > 0 && longs.get(n - 1) == 0) {
      --n;
    }
    if (n == 0) {
      return EMPTY;
    }
    long[] words = new long[n];
    longs.get(words);
    return new ImmutableBitSet(words);
  }

  /**
   * Returns a new immutable bit set containing all the bits in the given
   * {@link BitSet}.
   */
  public static ImmutableBitSet fromBitSet(BitSet input) {
    return ImmutableBitSet.of(BitSets.toIter(input));
  }

  /**
   * Creates an ImmutableBitSet with bits from {@code fromIndex} (inclusive) to
   * specified {@code toIndex} (exclusive) set to {@code true}.
   *
   * <p>For example, {@code range(0, 3)} returns a bit set with bits
   * {0, 1, 2} set.
   *
   * @param fromIndex Index of the first bit to be set.
   * @param toIndex   Index after the last bit to be set.
   * @return Bit set
   */
  public static ImmutableBitSet range(int fromIndex, int toIndex) {
    if (fromIndex > toIndex) {
      throw new IllegalArgumentException();
    }
    if (toIndex < 0) {
      throw new IllegalArgumentException();
    }
    if (fromIndex == toIndex) {
      return EMPTY;
    }
    int startWordIndex = wordIndex(fromIndex);
    int endWordIndex   = wordIndex(toIndex - 1);
    long[] words = new long[endWordIndex + 1];

    long firstWordMask = WORD_MASK << fromIndex;
    long lastWordMask  = WORD_MASK >>> -toIndex;
    if (startWordIndex == endWordIndex) {
      // One word
      words[startWordIndex] |= firstWordMask & lastWordMask;
    } else {
      // First word, middle words, last word
      words[startWordIndex] |= firstWordMask;
      for (int i = startWordIndex + 1; i < endWordIndex; i++) {
        words[i] = WORD_MASK;
      }
      words[endWordIndex] |= lastWordMask;
    }
    return new ImmutableBitSet(words);
  }

  /** Creates an ImmutableBitSet with bits between 0 and {@code toIndex} set. */
  public static ImmutableBitSet range(int toIndex) {
    return range(0, toIndex);
  }

  /**
   * Given a bit index, return word index containing it.
   */
  private static int wordIndex(int bitIndex) {
    return bitIndex >> ADDRESS_BITS_PER_WORD;
  }

  /** Computes the power set (set of all sets) of this bit set. */
  public Iterable<ImmutableBitSet> powerSet() {
    List<List<ImmutableBitSet>> singletons = new ArrayList<>();
    for (int bit : this) {
      singletons.add(
          ImmutableList.of(ImmutableBitSet.of(), ImmutableBitSet.of(bit)));
    }
    return Iterables.transform(Linq4j.product(singletons),
        ImmutableBitSet::union);
  }

  /**
   * Returns the value of the bit with the specified index. The value
   * is {@code true} if the bit with the index {@code bitIndex}
   * is currently set in this {@code ImmutableBitSet}; otherwise, the result
   * is {@code false}.
   *
   * @param  bitIndex   the bit index
   * @return the value of the bit with the specified index
   * @throws IndexOutOfBoundsException if the specified index is negative
   */
  public boolean get(int bitIndex) {
    if (bitIndex < 0) {
      throw new IndexOutOfBoundsException(""bitIndex < 0: "" + bitIndex);
    }
    int wordIndex = wordIndex(bitIndex);
    return (wordIndex < words.length)
        && ((words[wordIndex] & (1L << bitIndex)) != 0);
  }

  /**
   * Returns a new {@code ImmutableBitSet}
   * composed of bits from this {@code ImmutableBitSet}
   * from {@code fromIndex} (inclusive) to {@code toIndex} (exclusive).
   *
   * @param  fromIndex index of the first bit to include
   * @param  toIndex index after the last bit to include
   * @return a new {@code ImmutableBitSet} from a range of
   *         this {@code ImmutableBitSet}
   * @throws IndexOutOfBoundsException if {@code fromIndex} is negative,
   *         or {@code toIndex} is negative, or {@code fromIndex} is
   *         larger than {@code toIndex}
   */
  public ImmutableBitSet get(int fromIndex, int toIndex) {
    checkRange(fromIndex, toIndex);
    final Builder builder = builder();
    for (int i = nextSetBit(fromIndex); i >= 0 && i < toIndex;
         i = nextSetBit(i + 1)) {
      builder.set(i);
    }
    return builder.build();
  }

  /**
   * Checks that fromIndex ... toIndex is a valid range of bit indices.
   */
  private static void checkRange(int fromIndex, int toIndex) {
    if (fromIndex < 0) {
      throw new IndexOutOfBoundsException(""fromIndex < 0: "" + fromIndex);
    }
    if (toIndex < 0) {
      throw new IndexOutOfBoundsException(""toIndex < 0: "" + toIndex);
    }
    if (fromIndex > toIndex) {
      throw new IndexOutOfBoundsException(""fromIndex: "" + fromIndex
          + "" > toIndex: "" + toIndex);
    }
  }

  /**
   * Returns a string representation of this bit set. For every index
   * for which this {@code BitSet} contains a bit in the set
   * state, the decimal representation of that index is included in
   * the result. Such indices are listed in order from lowest to
   * highest, separated by "",&nbsp;"" (a comma and a space) and
   * surrounded by braces, resulting in the usual mathematical
   * notation for a set of integers.
   *
   * <p>Example:
   * <pre>
   * BitSet drPepper = new BitSet();</pre>
   * Now {@code drPepper.toString()} returns ""{@code {}}"".
   * <pre>
   * drPepper.set(2);</pre>
   * Now {@code drPepper.toString()} returns ""{@code {2}}"".
   * <pre>
   * drPepper.set(4);
   * drPepper.set(10);</pre>
   * Now {@code drPepper.toString()} returns ""{@code {2, 4, 10}}"".
   *
   * @return a string representation of this bit set
   */
  public String toString() {
    int numBits = words.length * BITS_PER_WORD;
    StringBuilder b = new StringBuilder(6 * numBits + 2);
    b.append('{');

    int i = nextSetBit(0);
    if (i != -1) {
      b.append(i);
      for (i = nextSetBit(i + 1); i >= 0; i = nextSetBit(i + 1)) {
        int endOfRun = nextClearBit(i);
        do {
          b.append("", "").append(i);
        }
        while (++i < endOfRun);
      }
    }

    b.append('}');
    return b.toString();
  }

  /**
   * Returns true if the specified {@code ImmutableBitSet} has any bits set to
   * {@code true} that are also set to {@code true} in this
   * {@code ImmutableBitSet}.
   *
   * @param  set {@code ImmutableBitSet} to intersect with
   * @return boolean indicating whether this {@code ImmutableBitSet} intersects
   *         the specified {@code ImmutableBitSet}
   */
  public boolean intersects(ImmutableBitSet set) {
    for (int i = Math.min(words.length, set.words.length) - 1; i >= 0; i--) {
      if ((words[i] & set.words[i]) != 0) {
        return true;
      }
    }
    return false;
  }

  /** Returns the number of bits set to {@code true} in this
   * {@code ImmutableBitSet}.
   *
   * @see #size() */
  public int cardinality() {
    return countBits(words);
  }

  private static int countBits(long[] words) {
    int sum = 0;
    for (long word : words) {
      sum += Long.bitCount(word);
    }
    return sum;
  }

  /**
   * Returns the hash code value for this bit set. The hash code
   * depends only on which bits are set within this {@code ImmutableBitSet}.
   *
   * <p>The hash code is defined using the same calculation as
   * {@link java.util.BitSet#hashCode()}.
   *
   * @return the hash code value for this bit set
   */
  public int hashCode() {
    long h = 1234;
    for (int i = words.length; --i >= 0;) {
      h ^= words[i] * (i + 1);
    }
    return (int) ((h >> 32) ^ h);
  }

  /**
   * Returns the number of bits of space actually in use by this
   * {@code ImmutableBitSet} to represent bit values.
   * The maximum element in the set is the size - 1st element.
   *
   * @return the number of bits currently in this bit set
   *
   * @see #cardinality()
   */
  public int size() {
    return words.length * BITS_PER_WORD;
  }

  /**
   * Compares this object against the specified object.
   * The result is {@code true} if and only if the argument is
   * not {@code null} and is a {@code ImmutableBitSet} object that has
   * exactly the same set of bits set to {@code true} as this bit
   * set.
   *
   * @param  obj the object to compare with
   * @return {@code true} if the objects are the same;
   *         {@code false} otherwise
   * @see    #size()
   */
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (!(obj instanceof ImmutableBitSet)) {
      return false;
    }
    ImmutableBitSet set = (ImmutableBitSet) obj;
    return Arrays.equals(words, set.words);
  }

  /** Compares this ImmutableBitSet with another, using a lexicographic
   * ordering.
   *
   * <p>Bit sets {@code (), (0), (0, 1), (0, 1, 3), (1), (2, 3)} are in sorted
   * order.</p>
   */
  public int compareTo(@Nonnull ImmutableBitSet o) {
    int i = 0;
    for (;;) {
      int n0 = nextSetBit(i);
      int n1 = o.nextSetBit(i);
      int c = Utilities.compare(n0, n1);
      if (c != 0 || n0 < 0) {
        return c;
      }
      i = n0 + 1;
    }
  }

  /**
   * Returns the index of the first bit that is set to {@code true}
   * that occurs on or after the specified starting index. If no such
   * bit exists then {@code -1} is returned.
   *
   * <p>Based upon {@link BitSet#nextSetBit}.
   *
   * @param  fromIndex the index to start checking from (inclusive)
   * @return the index of the next set bit, or {@code -1} if there
   *         is no such bit
   * @throws IndexOutOfBoundsException if the specified index is negative
   */
  public int nextSetBit(int fromIndex) {
    if (fromIndex < 0) {
      throw new IndexOutOfBoundsException(""fromIndex < 0: "" + fromIndex);
    }
    int u = wordIndex(fromIndex);
    if (u >= words.length) {
      return -1;
    }
    long word = words[u] & (WORD_MASK << fromIndex);

    while (true) {
      if (word != 0) {
        return (u * BITS_PER_WORD) + Long.numberOfTrailingZeros(word);
      }
      if (++u == words.length) {
        return -1;
      }
      word = words[u];
    }
  }

  /**
   * Returns the index of the first bit that is set to {@code false}
   * that occurs on or after the specified starting index.
   *
   * @param  fromIndex the index to start checking from (inclusive)
   * @return the index of the next clear bit
   * @throws IndexOutOfBoundsException if the specified index is negative
   */
  public int nextClearBit(int fromIndex) {
    if (fromIndex < 0) {
      throw new IndexOutOfBoundsException(""fromIndex < 0: "" + fromIndex);
    }
    int u = wordIndex(fromIndex);
    if (u >= words.length) {
      return fromIndex;
    }
    long word = ~words[u] & (WORD_MASK << fromIndex);

    while (true) {
      if (word != 0) {
        return (u * BITS_PER_WORD) + Long.numberOfTrailingZeros(word);
      }
      if (++u == words.length) {
        return words.length * BITS_PER_WORD;
      }
      word = ~words[u];
    }
  }

  /**
   * Returns the index of the nearest bit that is set to {@code false}
   * that occurs on or before the specified starting index.
   * If no such bit exists, or if {@code -1} is given as the
   * starting index, then {@code -1} is returned.
   *
   * @param  fromIndex the index to start checking from (inclusive)
   * @return the index of the previous clear bit, or {@code -1} if there
   *         is no such bit
   * @throws IndexOutOfBoundsException if the specified index is less
   *         than {@code -1}
   */
  public int previousClearBit(int fromIndex) {
    if (fromIndex < 0) {
      if (fromIndex == -1) {
        return -1;
      }
      throw new IndexOutOfBoundsException(""fromIndex < -1: "" + fromIndex);
    }

    int u = wordIndex(fromIndex);
    if (u >= words.length) {
      return fromIndex;
    }
    long word = ~words[u] & (WORD_MASK >>> -(fromIndex + 1));

    while (true) {
      if (word != 0) {
        return (u + 1) * BITS_PER_WORD - 1 - Long.numberOfLeadingZeros(word);
      }
      if (u-- == 0) {
        return -1;
      }
      word = ~words[u];
    }
  }

  public Iterator<Integer> iterator() {
    return new Iterator<Integer>() {
      int i = nextSetBit(0);

      public boolean hasNext() {
        return i >= 0;
      }

      public Integer next() {
        int prev = i;
        i = nextSetBit(i + 1);
        return prev;
      }

      public void remove() {
        throw new UnsupportedOperationException();
      }
    };
  }

  /** Converts this bit set to a list. */
  public List<Integer> toList() {
    final List<Integer> list = new ArrayList<>();
    for (int i = nextSetBit(0); i >= 0; i = nextSetBit(i + 1)) {
      list.add(i);
    }
    return list;
  }

  /** Creates a view onto this bit set as a list of integers.
   *
   * <p>The {@code cardinality} and {@code get} methods are both O(n), but
   * the iterator is efficient. The list is memory efficient, and the CPU cost
   * breaks even (versus {@link #toList}) if you intend to scan it only once. */
  public List<Integer> asList() {
    return new AbstractList<Integer>() {
      @Override public Integer get(int index) {
        return nth(index);
      }

      @Override public int size() {
        return cardinality();
      }

      @Nonnull @Override public Iterator<Integer> iterator() {
        return ImmutableBitSet.this.iterator();
      }
    };
  }

  /** Creates a view onto this bit set as a set of integers.
   *
   * <p>The {@code size} and {@code contains} methods are both O(n), but the
   * iterator is efficient. */
  public Set<Integer> asSet() {
    return new AbstractSet<Integer>() {
      @Nonnull public Iterator<Integer> iterator() {
        return ImmutableBitSet.this.iterator();
      }

      public int size() {
        return cardinality();
      }

      @Override public boolean contains(Object o) {
        return ImmutableBitSet.this.get((Integer) o);
      }
    };
  }

  /**
   * Converts this bit set to an array.
   *
   * <p>Each entry of the array is the ordinal of a set bit. The array is
   * sorted.
   *
   * @return Array of set bits
   */
  public int[] toArray() {
    final int[] integers = new int[cardinality()];
    int j = 0;
    for (int i = nextSetBit(0); i >= 0; i = nextSetBit(i + 1)) {
      integers[j++] = i;
    }
    return integers;
  }

  /**
   * Converts this bit set to an array of little-endian words.
   */
  public long[] toLongArray() {
    return words.length == 0 ? words : words.clone();
  }

  /** Returns the union of this immutable bit set with a {@link BitSet}. */
  public ImmutableBitSet union(BitSet other) {
    return rebuild() // remember ""this"" and try to re-use later
        .addAll(BitSets.toIter(other))
        .build();
  }

  /** Returns the union of this bit set with another. */
  public ImmutableBitSet union(ImmutableBitSet other) {
    return rebuild() // remember ""this"" and try to re-use later
        .addAll(other)
        .build(other); // try to re-use ""other""
  }

  /** Returns the union of a number of bit sets. */
  public static ImmutableBitSet union(
      Iterable<? extends ImmutableBitSet> sets) {
    final Builder builder = builder();
    for (ImmutableBitSet set : sets) {
      builder.addAll(set);
    }
    return builder.build();
  }

  /** Returns a bit set with all the bits in this set that are not in
   * another.
   *
   * @see BitSet#andNot(java.util.BitSet) */
  public ImmutableBitSet except(ImmutableBitSet that) {
    final Builder builder = rebuild();
    builder.removeAll(that);
    return builder.build();
  }

  /** Returns a bit set with all the bits set in both this set and in
   * another.
   *
   * @see BitSet#and */
  public ImmutableBitSet intersect(ImmutableBitSet that) {
    final Builder builder = rebuild();
    builder.intersect(that);
    return builder.build();
  }

  /**
   * Returns true if all bits set in the second parameter are also set in the
   * first. In other words, whether x is a super-set of y.
   *
   * @param set1 Bitmap to be checked
   *
   * @return Whether all bits in set1 are set in set0
   */
  public boolean contains(ImmutableBitSet set1) {
    for (int i = set1.nextSetBit(0); i >= 0; i = set1.nextSetBit(i + 1)) {
      if (!get(i)) {
        return false;
      }
    }
    return true;
  }

  /**
   * The ordinal of a given bit, or -1 if it is not set.
   */
  public int indexOf(int bit) {
    for (int i = nextSetBit(0), k = 0;; i = nextSetBit(i + 1), ++k) {
      if (i < 0) {
        return -1;
      }
      if (i == bit) {
        return k;
      }
    }
  }

  /** Computes the closure of a map from integers to bits.
   *
   * <p>The input must have an entry for each position.
   *
   * <p>Does not modify the input map or its bit sets. */
  public static SortedMap<Integer, ImmutableBitSet> closure(
      SortedMap<Integer, ImmutableBitSet> equivalence) {
    if (equivalence.isEmpty()) {
      return ImmutableSortedMap.of();
    }
    int length = equivalence.lastKey();
    for (ImmutableBitSet bitSet : equivalence.values()) {
      length = Math.max(length, bitSet.length());
    }
    if (equivalence.size() < length
        || equivalence.firstKey() != 0) {
      SortedMap<Integer, ImmutableBitSet> old = equivalence;
      equivalence = new TreeMap<>();
      for (int i = 0; i < length; i++) {
        final ImmutableBitSet bitSet = old.get(i);
        equivalence.put(i, bitSet == null ? ImmutableBitSet.of() : bitSet);
      }
    }
    final Closure closure = new Closure(equivalence);
    return closure.closure;
  }

  /**
   * Returns the ""logical size"" of this {@code ImmutableBitSet}: the index of
   * the highest set bit in the {@code ImmutableBitSet} plus one. Returns zero
   * if the {@code ImmutableBitSet} contains no set bits.
   *
   * @return the logical size of this {@code ImmutableBitSet}
   */
  public int length() {
    if (words.length == 0) {
      return 0;
    }
    return BITS_PER_WORD * (words.length - 1)
        + (BITS_PER_WORD - Long.numberOfLeadingZeros(words[words.length - 1]));
  }

  /**
   * Returns true if this {@code ImmutableBitSet} contains no bits that are set
   * to {@code true}.
   */
  public boolean isEmpty() {
    return words.length == 0;
  }

  /** Creates an empty Builder. */
  public static Builder builder() {
    return new Builder(EMPTY_LONGS);
  }

  @Deprecated // to be removed before 2.0
  public static Builder builder(ImmutableBitSet bitSet) {
    return bitSet.rebuild();
  }

  /** Creates a Builder whose initial contents are the same as this
   * ImmutableBitSet. */
  public Builder rebuild() {
    return new Rebuilder(this);
  }

  /** Returns the {@code n}th set bit.
   *
   * @throws java.lang.IndexOutOfBoundsException if n is less than 0 or greater
   * than the number of bits set */
  public int nth(int n) {
    int start = 0;
    for (long word : words) {
      final int bitCount = Long.bitCount(word);
      if (n < bitCount) {
        while (word != 0) {
          if ((word & 1) == 1) {
            if (n == 0) {
              return start;
            }
            --n;
          }
          word >>= 1;
          ++start;
        }
      }
      start += 64;
      n -= bitCount;
    }
    throw new IndexOutOfBoundsException(""index out of range: "" + n);
  }

  /** Returns a bit set the same as this but with a given bit set. */
  public ImmutableBitSet set(int i) {
    return union(ImmutableBitSet.of(i));
  }

  /** Returns a bit set the same as this but with a given bit set (if b is
   * true) or unset (if b is false). */
  public ImmutableBitSet set(int i, boolean b) {
    if (get(i) == b) {
      return this;
    }
    return b ? set(i) : clear(i);
  }

  /** Returns a bit set the same as this but with a given bit set if condition
   * is true. */
  public ImmutableBitSet setIf(int bit, boolean condition) {
    return condition ? set(bit) : this;
  }

  /** Returns a bit set the same as this but with a given bit cleared. */
  public ImmutableBitSet clear(int i) {
    return except(ImmutableBitSet.of(i));
  }

  /** Returns a bit set the same as this but with a given bit cleared if
   * condition is true. */
  public ImmutableBitSet clearIf(int i, boolean condition) {
    return condition ? except(ImmutableBitSet.of(i)) : this;
  }

  /** Returns a {@link BitSet} that has the same contents as this
   * {@code ImmutableBitSet}. */
  public BitSet toBitSet() {
    return BitSets.of(this);
  }

  /** Permutes a bit set according to a given mapping. */
  public ImmutableBitSet permute(Map<Integer, Integer> map) {
    final Builder builder = builder();
    for (int i = nextSetBit(0); i >= 0; i = nextSetBit(i + 1)) {
      builder.set(map.get(i));
    }
    return builder.build();
  }

  /** Permutes a collection of bit sets according to a given mapping. */
  public static Iterable<ImmutableBitSet> permute(
      Iterable<ImmutableBitSet> bitSets,
      final Map<Integer, Integer> map) {
    return Iterables.transform(bitSets, bitSet -> bitSet.permute(map));
  }

  /** Returns a bit set with every bit moved up {@code offset} positions.
   * Offset may be negative, but throws if any bit ends up negative. */
  public ImmutableBitSet shift(int offset) {
    if (offset == 0) {
      return this;
    }
    final Builder builder = builder();
    for (int i = nextSetBit(0); i >= 0; i = nextSetBit(i + 1)) {
      builder.set(i + offset);
    }
    return builder.build();
  }

  /**
   * Setup equivalence Sets for each position. If i and j are equivalent then
   * they will have the same equivalence Set. The algorithm computes the
   * closure relation at each position for the position wrt to positions
   * greater than it. Once a closure is computed for a position, the closure
   * Set is set on all its descendants. So the closure computation bubbles up
   * from lower positions and the final equivalence Set is propagated down
   * from the lowest element in the Set.
   */
  private static class Closure {
    private SortedMap<Integer, ImmutableBitSet> equivalence;
    private final SortedMap<Integer, ImmutableBitSet> closure =
        new TreeMap<>();

    Closure(SortedMap<Integer, ImmutableBitSet> equivalence) {
      this.equivalence = equivalence;
      final ImmutableIntList keys =
          ImmutableIntList.copyOf(equivalence.keySet());
      for (int pos : keys) {
        computeClosure(pos);
      }
    }

    private ImmutableBitSet computeClosure(int pos) {
      ImmutableBitSet o = closure.get(pos);
      if (o != null) {
        return o;
      }
      final ImmutableBitSet b = equivalence.get(pos);
      o = b;
      int i = b.nextSetBit(pos + 1);
      for (; i >= 0; i = b.nextSetBit(i + 1)) {
        o = o.union(computeClosure(i));
      }
      closure.put(pos, o);
      i = o.nextSetBit(pos + 1);
      for (; i >= 0; i = b.nextSetBit(i + 1)) {
        closure.put(i, o);
      }
      return o;
    }
  }

  /** Builder. */
  public static class Builder {
    private long[] words;

    private Builder(long[] words) {
      this.words = words;
    }

    /** Builds an ImmutableBitSet from the contents of this Builder.
     *
     * <p>After calling this method, the Builder cannot be used again. */
    public ImmutableBitSet build() {
      if (words.length == 0) {
        return EMPTY;
      }
      long[] words = this.words;
      this.words = null; // prevent re-use of builder
      return new ImmutableBitSet(words);
    }

    /** Builds an ImmutableBitSet from the contents of this Builder, using
     * an existing ImmutableBitSet if it happens to have the same contents.
     *
     * <p>Supplying the existing bit set if useful for set operations,
     * where there is a significant chance that the original bit set is
     * unchanged. We save memory because we use the same copy. For example:
     *
     * <blockquote><pre>
     * ImmutableBitSet primeNumbers;
     * ImmutableBitSet hundreds = ImmutableBitSet.of(100, 200, 300);
     * return primeNumbers.except(hundreds);</pre></blockquote>
     *
     * <p>After calling this method, the Builder cannot be used again. */
    public ImmutableBitSet build(ImmutableBitSet bitSet) {
      if (wouldEqual(bitSet)) {
        return bitSet;
      }
      return build();
    }

    public Builder set(int bit) {
      if (words == null) {
        throw new IllegalArgumentException(""can only use builder once"");
      }
      int wordIndex = wordIndex(bit);
      if (wordIndex >= words.length) {
        words = Arrays.copyOf(words, wordIndex + 1);
      }
      words[wordIndex] |= 1L << bit;
      return this;
    }

    private void trim(int wordCount) {
      while (wordCount > 0 && words[wordCount - 1] == 0L) {
        --wordCount;
      }
      if (wordCount == words.length) {
        return;
      }
      if (wordCount == 0) {
        words = EMPTY_LONGS;
      } else {
        words = Arrays.copyOfRange(words, 0, wordCount);
      }
    }

    public Builder clear(int bit) {
      int wordIndex = wordIndex(bit);
      if (wordIndex < words.length) {
        words[wordIndex] &= ~(1L << bit);
        trim(words.length);
      }
      return this;
    }

    /** Returns whether the bit set that would be created by this Builder would
     * equal a given bit set. */
    public boolean wouldEqual(ImmutableBitSet bitSet) {
      if (words == null) {
        throw new IllegalArgumentException(""can only use builder once"");
      }
      return Arrays.equals(words, bitSet.words);
    }

    /** Returns the number of set bits. */
    public int cardinality() {
      if (words == null) {
        throw new IllegalArgumentException(""can only use builder once"");
      }
      return countBits(words);
    }

    /** Sets all bits in a given bit set. */
    public Builder addAll(ImmutableBitSet bitSet) {
      for (Integer bit : bitSet) {
        set(bit);
      }
      return this;
    }

    /** Sets all bits in a given list of bits. */
    public Builder addAll(Iterable<Integer> integers) {
      for (Integer integer : integers) {
        set(integer);
      }
      return this;
    }

    /** Sets all bits in a given list of {@code int}s. */
    public Builder addAll(ImmutableIntList integers) {
      //noinspection ForLoopReplaceableByForEach
      for (int i = 0; i < integers.size(); i++) {
        set(integers.get(i));
      }
      return this;
    }

    /** Clears all bits in a given bit set. */
    public Builder removeAll(ImmutableBitSet bitSet) {
      for (Integer bit : bitSet) {
        clear(bit);
      }
      return this;
    }

    /** Sets a range of bits, from {@code from} to {@code to} - 1. */
    public Builder set(int fromIndex, int toIndex) {
      if (fromIndex > toIndex) {
        throw new IllegalArgumentException();
      }
      if (toIndex < 0) {
        throw new IllegalArgumentException();
      }
      if (fromIndex < toIndex) {
        // Increase capacity if necessary
        int startWordIndex = wordIndex(fromIndex);
        int endWordIndex   = wordIndex(toIndex - 1);
        if (endWordIndex >= words.length) {
          words = Arrays.copyOf(words, endWordIndex + 1);
        }

        long firstWordMask = WORD_MASK << fromIndex;
        long lastWordMask  = WORD_MASK >>> -toIndex;
        if (startWordIndex == endWordIndex) {
          // One word
          words[startWordIndex] |= firstWordMask & lastWordMask;
        } else {
          // First word, middle words, last word
          words[startWordIndex] |= firstWordMask;
          for (int i = startWordIndex + 1; i < endWordIndex; i++) {
            words[i] = WORD_MASK;
          }
          words[endWordIndex] |= lastWordMask;
        }
      }
      return this;
    }

    public boolean isEmpty() {
      return words.length == 0;
    }

    public void intersect(ImmutableBitSet that) {
      int x = Math.min(words.length, that.words.length);
      for (int i = 0; i < x; i++) {
        words[i] &= that.words[i];
      }
      trim(x);
    }
  }

  /** Refinement of {@link Builder} that remembers its original
   * {@link org.apache.calcite.util.ImmutableBitSet} and tries to use it
   * when {@link #build} is called. */
  private static class Rebuilder extends Builder {
    private final ImmutableBitSet originalBitSet;

    private Rebuilder(ImmutableBitSet originalBitSet) {
      super(originalBitSet.words.clone());
      this.originalBitSet = originalBitSet;
    }

    @Override public ImmutableBitSet build() {
      if (wouldEqual(originalBitSet)) {
        return originalBitSet;
      }
      return super.build();
    }

    @Override public ImmutableBitSet build(ImmutableBitSet bitSet) {
      // We try to re-use both originalBitSet and bitSet.
      if (wouldEqual(originalBitSet)) {
        return originalBitSet;
      }
      return super.build(bitSet);
    }
  }
}
",blob
605,"    @Override
    public void execute() throws ResourceUnavailableException, InsufficientCapacityException, ServerApiException, ConcurrentOperationException,
        ResourceAllocationException, NetworkRuleConflictException {

        Map<String, String> dm = new HashMap();

        dm.put(ApiConstants.S3_ACCESS_KEY, getAccessKey());
        dm.put(ApiConstants.S3_SECRET_KEY, getSecretKey());
        dm.put(ApiConstants.S3_END_POINT, getEndPoint());
        dm.put(ApiConstants.S3_BUCKET_NAME, getBucketName());

        if (getSigner() != null && (getSigner().equals(ApiConstants.S3_V3_SIGNER) || getSigner().equals(ApiConstants.S3_V4_SIGNER))) {
            dm.put(ApiConstants.S3_SIGNER, getSigner());
        }
        if (isHttps() != null) {
            dm.put(ApiConstants.S3_HTTPS_FLAG, isHttps().toString());
        }
        if (getConnectionTimeout() != null) {
            dm.put(ApiConstants.S3_CONNECTION_TIMEOUT, getConnectionTimeout().toString());
        }
        if (getMaxErrorRetry() != null) {
            dm.put(ApiConstants.S3_MAX_ERROR_RETRY, getMaxErrorRetry().toString());
        }
        if (getSocketTimeout() != null) {
            dm.put(ApiConstants.S3_SOCKET_TIMEOUT, getSocketTimeout().toString());
        }
        if (getConnectionTtl() != null) {
            dm.put(ApiConstants.S3_CONNECTION_TTL, getConnectionTtl().toString());
        }
        if (getUseTCPKeepAlive() != null) {
            dm.put(ApiConstants.S3_USE_TCP_KEEPALIVE, getUseTCPKeepAlive().toString());
        }

        try{
            ImageStore result = _storageService.discoverImageStore(null, null, ""S3"", null, dm);
            ImageStoreResponse storeResponse;
            if (result != null) {
                storeResponse = _responseGenerator.createImageStoreResponse(result);
                storeResponse.setResponseName(getCommandName());
                storeResponse.setObjectName(""imagestore"");
                setResponseObject(storeResponse);
            } else {
                throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ""Failed to add S3 Image Store."");
            }
        } catch (DiscoveryException ex) {
            s_logger.warn(""Exception: "", ex);
            throw new ServerApiException(ApiErrorCode.INTERNAL_ERROR, ex.getMessage());
        }
    }
",long method
1201,"	public class ListElement extends Canvas
	{

		private Tab tab;

		private int index;

		private boolean selected;

		private boolean hover;

		public ListElement( Composite parent, final Tab tab, int index )
		{
			super( parent, SWT.NO_FOCUS );
			this.tab = tab;
			hover = false;
			selected = false;
			this.index = index;

			addPaintListener( new PaintListener( ) {

				public void paintControl( PaintEvent e )
				{
					paint( e );
				}
			} );
			addMouseListener( new MouseAdapter( ) {

				public void mouseDown( MouseEvent e )
				{
					if ( !selected )
					{
						select( getIndex( ListElement.this ), true );
					}
					Composite tabbedPropertyComposite = getParent( );
					Control[] children = tabbedPropertyComposite.getParent( )
							.getTabList( );
					if ( children != null && children.length > 0 )
					{
						for ( int i = 0; i < children.length; i++ )
						{
							if ( children[i] == TabbedPropertyList.this )
							{
								continue;
							}
							else if ( children[i].setFocus( ) )
							{
								focus = false;
								return;
							}
						}
					}
				}
			} );
			addMouseMoveListener( new MouseMoveListener( ) {

				public void mouseMove( MouseEvent e )
				{
					if ( !hover )
					{
						hover = true;
						redraw( );
					}
				}
			} );
			addMouseTrackListener( new MouseTrackAdapter( ) {

				public void mouseExit( MouseEvent e )
				{
					hover = false;
					redraw( );
				}
			} );
		}

		public void setSelected( boolean selected )
		{
			this.selected = selected;
			redraw( );
		}

		/**
		 * Draws elements and collects element areas.
		 */
		private void paint( PaintEvent e )
		{
			/*
			 * draw the top two lines of the tab, same for selected, hover and
			 * default
			 */
			Rectangle bounds = getBounds( );
			e.gc.setForeground( widgetNormalShadow );
			e.gc.drawLine( 0, 0, bounds.width - 1, 0 );
			e.gc.setForeground( listBackground );
			e.gc.drawLine( 0, 1, bounds.width - 1, 1 );

			/* draw the fill in the tab */
			if ( selected )
			{
				e.gc.setBackground( listBackground );
				e.gc.fillRectangle( 0, 2, bounds.width, bounds.height - 1 );
			}
			else if ( hover && tab.isIndented( ) )
			{
				e.gc.setBackground( indentedHoverBackground );
				e.gc.fillRectangle( 0, 2, bounds.width - 1, bounds.height - 1 );
			}
			else if ( hover )
			{
				e.gc.setForeground( hoverGradientStart );
				e.gc.setBackground( hoverGradientEnd );
				e.gc.fillGradientRectangle( 0,
						2,
						bounds.width - 1,
						bounds.height - 1,
						true );
			}
			else if ( tab.isIndented( ) )
			{
				e.gc.setBackground( indentedDefaultBackground );
				e.gc.fillRectangle( 0, 2, bounds.width - 1, bounds.height - 1 );
			}
			else
			{
				e.gc.setForeground( defaultGradientStart );
				e.gc.setBackground( defaultGradientEnd );
				e.gc.fillGradientRectangle( 0,
						2,
						bounds.width - 1,
						bounds.height - 1,
						true );
			}

			if ( !selected )
			{
				e.gc.setForeground( widgetNormalShadow );
				e.gc.drawLine( bounds.width - 1,
						1,
						bounds.width - 1,
						bounds.height + 1 );
			}

			int textIndent = INDENT;
			FontMetrics fm = e.gc.getFontMetrics( );
			int height = fm.getHeight( );
			int textMiddle = ( bounds.height - height ) / 2;

			if ( selected
					&& tab.getImage( ) != null
					&& !tab.getImage( ).isDisposed( ) )
			{
				/* draw the icon for the selected tab */
				if ( tab.isIndented( ) )
				{
					textIndent = textIndent + INDENT;
				}
				else
				{
					textIndent = textIndent - 3;
				}
				e.gc.drawImage( tab.getImage( ), textIndent, textMiddle - 1 );
				textIndent = textIndent + 16 + 5;
			}
			else if ( tab.isIndented( ) )
			{
				textIndent = textIndent + INDENT;
			}

			/* draw the text */
			e.gc.setForeground( widgetForeground );
			if ( selected )
			{
				/* selected tab is bold font */
				e.gc.setFont( JFaceResources.getFontRegistry( )
						.getBold( JFaceResources.DEFAULT_FONT ) );
			}
			e.gc.drawText( tab.getText( ), textIndent, textMiddle, true );

			if ( ( (TabbedPropertyList) getParent( ) ).focus
					&& selected
					&& focus )
			{
				/* draw a line if the tab has focus */
				Point point = e.gc.textExtent( tab.getText( ) );
				e.gc.drawLine( textIndent, bounds.height - 4, textIndent
						+ point.x, bounds.height - 4 );
			}

			/* draw the bottom line on the tab for selected and default */
			if ( !hover )
			{
				e.gc.setForeground( listBackground );
				e.gc.drawLine( 0,
						bounds.height - 1,
						bounds.width - 2,
						bounds.height - 1 );
			}

		}

		public String getText( )
		{
			return tab.getText( );
		}

		public String toString( )
		{
			return tab.getText( );
		}
	}
",blob
12,"public class DimsDataList implements Serializable {

	
	/**
	 * 
	 */
	private static final long serialVersionUID = -5902704017223885965L;
	
	
	private List<DimsData> dimsData;

	private boolean        expression;
		
	public DimsDataList() {
	}

	public DimsDataList(List<DimsData> chunk) {
		dimsData = chunk;
	}
	
	public DimsDataList(int[] dataShape) throws Exception {
		
		try {
						
			// For now we just assume the first dimensions are the slow ones to make an axis out
			// of. Later read the axis from the meta list but we do not have examples of this so
			// far.
			int xaxis=-1,yaxis=-1;
			for (int i = 0; i<dataShape.length; ++i) {
				add(new DimsData(i));
			}
			for (int i = dataShape.length-1; i>=0; i--) {
				
				if (dataShape[i]>1) {
					if (yaxis<0) {
						getDimsData(i).setPlotAxis(AxisType.Y);
						yaxis = i;
						continue;
					} else  if (xaxis<0) {
						getDimsData(i).setPlotAxis(AxisType.X);
						xaxis = i;
						continue;
					}
				}
			}
			
			// If we only found a y it may be a multiple-dimension set with only 1D possible.
			// In that case change y to x.
			if (yaxis>-1 && xaxis<0) {
				getDimsData(yaxis).setPlotAxis(AxisType.X);
			}
		} finally {
			//file.close();
		}
	}

	public Iterable<DimsData> iterable() {
		return dimsData;
	}
	
	public void add(DimsData dimension) {
		if (dimsData==null) dimsData = new ArrayList<DimsData>(3);
		if (dimsData.size()>dimension.getDimension() && dimension.getDimension()>-1) {
			dimsData.set(dimension.getDimension(), dimension);
		} else {
			dimsData.add(dimension);
		}
	}

	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((dimsData == null) ? 0 : dimsData.hashCode());
		return result;
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		DimsDataList other = (DimsDataList) obj;
		if (dimsData == null) {
			if (other.dimsData != null)
				return false;
		} else if (!dimsData.equals(other.dimsData))
			return false;
		return true;
	}

	public static Object[] getDefault() {
		return new DimsData[]{new DimsData(0)};
	}
	
	public Object[] getElements() {
		if (dimsData==null) return null;
		return dimsData.toArray(new DimsData[dimsData.size()]);
	}

	public int size() {
		if (dimsData==null) return 0;
		return dimsData.size();
	}

	public DimsData getDimsData(int i) {
		if (dimsData==null) return null;
		return dimsData.get(i);
	}

	public Iterator<DimsData> iterator() {
		if (dimsData==null) return null;
		return dimsData.iterator();
	}
	
	public void clear() {
		if (dimsData!=null) dimsData.clear();
	}
	
	public String toString() {
		return toString(null);
	}
	public String toString(int[] shape) {
		
		final StringBuilder buf = new StringBuilder();
		buf.append(""[ "");
		
		int index = 0;
		for (DimsData d : dimsData) {
			
			final int upper = shape!=null ? shape[index] : -1;
			buf.append(d.getUserString(upper));
			if (d!=dimsData.get(dimsData.size()-1)) buf.append("",  "");
			++index;
		}
		buf.append("" ]"");
		return buf.toString();
	}

	public boolean isRangeDefined() {
		for (DimsData data : iterable()) {
			if (data.getSliceRange()!=null) return true;
		}
		return false;
	}
	
	public int getAxisCount() {
		if (dimsData==null) return -1;
		int count = 0;
		for (DimsData dd : dimsData) {
			if (!dd.getPlotAxis().hasValue()) count++;
		}
		return count;
	}
	
	public int getRangeCount() {
		int count = 0;
		for (DimsData dd : dimsData) {
			if (dd.getPlotAxis()==AxisType.RANGE) count++;
		}
		return count;
	}

	public boolean is2D() {
		return getAxisCount()==2;
	}
	
	public DimsDataList clone() {
		final DimsDataList clone = new DimsDataList();
		for (DimsData dd : iterable()) {
			DimsData dnew = dd.clone();
			clone.add(dnew);
		}
		clone.expression = expression;
		return clone;
	}

	/**
	 * Sets any axes there are to  the axis passed in
	 */
	public void normalise(AxisType axis) {
		for (DimsData dd : iterable()) {
			if (!dd.getPlotAxis().hasValue()) dd.setPlotAxis(axis);
		}
	}

	/**
	 * Probably not best algorithm but we are dealing with very small arrays here.
	 * This is simply trying to ensure that only one dimension is selected as an
	 * axis because the plot has changed.
	 * 
	 * @param iaxisToFind
	 */
	public void setSingleAxisOnly(AxisType iaxisToFind, AxisType iaxisValue) {
		DimsData found = null;
		for (DimsData dd : iterable()) {
			if (dd.getPlotAxis()==iaxisToFind) {
				dd.setPlotAxis(iaxisValue);
				found=dd;
			}
		}
		
		if (found!=null) {
			for (DimsData dd : iterable()) {
				if (dd==found) continue;
				dd.setPlotAxis(AxisType.SLICE);
			}
			return;
		} else { // We have to decide which of the others is x
			
			for (DimsData dd : iterable()) {
				if (!dd.getPlotAxis().hasValue()) {
				    dd.setPlotAxis(iaxisValue);
				    found=dd;
				}
			}
			for (DimsData dd : iterable()) {
				if (dd==found) continue;
				dd.setPlotAxis(AxisType.SLICE);
			}
		}
	}

	/**
	 * Bit of a complex  method. It simply tries to leave the data with
	 * two axes selected by finding the most likely two dimensions that
	 * should be plot axes.
	 * 
	 * @param firstAxis
	 * @param secondAxis
	 */
	public void setTwoAxesOnly(AxisType firstAxis, AxisType secondAxis) {
		boolean foundFirst = false, foundSecond = false;
		for (DimsData dd : iterable()) {
			if (dd.getPlotAxis()==firstAxis)  foundFirst  = true;
			if (dd.getPlotAxis()==secondAxis) foundSecond = true;
		}
		
		if (foundFirst&&foundSecond) {
			for (DimsData dd : iterable()) {
				if (dd.getPlotAxis()==firstAxis)  continue;
				if (dd.getPlotAxis()==secondAxis) continue;
				if (dd.getPlotAxis()==AxisType.RANGE) continue;
				dd.setPlotAxis(AxisType.SLICE);
			}
			return;
		} else { // We have to decide which of the others is first and second
			
			if (!foundFirst)  foundFirst  = processAxis(firstAxis, secondAxis);
			if (!foundSecond) foundSecond = processAxis(secondAxis, firstAxis);
			
			for (DimsData dd : iterable()) {
				if (dd.getPlotAxis()==firstAxis)  continue;
				if (dd.getPlotAxis()==secondAxis) continue;
				if (dd.getPlotAxis()==AxisType.RANGE) continue;
				dd.setPlotAxis(AxisType.SLICE);
			}
			return;
				
		}
		
	}
	
	/**
	 * Bit of a complex  method. It simply tries to leave the data with
	 * two axes selected by finding the most likely two dimensions that
	 * should be plot axes.
	 * 
	 * @param firstAxis
	 * @param secondAxis
	 * @param thirdAxis
	 */
	public void setThreeAxesOnly(AxisType firstAxis, AxisType secondAxis, AxisType thirdAxis) {

		boolean foundFirst = false, foundSecond = false, foundThird = false;
		for (DimsData dd : iterable()) {
			if (dd.getPlotAxis()==firstAxis)  foundFirst  = true;
			if (dd.getPlotAxis()==secondAxis) foundSecond = true;
			if (dd.getPlotAxis()==thirdAxis)  foundThird  = true;
		}
		
		if (foundFirst&&foundSecond&&foundThird) {
			for (DimsData dd : iterable()) {
				if (dd.getPlotAxis()==firstAxis)  continue;
				if (dd.getPlotAxis()==secondAxis) continue;
				if (dd.getPlotAxis()==thirdAxis)  continue;
				if (dd.getPlotAxis()==AxisType.RANGE) continue;
				dd.setPlotAxis(AxisType.SLICE);
			}
			return;
		} else { // We have to decide which of the others is first and second
			
			if (!foundFirst)  foundFirst  = processAxis(firstAxis,  secondAxis, thirdAxis);
			if (!foundSecond) foundSecond = processAxis(secondAxis, firstAxis,  thirdAxis);
			if (!foundThird)  foundThird  = processAxis(thirdAxis,  firstAxis,  secondAxis);
			
			for (DimsData dd : iterable()) {
				if (dd.getPlotAxis()==firstAxis)  continue;
				if (dd.getPlotAxis()==secondAxis) continue;
				if (dd.getPlotAxis()==thirdAxis)  continue;
				if (dd.getPlotAxis()==AxisType.RANGE) continue;
				dd.setPlotAxis(AxisType.SLICE);
			}
			return;
				
		}

	}

	
	private final boolean processAxis(AxisType axis, AxisType... ignoredAxes) {
		
		final List<Object> ignored = asList(ignoredAxes);
		for (DimsData dd : iterable()) {
			if (!dd.getPlotAxis().hasValue() && !ignored.contains(dd.getPlotAxis())) {
			    dd.setPlotAxis(axis);
			    return true;
			}
		}	
		
		for (DimsData dd : iterable()) {
			if (!ignored.contains(dd.getPlotAxis())) {
				dd.setPlotAxis(axis);
				return true;
			}
		}
		
		return false;
	}
	
	/**
	 * Convert a primitive array to a list.
	 * @param array - an array of primitives
	 * @return
	 */
	@SuppressWarnings(""unchecked"")
    private static final <T> List<T> asList(final Object array) {
		
        if (!array.getClass().isArray()) throw new IllegalArgumentException(""Not an array"");
        return new AbstractList<T>() {
            @Override
            public T get(int index) {
                return (T) Array.get(array, index);
            }

            @Override
            public int size() {
                return Array.getLength(array);
            }
        };
    }

	public boolean isXFirst() {
		for (DimsData dd : iterable()) {
			if (dd.getPlotAxis().hasValue()) continue;
			return dd.getPlotAxis()==AxisType.X;
		}
		return false;
	}

	public void reverseImage() {
		for (DimsData dd : iterable()) {
			if (dd.getPlotAxis()==AxisType.X) {
				dd.setPlotAxis(AxisType.Y);
				continue;
			}
			
			if (dd.getPlotAxis()==AxisType.Y) {
				dd.setPlotAxis(AxisType.X);
				continue;
			}
		}
	}

	public boolean isExpression() {
		return expression;
	}

	public void setExpression(boolean expression) {
		this.expression = expression;
	}

	public boolean isEmpty() {
		return dimsData==null || dimsData.isEmpty();
	}

	public boolean isAdvanced() {
		for (DimsData dd : iterable()) {
            if (dd.getPlotAxis().isAdvanced()) return true;
		}
		return false;
	}

	/**
	 * DO NOT USE THIS IS FOR XML SERLIALIZATION
	 * @return
	 */
	public List<DimsData> getDimsData() {
		return dimsData;
	}

	/**
	 * DO NOT USE THIS IS FOR XML SERLIALIZATION
	 * @return
	 */
	public void setDimsData(List<DimsData> dimsData) {
		this.dimsData = dimsData;
	}

	public void removeLargeStacks(ISliceSystem slicingSystem, int maxStack) {
		
		for (DimsData dd : getDimsData()) {
			if (dd.getPlotAxis().isStack(slicingSystem)) {
				if (dd.getSliceRange(true)==null || """".equals(dd.getSliceRange(true)) || ""all"".equals(dd.getSliceRange(true))) {
					final ILazyDataset lz = slicingSystem.getData().getLazySet();
					if (lz!=null) {
						final int size = lz.getShape()[dd.getDimension()];
						if (size>=maxStack) { // We set a default slice
							dd.setSliceRange(""0:25"");
						}
					}
				}
			}
		}
		
	}

	public Slice[] toSliceArray(int[] dataShape) {
		
		final Slice[] ret = new Slice[size()];
		for (int i = 0; i < size(); i++) {
			DimsData dd = getDimsData(i);			
			if (dd.isSlice()) {
				ret[i] = new Slice(dd.getSlice(), dd.getSlice()+1);
			} else {
				ret[i] = new Slice(dataShape[dd.getDimension()]);
			}
		}
		return ret;	
	}

	/**
	 * Export to Map from DimsDataList
	 * @return
	 */
	public Map<Integer, String> toMap() {
		final Map<Integer, String> ret = new HashMap<Integer, String>(size());
		for (DimsData dd : iterable()) {
			if (dd.isSlice()) {
				ret.put(dd.getDimension(), String.valueOf(dd.getSlice()));
			} else if (dd.isTextRange()) {
				ret.put(dd.getDimension(), dd.getSliceRange()!=null ? dd.getSliceRange() : ""all"");
			} else if ( dd.getPlotAxis()!=null){
				ret.put(dd.getDimension(), dd.getPlotAxis().getName());
			}
		}
	    return ret;
	}

    /**
     * Set the current DimsDataList to what is defined in the pass in map.
     * @param map
     * @param shape
     */
	public void fromMap(Map<Integer, String> map, int[] shape) {
		
		clear();
		
		for (int i = 0; i < shape.length; i++) {
			add(new DimsData(i));
		}

		if (map.isEmpty()) { // Make one up
			getDimsData(0).setSliceRange(""all"");
			if (size()==2) {
				getDimsData(1).setPlotAxis(AxisType.X);

			} else if (size()>2) {
				getDimsData(1).setPlotAxis(AxisType.Y);
				getDimsData(2).setPlotAxis(AxisType.X);
				for (int i = 3; i < size(); i++) {
					getDimsData(i).setSlice(0);
				}
			}

		} else { // Init one from map saved

			int dim = 0;
			
			for (DimsData dd : iterable()) {
				String value = map.get(dd.getDimension());
				if (value==null) value = map.get(String.valueOf(dd.getDimension()));
				if (value!=null) {
					if (""all"".equals(value)) {
						dd.setPlotAxis(AxisType.RANGE);
						continue;
					}
					
					AxisType at = AxisType.forLabel(value);
					if (at!=null) {
						dd.setPlotAxis(at);
						continue;
					}
					
					try {
						dd.setSlice(Integer.parseInt(value));
					} catch (Exception ne) {
						dd.setSliceRange(value);
					}
				} else {
					AxisType type = AxisType.forAxis(dim);
					dd.setPlotAxis(type);
					++dim;
				}
			}

		}
		
	}

}
",blob
21,"    public static class Build {

        /**
         * Project version.
         */
        private String version = """";

        public String getVersion() {
            return version;
        }

        public void setVersion(final String version) {
            this.version = version;
        }

    }
",data class
267,"public class PerforceScmProvider
    extends AbstractScmProvider
{
    private static final String[] PROTOCOLS = { ""tcp"", ""tcp4"", ""tcp6"", ""tcp46"", ""tcp64"", ""ssl"", ""ssl4"", ""ssl6"",
        ""ssl46"", ""ssl64"" };

    // ----------------------------------------------------------------------
    // ScmProvider Implementation
    // ----------------------------------------------------------------------

    public boolean requiresEditMode()
    {
        return true;
    }

    public ScmProviderRepository makeProviderScmRepository( String scmSpecificUrl, char delimiter )
        throws ScmRepositoryException
    {
        String protocol = null;
        String path;
        int port = 0;
        String host = null;

        //minimal logic to support perforce protocols in scm url, and keep the next part unchange
        int i0 = scmSpecificUrl.indexOf( delimiter );
        if ( i0 > 0 )
        {
            protocol = scmSpecificUrl.substring( 0, i0 );
            HashSet<String> protocols = new HashSet<String>( Arrays.asList( PROTOCOLS ) );
            if ( protocols.contains( protocol ) )
            {
                scmSpecificUrl = scmSpecificUrl.substring( i0 + 1 );
            }
            else
            {
                protocol = null;
            }
        }

        int i1 = scmSpecificUrl.indexOf( delimiter );
        int i2 = scmSpecificUrl.indexOf( delimiter, i1 + 1 );

        if ( i1 > 0 )
        {
            int lastDelimiter = scmSpecificUrl.lastIndexOf( delimiter );
            path = scmSpecificUrl.substring( lastDelimiter + 1 );
            host = scmSpecificUrl.substring( 0, i1 );

            // If there is tree parts in the scm url, the second is the port
            if ( i2 >= 0 )
            {
                try
                {
                    String tmp = scmSpecificUrl.substring( i1 + 1, lastDelimiter );
                    port = Integer.parseInt( tmp );
                }
                catch ( NumberFormatException ex )
                {
                    throw new ScmRepositoryException( ""The port has to be a number."" );
                }
            }
        }
        else
        {
            path = scmSpecificUrl;
        }

        String user = null;
        String password = null;
        if ( host != null && host.indexOf( '@' ) > 1 )
        {
            user = host.substring( 0, host.indexOf( '@' ) );
            host = host.substring( host.indexOf( '@' ) + 1 );
        }

        if ( path.indexOf( '@' ) > 1 )
        {
            if ( host != null )
            {
                if ( getLogger().isWarnEnabled() )
                {
                    getLogger().warn(
                                      ""Username as part of path is deprecated, the new format is ""
                                          + ""scm:perforce:[username@]host:port:path_to_repository"" );
                }
            }

            user = path.substring( 0, path.indexOf( '@' ) );
            path = path.substring( path.indexOf( '@' ) + 1 );
        }

        return new PerforceScmProviderRepository( protocol, host, port, path, user, password );
    }

    public String getScmType()
    {
        return ""perforce"";
    }

    /** {@inheritDoc} */
    protected ChangeLogScmResult changelog( ScmProviderRepository repository, ScmFileSet fileSet,
                                            CommandParameters parameters )
        throws ScmException
    {
        PerforceChangeLogCommand command = new PerforceChangeLogCommand();
        command.setLogger( getLogger() );
        return (ChangeLogScmResult) command.execute( repository, fileSet, parameters );
    }

    public AddScmResult add( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )
        throws ScmException
    {
        PerforceAddCommand command = new PerforceAddCommand();
        command.setLogger( getLogger() );
        return (AddScmResult) command.execute( repository, fileSet, params );
    }

    protected RemoveScmResult remove( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )
        throws ScmException
    {
        PerforceRemoveCommand command = new PerforceRemoveCommand();
        command.setLogger( getLogger() );
        return (RemoveScmResult) command.execute( repository, fileSet, params );
    }

    protected CheckInScmResult checkin( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )
        throws ScmException
    {
        PerforceCheckInCommand command = new PerforceCheckInCommand();
        command.setLogger( getLogger() );
        return (CheckInScmResult) command.execute( repository, fileSet, params );
    }

    protected CheckOutScmResult checkout( ScmProviderRepository repository, ScmFileSet fileSet,
                                          CommandParameters params )
        throws ScmException
    {
        PerforceCheckOutCommand command = new PerforceCheckOutCommand();
        command.setLogger( getLogger() );
        return (CheckOutScmResult) command.execute( repository, fileSet, params );
    }

    protected DiffScmResult diff( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )
        throws ScmException
    {
        PerforceDiffCommand command = new PerforceDiffCommand();
        command.setLogger( getLogger() );
        return (DiffScmResult) command.execute( repository, fileSet, params );
    }

    protected EditScmResult edit( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )
        throws ScmException
    {
        PerforceEditCommand command = new PerforceEditCommand();
        command.setLogger( getLogger() );
        return (EditScmResult) command.execute( repository, fileSet, params );
    }

    protected LoginScmResult login( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )
        throws ScmException
    {
        PerforceLoginCommand command = new PerforceLoginCommand();
        command.setLogger( getLogger() );
        return (LoginScmResult) command.execute( repository, fileSet, params );
    }

    protected StatusScmResult status( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )
        throws ScmException
    {
        PerforceStatusCommand command = new PerforceStatusCommand();
        command.setLogger( getLogger() );
        return (StatusScmResult) command.execute( repository, fileSet, params );
    }

    protected TagScmResult tag( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )
        throws ScmException
    {
        PerforceTagCommand command = new PerforceTagCommand();
        command.setLogger( getLogger() );
        return (TagScmResult) command.execute( repository, fileSet, params );
    }

    protected UnEditScmResult unedit( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )
        throws ScmException
    {
        PerforceUnEditCommand command = new PerforceUnEditCommand();
        command.setLogger( getLogger() );
        return (UnEditScmResult) command.execute( repository, fileSet, params );
    }

    protected UpdateScmResult update( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )
        throws ScmException
    {
        PerforceUpdateCommand command = new PerforceUpdateCommand();
        command.setLogger( getLogger() );
        return (UpdateScmResult) command.execute( repository, fileSet, params );
    }

    protected BlameScmResult blame( ScmProviderRepository repository, ScmFileSet fileSet, CommandParameters params )
        throws ScmException
    {
        PerforceBlameCommand command = new PerforceBlameCommand();
        command.setLogger( getLogger() );
        return (BlameScmResult) command.execute( repository, fileSet, params );
    }

    public static Commandline createP4Command( PerforceScmProviderRepository repo, File workingDir )
    {
        Commandline command = new Commandline();
        command.setExecutable( ""p4"" );
        if ( workingDir != null )
        {
            // SCM-209
            command.createArg().setValue( ""-d"" );
            command.createArg().setValue( workingDir.getAbsolutePath() );
        }


        if ( repo.getHost() != null )
        {
            command.createArg().setValue( ""-p"" );
            String value = """";
            if ( ! StringUtils.isBlank( repo.getProtocol() ) )
            {
                value += repo.getProtocol() + "":"";
            }
            value += repo.getHost();
            if ( repo.getPort() != 0 )
            {
                value += "":"" + Integer.toString( repo.getPort() );
            }
            command.createArg().setValue( value );
        }

        if ( StringUtils.isNotEmpty( repo.getUser() ) )
        {
            command.createArg().setValue( ""-u"" );
            command.createArg().setValue( repo.getUser() );
        }

        if ( StringUtils.isNotEmpty( repo.getPassword() ) )
        {
            command.createArg().setValue( ""-P"" );
            command.createArg().setValue( repo.getPassword() );
        }
        return command;
    }

    public static String clean( String string )
    {
        if ( string.indexOf( "" -P "" ) == -1 )
        {
            return string;
        }
        int idx = string.indexOf( "" -P "" ) + 4;
        int end = string.indexOf( ' ', idx );
        return string.substring( 0, idx ) + StringUtils.repeat( ""*"", end - idx ) + string.substring( end );
    }

    /**
     * Given a path like ""//depot/foo/bar"", returns the
     * proper path to include everything beneath it.
     * <p/>
     * //depot/foo/bar -> //depot/foo/bar/...
     * //depot/foo/bar/ -> //depot/foo/bar/...
     * //depot/foo/bar/... -> //depot/foo/bar/...
     *
     * @param repoPath
     * @return
     */
    public static String getCanonicalRepoPath( String repoPath )
    {
        if ( repoPath.endsWith( ""/..."" ) )
        {
            return repoPath;
        }
        else if ( repoPath.endsWith( ""/"" ) )
        {
            return repoPath + ""..."";
        }
        else
        {
            return repoPath + ""/..."";
        }
    }

    private static final String NEWLINE = ""\r\n"";

    /*
     * Clientspec name can be overridden with the system property below.  I don't
     * know of any way for this code to get access to maven's settings.xml so this
     * is the best I can do.
     *
     * Sample clientspec:

     Client: mperham-mikeperham-dt-maven
     Root: d:\temp\target
     Owner: mperham
     View:
     //depot/sandbox/mperham/tsa/tsa-domain/... //mperham-mikeperham-dt-maven/...
     Description:
     Created by maven-scm-provider-perforce

     */
    public static String createClientspec( ScmLogger logger, PerforceScmProviderRepository repo, File workDir,
                                           String repoPath )
    {
        String clientspecName = getClientspecName( logger, repo, workDir );
        String userName = getUsername( logger, repo );

        String rootDir;
        try
        {
            // SCM-184
            rootDir = workDir.getCanonicalPath();
        }
        catch ( IOException ex )
        {
            //getLogger().error(""Error getting canonical path for working directory: "" + workDir, ex);
            rootDir = workDir.getAbsolutePath();
        }

        StringBuilder buf = new StringBuilder();
        buf.append( ""Client: "" ).append( clientspecName ).append( NEWLINE );
        buf.append( ""Root: "" ).append( rootDir ).append( NEWLINE );
        buf.append( ""Owner: "" ).append( userName ).append( NEWLINE );
        buf.append( ""View:"" ).append( NEWLINE );
        buf.append( ""\t"" ).append( PerforceScmProvider.getCanonicalRepoPath( repoPath ) );
        buf.append( "" //"" ).append( clientspecName ).append( ""/..."" ).append( NEWLINE );
        buf.append( ""Description:"" ).append( NEWLINE );
        buf.append( ""\t"" ).append( ""Created by maven-scm-provider-perforce"" ).append( NEWLINE );
        return buf.toString();
    }

    public static final String DEFAULT_CLIENTSPEC_PROPERTY = ""maven.scm.perforce.clientspec.name"";

    public static String getClientspecName( ScmLogger logger, PerforceScmProviderRepository repo, File workDir )
    {
        String def = generateDefaultClientspecName( logger, repo, workDir );
        // until someone put clearProperty in DefaultContinuumScm.getScmRepository( Project , boolean  )
        String l = System.getProperty( DEFAULT_CLIENTSPEC_PROPERTY, def );
        if ( l == null || """".equals( l.trim() ) )
        {
            return def;
        }
        return l;
    }

    private static String generateDefaultClientspecName( ScmLogger logger, PerforceScmProviderRepository repo,
                                                         File workDir )
    {
        String username = getUsername( logger, repo );
        String hostname;
        String path;
        try
        {
            hostname = InetAddress.getLocalHost().getHostName();
            // [SCM-370][SCM-351] client specs cannot contain forward slashes, spaces and ~; ""-"" is okay
            path = workDir.getCanonicalPath().replaceAll( ""[/ ~]"", ""-"" );
        }
        catch ( UnknownHostException e )
        {
            // Should never happen
            throw new RuntimeException( e );
        }
        catch ( IOException e )
        {
            throw new RuntimeException( e );
        }
        return username + ""-"" + hostname + ""-MavenSCM-"" + path;
    }

    private static String getUsername( ScmLogger logger, PerforceScmProviderRepository repo )
    {
        String username = PerforceInfoCommand.getInfo( logger, repo ).getEntry( ""User name"" );
        if ( username == null )
        {
            // os user != perforce user
            username = repo.getUser();
            if ( username == null )
            {
                username = System.getProperty( ""user.name"", ""nouser"" );
            }
        }
        return username;
    }

    /**
     * This is a ""safe"" method which handles cases where repo.getPath() is
     * not actually a valid Perforce depot location.  This is a frequent error
     * due to branches and directory naming where dir name != artifactId.
     *
     * @param log     the logging object to use
     * @param repo    the Perforce repo
     * @param basedir the base directory we are operating in.  If pom.xml exists in this directory,
     *                this method will verify <pre>repo.getPath()/pom.xml</pre> == <pre>p4 where basedir/pom.xml</pre>
     * @return repo.getPath if it is determined to be accurate.  The p4 where location otherwise.
     */
    public static String getRepoPath( ScmLogger log, PerforceScmProviderRepository repo, File basedir )
    {
        PerforceWhereCommand where = new PerforceWhereCommand( log, repo );

        // Handle an edge case where we release:prepare'd a module with an invalid SCM location.
        // In this case, the release.properties will contain the invalid URL for checkout purposes
        // during release:perform.  In this case, the basedir is not the module root so we detect that
        // and remove the trailing target/checkout directory.
        if ( basedir.toString().replace( '\\', '/' ).endsWith( ""/target/checkout"" ) )
        {
            String dir = basedir.toString();
            basedir = new File( dir.substring( 0, dir.length() - ""/target/checkout"".length() ) );
            log.debug( ""Fixing checkout URL: "" + basedir );
        }
        File pom = new File( basedir, ""pom.xml"" );
        String loc = repo.getPath();
        log.debug( ""SCM path in pom: "" + loc );
        if ( pom.exists() )
        {
            loc = where.getDepotLocation( pom );
            if ( loc == null )
            {
                loc = repo.getPath();
                log.debug( ""cannot find depot => using "" + loc );
            }
            else if ( loc.endsWith( ""/pom.xml"" ) )
            {
                loc = loc.substring( 0, loc.length() - ""/pom.xml"".length() );
                log.debug( ""Actual POM location: "" + loc );
                if ( !repo.getPath().equals( loc ) )
                {
                    log.info( ""The SCM location in your pom.xml ("" + repo.getPath()
                        + "") is not equal to the depot location ("" + loc
                        + "").  This happens frequently with branches.  "" + ""Ignoring the SCM location."" );
                }
            }
        }
        return loc;
    }


    private static Boolean live = null;

    public static boolean isLive()
    {
        if ( live == null )
        {
            if ( !Boolean.getBoolean( ""maven.scm.testing"" ) )
            {
                // We are not executing in the tests so we are live.
                live = Boolean.TRUE;
            }
            else
            {
                // During unit tests, we need to check the local system
                // to see if the user has Perforce installed.  If not, we mark
                // the provider as ""not live"" (or dead, I suppose!) and skip
                // anything that requires an active server connection.
                try
                {
                    Commandline command = new Commandline();
                    command.setExecutable( ""p4"" );
                    Process proc = command.execute();
                    BufferedReader br = new BufferedReader( new InputStreamReader( proc.getInputStream() ) );
                    @SuppressWarnings( ""unused"" )
                    String line;
                    while ( ( line = br.readLine() ) != null )
                    {
                        //System.out.println(line);
                    }
                    int rc = proc.exitValue();
                    live = ( rc == 0 ? Boolean.TRUE : Boolean.FALSE );
                }
                catch ( Exception e )
                {
                    e.printStackTrace();
                    live = Boolean.FALSE;
                }
            }
        }

        return live.booleanValue();
    }
}
",blob
60,"	private static class CountPageable implements Pageable {

		private Pageable delegate;

		public CountPageable(Pageable delegate) {
			this.delegate = delegate;
		}

		public int getPageNumber() {
			return delegate.getPageNumber();
		}

		public int getPageSize() {
			return delegate.getPageSize();
		}

		public long getOffset() {
			return delegate.getOffset();
		}

		public Sort getSort() {
		  // Sorting is not allowed on aggregate count queries.
			return Sort.unsorted();
		}

		public Pageable next() {
			return delegate.next();
		}

		public Pageable previousOrFirst() {
			return delegate.previousOrFirst();
		}

		public Pageable first() {
			return delegate.first();
		}

		public boolean hasPrevious() {
			return delegate.hasPrevious();
		}

	}
",data class
1249,"    @Override public Iterator<Row> getRows(Session ses, SearchRow first, SearchRow last) {
        List<Row> rows = new ArrayList<>();

        Collection<ClusterNode> nodes;

        SqlSystemViewColumnCondition idCond = conditionForColumn(""NODE_ID"", first, last);

        if (idCond.isEquality()) {
            try {
                UUID nodeId = uuidFromValue(idCond.valueForEquality());

                ClusterNode node = nodeId == null ? null : ctx.discovery().node(nodeId);

                if (node != null)
                    nodes = Collections.singleton(node);
                else
                    nodes = Collections.emptySet();
            }
            catch (Exception e) {
                nodes = Collections.emptySet();
            }
        }
        else
            nodes = F.concat(false, ctx.discovery().allNodes(), ctx.discovery().daemonNodes());

        for (ClusterNode node : nodes) {
            if (node != null) {
                ClusterMetrics metrics = node.metrics();

                rows.add(
                    createRow(
                        ses,
                        node.id(),
                        valueTimestampFromMillis(metrics.getLastUpdateTime()),
                        metrics.getMaximumActiveJobs(),
                        metrics.getCurrentActiveJobs(),
                        metrics.getAverageActiveJobs(),
                        metrics.getMaximumWaitingJobs(),
                        metrics.getCurrentWaitingJobs(),
                        metrics.getAverageWaitingJobs(),
                        metrics.getMaximumRejectedJobs(),
                        metrics.getCurrentRejectedJobs(),
                        metrics.getAverageRejectedJobs(),
                        metrics.getTotalRejectedJobs(),
                        metrics.getMaximumCancelledJobs(),
                        metrics.getCurrentCancelledJobs(),
                        metrics.getAverageCancelledJobs(),
                        metrics.getTotalCancelledJobs(),
                        metrics.getMaximumJobWaitTime(),
                        metrics.getCurrentJobWaitTime(),
                        (long)metrics.getAverageJobWaitTime(),
                        metrics.getMaximumJobExecuteTime(),
                        metrics.getCurrentJobExecuteTime(),
                        (long)metrics.getAverageJobExecuteTime(),
                        metrics.getTotalJobsExecutionTime(),
                        metrics.getTotalExecutedJobs(),
                        metrics.getTotalExecutedTasks(),
                        metrics.getTotalBusyTime(),
                        metrics.getTotalIdleTime(),
                        metrics.getCurrentIdleTime(),
                        metrics.getBusyTimePercentage(),
                        metrics.getIdleTimePercentage(),
                        metrics.getTotalCpus(),
                        metrics.getCurrentCpuLoad(),
                        metrics.getAverageCpuLoad(),
                        metrics.getCurrentGcCpuLoad(),
                        metrics.getHeapMemoryInitialized(),
                        metrics.getHeapMemoryUsed(),
                        metrics.getHeapMemoryCommitted(),
                        metrics.getHeapMemoryMaximum(),
                        metrics.getHeapMemoryTotal(),
                        metrics.getNonHeapMemoryInitialized(),
                        metrics.getNonHeapMemoryUsed(),
                        metrics.getNonHeapMemoryCommitted(),
                        metrics.getNonHeapMemoryMaximum(),
                        metrics.getNonHeapMemoryTotal(),
                        metrics.getUpTime(),
                        valueTimestampFromMillis(metrics.getStartTime()),
                        valueTimestampFromMillis(metrics.getNodeStartTime()),
                        metrics.getLastDataVersion(),
                        metrics.getCurrentThreadCount(),
                        metrics.getMaximumThreadCount(),
                        metrics.getTotalStartedThreadCount(),
                        metrics.getCurrentDaemonThreadCount(),
                        metrics.getSentMessagesCount(),
                        metrics.getSentBytesCount(),
                        metrics.getReceivedMessagesCount(),
                        metrics.getReceivedBytesCount(),
                        metrics.getOutboundMessagesQueueSize()
                    )
                );
            }
        }

        return rows.iterator();
    }
",long method
34,"public class MapImageLayerTablesSample extends Application {

  private MapView mapView;
  private GraphicsOverlay graphicsOverlay;
  private ServiceFeatureTable commentsTable;
  private ListView<Feature> commentsListView;

  /**
   * Starting point of this application.
   *
   * @param args arguments to this application.
   */
  public static void main(String[] args) {

    Application.launch(args);
  }

  @Override
  public void start(Stage stage) {

    try {
      // create a stack pane and application scene
      StackPane stackPane = new StackPane();
      Scene scene = new Scene(stackPane);
      scene.getStylesheets().add(getClass().getResource(""/css/style.css"").toExternalForm());

      // size the stage and add a title
      stage.setTitle(""Map Image Layer Tables Sample"");
      stage.setWidth(800);
      stage.setHeight(700);
      stage.setScene(scene);
      stage.show();

      // create a map with a basemap
      ArcGISMap map = new ArcGISMap(Basemap.createStreetsVector());

      // create and add a map image layer to the map
      // the map image layer contains a feature table with related spatial and non-spatial comment features
      ArcGISMapImageLayer imageLayer = new ArcGISMapImageLayer(
          ""https://sampleserver6.arcgisonline.com/arcgis/rest/services/ServiceRequest/MapServer"");
      map.getOperationalLayers().add(imageLayer);

      // create a map view and set the map to it
      mapView = new MapView();
      mapView.setMap(map);

      // create a graphics overlay to show the related spatial features in
      graphicsOverlay = new GraphicsOverlay();
      mapView.getGraphicsOverlays().add(graphicsOverlay);

      // show the related graphics as cyan circles
      SimpleRenderer renderer = new SimpleRenderer();
      renderer.setSymbol(new SimpleMarkerSymbol(SimpleMarkerSymbol.Style.CIRCLE, 0xFF00FFFF, 14));
      graphicsOverlay.setRenderer(renderer);

      // create a list view to show the non-spatial comment features
      commentsListView = new ListView<>();
      commentsListView.setMaxSize(200.0, 150.0);
      // show the comments attribute of the feature in the list
      commentsListView.setCellFactory(listView -> new ListCell<Feature>() {
        @Override
        protected void updateItem(Feature item, boolean empty) {
          super.updateItem(item, empty);
          if (item != null) {
            ArcGISFeature feature = (ArcGISFeature) item;
            setText((String) feature.getAttributes().get(""comments""));
          }
        }
      });

      // when a comment is selected, query its related spatial features and show the first result on the map
      commentsListView.getSelectionModel().selectedItemProperty().addListener(observable -> showRelatedRequests());

      // when the layer is loaded, get the comment features
      imageLayer.addDoneLoadingListener(() -> {
        if (imageLayer.getLoadStatus() == LoadStatus.LOADED) {
          // zoom to the layer's extent
          mapView.setViewpoint(new Viewpoint(imageLayer.getFullExtent()));

          // get the comments feature table
          commentsTable = imageLayer.getTables().get(0);

          // create query parameters to get features that have non-empty comments
          QueryParameters queryParameters = new QueryParameters();
          queryParameters.setWhereClause(""requestid <> '' AND comments <> ''"");

          // query the comments table for features
          ListenableFuture<FeatureQueryResult> featureQuery = commentsTable.queryFeaturesAsync(queryParameters);
          featureQuery.addDoneListener(() -> {
            try {
              // add the returned features to the list view
              FeatureQueryResult results = featureQuery.get();
              for (Feature f : results) {
                commentsListView.getItems().addAll(f);
              }
            } catch (InterruptedException | ExecutionException ex) {
              new Alert(Alert.AlertType.ERROR, ""Error querying comment features"");
            }
          });
        } else {
          new Alert(Alert.AlertType.ERROR, imageLayer.getLoadError().getMessage()).show();
        }
      });

      // add the mapview and controls to the stack pane
      stackPane.getChildren().addAll(mapView, commentsListView);
      StackPane.setAlignment(commentsListView, Pos.TOP_LEFT);
      StackPane.setMargin(commentsListView, new Insets(10, 0, 0, 10));

    } catch (Exception e) {
      // on any error, display the stack trace.
      e.printStackTrace();
    }
  }

  /**
   * Queries for spatial features related to the selected comment in the list view and shows the first result on the
   * map as a graphic.
   */
  private void showRelatedRequests() {
    // clear any previous results
    graphicsOverlay.getGraphics().clear();

    // get the selected comment feature from the list view
    Feature selectedCommentFeature = commentsListView.getSelectionModel().getSelectedItem();
    if (selectedCommentFeature != null) {

      // get the relationships info between layers in the table
      ArcGISFeature feature = (ArcGISFeature) selectedCommentFeature;
      List<RelationshipInfo> relationshipInfos = commentsTable.getLayerInfo().getRelationshipInfos();
      if (!relationshipInfos.isEmpty()) {

        // use the first relationship for the related query parameters
        RelationshipInfo commentsRelationshipInfo = relationshipInfos.get(0);
        RelatedQueryParameters relatedQueryParameters = new RelatedQueryParameters(commentsRelationshipInfo);
        relatedQueryParameters.setReturnGeometry(true);

        // query the table for related features using the parameters
        ListenableFuture<List<RelatedFeatureQueryResult>> relatedFeaturesRequest = commentsTable
            .queryRelatedFeaturesAsync(feature, relatedQueryParameters);
        relatedFeaturesRequest.addDoneListener(() -> {
          try {
            // loop through the returned related features
            List<RelatedFeatureQueryResult> results = relatedFeaturesRequest.get();
            if (!results.isEmpty()) {
              RelatedFeatureQueryResult relatedResult = results.get(0);
              if (relatedResult.iterator().hasNext()) {
                // get the first related feature
                ArcGISFeature relatedFeature = (ArcGISFeature) relatedResult.iterator().next();
                // load the feature and get its geometry to show as a graphic on the map
                relatedFeature.loadAsync();
                relatedFeature.addDoneLoadingListener(() -> {
                  if (relatedFeature.getLoadStatus() == LoadStatus.LOADED) {
                    Point point = (Point) relatedFeature.getGeometry();
                    Graphic graphic = new Graphic(point);
                    graphicsOverlay.getGraphics().add(graphic);
                    // zoom to the graphic
                    mapView.setViewpointCenterAsync(point, 40000);
                  }
                });
              }
            } else {
              new Alert(Alert.AlertType.INFORMATION, ""No related features found"").show();
            }
          } catch (InterruptedException | ExecutionException ex) {
            new Alert(Alert.AlertType.ERROR, ""Failed to query relationships"").show();
          }
        });
      }
    }

  }

  @Override
  public void stop() {

    // releases resources when the application closes
    if (mapView != null) {
      mapView.dispose();
    }
  }
}
",blob
1428,"public class BrocadeVcsApi {
    private static final Logger s_logger = Logger.getLogger(BrocadeVcsApi.class);

    private final String _host;
    private final String _adminuser;
    private final String _adminpass;

    protected DefaultHttpClient _client;

    protected HttpRequestBase createMethod(String type, String uri) throws BrocadeVcsApiException {
        String url;
        try {
            url = new URL(Constants.PROTOCOL, _host, Constants.PORT, uri).toString();
        } catch (final MalformedURLException e) {
            s_logger.error(""Unable to build Brocade Switch API URL"", e);
            throw new BrocadeVcsApiException(""Unable to build Brocade Switch API URL"", e);
        }

        if (""post"".equalsIgnoreCase(type)) {
            return new HttpPost(url);
        } else if (""get"".equalsIgnoreCase(type)) {
            return new HttpGet(url);
        } else if (""delete"".equalsIgnoreCase(type)) {
            return new HttpDelete(url);
        } else if (""patch"".equalsIgnoreCase(type)) {
            return new HttpPatch(url);
        } else {
            throw new BrocadeVcsApiException(""Requesting unknown method type"");
        }
    }

    public BrocadeVcsApi(String address, String username, String password) {
        _host = address;
        _adminuser = username;
        _adminpass = password;
        _client = new DefaultHttpClient();
        _client.getCredentialsProvider().setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(_adminuser, _adminpass));

    }

    /*
     * Get Operational Status
     */
    public Output getSwitchStatus() throws BrocadeVcsApiException {
        return executeRetreiveStatus(Constants.STATUS_URI);

    }

    /*
     * Creates a new virtual network.
     */
    public boolean createNetwork(int vlanId, long networkId) throws BrocadeVcsApiException {

        if (createInterfaceVlan(vlanId)) {

            final PortProfile portProfile = createPortProfile(vlanId, networkId);

            if (portProfile != null) {
                return activatePortProfile(portProfile);
            }
        }
        return false;
    }

    /*
     * Activates a port-profile.
     */
    private boolean activatePortProfile(PortProfile portProfile) throws BrocadeVcsApiException {
        final PortProfileGlobal portProfileGlobal = new PortProfileGlobal();
        portProfile.setVlanProfile(null);
        final Activate activate = new Activate();
        portProfile.setActivate(activate);
        portProfileGlobal.setPortProfile(portProfile);

        //activate port-profile
        return executeUpdateObject(portProfileGlobal, Constants.URI);
    }

    /*
     *  Creates AMPP port-profile.
     */
    private PortProfile createPortProfile(int vlanId, long networkId) throws BrocadeVcsApiException {

        final PortProfile portProfile = new PortProfile();
        portProfile.setName(Constants.PORT_PROFILE_NAME_PREFIX + networkId);
        if (executeCreateObject(portProfile, Constants.URI)) {
            if (createVlanSubProfile(vlanId, portProfile)) {
                return portProfile;
            }
        }
        return null;
    }

    /*
     * Create vlan sub-profile for port-profile
     */
    private boolean createVlanSubProfile(int vlanId, PortProfile portProfile) throws BrocadeVcsApiException {
        final VlanProfile vlanProfile = new VlanProfile();
        portProfile.setVlanProfile(vlanProfile);
        if (executeUpdateObject(portProfile, Constants.URI)) {
            return configureVlanSubProfile(vlanId, portProfile);
        }
        return false;
    }

    /*
     * Configures vlan sub-profile for port-profile.
     * - configure L2 mode for vlan sub-profile
     * - configure trunk mode for vlan sub-profile
     * - configure allowed VLANs for vlan sub-profile
     */
    private boolean configureVlanSubProfile(int vlanId, PortProfile portProfile) throws BrocadeVcsApiException {
        final SwitchportBasic switchPortBasic = new SwitchportBasic();
        final Basic basic = new Basic();
        switchPortBasic.setBasic(basic);
        portProfile.getVlanProfile().setSwitchportBasic(switchPortBasic);
        // configure L2 mode for vlan sub-profile
        if (executeUpdateObject(portProfile, Constants.URI)) {
            VlanProfile vlanProfile = new VlanProfile();
            Switchport switchPort = new Switchport();
            final Mode mode = new Mode();
            mode.setVlanMode(""trunk"");
            switchPort.setMode(mode);
            vlanProfile.setSwitchport(switchPort);
            portProfile.setVlanProfile(vlanProfile);

            // configure trunk mode for vlan sub-profile
            if (executeUpdateObject(portProfile, Constants.URI)) {
                vlanProfile = new VlanProfile();
                switchPort = new Switchport();
                final Trunk trunk = new Trunk();
                final Allowed allowed = new Allowed();
                final Allowed.Vlan allowedVlan = new Allowed.Vlan();
                allowedVlan.setAdd(vlanId);
                allowed.setVlan(allowedVlan);
                trunk.setAllowed(allowed);
                switchPort.setTrunk(trunk);
                vlanProfile.setSwitchport(switchPort);
                portProfile.setVlanProfile(vlanProfile);

                //configure allowed VLANs for vlan sub-profile
                return executeUpdateObject(portProfile, Constants.URI);
            }
        }

        return false;

    }

    /*
     * Creates a vlan interface.
     */
    private boolean createInterfaceVlan(int vlanId) throws BrocadeVcsApiException {
        final InterfaceVlan interfaceVlan = new InterfaceVlan();
        final Interface interfaceObj = new Interface();
        final Vlan vlan = new Vlan();
        vlan.setName(vlanId);
        interfaceObj.setVlan(vlan);
        interfaceVlan.setInterface(interfaceObj);

        return executeUpdateObject(interfaceVlan, Constants.URI);

    }

    /*
     * Associates a MAC address to virtual network.
     */
    public boolean associateMacToNetwork(long networkId, String macAddress) throws BrocadeVcsApiException {

        final PortProfileGlobal portProfileGlobal = new PortProfileGlobal();
        final PortProfile portProfile = new PortProfile();
        portProfile.setName(Constants.PORT_PROFILE_NAME_PREFIX + networkId);
        final Static staticObj = new Static();
        staticObj.setMacAddress(macAddress);
        portProfile.setStatic(staticObj);
        portProfileGlobal.setPortProfile(portProfile);

        //associates a mac address to a port-profile
        return executeUpdateObject(portProfileGlobal, Constants.URI);
    }

    /*
     * Disassociates a MAC address from virtual network.
     */
    public boolean disassociateMacFromNetwork(long networkId, String macAddress) throws BrocadeVcsApiException {

        final PortProfileGlobal portProfileGlobal = new PortProfileGlobal();
        final PortProfile portProfile = new PortProfile();
        portProfile.setName(Constants.PORT_PROFILE_NAME_PREFIX + networkId);
        final Static staticObj = new Static();
        staticObj.setOperation(""delete"");
        staticObj.setMacAddress(macAddress);
        portProfile.setStatic(staticObj);
        portProfileGlobal.setPortProfile(portProfile);

        //associates a mac address to a port-profile
        return executeUpdateObject(portProfileGlobal, Constants.URI);
    }

    /*
     * Deletes a new virtual network.
     */
    public boolean deleteNetwork(int vlanId, long networkId) throws BrocadeVcsApiException {

        if (deactivatePortProfile(networkId)) {

            if (deletePortProfile(networkId)) {
                return deleteInterfaceVlan(vlanId);
            }
        }
        return false;
    }

    /*
     * Deletes a vlan interface.
     */
    private boolean deleteInterfaceVlan(int vlanId) throws BrocadeVcsApiException {
        final InterfaceVlan interfaceVlan = new InterfaceVlan();
        final Interface interfaceObj = new Interface();
        final Vlan vlan = new Vlan();
        vlan.setOperation(""delete"");
        vlan.setName(vlanId);
        interfaceObj.setVlan(vlan);
        interfaceVlan.setInterface(interfaceObj);

        return executeUpdateObject(interfaceVlan, Constants.URI);

    }

    /*
     * Deactivates a port-profile.
     */
    private boolean deactivatePortProfile(long networkId) throws BrocadeVcsApiException {
        final PortProfileGlobal portProfileGlobal = new PortProfileGlobal();
        final PortProfile portProfile = new PortProfile();
        portProfile.setName(Constants.PORT_PROFILE_NAME_PREFIX + networkId);
        final Activate activate = new Activate();
        activate.setOperation(""delete"");
        portProfile.setActivate(activate);
        portProfileGlobal.setPortProfile(portProfile);

        //activate port-profile
        return executeUpdateObject(portProfileGlobal, Constants.URI);
    }

    /*
     *  Deletes AMPP port-profile.
     */
    private boolean deletePortProfile(long networkId) throws BrocadeVcsApiException {

        final PortProfile portProfile = new PortProfile();
        portProfile.setName(Constants.PORT_PROFILE_NAME_PREFIX + networkId);
        portProfile.setOperation(""delete"");
        //deletes port-profile
        return executeUpdateObject(portProfile, Constants.URI);
    }

    protected <T> boolean executeUpdateObject(T newObject, String uri) throws BrocadeVcsApiException {

        final boolean result = true;

        if (_host == null || _host.isEmpty() || _adminuser == null || _adminuser.isEmpty() || _adminpass == null || _adminpass.isEmpty()) {
            throw new BrocadeVcsApiException(""Hostname/credentials are null or empty"");
        }

        final HttpPatch pm = (HttpPatch)createMethod(""patch"", uri);
        pm.setHeader(""Accept"", ""application/vnd.configuration.resource+xml"");

        pm.setEntity(new StringEntity(convertToString(newObject), ContentType.APPLICATION_XML));

        final HttpResponse response = executeMethod(pm);

        if (response.getStatusLine().getStatusCode() != HttpStatus.SC_NO_CONTENT) {

            String errorMessage;
            try {
                errorMessage = responseToErrorMessage(response);
            } catch (final IOException e) {
                s_logger.error(""Failed to update object : "" + e.getMessage());
                throw new BrocadeVcsApiException(""Failed to update object : "" + e.getMessage());
            }

            pm.releaseConnection();
            s_logger.error(""Failed to update object : "" + errorMessage);
            throw new BrocadeVcsApiException(""Failed to update object : "" + errorMessage);
        }

        pm.releaseConnection();

        return result;
    }

    protected <T> String convertToString(T object) throws BrocadeVcsApiException {

        final StringWriter stringWriter = new StringWriter();

        try {
            final JAXBContext context = JAXBContext.newInstance(object.getClass());
            final Marshaller marshaller = context.createMarshaller();

            marshaller.marshal(object, stringWriter);

        } catch (final JAXBException e) {
            s_logger.error(""Failed to convert object to string : "" + e.getMessage());
            throw new BrocadeVcsApiException(""Failed to convert object to string : "" + e.getMessage());
        }

        final String str = stringWriter.toString();
        s_logger.info(str);

        return str;

    }

    protected Output convertToXML(String object) throws BrocadeVcsApiException {

        Output output = null;
        try {
            final JAXBContext context = JAXBContext.newInstance(Output.class);

            final StringReader reader = new StringReader(object);

            final Unmarshaller unmarshaller = context.createUnmarshaller();
            final Object result = unmarshaller.unmarshal(reader);

            if (result instanceof Output) {
                output = (Output)result;
                s_logger.info(output);
            }

        } catch (final JAXBException e) {
            s_logger.error(""Failed to convert string to object : "" + e.getMessage());
            throw new BrocadeVcsApiException(""Failed to convert string to object : "" + e.getMessage());
        }

        return output;

    }

    protected <T> boolean executeCreateObject(T newObject, String uri) throws BrocadeVcsApiException {
        if (_host == null || _host.isEmpty() || _adminuser == null || _adminuser.isEmpty() || _adminpass == null || _adminpass.isEmpty()) {
            throw new BrocadeVcsApiException(""Hostname/credentials are null or empty"");
        }

        final boolean result = true;
        final HttpPost pm = (HttpPost)createMethod(""post"", uri);
        pm.setHeader(""Accept"", ""application/vnd.configuration.resource+xml"");
        pm.setEntity(new StringEntity(convertToString(newObject), ContentType.APPLICATION_XML));

        final HttpResponse response = executeMethod(pm);

        if (response.getStatusLine().getStatusCode() != HttpStatus.SC_CREATED) {

            String errorMessage;
            try {
                errorMessage = responseToErrorMessage(response);
            } catch (final IOException e) {
                s_logger.error(""Failed to create object : "" + e.getMessage());
                throw new BrocadeVcsApiException(""Failed to create object : "" + e.getMessage());
            }

            pm.releaseConnection();
            s_logger.error(""Failed to create object : "" + errorMessage);
            throw new BrocadeVcsApiException(""Failed to create object : "" + errorMessage);
        }

        pm.releaseConnection();

        return result;
    }

    protected Output executeRetreiveStatus(String uri) throws BrocadeVcsApiException {
        if (_host == null || _host.isEmpty() || _adminuser == null || _adminuser.isEmpty() || _adminpass == null || _adminpass.isEmpty()) {
            throw new BrocadeVcsApiException(""Hostname/credentials are null or empty"");
        }

        String readLine = null;
        StringBuffer sb = null;

        final HttpPost pm = (HttpPost)createMethod(""post"", uri);
        pm.setHeader(""Accept"", ""application/vnd.operational-state.resource+xml"");
        pm.setEntity(new StringEntity(""<show-vcs></show-vcs>"", ContentType.APPLICATION_XML));

        final HttpResponse response = executeMethod(pm);

        if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {

            String errorMessage;
            try {
                errorMessage = responseToErrorMessage(response);
            } catch (final IOException e) {
                s_logger.error(""Failed to retreive status : "" + e.getMessage());
                throw new BrocadeVcsApiException(""Failed to retreive status : "" + e.getMessage());
            }

            pm.releaseConnection();
            s_logger.error(""Failed to retreive status : "" + errorMessage);
            throw new BrocadeVcsApiException(""Failed to retreive status : "" + errorMessage);
        }

        try (BufferedReader br = new BufferedReader(new InputStreamReader(response.getEntity().getContent(), Charset.forName(""UTF-8"")))) {
            sb = new StringBuffer();

            while ((readLine = br.readLine()) != null) {
                s_logger.debug(readLine);
                sb.append(readLine);

            }
        } catch (final Exception e) {
            s_logger.error(""Failed to retreive status : "" + e.getMessage());
            throw new BrocadeVcsApiException(""Failed to retreive status : "" + e.getMessage());
        }

        pm.releaseConnection();

        return convertToXML(sb.toString());
    }

    protected void executeDeleteObject(String uri) throws BrocadeVcsApiException {
        if (_host == null || _host.isEmpty() || _adminuser == null || _adminuser.isEmpty() || _adminpass == null || _adminpass.isEmpty()) {
            throw new BrocadeVcsApiException(""Hostname/credentials are null or empty"");
        }

        final HttpDelete dm = (HttpDelete)createMethod(""delete"", uri);
        dm.setHeader(""Accept"", ""application/vnd.configuration.resource+xml"");

        final HttpResponse response = executeMethod(dm);

        if (response.getStatusLine().getStatusCode() != HttpStatus.SC_NO_CONTENT) {

            String errorMessage;
            try {
                errorMessage = responseToErrorMessage(response);
            } catch (final IOException e) {
                s_logger.error(""Failed to delete object : "" + e.getMessage());
                throw new BrocadeVcsApiException(""Failed to delete object : "" + e.getMessage());
            }

            dm.releaseConnection();
            s_logger.error(""Failed to delete object : "" + errorMessage);
            throw new BrocadeVcsApiException(""Failed to delete object : "" + errorMessage);
        }
        dm.releaseConnection();
    }

    protected HttpResponse executeMethod(HttpRequestBase method) throws BrocadeVcsApiException {
        HttpResponse response = null;
        try {
            response = _client.execute(method);
            if (response.getStatusLine().getStatusCode() == HttpStatus.SC_UNAUTHORIZED) {
                method.releaseConnection();
                response = _client.execute(method);
            }
        } catch (final IOException e) {
            s_logger.error(""IOException caught while trying to connect to the Brocade Switch"", e);
            method.releaseConnection();
            throw new BrocadeVcsApiException(""API call to Brocade Switch Failed"", e);
        }

        return response;
    }

    private String responseToErrorMessage(HttpResponse response) throws IOException {

        if (""text/html"".equals(response.getEntity().getContentType().getValue())) {

            try (BufferedReader rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent(), Charset.forName(""UTF-8"")))) {

                final StringBuffer result = new StringBuffer();
                String line = """";
                while ((line = rd.readLine()) != null) {
                    result.append(line);
                }
                return result.toString();
            }
        }
        return null;
    }

}
",blob
114,"@ThreadSafe
public final class MetricsFactory {
    private static final UtilCache<String, Metrics> METRICS_CACHE = UtilCache.createUtilCache(""base.metrics"", 0, 0);
    /**
     * A ""do-nothing"" <code>Metrics</code> instance.
     */
    public static final Metrics NULL_METRICS = new NullMetrics();

    /**
     * Creates a <code>Metrics</code> instance based on <code>element</code> attributes.
     * If an instance with the same name already exists, it will be returned.
     * <table border=""1"">
     *   <caption><strong>Element Attributes</strong></caption>
     *   <tr><th>Attribute Name</th><th>Requirements</th><th>Description</th><th>Notes</th></tr>
     *   <tr>
     *     <td>name</td>
     *     <td>Required</td>
     *     <td>The metric name.</td>
     *     <td>&nbsp;</td>
     *   <tr>
     *     <td>estimation-size</td>
     *     <td>Optional</td>
     *     <td>Positive integer number of events to include in the metrics calculation.</td>
     *     <td>Defaults to ""100"".</td>
     *   </tr>
     *   <tr>
     *     <td>estimation-time</td>
     *     <td>Optional</td>
     *     <td>Positive integer number of milliseconds to include in the metrics calculation.</td>
     *     <td>Defaults to ""1000"".</td>
     *   </tr>
     *   <tr>
     *     <td>smoothing</td>
     *     <td>Optional</td>
     *     <td>Smoothing factor - used to smooth the differences between calculations.</td>
     *     <td>A value of ""1"" disables smoothing. Defaults to ""0.7"".</td>
     *   </tr>
     *   <tr>
     *     <td>threshold</td>
     *     <td>Optional</td>
     *     <td>The metric threshold. The meaning of the threshold is determined by client code.</td>
     *     <td>Defaults to ""0.0"".</td></tr>
     * </table>
     * 
     * @param element The element whose attributes will be used to create the <code>Metrics</code> instance
     * @return A <code>Metrics</code> instance based on <code>element</code> attributes
     * @throws IllegalArgumentException if <code>element</code> is null or if the name attribute is empty
     * @throws NumberFormatException if any of the numeric attribute values are unparsable
     */
    public static Metrics getInstance(Element element) {
        Assert.notNull(""element"", element);
        String name = element.getAttribute(""name"");
        Assert.notEmpty(""name attribute"", name);
        Metrics result = METRICS_CACHE.get(name);
        if (result == null) {
            int estimationSize = UtilProperties.getPropertyAsInteger(""serverstats"", ""metrics.estimation.size"", 100); 
            String attributeValue = element.getAttribute(""estimation-size"");
            if (!attributeValue.isEmpty()) {
                estimationSize = Integer.parseInt(attributeValue);
            }
            long estimationTime = UtilProperties.getPropertyAsLong(""serverstats"", ""metrics.estimation.time"", 1000);
            attributeValue = element.getAttribute(""estimation-time"");
            if (!attributeValue.isEmpty()) {
                estimationTime = Long.parseLong(attributeValue);
            }
            double smoothing = UtilProperties.getPropertyNumber(""serverstats"", ""metrics.smoothing.factor"", 0.7);
            attributeValue = element.getAttribute(""smoothing"");
            if (!attributeValue.isEmpty()) {
                smoothing = Double.parseDouble(attributeValue);
            }
            double threshold = 0.0;
            attributeValue = element.getAttribute(""threshold"");
            if (!attributeValue.isEmpty()) {
                threshold = Double.parseDouble(attributeValue);
            }
            result = new MetricsImpl(name, estimationSize, estimationTime, smoothing, threshold);
            METRICS_CACHE.putIfAbsent(name, result);
            result = METRICS_CACHE.get(name);
        }
        return result;
    }

    /**
     * Creates a <code>Metrics</code> instance.
     * If an instance with the same name already exists, it will be returned.
     * @param name The metric name.
     * @param estimationSize Positive integer number of events to include in the metrics calculation.
     * @param estimationTime Positive integer number of milliseconds to include in the metrics calculation.
     * @param smoothing Smoothing factor - used to smooth the differences between calculations.
     * @return A <code>Metrics</code> instance
     */
    public static Metrics getInstance(String name, int estimationSize, long estimationTime, double smoothing, double threshold) {
        Assert.notNull(""name"", name);
        Metrics result = METRICS_CACHE.get(name);
        if (result == null) {
            result = new MetricsImpl(name, estimationSize, estimationTime, smoothing, threshold);
            METRICS_CACHE.putIfAbsent(name, result);
            result = METRICS_CACHE.get(name);
        }
        return result;
    }

    /**
     * Returns an existing <code>Metric</code> instance with the specified name.
     * Returns <code>null</code> if the metric does not exist.
     * @param name The metric name
     */
    public static Metrics getMetric(String name) {
        Assert.notNull(""name"", name);
        return METRICS_CACHE.get(name);
    }

    /**
     * Returns all <code>Metric</code> instances, sorted by name.
     */
    public static Collection<Metrics> getMetrics() {
        return new TreeSet<Metrics>(METRICS_CACHE.values());
    }

    private static final class MetricsImpl implements Metrics, Comparable<Metrics> {
        private int count = 0;
        private long lastTime = System.currentTimeMillis();
        private double serviceRate = 0.0;
        private long totalServiceTime = 0;
        private long totalEvents = 0;
        private long cumulativeEvents = 0;
        private final String name;
        private final int estimationSize;
        private final long estimationTime;
        private final double smoothing;
        private final double threshold;

        private MetricsImpl(String name, int estimationSize, long estimationTime, double smoothing, double threshold) {
            this.name = name;
            this.estimationSize = estimationSize;
            this.estimationTime = estimationTime;
            this.smoothing = smoothing;
            this.threshold = threshold;
        }

        @Override
        public int compareTo(Metrics other) {
            return this.name.compareTo(other.getName());
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == this) {
                return true;
            }
            try {
                MetricsImpl that = (MetricsImpl) obj;
                return this.name.equals(that.name);
            } catch (Exception e) {}
            return false;
        }

        @Override
        public String getName() {
            return name;
        }

        @Override
        public synchronized double getServiceRate() {
            return serviceRate;
        }

        @Override
        public double getThreshold() {
            return threshold;
        }

        @Override
        public synchronized long getTotalEvents() {
            return cumulativeEvents;
        }

        @Override
        public int hashCode() {
            return name.hashCode();
        }

        @Override
        public synchronized void recordServiceRate(int numEvents, long time) {
            totalEvents += numEvents;
            cumulativeEvents += numEvents;
            totalServiceTime += time;
            count++;
            long curTime = System.currentTimeMillis();
            if ((count == estimationSize) || (curTime - lastTime >= estimationTime)) {
                if (totalEvents == 0) {
                    totalEvents = 1;
                }
                double rate = totalServiceTime / totalEvents;
                serviceRate = (rate * smoothing) + (serviceRate * (1.0 - smoothing));
                count = 0;
                lastTime = curTime;
                totalEvents = totalServiceTime = 0;
            }
        }

        @Override
        public synchronized void reset() {
            serviceRate = 0.0;
            count = 0;
            lastTime = System.currentTimeMillis();
            totalEvents = totalServiceTime = cumulativeEvents = 0;
        }

        @Override
        public String toString() {
            return name;
        }
    }

    private static final class NullMetrics implements Metrics {

        @Override
        public String getName() {
            return ""NULL"";
        }

        @Override
        public double getServiceRate() {
            return 0;
        }

        @Override
        public double getThreshold() {
            return 0.0;
        }

        @Override
        public long getTotalEvents() {
            return 0;
        }

        @Override
        public void recordServiceRate(int numEvents, long time) {
        }

        @Override
        public void reset() {
        }
    }

    private MetricsFactory() {}
}
",data class
449,"    public void run()
    {
      try
      {
        IThreadContext threadContext = ThreadContextFactory.make();
        while (true)
        {
          try
          {
            if (Thread.currentThread().isInterrupted())
              throw new ManifoldCFException(""Interrupted"",ManifoldCFException.INTERRUPTED);

            checkAgents(threadContext);
            ManifoldCF.sleep(5000L);
          }
          catch (InterruptedException e)
          {
            break;
          }
          catch (ManifoldCFException e)
          {
            if (e.getErrorCode() == ManifoldCFException.INTERRUPTED)
              break;
            if (e.getErrorCode() == ManifoldCFException.SETUP_ERROR)
            {
              System.err.println(""Misconfigured ManifoldCF agents - shutting down"");
              Logging.agents.fatal(""AgentThread configuration exception tossed: ""+e.getMessage(),e);
              System.exit(-200);
            }
            Logging.agents.error(""Exception tossed: ""+e.getMessage(),e);
          }
          catch (OutOfMemoryError e)
          {
            System.err.println(""Agents process ran out of memory - shutting down"");
            e.printStackTrace(System.err);
            System.exit(-200);
          }
          catch (Throwable e)
          {
            Logging.agents.fatal(""Error tossed: ""+e.getMessage(),e);
          }
        }
      }
      catch (Throwable e)
      {
        // Severe error on initialization
        System.err.println(""Agents process could not start - shutting down"");
        Logging.agents.fatal(""AgentThread initialization error tossed: ""+e.getMessage(),e);
        System.exit(-300);
      }
    }
",long method
439,"  private void processEmail(EmailData emailData) {
    if (logger.isTraceEnabled()) {
      logger.trace(""Entered MailManager:processEmail"");
    }

    if (mailHost == null || mailHost.length() == 0 || emailData == null
        || mailToAddresses.length == 0) {
      logger.error(""Required mail server configuration is not specfied."");
      if (logger.isDebugEnabled()) {
        logger.debug(""Exited MailManager:processEmail: Not sending email as conditions not met"");
      }
      return;
    }

    Session session = Session.getDefaultInstance(getMailHostConfiguration());
    MimeMessage mimeMessage = new MimeMessage(session);
    String subject = emailData.subject;
    String message = emailData.message;
    String mailToList = getMailToAddressesAsString();

    try {
      for (int i = 0; i < mailToAddresses.length; i++) {
        mimeMessage.addRecipient(Message.RecipientType.TO, new InternetAddress(mailToAddresses[i]));
      }

      if (subject == null) {
        subject = ""Alert from GemFire Admin Agent"";
      }
      mimeMessage.setSubject(subject);

      if (message == null) {
        message = """";
      }
      mimeMessage.setText(message);

      Transport.send(mimeMessage);
      logger.info(""Email sent to {}. Subject: {}, Content: {}"",
          new Object[] {mailToList, subject, message});
    } catch (VirtualMachineError err) {
      SystemFailure.initiateFailure(err);
      // If this ever returns, rethrow the error. We're poisoned
      // now, so don't let this thread continue.
      throw err;
    } catch (Throwable ex) {
      // Whenever you catch Error or Throwable, you must also
      // catch VirtualMachineError (see above). However, there is
      // _still_ a possibility that you are dealing with a cascading
      // error condition, so you also need to check to see if the JVM
      // is still usable:
      SystemFailure.checkFailure();
      StringBuilder buf = new StringBuilder();
      buf.append(""An exception occurred while sending email."");
      buf.append(
          ""Unable to send email. Please check your mail settings and the log file."");
      buf.append(""\n\n"").append(
          String.format(""Exception message: %s"", ex.getMessage()));
      buf.append(""\n\n"").append(
          ""Following email was not delivered:"");
      buf.append(""\n\t"")
          .append(String.format(""Mail Host: %s"", mailHost));
      buf.append(""\n\t"").append(String.format(""From: %s"", mailFrom));
      buf.append(""\n\t"").append(String.format(""To: %s"", mailToList));
      buf.append(""\n\t"").append(String.format(""Subject: %s"", subject));
      buf.append(""\n\t"").append(String.format(""Content: %s"", message));

      logger.error(buf.toString(), ex);
    }
    if (logger.isTraceEnabled()) {
      logger.trace(""Exited MailManager:processEmail"");
    }
  }
",feature envy
1034,"    static class HttpsTokenInInterceptor extends AbstractPhaseInterceptor<Message> {
        HttpsTokenInInterceptor() {
            super(Phase.PRE_STREAM);
            addBefore(WSS4JStaxInInterceptor.class.getName());
        }

        public void handleMessage(Message message) throws Fault {
            AssertionInfoMap aim = message.get(AssertionInfoMap.class);
            // extract Assertion information
            if (aim != null) {
                Collection<AssertionInfo> ais =
                    PolicyUtils.getAllAssertionsByLocalname(aim, SPConstants.HTTPS_TOKEN);
                boolean requestor = isRequestor(message);
                if (ais.isEmpty()) {
                    if (!requestor) {
                        try {
                            assertNonHttpsTransportToken(message);
                        } catch (XMLSecurityException e) {
                            LOG.fine(e.getMessage());
                        }
                    }
                    return;
                }
                if (!requestor) {
                    try {
                        assertHttps(aim, ais, message);
                    } catch (XMLSecurityException e) {
                        LOG.fine(e.getMessage());
                    }
                    // Store the TLS principal on the message context
                    SecurityContext sc = message.get(SecurityContext.class);
                    if (sc == null || sc.getUserPrincipal() == null) {
                        TLSSessionInfo tlsInfo = message.get(TLSSessionInfo.class);
                        if (tlsInfo != null && tlsInfo.getPeerCertificates() != null
                                && tlsInfo.getPeerCertificates().length > 0
                                && (tlsInfo.getPeerCertificates()[0] instanceof X509Certificate)
                        ) {
                            X509Certificate cert = (X509Certificate)tlsInfo.getPeerCertificates()[0];
                            message.put(
                                SecurityContext.class, createSecurityContext(cert.getSubjectX500Principal())
                            );
                        }
                    }

                } else {
                    //client side should be checked on the way out
                    for (AssertionInfo ai : ais) {
                        ai.setAsserted(true);
                    }

                    PolicyUtils.assertPolicy(aim, SPConstants.HTTP_DIGEST_AUTHENTICATION);
                    PolicyUtils.assertPolicy(aim, SPConstants.HTTP_BASIC_AUTHENTICATION);
                    PolicyUtils.assertPolicy(aim, SPConstants.REQUIRE_CLIENT_CERTIFICATE);
                }
            }
        }

        private void assertHttps(
            AssertionInfoMap aim,
            Collection<AssertionInfo> ais,
            Message message
        ) throws XMLSecurityException {
            List<SecurityEvent> securityEvents = getSecurityEventList(message);
            AuthorizationPolicy policy = message.get(AuthorizationPolicy.class);

            for (AssertionInfo ai : ais) {
                boolean asserted = true;
                HttpsToken token = (HttpsToken)ai.getAssertion();

                HttpsTokenSecurityEvent httpsTokenSecurityEvent = new HttpsTokenSecurityEvent();

                Map<String, List<String>> headers = getProtocolHeaders(message);
                if (token.getAuthenticationType() == HttpsToken.AuthenticationType.HttpBasicAuthentication) {
                    List<String> auth = headers.get(""Authorization"");
                    if (auth == null || auth.isEmpty()
                        || !auth.get(0).startsWith(""Basic"")) {
                        asserted = false;
                    } else {
                        httpsTokenSecurityEvent.setAuthenticationType(
                            HttpsTokenSecurityEvent.AuthenticationType.HttpBasicAuthentication
                        );
                        HttpsSecurityTokenImpl httpsSecurityToken =
                            new HttpsSecurityTokenImpl(true, policy.getUserName());
                        httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
                        httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);
                        PolicyUtils.assertPolicy(aim,
                                                 new QName(token.getName().getNamespaceURI(),
                                                           SPConstants.HTTP_BASIC_AUTHENTICATION));
                    }
                }
                if (token.getAuthenticationType() == HttpsToken.AuthenticationType.HttpDigestAuthentication) {
                    List<String> auth = headers.get(""Authorization"");
                    if (auth == null || auth.isEmpty()
                        || !auth.get(0).startsWith(""Digest"")) {
                        asserted = false;
                    } else {
                        httpsTokenSecurityEvent.setAuthenticationType(
                            HttpsTokenSecurityEvent.AuthenticationType.HttpDigestAuthentication
                        );
                        HttpsSecurityTokenImpl httpsSecurityToken =
                            new HttpsSecurityTokenImpl(false, policy.getUserName());
                        httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
                        httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);
                        PolicyUtils.assertPolicy(aim,
                                                 new QName(token.getName().getNamespaceURI(),
                                                           SPConstants.HTTP_DIGEST_AUTHENTICATION));
                    }
                }

                TLSSessionInfo tlsInfo = message.get(TLSSessionInfo.class);
                if (tlsInfo != null) {
                    if (token.getAuthenticationType()
                        == HttpsToken.AuthenticationType.RequireClientCertificate) {
                        if (tlsInfo.getPeerCertificates() == null
                            || tlsInfo.getPeerCertificates().length == 0) {
                            asserted = false;
                        } else {
                            PolicyUtils.assertPolicy(aim,
                                                     new QName(token.getName().getNamespaceURI(),
                                                               SPConstants.REQUIRE_CLIENT_CERTIFICATE));
                        }
                    }

                    if (tlsInfo.getPeerCertificates() != null && tlsInfo.getPeerCertificates().length > 0) {
                        httpsTokenSecurityEvent.setAuthenticationType(
                            HttpsTokenSecurityEvent.AuthenticationType.HttpsClientCertificateAuthentication
                        );
                        HttpsSecurityTokenImpl httpsSecurityToken =
                            new HttpsSecurityTokenImpl((X509Certificate)tlsInfo.getPeerCertificates()[0]);
                        httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
                        httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);
                    } else if (httpsTokenSecurityEvent.getAuthenticationType() == null) {
                        httpsTokenSecurityEvent.setAuthenticationType(
                            HttpsTokenSecurityEvent.AuthenticationType.HttpsNoAuthentication
                        );
                        HttpsSecurityTokenImpl httpsSecurityToken = new HttpsSecurityTokenImpl();
                        httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
                        httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);
                    }
                } else {
                    asserted = false;
                }

                ai.setAsserted(asserted);

                if (asserted) {
                    securityEvents.add(httpsTokenSecurityEvent);
                }
            }
        }

        // We might have an IssuedToken TransportToken
        private void assertNonHttpsTransportToken(Message message) throws XMLSecurityException {
            TLSSessionInfo tlsInfo = message.get(TLSSessionInfo.class);
            if (tlsInfo != null) {
                HttpsTokenSecurityEvent httpsTokenSecurityEvent = new HttpsTokenSecurityEvent();
                if (tlsInfo.getPeerCertificates() != null && tlsInfo.getPeerCertificates().length > 0) {
                    httpsTokenSecurityEvent.setAuthenticationType(
                        HttpsTokenSecurityEvent.AuthenticationType.HttpsClientCertificateAuthentication
                    );
                    HttpsSecurityTokenImpl httpsSecurityToken =
                        new HttpsSecurityTokenImpl((X509Certificate)tlsInfo.getPeerCertificates()[0]);
                    httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
                    httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);
                } else if (httpsTokenSecurityEvent.getAuthenticationType() == null) {
                    httpsTokenSecurityEvent.setAuthenticationType(
                        HttpsTokenSecurityEvent.AuthenticationType.HttpsNoAuthentication
                    );
                    HttpsSecurityTokenImpl httpsSecurityToken = new HttpsSecurityTokenImpl();
                    httpsSecurityToken.addTokenUsage(WSSecurityTokenConstants.TOKENUSAGE_MAIN_SIGNATURE);
                    httpsTokenSecurityEvent.setSecurityToken(httpsSecurityToken);
                }
                List<SecurityEvent> securityEvents = getSecurityEventList(message);
                securityEvents.add(httpsTokenSecurityEvent);
            }
        }

        private List<SecurityEvent> getSecurityEventList(Message message) {
            @SuppressWarnings(""unchecked"")
            List<SecurityEvent> securityEvents =
                (List<SecurityEvent>) message.getExchange().get(SecurityEvent.class.getName() + "".out"");
            if (securityEvents == null) {
                securityEvents = new ArrayList<>();
                message.getExchange().put(SecurityEvent.class.getName() + "".out"", securityEvents);
            }

            return securityEvents;
        }

        private SecurityContext createSecurityContext(final Principal p) {
            return new SecurityContext() {
                public Principal getUserPrincipal() {
                    return p;
                }
                public boolean isUserInRole(String role) {
                    return false;
                }
            };
        }
    }
",blob
544,"  @XmlAccessorType(XmlAccessType.FIELD)
  @XmlType(name = """", propOrder = {""gateways""})
  public static class GatewayHub {

    @XmlElement(name = ""gateway"", namespace = ""http://geode.apache.org/schema/cache"")
    protected List<Gateway> gateways;
    @XmlAttribute(name = ""id"", required = true)
    protected String id;
    @XmlAttribute(name = ""bind-address"")
    protected String bindAddress;
    @XmlAttribute(name = ""maximum-time-between-pings"")
    protected String maximumTimeBetweenPings;
    @XmlAttribute(name = ""port"")
    protected String port;
    @XmlAttribute(name = ""socket-buffer-size"")
    protected String socketBufferSize;
    @XmlAttribute(name = ""startup-policy"")
    protected String startupPolicy;
    @XmlAttribute(name = ""manual-start"")
    protected Boolean manualStart;
    @XmlAttribute(name = ""max-connections"")
    protected BigInteger maxConnections;

    /**
     * Gets the value of the gateway property.
     *
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the gateway property.
     *
     * <p>
     * For example, to add a new item, do as follows:
     *
     * <pre>
     * getGateway().add(newItem);
     * </pre>
     *
     *
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link CacheConfig.GatewayHub.Gateway }
     *
     *
     */
    public List<Gateway> getGateway() {
      if (gateways == null) {
        gateways = new ArrayList<Gateway>();
      }
      return this.gateways;
    }

    /**
     * Gets the value of the id property.
     *
     * possible object is
     * {@link String }
     *
     */
    public String getId() {
      return id;
    }

    /**
     * Sets the value of the id property.
     *
     * allowed object is
     * {@link String }
     *
     */
    public void setId(String value) {
      this.id = value;
    }

    /**
     * Gets the value of the bindAddress property.
     *
     * possible object is
     * {@link String }
     *
     */
    public String getBindAddress() {
      return bindAddress;
    }

    /**
     * Sets the value of the bindAddress property.
     *
     * allowed object is
     * {@link String }
     *
     */
    public void setBindAddress(String value) {
      this.bindAddress = value;
    }

    /**
     * Gets the value of the maximumTimeBetweenPings property.
     *
     * possible object is
     * {@link String }
     *
     */
    public String getMaximumTimeBetweenPings() {
      return maximumTimeBetweenPings;
    }

    /**
     * Sets the value of the maximumTimeBetweenPings property.
     *
     * allowed object is
     * {@link String }
     *
     */
    public void setMaximumTimeBetweenPings(String value) {
      this.maximumTimeBetweenPings = value;
    }

    /**
     * Gets the value of the port property.
     *
     * possible object is
     * {@link String }
     *
     */
    public String getPort() {
      return port;
    }

    /**
     * Sets the value of the port property.
     *
     * allowed object is
     * {@link String }
     *
     */
    public void setPort(String value) {
      this.port = value;
    }

    /**
     * Gets the value of the socketBufferSize property.
     *
     * possible object is
     * {@link String }
     *
     */
    public String getSocketBufferSize() {
      return socketBufferSize;
    }

    /**
     * Sets the value of the socketBufferSize property.
     *
     * allowed object is
     * {@link String }
     *
     */
    public void setSocketBufferSize(String value) {
      this.socketBufferSize = value;
    }

    /**
     * Gets the value of the startupPolicy property.
     *
     * possible object is
     * {@link String }
     *
     */
    public String getStartupPolicy() {
      return startupPolicy;
    }

    /**
     * Sets the value of the startupPolicy property.
     *
     * allowed object is
     * {@link String }
     *
     */
    public void setStartupPolicy(String value) {
      this.startupPolicy = value;
    }

    /**
     * Gets the value of the manualStart property.
     *
     * possible object is
     * {@link Boolean }
     *
     */
    public Boolean isManualStart() {
      return manualStart;
    }

    /**
     * Sets the value of the manualStart property.
     *
     * allowed object is
     * {@link Boolean }
     *
     */
    public void setManualStart(Boolean value) {
      this.manualStart = value;
    }

    /**
     * Gets the value of the maxConnections property.
     *
     * possible object is
     * {@link BigInteger }
     *
     */
    public BigInteger getMaxConnections() {
      return maxConnections;
    }

    /**
     * Sets the value of the maxConnections property.
     *
     * allowed object is
     * {@link BigInteger }
     *
     */
    public void setMaxConnections(BigInteger value) {
      this.maxConnections = value;
    }


    /**
     * <p>
     * Java class for anonymous complex type.
     *
     * <p>
     * The following schema fragment specifies the expected content contained within this class.
     *
     * <pre>
     * &lt;complexType>
     *   &lt;complexContent>
     *     &lt;restriction base=""{http://www.w3.org/2001/XMLSchema}anyType"">
     *       &lt;sequence>
     *         &lt;choice>
     *           &lt;element name=""gateway-endpoint"" maxOccurs=""unbounded"">
     *             &lt;complexType>
     *               &lt;complexContent>
     *                 &lt;restriction base=""{http://www.w3.org/2001/XMLSchema}anyType"">
     *                   &lt;attribute name=""host"" use=""required"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
     *                   &lt;attribute name=""id"" use=""required"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
     *                   &lt;attribute name=""port"" use=""required"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
     *                 &lt;/restriction>
     *               &lt;/complexContent>
     *             &lt;/complexType>
     *           &lt;/element>
     *           &lt;element name=""gateway-listener"" maxOccurs=""unbounded"">
     *             &lt;complexType>
     *               &lt;complexContent>
     *                 &lt;restriction base=""{http://www.w3.org/2001/XMLSchema}anyType"">
     *                   &lt;sequence>
     *                     &lt;element name=""class-name"" type=""{http://geode.apache.org/schema/cache}class-name-type""/>
     *                     &lt;element name=""parameter"" type=""{http://geode.apache.org/schema/cache}parameter-type"" maxOccurs=""unbounded"" minOccurs=""0""/>
     *                   &lt;/sequence>
     *                 &lt;/restriction>
     *               &lt;/complexContent>
     *             &lt;/complexType>
     *           &lt;/element>
     *         &lt;/choice>
     *         &lt;element name=""gateway-queue"" minOccurs=""0"">
     *           &lt;complexType>
     *             &lt;complexContent>
     *               &lt;restriction base=""{http://www.w3.org/2001/XMLSchema}anyType"">
     *                 &lt;attribute name=""alert-threshold"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
     *                 &lt;attribute name=""batch-conflation"" type=""{http://www.w3.org/2001/XMLSchema}boolean"" />
     *                 &lt;attribute name=""batch-size"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
     *                 &lt;attribute name=""batch-time-interval"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
     *                 &lt;attribute name=""enable-persistence"" type=""{http://www.w3.org/2001/XMLSchema}boolean"" />
     *                 &lt;attribute name=""disk-store-name"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
     *                 &lt;attribute name=""roll-oplogs"" type=""{http://www.w3.org/2001/XMLSchema}boolean"" />
     *                 &lt;attribute name=""maximum-queue-memory"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
     *                 &lt;attribute name=""overflow-directory"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
     *               &lt;/restriction>
     *             &lt;/complexContent>
     *           &lt;/complexType>
     *         &lt;/element>
     *       &lt;/sequence>
     *       &lt;attribute name=""early-ack"" type=""{http://www.w3.org/2001/XMLSchema}boolean"" />
     *       &lt;attribute name=""id"" use=""required"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
     *       &lt;attribute name=""socket-buffer-size"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
     *       &lt;attribute name=""socket-read-timeout"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
     *       &lt;attribute name=""concurrency-level"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
     *       &lt;attribute name=""order-policy"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
     *     &lt;/restriction>
     *   &lt;/complexContent>
     * &lt;/complexType>
     * </pre>
     *
     *
     */
    @XmlAccessorType(XmlAccessType.FIELD)
    @XmlType(name = """", propOrder = {""gatewayEndpoints"", ""gatewayListeners"", ""gatewayQueue""})
    public static class Gateway {

      @XmlElement(name = ""gateway-endpoint"", namespace = ""http://geode.apache.org/schema/cache"")
      protected List<GatewayEndpoint> gatewayEndpoints;
      @XmlElement(name = ""gateway-listener"", namespace = ""http://geode.apache.org/schema/cache"")
      protected List<DeclarableType> gatewayListeners;
      @XmlElement(name = ""gateway-queue"", namespace = ""http://geode.apache.org/schema/cache"")
      protected CacheConfig.GatewayHub.Gateway.GatewayQueue gatewayQueue;
      @XmlAttribute(name = ""early-ack"")
      protected Boolean earlyAck;
      @XmlAttribute(name = ""id"", required = true)
      protected String id;
      @XmlAttribute(name = ""socket-buffer-size"")
      protected String socketBufferSize;
      @XmlAttribute(name = ""socket-read-timeout"")
      protected String socketReadTimeout;
      @XmlAttribute(name = ""concurrency-level"")
      protected String concurrencyLevel;
      @XmlAttribute(name = ""order-policy"")
      protected String orderPolicy;

      /**
       * Gets the value of the gatewayEndpoints property.
       *
       * <p>
       * This accessor method returns a reference to the live list,
       * not a snapshot. Therefore any modification you make to the
       * returned list will be present inside the JAXB object.
       * This is why there is not a <CODE>set</CODE> method for the gatewayEndpoints property.
       *
       * <p>
       * For example, to add a new item, do as follows:
       *
       * <pre>
       * getGatewayEndpoints().add(newItem);
       * </pre>
       *
       *
       * <p>
       * Objects of the following type(s) are allowed in the list
       * {@link CacheConfig.GatewayHub.Gateway.GatewayEndpoint }
       *
       *
       */
      public List<GatewayEndpoint> getGatewayEndpoints() {
        if (gatewayEndpoints == null) {
          gatewayEndpoints = new ArrayList<GatewayEndpoint>();
        }
        return this.gatewayEndpoints;
      }

      /**
       * Gets the value of the gatewayListeners property.
       *
       * <p>
       * This accessor method returns a reference to the live list,
       * not a snapshot. Therefore any modification you make to the
       * returned list will be present inside the JAXB object.
       * This is why there is not a <CODE>set</CODE> method for the gatewayListeners property.
       *
       * <p>
       * For example, to add a new item, do as follows:
       *
       * <pre>
       * getGatewayListeners().add(newItem);
       * </pre>
       *
       *
       * <p>
       * Objects of the following type(s) are allowed in the list
       * {@link DeclarableType }
       *
       *
       */
      public List<DeclarableType> getGatewayListeners() {
        if (gatewayListeners == null) {
          gatewayListeners = new ArrayList<DeclarableType>();
        }
        return this.gatewayListeners;
      }

      /**
       * Gets the value of the gatewayQueue property.
       *
       * possible object is
       * {@link CacheConfig.GatewayHub.Gateway.GatewayQueue }
       *
       */
      public CacheConfig.GatewayHub.Gateway.GatewayQueue getGatewayQueue() {
        return gatewayQueue;
      }

      /**
       * Sets the value of the gatewayQueue property.
       *
       * allowed object is
       * {@link CacheConfig.GatewayHub.Gateway.GatewayQueue }
       *
       */
      public void setGatewayQueue(CacheConfig.GatewayHub.Gateway.GatewayQueue value) {
        this.gatewayQueue = value;
      }

      /**
       * Gets the value of the earlyAck property.
       *
       * possible object is
       * {@link Boolean }
       *
       */
      public Boolean isEarlyAck() {
        return earlyAck;
      }

      /**
       * Sets the value of the earlyAck property.
       *
       * allowed object is
       * {@link Boolean }
       *
       */
      public void setEarlyAck(Boolean value) {
        this.earlyAck = value;
      }

      /**
       * Gets the value of the id property.
       *
       * possible object is
       * {@link String }
       *
       */
      public String getId() {
        return id;
      }

      /**
       * Sets the value of the id property.
       *
       * allowed object is
       * {@link String }
       *
       */
      public void setId(String value) {
        this.id = value;
      }

      /**
       * Gets the value of the socketBufferSize property.
       *
       * possible object is
       * {@link String }
       *
       */
      public String getSocketBufferSize() {
        return socketBufferSize;
      }

      /**
       * Sets the value of the socketBufferSize property.
       *
       * allowed object is
       * {@link String }
       *
       */
      public void setSocketBufferSize(String value) {
        this.socketBufferSize = value;
      }

      /**
       * Gets the value of the socketReadTimeout property.
       *
       * possible object is
       * {@link String }
       *
       */
      public String getSocketReadTimeout() {
        return socketReadTimeout;
      }

      /**
       * Sets the value of the socketReadTimeout property.
       *
       * allowed object is
       * {@link String }
       *
       */
      public void setSocketReadTimeout(String value) {
        this.socketReadTimeout = value;
      }

      /**
       * Gets the value of the concurrencyLevel property.
       *
       * possible object is
       * {@link String }
       *
       */
      public String getConcurrencyLevel() {
        return concurrencyLevel;
      }

      /**
       * Sets the value of the concurrencyLevel property.
       *
       * allowed object is
       * {@link String }
       *
       */
      public void setConcurrencyLevel(String value) {
        this.concurrencyLevel = value;
      }

      /**
       * Gets the value of the orderPolicy property.
       *
       * possible object is
       * {@link String }
       *
       */
      public String getOrderPolicy() {
        return orderPolicy;
      }

      /**
       * Sets the value of the orderPolicy property.
       *
       * allowed object is
       * {@link String }
       *
       */
      public void setOrderPolicy(String value) {
        this.orderPolicy = value;
      }


      /**
       * <p>
       * Java class for anonymous complex type.
       *
       * <p>
       * The following schema fragment specifies the expected content contained within this class.
       *
       * <pre>
       * &lt;complexType>
       *   &lt;complexContent>
       *     &lt;restriction base=""{http://www.w3.org/2001/XMLSchema}anyType"">
       *       &lt;attribute name=""host"" use=""required"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
       *       &lt;attribute name=""id"" use=""required"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
       *       &lt;attribute name=""port"" use=""required"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
       *     &lt;/restriction>
       *   &lt;/complexContent>
       * &lt;/complexType>
       * </pre>
       *
       *
       */
      @XmlAccessorType(XmlAccessType.FIELD)
      @XmlType(name = """")
      public static class GatewayEndpoint {

        @XmlAttribute(name = ""host"", required = true)
        protected String host;
        @XmlAttribute(name = ""id"", required = true)
        protected String id;
        @XmlAttribute(name = ""port"", required = true)
        protected String port;

        /**
         * Gets the value of the host property.
         *
         * possible object is
         * {@link String }
         *
         */
        public String getHost() {
          return host;
        }

        /**
         * Sets the value of the host property.
         *
         * allowed object is
         * {@link String }
         *
         */
        public void setHost(String value) {
          this.host = value;
        }

        /**
         * Gets the value of the id property.
         *
         * possible object is
         * {@link String }
         *
         */
        public String getId() {
          return id;
        }

        /**
         * Sets the value of the id property.
         *
         * allowed object is
         * {@link String }
         *
         */
        public void setId(String value) {
          this.id = value;
        }

        /**
         * Gets the value of the port property.
         *
         * possible object is
         * {@link String }
         *
         */
        public String getPort() {
          return port;
        }

        /**
         * Sets the value of the port property.
         *
         * allowed object is
         * {@link String }
         *
         */
        public void setPort(String value) {
          this.port = value;
        }

      }

      /**
       * <p>
       * Java class for anonymous complex type.
       *
       * <p>
       * The following schema fragment specifies the expected content contained within this class.
       *
       * <pre>
       * &lt;complexType>
       *   &lt;complexContent>
       *     &lt;restriction base=""{http://www.w3.org/2001/XMLSchema}anyType"">
       *       &lt;attribute name=""alert-threshold"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
       *       &lt;attribute name=""batch-conflation"" type=""{http://www.w3.org/2001/XMLSchema}boolean"" />
       *       &lt;attribute name=""batch-size"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
       *       &lt;attribute name=""batch-time-interval"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
       *       &lt;attribute name=""enable-persistence"" type=""{http://www.w3.org/2001/XMLSchema}boolean"" />
       *       &lt;attribute name=""disk-store-name"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
       *       &lt;attribute name=""roll-oplogs"" type=""{http://www.w3.org/2001/XMLSchema}boolean"" />
       *       &lt;attribute name=""maximum-queue-memory"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
       *       &lt;attribute name=""overflow-directory"" type=""{http://www.w3.org/2001/XMLSchema}string"" />
       *     &lt;/restriction>
       *   &lt;/complexContent>
       * &lt;/complexType>
       * </pre>
       *
       *
       */
      @XmlAccessorType(XmlAccessType.FIELD)
      @XmlType(name = """")
      public static class GatewayQueue {

        @XmlAttribute(name = ""alert-threshold"")
        protected String alertThreshold;
        @XmlAttribute(name = ""batch-conflation"")
        protected Boolean batchConflation;
        @XmlAttribute(name = ""batch-size"")
        protected String batchSize;
        @XmlAttribute(name = ""batch-time-interval"")
        protected String batchTimeInterval;
        @XmlAttribute(name = ""enable-persistence"")
        protected Boolean enablePersistence;
        @XmlAttribute(name = ""disk-store-name"")
        protected String diskStoreName;
        @XmlAttribute(name = ""roll-oplogs"")
        protected Boolean rollOplogs;
        @XmlAttribute(name = ""maximum-queue-memory"")
        protected String maximumQueueMemory;
        @XmlAttribute(name = ""overflow-directory"")
        protected String overflowDirectory;

        /**
         * Gets the value of the alertThreshold property.
         *
         * possible object is
         * {@link String }
         *
         */
        public String getAlertThreshold() {
          return alertThreshold;
        }

        /**
         * Sets the value of the alertThreshold property.
         *
         * allowed object is
         * {@link String }
         *
         */
        public void setAlertThreshold(String value) {
          this.alertThreshold = value;
        }

        /**
         * Gets the value of the batchConflation property.
         *
         * possible object is
         * {@link Boolean }
         *
         */
        public Boolean isBatchConflation() {
          return batchConflation;
        }

        /**
         * Sets the value of the batchConflation property.
         *
         * allowed object is
         * {@link Boolean }
         *
         */
        public void setBatchConflation(Boolean value) {
          this.batchConflation = value;
        }

        /**
         * Gets the value of the batchSize property.
         *
         * possible object is
         * {@link String }
         *
         */
        public String getBatchSize() {
          return batchSize;
        }

        /**
         * Sets the value of the batchSize property.
         *
         * allowed object is
         * {@link String }
         *
         */
        public void setBatchSize(String value) {
          this.batchSize = value;
        }

        /**
         * Gets the value of the batchTimeInterval property.
         *
         * possible object is
         * {@link String }
         *
         */
        public String getBatchTimeInterval() {
          return batchTimeInterval;
        }

        /**
         * Sets the value of the batchTimeInterval property.
         *
         * allowed object is
         * {@link String }
         *
         */
        public void setBatchTimeInterval(String value) {
          this.batchTimeInterval = value;
        }

        /**
         * Gets the value of the enablePersistence property.
         *
         * possible object is
         * {@link Boolean }
         *
         */
        public Boolean isEnablePersistence() {
          return enablePersistence;
        }

        /**
         * Sets the value of the enablePersistence property.
         *
         * allowed object is
         * {@link Boolean }
         *
         */
        public void setEnablePersistence(Boolean value) {
          this.enablePersistence = value;
        }

        /**
         * Gets the value of the diskStoreName property.
         *
         * possible object is
         * {@link String }
         *
         */
        public String getDiskStoreName() {
          return diskStoreName;
        }

        /**
         * Sets the value of the diskStoreName property.
         *
         * allowed object is
         * {@link String }
         *
         */
        public void setDiskStoreName(String value) {
          this.diskStoreName = value;
        }

        /**
         * Gets the value of the rollOplogs property.
         *
         * possible object is
         * {@link Boolean }
         *
         */
        public Boolean isRollOplogs() {
          return rollOplogs;
        }

        /**
         * Sets the value of the rollOplogs property.
         *
         * allowed object is
         * {@link Boolean }
         *
         */
        public void setRollOplogs(Boolean value) {
          this.rollOplogs = value;
        }

        /**
         * Gets the value of the maximumQueueMemory property.
         *
         * possible object is
         * {@link String }
         *
         */
        public String getMaximumQueueMemory() {
          return maximumQueueMemory;
        }

        /**
         * Sets the value of the maximumQueueMemory property.
         *
         * allowed object is
         * {@link String }
         *
         */
        public void setMaximumQueueMemory(String value) {
          this.maximumQueueMemory = value;
        }

        /**
         * Gets the value of the overflowDirectory property.
         *
         * possible object is
         * {@link String }
         *
         */
        public String getOverflowDirectory() {
          return overflowDirectory;
        }

        /**
         * Sets the value of the overflowDirectory property.
         *
         * allowed object is
         * {@link String }
         *
         */
        public void setOverflowDirectory(String value) {
          this.overflowDirectory = value;
        }

      }

    }

  }
",data class
182,"    public final static class Builder<A> {

        private Supplier<A> initialValue;
        private UnaryOperator<A> splitOperator = null;
        private BinaryOperator<A> mergeOperator = null;

        private Builder() {
        }

        public Builder initialValue(final Supplier<A> initialValue) {
            this.initialValue = initialValue;
            return this;
        }

        public Builder splitOperator(final UnaryOperator<A> splitOperator) {
            this.splitOperator = splitOperator;
            return this;
        }

        public Builder mergeOperator(final BinaryOperator<A> mergeOperator) {
            this.mergeOperator = mergeOperator;
            return this;
        }

        public SackStrategy create() {
            return new SackStrategy(this.initialValue, this.splitOperator, this.mergeOperator);
        }
    }
",data class
412,"public class MemoryConsumptionTestClient
{
    private static final Logger LOGGER = LoggerFactory.getLogger(MemoryConsumptionTestClient.class);

    private static final String RESULTS_FILE_ARG = ""resultsFile"";

    private static final String JNDI_PROPERTIES_ARG = ""jndiProperties"";
    private static final String JNDI_CONNECTION_FACTORY_ARG = ""jndiConnectionFactory"";
    private static final String JNDI_DESTINATION_ARG = ""jndiDestination"";

    private static final String CONNECTIONS_ARG = ""connections"";
    private static final String SESSIONS_ARG = ""sessions"";
    private static final String PRODUCERS_ARG = ""producers"";
    private static final String MESSAGE_COUNT_ARG = ""messagecount"";
    private static final String MESSAGE_SIZE_ARG = ""size"";
    private static final String PERSISTENT_ARG = ""persistent"";
    private static final String TIMEOUT_ARG = ""timeout"";
    private static final String TRANSACTED_ARG = ""transacted"";
    private static final String JMX_HOST_ARG = ""jmxhost"";
    private static final String JMX_PORT_ARG = ""jmxport"";
    private static final String JMX_USER_ARG = ""jmxuser"";
    private static final String JMX_USER_PASSWORD_ARG = ""jmxpassword"";

    private static final String RESULTS_FILE_DEFAULT = ""results.csv"";
    private static final String JNDI_PROPERTIES_DEFAULT = ""stress-test-client-qpid-jms-client-0-x.properties"";
    private static final String JNDI_CONNECTION_FACTORY_DEFAULT = ""qpidConnectionFactory"";
    private static final String JNDI_DESTINATION_DEFAULT = ""stressTestQueue"";
    private static final String CONNECTIONS_DEFAULT = ""1"";
    private static final String SESSIONS_DEFAULT = ""1"";
    private static final String PRODUCERS_DEFAULT = ""1"";
    private static final String MESSAGE_COUNT_DEFAULT = ""1"";
    private static final String MESSAGE_SIZE_DEFAULT = ""256"";
    private static final String PERSISTENT_DEFAULT = ""false"";
    private static final String TIMEOUT_DEFAULT = ""1000"";
    private static final String TRANSACTED_DEFAULT = ""false"";

    private static final String JMX_HOST_DEFAULT = ""localhost"";
    private static final String JMX_PORT_DEFAULT = ""8999"";
    private static final String JMX_GARBAGE_COLLECTOR_MBEAN = ""gc"";

    public static void main(String[] args) throws Exception
    {
        Map<String,String> options = new HashMap<>();
        options.put(RESULTS_FILE_ARG, RESULTS_FILE_DEFAULT);
        options.put(JNDI_PROPERTIES_ARG, JNDI_PROPERTIES_DEFAULT);
        options.put(JNDI_CONNECTION_FACTORY_ARG, JNDI_CONNECTION_FACTORY_DEFAULT);
        options.put(JNDI_DESTINATION_ARG, JNDI_DESTINATION_DEFAULT);
        options.put(CONNECTIONS_ARG, CONNECTIONS_DEFAULT);
        options.put(SESSIONS_ARG, SESSIONS_DEFAULT);
        options.put(PRODUCERS_ARG, PRODUCERS_DEFAULT);
        options.put(MESSAGE_COUNT_ARG, MESSAGE_COUNT_DEFAULT);
        options.put(MESSAGE_SIZE_ARG, MESSAGE_SIZE_DEFAULT);
        options.put(PERSISTENT_ARG, PERSISTENT_DEFAULT);
        options.put(TIMEOUT_ARG, TIMEOUT_DEFAULT);
        options.put(TRANSACTED_ARG, TRANSACTED_DEFAULT);
        options.put(JMX_HOST_ARG, JMX_HOST_DEFAULT);
        options.put(JMX_PORT_ARG, JMX_PORT_DEFAULT);
        options.put(JMX_USER_ARG, """");
        options.put(JMX_USER_PASSWORD_ARG, """");
        options.put(JMX_GARBAGE_COLLECTOR_MBEAN, ""java.lang:type=GarbageCollector,name=ConcurrentMarkSweep"");

        if(args.length == 1 &&
                (args[0].equals(""-h"") || args[0].equals(""--help"") || args[0].equals(""help"")))
        {
            System.out.println(""arg=value options: \n"" + options.keySet());
            return;
        }

        parseArgumentsIntoConfig(options, args);

        MemoryConsumptionTestClient testClient = new MemoryConsumptionTestClient();
        testClient.runTest(options);
    }

    private static void parseArgumentsIntoConfig(Map<String, String> initialValues, String[] args)
    {
        for(String arg: args)
        {
            int equalPos = arg.indexOf('=');
            if(equalPos == -1)
            {
                throw new IllegalArgumentException(""arguments must have format <name>=<value>: "" + arg);
            }

            if(initialValues.put(arg.substring(0, equalPos), arg.substring(equalPos + 1)) == null)
            {
                throw new IllegalArgumentException(""not a valid configuration property: "" + arg);
            }
        }
    }


    private void runTest(Map<String,String> options) throws Exception
    {
        String resultsFile = options.get(RESULTS_FILE_ARG);
        String jndiProperties = options.get(JNDI_PROPERTIES_ARG);
        String connectionFactoryString = options.get(JNDI_CONNECTION_FACTORY_ARG);
        int numConnections = Integer.parseInt(options.get(CONNECTIONS_ARG));
        int numSessions = Integer.parseInt(options.get(SESSIONS_ARG));
        int numProducers = Integer.parseInt(options.get(PRODUCERS_ARG));
        int numMessage = Integer.parseInt(options.get(MESSAGE_COUNT_ARG));
        int messageSize = Integer.parseInt(options.get(MESSAGE_SIZE_ARG));
        String queueString = options.get(JNDI_DESTINATION_ARG);
        int deliveryMode = Boolean.valueOf(options.get(PERSISTENT_ARG)) ? DeliveryMode.PERSISTENT : DeliveryMode.NON_PERSISTENT;
        long receiveTimeout = Long.parseLong(options.get(TIMEOUT_ARG));
        boolean transacted = Boolean.valueOf(options.get(TRANSACTED_ARG));

        LOGGER.info(""Using options: "" + options);


        // Load JNDI properties
        Context ctx = getInitialContext(jndiProperties);
        final ConnectionFactory conFac = (ConnectionFactory) ctx.lookup(connectionFactoryString);

        Destination destination = ensureQueueCreated(queueString, conFac);
        Map<Connection, List<Session>> connectionsAndSessions = openConnectionsAndSessions(numConnections, numSessions, transacted, conFac);
        publish(numMessage, messageSize, numProducers, deliveryMode, destination, connectionsAndSessions);
        MemoryStatistic memoryStatistics = collectMemoryStatistics(options);
        generateCSV(memoryStatistics, numConnections, numSessions, transacted, numMessage, messageSize, numProducers, deliveryMode, resultsFile);
        purgeQueue(conFac, queueString, receiveTimeout);
        closeConnections(connectionsAndSessions.keySet());
        System.exit(0);
    }

    private void generateCSV(MemoryStatistic memoryStatistics,
                             int numConnections,
                             int numSessions,
                             boolean transacted,
                             int numMessage,
                             int messageSize,
                             int numProducers,
                             int deliveryMode,
                             final String resultsFile) throws IOException
    {
        try (FileWriter writer = new FileWriter(resultsFile))
        {
            writer.write(memoryStatistics.getHeapUsage()
                         + "",""
                         + memoryStatistics.getDirectMemoryUsage()
                         + "",""
                         + numConnections
                         + "",""
                         + numSessions
                         + "",""
                         + numProducers
                         + "",""
                         + transacted
                         + "",""
                         + numMessage
                         + "",""
                         + messageSize
                         + "",""
                         + deliveryMode
                         + "",""
                         + toUserFriendlyName(memoryStatistics.getHeapUsage())
                         + "",""
                         + toUserFriendlyName(memoryStatistics.getDirectMemoryUsage())
                         + System.lineSeparator());
        }
    }

    private void publish(int numberOfMessages, int messageSize, int numberOfProducers, int deliveryMode,
                         Destination destination, Map<Connection, List<Session>> connectionsAndSessions) throws JMSException
    {
        byte[] messageBytes = generateMessage(messageSize);
        for (List<Session> sessions : connectionsAndSessions.values())
        {
            for (Session session: sessions)
            {
                BytesMessage message = session.createBytesMessage();

                if (messageSize > 0)
                {
                    message.writeBytes(messageBytes);
                }

                for(int i = 0; i < numberOfProducers ; i++)
                {
                    MessageProducer prod = session.createProducer(destination);
                    for(int j = 0; j < numberOfMessages ; j++)
                    {
                        prod.send(message, deliveryMode, Message.DEFAULT_PRIORITY, Message.DEFAULT_TIME_TO_LIVE);
                        if(session.getTransacted())
                        {
                            session.commit();
                        }
                    }
                }
            }
        }
    }

    private Map<Connection, List<Session>> openConnectionsAndSessions(int numConnections, int numSessions, boolean transacted, ConnectionFactory conFac) throws JMSException
    {
        Map<Connection, List<Session>> connectionAndSessions = new HashMap<>();
        for (int i= 0; i < numConnections ; i++)
        {
            Connection connection = conFac.createConnection();
            connection.setExceptionListener(jmse -> {
                LOGGER.error(""The sample received an exception through the ExceptionListener"", jmse);
                System.exit(1);
            });

            List<Session> sessions = new ArrayList<>();
            connectionAndSessions.put(connection, sessions);
            connection.start();
            for (int s= 0; s < numSessions ; s++)
            {
                Session session = connection.createSession(transacted, transacted?Session.SESSION_TRANSACTED:Session.AUTO_ACKNOWLEDGE);
                sessions.add(session);
            }
        }
        return connectionAndSessions;
    }

    private Context getInitialContext(final String jndiProperties) throws IOException, NamingException
    {
        Properties properties = new Properties();
        try(InputStream is = this.getClass().getClassLoader().getResourceAsStream(jndiProperties))
        {
            if (is != null)
            {
                properties.load(is);
                return new InitialContext(properties);
            }
        }

        System.out.printf(MemoryConsumptionTestClient.class.getSimpleName() + "": Failed to find '%s' on classpath, using fallback\n"", jndiProperties);
        return new InitialContext();
    }

    private Destination ensureQueueCreated(String queueURL, ConnectionFactory connectionFactory) throws JMSException
    {
        Connection connection = connectionFactory.createConnection();
        Destination destination;
        try
        {
            Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
            destination = session.createQueue(queueURL);
            MessageConsumer consumer = session.createConsumer(destination);
            consumer.close();
            session.close();
        }
        finally
        {
            connection.close();
        }
        return destination;
    }

    private void closeConnections(Collection<Connection> connections) throws JMSException, NamingException
    {
        for (Connection c: connections)
        {
            c.close();
        }
    }

    private void purgeQueue(ConnectionFactory connectionFactory, String queueString, long receiveTimeout) throws JMSException
    {
        LOGGER.debug(""Consuming left over messages, using receive timeout:"" + receiveTimeout);

        Connection connection = connectionFactory.createConnection();
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        Destination destination = session.createQueue(queueString);
        MessageConsumer consumer = session.createConsumer(destination);
        connection.start();

        int count = 0;
        while (true)
        {
            BytesMessage msg = (BytesMessage) consumer.receive(receiveTimeout);

            if(msg == null)
            {
                LOGGER.debug(""Received {} message(s)"", count);
                break;
            }
            else
            {
                count++;
            }
        }

        consumer.close();
        session.close();
        connection.close();
    }

    private MemoryStatistic collectMemoryStatistics(Map<String, String> options) throws Exception
    {
        String host = options.get(JMX_HOST_ARG);
        String port = options.get(JMX_PORT_ARG);
        String user = options.get(JMX_USER_ARG);
        String password = options.get(JMX_USER_PASSWORD_ARG);

        if (!"""".equals(host) && !"""".equals(port) && !"""".equals(user) && !"""".equals(password))
        {
            Map<String, Object> environment = Collections.<String, Object>singletonMap(JMXConnector.CREDENTIALS, new String[]{user, password});

            try(JMXConnector jmxConnector = JMXConnectorFactory.newJMXConnector(new JMXServiceURL(""rmi"", """", 0, ""/jndi/rmi://"" + host + "":"" + port + ""/jmxrmi""), environment))
            {
                jmxConnector.connect();
                final MBeanServerConnection mBeanServerConnection = jmxConnector.getMBeanServerConnection();
                final ObjectName memoryMBean = new ObjectName(""java.lang:type=Memory"");
                String gcCollectorMBeanName = options.get(JMX_GARBAGE_COLLECTOR_MBEAN);
                if (gcCollectorMBeanName.equals(""""))
                {
                    mBeanServerConnection.invoke(memoryMBean, ""gc"", null, null);
                    MemoryStatistic memoryStatistics = new MemoryStatistic();
                    collectMemoryStatistics(memoryStatistics, mBeanServerConnection, memoryMBean);
                    return memoryStatistics;
                }
                else
                {
                    ObjectName gcMBean = new ObjectName(gcCollectorMBeanName);
                    if (mBeanServerConnection.isRegistered(gcMBean))
                    {
                        return collectMemoryStatisticsAfterGCNotification(mBeanServerConnection, gcMBean);
                    }
                    else
                    {
                        Set<ObjectName> existingGCs = mBeanServerConnection.queryNames(new ObjectName(""java.lang:type=GarbageCollector,name=*""), null);
                        throw new IllegalArgumentException(""MBean '"" +gcCollectorMBeanName + ""' does not exists! Registered GC MBeans :"" + existingGCs);
                    }
                }
            }
        }
        return null;
    }

    private MemoryStatistic collectMemoryStatisticsAfterGCNotification(final MBeanServerConnection mBeanServerConnection, ObjectName gcMBean)
            throws MalformedObjectNameException, IOException, InstanceNotFoundException, ReflectionException, MBeanException, InterruptedException
    {
        final MemoryStatistic memoryStatistics = new MemoryStatistic();
        final CountDownLatch notificationReceived = new CountDownLatch(1);
        final ObjectName memoryMBean = new ObjectName(""java.lang:type=Memory"");
        mBeanServerConnection.addNotificationListener(gcMBean, (notification, handback) -> {
            if (notification.getType().equals(""com.sun.management.gc.notification""))
            {
                CompositeData userData = (CompositeData) notification.getUserData();
                try
                {
                    Object gcAction = userData.get(""gcAction"");
                    Object gcCause = userData.get(""gcCause"");
                    if (""System.gc()"".equals(gcCause) && String.valueOf(gcAction).contains(""end of major GC""))
                    {
                        try
                        {
                            collectMemoryStatistics(memoryStatistics, mBeanServerConnection, memoryMBean);
                        }
                        finally
                        {
                            notificationReceived.countDown();
                        }

                    }
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                    notificationReceived.countDown();
                }
            }
        }, null, null);

        mBeanServerConnection.invoke(memoryMBean, ""gc"", null, null);
        if (!notificationReceived.await(5, TimeUnit.SECONDS))
        {
            throw new RuntimeException(""GC notification was not sent in timely manner"");
        }
        return memoryStatistics;
    }

    private void collectMemoryStatistics(MemoryStatistic memoryStatistics, MBeanServerConnection mBeanServerConnection, ObjectName memoryMBean) throws MBeanException, AttributeNotFoundException, InstanceNotFoundException, ReflectionException, IOException, MalformedObjectNameException
    {
        Object heapMemoryUsage = mBeanServerConnection.getAttribute(memoryMBean, ""HeapMemoryUsage"");
        Object used = ((CompositeData) heapMemoryUsage).get(""used"");
        Object directMemoryTotalCapacity = mBeanServerConnection.getAttribute(new ObjectName(""java.nio:type=BufferPool,name=direct""), ""TotalCapacity"");
        memoryStatistics.setHeapUsage(Long.parseLong(String.valueOf(used)));
        memoryStatistics.setDirectMemoryUsage(Long.parseLong(String.valueOf(directMemoryTotalCapacity)));
    }

    private String toUserFriendlyName(Object intValue)
    {
        long value = Long.parseLong(String.valueOf(intValue));
        if (value <= 1024)
        {
            return String.valueOf(value) + ""B"";
        }
        else if (value <= 1024 * 1024)
        {
            return String.valueOf(value/1024) + ""kB"";
        }
        else if (value <= 1024L * 1024L * 1024L)
        {
            return String.valueOf(value/1024L/1024L) + ""MB"";
        }
        else
        {
            return String.valueOf(value/1024L/1024L/1024L) + ""GB"";
        }
    }


    private byte[] generateMessage(int messageSize)
    {
        byte[] sentBytes = new byte[messageSize];
        for(int r = 0 ; r < messageSize ; r++)
        {
            sentBytes[r] = (byte) (48 + (r % 10));
        }
        return sentBytes;
    }

    private class MemoryStatistic
    {
        private long heapUsage;
        private long directMemoryUsage;

        long getHeapUsage()
        {
            return heapUsage;
        }

        void setHeapUsage(long heapUsage)
        {
            this.heapUsage = heapUsage;
        }

        long getDirectMemoryUsage()
        {
            return directMemoryUsage;
        }

        void setDirectMemoryUsage(long directMemoryUsage)
        {
            this.directMemoryUsage = directMemoryUsage;
        }
    }
}
",blob
1295,,long method
271,"    @SuppressWarnings(""try"")
    private void doRun(Map<Method, CEntryPointData> entryPoints, Method mainEntryPoint,
                    JavaMainSupport javaMainSupport, String imageName, AbstractBootImage.NativeImageKind k,
                    SubstitutionProcessor harnessSubstitutions,
                    ForkJoinPool compilationExecutor, ForkJoinPool analysisExecutor) {
        List<HostedMethod> hostedEntryPoints = new ArrayList<>();

        OptionValues options = HostedOptionValues.singleton();
        SnippetReflectionProvider originalSnippetReflection = GraalAccess.getOriginalSnippetReflection();
        try (DebugContext debug = DebugContext.create(options, new GraalDebugHandlersFactory(originalSnippetReflection))) {
            setupNativeImage(imageName, options, entryPoints, javaMainSupport, harnessSubstitutions, analysisExecutor, originalSnippetReflection, debug);

            boolean returnAfterAnalysis = runPointsToAnalysis(imageName, options, debug);
            if (returnAfterAnalysis) {
                return;
            }

            NativeImageHeap heap;
            HostedMethod mainEntryPointHostedStub;
            HostedMetaAccess hMetaAccess;
            SharedRuntimeConfigurationBuilder runtime;
            try (StopTimer t = new Timer(imageName, ""universe"").start()) {
                hUniverse = new HostedUniverse(bigbang);
                hMetaAccess = new HostedMetaAccess(hUniverse, bigbang.getMetaAccess());

                new UniverseBuilder(aUniverse, bigbang.getMetaAccess(), hUniverse, hMetaAccess, HostedConfiguration.instance().createStaticAnalysisResultsBuilder(bigbang, hUniverse),
                                bigbang.getUnsupportedFeatures()).build(debug);

                runtime = new HostedRuntimeConfigurationBuilder(options, bigbang.getHostVM(), hUniverse, hMetaAccess, bigbang.getProviders()).build();
                registerGraphBuilderPlugins(featureHandler, runtime.getRuntimeConfig(), (HostedProviders) runtime.getRuntimeConfig().getProviders(), bigbang.getMetaAccess(), aUniverse,
                                hMetaAccess, hUniverse,
                                nativeLibraries, loader, false, true, bigbang.getAnnotationSubstitutionProcessor(), new SubstrateClassInitializationPlugin((SVMHost) aUniverse.hostVM()),
                                bigbang.getHostVM().getClassInitializationSupport());

                if (NativeImageOptions.PrintUniverse.getValue()) {
                    printTypes();
                }

                /* Find the entry point methods in the hosted world. */
                for (AnalysisMethod m : aUniverse.getMethods()) {
                    if (m.isEntryPoint()) {
                        HostedMethod found = hUniverse.lookup(m);
                        assert found != null;
                        hostedEntryPoints.add(found);
                    }
                }
                /* Find main entry point */
                if (mainEntryPoint != null) {
                    AnalysisMethod analysisStub = CEntryPointCallStubSupport.singleton().getStubForMethod(mainEntryPoint);
                    mainEntryPointHostedStub = (HostedMethod) hMetaAccess.getUniverse().lookup(analysisStub);
                    assert hostedEntryPoints.contains(mainEntryPointHostedStub);
                } else {
                    mainEntryPointHostedStub = null;
                }
                if (hostedEntryPoints.size() == 0) {
                    throw UserError.abort(""Warning: no entry points found, i.e., no method annotated with @"" + CEntryPoint.class.getSimpleName());
                }

                heap = new NativeImageHeap(aUniverse, hUniverse, hMetaAccess);

                BeforeCompilationAccessImpl config = new BeforeCompilationAccessImpl(featureHandler, loader, aUniverse, hUniverse, hMetaAccess, heap, debug);
                featureHandler.forEachFeature(feature -> feature.beforeCompilation(config));

                bigbang.getUnsupportedFeatures().report(bigbang);
            } catch (UnsupportedFeatureException ufe) {
                throw UserError.abort(ufe.getMessage());
            }

            recordMethodsWithStackValues();
            recordRestrictHeapAccessCallees(aUniverse.getMethods());

            /*
             * After this point, all TypeFlow (and therefore also TypeState) objects are unreachable
             * and can be garbage collected. This is important to keep the overall memory footprint
             * low. However, this also means we no longer have complete call chain information. Only
             * the summarized information stored in the StaticAnalysisResult objects is available
             * after this point.
             */
            bigbang.cleanupAfterAnalysis();

            NativeImageCodeCache codeCache;
            CompileQueue compileQueue;
            try (StopTimer t = new Timer(imageName, ""compile"").start()) {
                compileQueue = HostedConfiguration.instance().createCompileQueue(debug, featureHandler, hUniverse, runtime, DeoptTester.enabled(), bigbang.getProviders().getSnippetReflection(),
                                compilationExecutor);
                compileQueue.finish(debug);

                /* release memory taken by graphs for the image writing */
                hUniverse.getMethods().forEach(HostedMethod::clear);

                codeCache = NativeImageCodeCacheFactory.get().newCodeCache(compileQueue, heap);
                codeCache.layoutConstants();
                codeCache.layoutMethods(debug, imageName);

                AfterCompilationAccessImpl config = new AfterCompilationAccessImpl(featureHandler, loader, aUniverse, hUniverse, hMetaAccess, heap, debug);
                featureHandler.forEachFeature(feature -> feature.afterCompilation(config));
            }

            try (Indent indent = debug.logAndIndent(""create native image"")) {
                try (DebugContext.Scope buildScope = debug.scope(""CreateBootImage"")) {
                    try (StopTimer t = new Timer(imageName, ""image"").start()) {

                        // Start building the model of the native image heap.
                        heap.addInitialObjects();
                        // Then build the model of the code cache, which can
                        // add objects to the native image heap.
                        codeCache.addConstantsToHeap();
                        // Finish building the model of the native image heap.
                        heap.addTrailingObjects();

                        AfterHeapLayoutAccessImpl config = new AfterHeapLayoutAccessImpl(featureHandler, loader, hMetaAccess, debug);
                        featureHandler.forEachFeature(feature -> feature.afterHeapLayout(config));

                        this.image = AbstractBootImage.create(k, hUniverse, hMetaAccess, nativeLibraries, heap, codeCache, hostedEntryPoints, mainEntryPointHostedStub, loader.getClassLoader());
                        image.build(debug);
                        if (NativeImageOptions.PrintUniverse.getValue()) {
                            /*
                             * This debug output must be printed _after_ and not _during_ image
                             * building, because it adds some PrintStream objects to static fields,
                             * which disrupts the heap.
                             */
                            codeCache.printCompilationResults();
                        }
                    }
                }
            }

            BeforeImageWriteAccessImpl beforeConfig = new BeforeImageWriteAccessImpl(featureHandler, loader, imageName, image,
                            runtime.getRuntimeConfig(), aUniverse, hUniverse, optionProvider, hMetaAccess, debug);
            featureHandler.forEachFeature(feature -> feature.beforeImageWrite(beforeConfig));

            try (StopTimer t = new Timer(imageName, ""write"").start()) {
                /*
                 * This will write the debug info too -- i.e. we may be writing more than one file,
                 * if the debug info is in a separate file. We need to push writing the file to the
                 * image implementation, because whether the debug info and image share a file or
                 * not is an implementation detail of the image.
                 */
                Path tmpDir = tempDirectory();
                Path imagePath = image.write(debug, generatedFiles(HostedOptionValues.singleton()), tmpDir, imageName, beforeConfig).getOutputFile();

                AfterImageWriteAccessImpl afterConfig = new AfterImageWriteAccessImpl(featureHandler, loader, hUniverse, imagePath, tmpDir, image.getBootImageKind(), debug);
                featureHandler.forEachFeature(feature -> feature.afterImageWrite(afterConfig));
            }
        }
    }
",feature envy
558,"public class _Repository4Soap_QueryPendingSetsWithLocalWorkspaces
    implements ElementSerializable
{
    // No attributes    

    // Elements
    protected String localWorkspaceName;
    protected String localWorkspaceOwner;
    protected String queryWorkspaceName;
    protected String ownerName;
    protected _ItemSpec[] itemSpecs;
    protected boolean generateDownloadUrls;
    protected String[] itemPropertyFilters;

    public _Repository4Soap_QueryPendingSetsWithLocalWorkspaces()
    {
        super();
    }

    public _Repository4Soap_QueryPendingSetsWithLocalWorkspaces(
        final String localWorkspaceName,
        final String localWorkspaceOwner,
        final String queryWorkspaceName,
        final String ownerName,
        final _ItemSpec[] itemSpecs,
        final boolean generateDownloadUrls,
        final String[] itemPropertyFilters)
    {
        // TODO : Call super() instead of setting all fields directly?
        setLocalWorkspaceName(localWorkspaceName);
        setLocalWorkspaceOwner(localWorkspaceOwner);
        setQueryWorkspaceName(queryWorkspaceName);
        setOwnerName(ownerName);
        setItemSpecs(itemSpecs);
        setGenerateDownloadUrls(generateDownloadUrls);
        setItemPropertyFilters(itemPropertyFilters);
    }

    public String getLocalWorkspaceName()
    {
        return this.localWorkspaceName;
    }

    public void setLocalWorkspaceName(String value)
    {
        this.localWorkspaceName = value;
    }

    public String getLocalWorkspaceOwner()
    {
        return this.localWorkspaceOwner;
    }

    public void setLocalWorkspaceOwner(String value)
    {
        this.localWorkspaceOwner = value;
    }

    public String getQueryWorkspaceName()
    {
        return this.queryWorkspaceName;
    }

    public void setQueryWorkspaceName(String value)
    {
        this.queryWorkspaceName = value;
    }

    public String getOwnerName()
    {
        return this.ownerName;
    }

    public void setOwnerName(String value)
    {
        this.ownerName = value;
    }

    public _ItemSpec[] getItemSpecs()
    {
        return this.itemSpecs;
    }

    public void setItemSpecs(_ItemSpec[] value)
    {
        this.itemSpecs = value;
    }

    public boolean isGenerateDownloadUrls()
    {
        return this.generateDownloadUrls;
    }

    public void setGenerateDownloadUrls(boolean value)
    {
        this.generateDownloadUrls = value;
    }

    public String[] getItemPropertyFilters()
    {
        return this.itemPropertyFilters;
    }

    public void setItemPropertyFilters(String[] value)
    {
        this.itemPropertyFilters = value;
    }

    public void writeAsElement(
        final XMLStreamWriter writer,
        final String name)
        throws XMLStreamException
    {
        writer.writeStartElement(name);

        // Elements
        XMLStreamWriterHelper.writeElement(
            writer,
            ""localWorkspaceName"",
            this.localWorkspaceName);
        XMLStreamWriterHelper.writeElement(
            writer,
            ""localWorkspaceOwner"",
            this.localWorkspaceOwner);
        XMLStreamWriterHelper.writeElement(
            writer,
            ""queryWorkspaceName"",
            this.queryWorkspaceName);
        XMLStreamWriterHelper.writeElement(
            writer,
            ""ownerName"",
            this.ownerName);

        if (this.itemSpecs != null)
        {
            /*
             * The element type is an array.
             */
            writer.writeStartElement(""itemSpecs"");

            for (int iterator0 = 0; iterator0 < this.itemSpecs.length; iterator0++)
            {
                this.itemSpecs[iterator0].writeAsElement(
                    writer,
                    ""ItemSpec"");
            }

            writer.writeEndElement();
        }

        XMLStreamWriterHelper.writeElement(
            writer,
            ""generateDownloadUrls"",
            this.generateDownloadUrls);

        if (this.itemPropertyFilters != null)
        {
            /*
             * The element type is an array.
             */
            writer.writeStartElement(""itemPropertyFilters"");

            for (int iterator0 = 0; iterator0 < this.itemPropertyFilters.length; iterator0++)
            {
                XMLStreamWriterHelper.writeElement(
                    writer,
                    ""string"",
                    this.itemPropertyFilters[iterator0]);
            }

            writer.writeEndElement();
        }

        writer.writeEndElement();
    }
}
",data class
706,"    private class ClientSelectDeleteMutationPlan implements MutationPlan {
        private final StatementContext context;
        private final TableRef targetTableRef;
        private final QueryPlan dataPlan;
        private final QueryPlan bestPlan;
        private final boolean hasPreOrPostProcessing;
        private final DeletingParallelIteratorFactory parallelIteratorFactory;
        private final List<TableRef> otherTableRefs;
        private final TableRef projectedTableRef;
        private final int maxSize;
        private final int maxSizeBytes;
        private final PhoenixConnection connection;

        public ClientSelectDeleteMutationPlan(TableRef targetTableRef, QueryPlan dataPlan, QueryPlan bestPlan,
                                              boolean hasPreOrPostProcessing,
                                              DeletingParallelIteratorFactory parallelIteratorFactory,
                                              List<TableRef> otherTableRefs, TableRef projectedTableRef, int maxSize,
                                              int maxSizeBytes, PhoenixConnection connection) {
            this.context = bestPlan.getContext();
            this.targetTableRef = targetTableRef;
            this.dataPlan = dataPlan;
            this.bestPlan = bestPlan;
            this.hasPreOrPostProcessing = hasPreOrPostProcessing;
            this.parallelIteratorFactory = parallelIteratorFactory;
            this.otherTableRefs = otherTableRefs;
            this.projectedTableRef = projectedTableRef;
            this.maxSize = maxSize;
            this.maxSizeBytes = maxSizeBytes;
            this.connection = connection;
        }

        @Override
        public ParameterMetaData getParameterMetaData() {
            return context.getBindManager().getParameterMetaData();
        }

        @Override
        public StatementContext getContext() {
            return context;
        }

        @Override
        public TableRef getTargetRef() {
            return targetTableRef;
        }

        @Override
        public Set<TableRef> getSourceRefs() {
            return dataPlan.getSourceRefs();
        }

        @Override
        public Operation getOperation() {
          return operation;
        }

        @Override
        public MutationState execute() throws SQLException {
            ResultIterator iterator = bestPlan.iterator();
            try {
                // If we're not doing any pre or post processing, we can produce the delete mutations directly
                // in the parallel threads executed for the scan
                if (!hasPreOrPostProcessing) {
                    Tuple tuple;
                    long totalRowCount = 0;
                    if (parallelIteratorFactory != null) {
                        parallelIteratorFactory.setQueryPlan(bestPlan);
                        parallelIteratorFactory.setOtherTableRefs(otherTableRefs);
                        parallelIteratorFactory.setProjectedTableRef(projectedTableRef);
                    }
                    while ((tuple=iterator.next()) != null) {// Runs query
                        Cell kv = tuple.getValue(0);
                        totalRowCount += PLong.INSTANCE.getCodec().decodeLong(kv.getValueArray(), kv.getValueOffset(), SortOrder.getDefault());
                    }
                    // Return total number of rows that have been deleted from the table. In the case of auto commit being off
                    // the mutations will all be in the mutation state of the current connection. We need to divide by the
                    // total number of tables we updated as otherwise the client will get an inflated result.
                    int totalTablesUpdateClientSide = 1; // data table is always updated
                    PTable bestTable = bestPlan.getTableRef().getTable();
                    // global immutable tables are also updated client side (but don't double count the data table)
                    if (bestPlan != dataPlan && isMaintainedOnClient(bestTable)) {
                        totalTablesUpdateClientSide++;
                    }
                    for (TableRef otherTableRef : otherTableRefs) {
                        PTable otherTable = otherTableRef.getTable();
                        // Don't double count the data table here (which morphs when it becomes a projected table, hence this check)
                        if (projectedTableRef != otherTableRef && isMaintainedOnClient(otherTable)) {
                            totalTablesUpdateClientSide++;
                        }
                    }
                    MutationState state = new MutationState(maxSize, maxSizeBytes, connection, totalRowCount/totalTablesUpdateClientSide);

                    // set the read metrics accumulated in the parent context so that it can be published when the mutations are committed.
                    state.setReadMetricQueue(context.getReadMetricsQueue());

                    return state;
                } else {
                    // Otherwise, we have to execute the query and produce the delete mutations in the single thread
                    // producing the query results.
                    return deleteRows(context, iterator, bestPlan, projectedTableRef, otherTableRefs);
                }
            } finally {
                iterator.close();
            }
        }

        @Override
        public ExplainPlan getExplainPlan() throws SQLException {
            List<String> queryPlanSteps =  bestPlan.getExplainPlan().getPlanSteps();
            List<String> planSteps = Lists.newArrayListWithExpectedSize(queryPlanSteps.size()+1);
            planSteps.add(""DELETE ROWS"");
            planSteps.addAll(queryPlanSteps);
            return new ExplainPlan(planSteps);
        }

        @Override
        public Long getEstimatedRowsToScan() throws SQLException {
            return bestPlan.getEstimatedRowsToScan();
        }

        @Override
        public Long getEstimatedBytesToScan() throws SQLException {
            return bestPlan.getEstimatedBytesToScan();
        }

        @Override
        public Long getEstimateInfoTimestamp() throws SQLException {
            return bestPlan.getEstimateInfoTimestamp();
        }

        @Override
        public QueryPlan getQueryPlan() {
            return bestPlan;
        }
    }
",data class
370,"  public static class Statement extends RoleElt {

    @JsonProperty(""Sid"")
    public String sid = newSid();

    /**
     * Default effect is Deny; forces callers to switch on Allow.
     */
    @JsonProperty(""Effect"")
    public Effects effect;

    @JsonProperty(""Action"")
    public List<String> action = new ArrayList<>(1);

    @JsonProperty(""Resource"")
    public List<String> resource = new ArrayList<>(1);

    public Statement(final Effects effect) {
      this.effect = effect;
    }

    @Override
    public void validate() {
      requireNonNull(sid, ""Sid"");
      requireNonNull(effect, ""Effect"");
      checkState(!(action.isEmpty()), ""Empty Action"");
      checkState(!(resource.isEmpty()), ""Empty Resource"");
    }

    public Statement setAllowed(boolean f) {
      effect = effect(f);
      return this;
    }

    public Statement addActions(String... actions) {
      Collections.addAll(action, actions);
      return this;
    }

    public Statement addActions(Collection<String> actions) {
      action.addAll(actions);
      return this;
    }

    public Statement addResources(String... resources) {
      Collections.addAll(resource, resources);
      return this;
    }

    /**
     * Add a list of resources.
     * @param resources resource list
     * @return this statement.
     */
    public Statement addResources(Collection<String> resources) {
      resource.addAll(resources);
      return this;
    }
  }
",data class
1425,"public class ConstantPartitioner implements DocumentPartitioner {

  /** The list with a single content type, the default one. */
  private final List<String> legalContentTypes;

  /** The single content type. */
  private final String contentType;

  /** The full document length. */
  private int documentLength = 0;

  /** Handle on the document. */
  private DocumentHandle documentHandle;

  /**
   * Constructor for a {@link ConstantPartitioner} that has a single partition of type ContentType.
   *
   * @param contentType the single content type
   */
  public ConstantPartitioner(final String contentType) {
    this.contentType = contentType;
    this.legalContentTypes = Collections.singletonList(this.contentType);
  }

  /**
   * Constructor for a {@link ConstantPartitioner} that has a single partition of type {@link
   * DefaultPartitioner#DEFAULT_CONTENT_TYPE}.
   */
  public ConstantPartitioner() {
    this(DEFAULT_CONTENT_TYPE);
  }

  @Override
  public void onDocumentChanged(final DocumentChangedEvent event) {
    final int removed = event.getLength();
    int added = 0;
    if (event.getText() != null) {
      added = event.getText().length();
    }
    final int sizeDelta = added - removed;
    this.documentLength += sizeDelta;
  }

  @Override
  public void initialize() {
    this.documentLength = getDocumentHandle().getDocument().getContentsCharCount();
  }

  @Override
  public List<String> getLegalContentTypes() {
    return legalContentTypes;
  }

  @Override
  public String getContentType(final int offset) {
    return this.contentType;
  }

  @Override
  public List<TypedRegion> computePartitioning(final int offset, final int length) {
    final TypedRegion region = getPartition(offset);
    return Collections.singletonList(region);
  }

  @Override
  public TypedRegion getPartition(final int offset) {
    return new TypedRegionImpl(offset, this.documentLength, this.contentType);
  }

  @Override
  public DocumentHandle getDocumentHandle() {
    return documentHandle;
  }

  @Override
  public void setDocumentHandle(DocumentHandle handle) {
    this.documentHandle = handle;
  }

  @Override
  public void release() {}
}
",data class
1064,"@Deprecated
public final class CompactCharArray implements Cloneable {

    /**
     * The total number of Unicode characters.
     * @deprecated This API is ICU internal only.
     * @hide draft / provisional / internal are hidden on Android
     */
    @Deprecated
    public static  final int UNICODECOUNT = 65536;

    /**
     * Default constructor for CompactCharArray, the default value of the
     * compact array is 0.
     * @deprecated This API is ICU internal only.
     * @hide draft / provisional / internal are hidden on Android
     */
    @Deprecated
    public CompactCharArray()
    {
        this((char)0);
    }

    /**
     * Constructor for CompactCharArray.
     * @param defaultValue the default value of the compact array.
     * @deprecated This API is ICU internal only.
     * @hide draft / provisional / internal are hidden on Android
     */
    @Deprecated
    public CompactCharArray(char defaultValue)
    {
        int i;
        values = new char[UNICODECOUNT];
        indices = new char[INDEXCOUNT];
        hashes = new int[INDEXCOUNT];
        for (i = 0; i < UNICODECOUNT; ++i) {
            values[i] = defaultValue;
        }
        for (i = 0; i < INDEXCOUNT; ++i) {
            indices[i] = (char)(i<<BLOCKSHIFT);
            hashes[i] = 0;
        }
        isCompact = false;

        this.defaultValue = defaultValue;
    }

    /**
     * Constructor for CompactCharArray.
     * @param indexArray the indicies of the compact array.
     * @param newValues the values of the compact array.
     * @exception IllegalArgumentException If the index is out of range.
     * @deprecated This API is ICU internal only.
     * @hide draft / provisional / internal are hidden on Android
     */
    @Deprecated
    public CompactCharArray(char indexArray[],
                             char newValues[])
    {
        int i;
        if (indexArray.length != INDEXCOUNT)
            throw new IllegalArgumentException(""Index out of bounds."");
        for (i = 0; i < INDEXCOUNT; ++i) {
            char index = indexArray[i];
            if (index >= newValues.length+BLOCKCOUNT)
                throw new IllegalArgumentException(""Index out of bounds."");
        }
        indices = indexArray;
        values = newValues;
        isCompact = true;
    }

    /**
     * Constructor for CompactCharArray.
     *
     * @param indexArray the RLE-encoded indicies of the compact array.
     * @param valueArray the RLE-encoded values of the compact array.
     *
     * @throws IllegalArgumentException if the index or value array is
     *          the wrong size.
     * @deprecated This API is ICU internal only.
     * @hide draft / provisional / internal are hidden on Android
     */
    @Deprecated
    public CompactCharArray(String indexArray,
                String valueArray)
    {
        this( Utility.RLEStringToCharArray(indexArray),
              Utility.RLEStringToCharArray(valueArray));
    }

    /**
     * Get the mapped value of a Unicode character.
     * @param index the character to get the mapped value with
     * @return the mapped value of the given character
     * @deprecated This API is ICU internal only.
     * @hide draft / provisional / internal are hidden on Android
     */
    @Deprecated
    public char elementAt(char index)
    {
    int ix = (indices[index >> BLOCKSHIFT] & 0xFFFF)
        + (index & BLOCKMASK);
    return ix >= values.length ? defaultValue : values[ix];
    }

    /**
     * Set a new value for a Unicode character.
     * Set automatically expands the array if it is compacted.
     * @param index the character to set the mapped value with
     * @param value the new mapped value
     * @deprecated This API is ICU internal only.
     * @hide draft / provisional / internal are hidden on Android
     */
    @Deprecated
    public void setElementAt(char index, char value)
    {
        if (isCompact)
            expand();
         values[index] = value;
        touchBlock(index >> BLOCKSHIFT, value);
    }

    /**
     * Set new values for a range of Unicode character.
     *
     * @param start the starting offset of the range
     * @param end the ending offset of the range
     * @param value the new mapped value
     * @deprecated This API is ICU internal only.
     * @hide draft / provisional / internal are hidden on Android
     */
    @Deprecated
    public void setElementAt(char start, char end, char value)
    {
        int i;
        if (isCompact) {
            expand();
        }
        for (i = start; i <= end; ++i) {
            values[i] = value;
            touchBlock(i >> BLOCKSHIFT, value);
        }
    }
    /**
     * Compact the array
     * @deprecated This API is ICU internal only.
     * @hide draft / provisional / internal are hidden on Android
     */
    @Deprecated
    public void compact() {
        compact(true);
    }

    /**
     * Compact the array.
     * @deprecated This API is ICU internal only.
     * @hide draft / provisional / internal are hidden on Android
     */
    @Deprecated
    public void compact(boolean exhaustive)
    {
        if (!isCompact) {
            int iBlockStart = 0;
            char iUntouched = 0xFFFF;
            int newSize = 0;

            char[] target = exhaustive ? new char[UNICODECOUNT] : values;

            for (int i = 0; i < indices.length; ++i, iBlockStart += BLOCKCOUNT) {
                indices[i] = 0xFFFF;
                boolean touched = blockTouched(i);
                if (!touched && iUntouched != 0xFFFF) {
                    // If no values in this block were set, we can just set its
                    // index to be the same as some other block with no values
                    // set, assuming we've seen one yet.
                    indices[i] = iUntouched;
                } else {
                    int jBlockStart = 0;
                    // See if we can find a previously compacted block that's identical
                    for (int j = 0; j < i; ++j, jBlockStart += BLOCKCOUNT) {
                        if (hashes[i] == hashes[j] &&
                                arrayRegionMatches(values, iBlockStart,
                                                   values, jBlockStart, BLOCKCOUNT)) {
                            indices[i] = indices[j];
                        }
                    }
                    if (indices[i] == 0xFFFF) {
                        int dest;   // Where to copy
                        if (exhaustive) {
                            // See if we can find some overlap with another block
                            dest = FindOverlappingPosition(iBlockStart, target,
                                                            newSize);
                        } else {
                            // Just copy to the end; it's quicker
                            dest = newSize;
                        }
                        int limit = dest + BLOCKCOUNT;
                        if (limit > newSize) {
                            for (int j = newSize; j < limit; ++j) {
                                target[j] = values[iBlockStart + j - dest];
                            }
                            newSize = limit;
                        }
                        indices[i] = (char)dest;
                        if (!touched) {
                            // If this is the first untouched block we've seen,
                            // remember its index.
                            iUntouched = (char)jBlockStart;
                        }
                    }
                }
            }
            // we are done compacting, so now make the array shorter
            char[] result = new char[newSize];
            System.arraycopy(target, 0, result, 0, newSize);
            values = result;
            isCompact = true;
            hashes = null;
        }
    }

    private int FindOverlappingPosition(int start, char[] tempValues, int tempCount)
    {
        for (int i = 0; i < tempCount; i += 1) {
            int currentCount = BLOCKCOUNT;
            if (i + BLOCKCOUNT > tempCount) {
                currentCount = tempCount - i;
            }
            if (arrayRegionMatches(values, start, tempValues, i, currentCount))
                return i;
        }
        return tempCount;
    }

    /**
     * Convenience utility to compare two arrays of doubles.
     * @param len the length to compare.
     * The start indices and start+len must be valid.
     */
    final static boolean arrayRegionMatches(char[] source, int sourceStart,
                                            char[] target, int targetStart,
                                            int len)
    {
        int sourceEnd = sourceStart + len;
        int delta = targetStart - sourceStart;
        for (int i = sourceStart; i < sourceEnd; i++) {
            if (source[i] != target[i + delta])
            return false;
        }
        return true;
    }

    /**
     * Remember that a specified block was ""touched"", i.e. had a value set.
     * Untouched blocks can be skipped when compacting the array
     */
    private final void touchBlock(int i, int value) {
        hashes[i] = (hashes[i] + (value<<1)) | 1;
    }

    /**
     * Query whether a specified block was ""touched"", i.e. had a value set.
     * Untouched blocks can be skipped when compacting the array
     */
    private final boolean blockTouched(int i) {
        return hashes[i] != 0;
    }

    /**
     * For internal use only.  Do not modify the result, the behavior of
     * modified results are undefined.
     * @deprecated This API is ICU internal only.
     * @hide draft / provisional / internal are hidden on Android
     */
    @Deprecated
    public char[] getIndexArray()
    {
        return indices;
    }

    /**
     * For internal use only.  Do not modify the result, the behavior of
     * modified results are undefined.
     * @deprecated This API is ICU internal only.
     * @hide draft / provisional / internal are hidden on Android
     */
    @Deprecated
    public char[] getValueArray()
    {
        return values;
    }

    /**
     * Overrides Cloneable
     * @deprecated This API is ICU internal only.
     * @hide draft / provisional / internal are hidden on Android
     */
    @Override
    @Deprecated
    public Object clone()
    {
        try {
            CompactCharArray other = (CompactCharArray) super.clone();
            other.values = values.clone();
            other.indices = indices.clone();
            if (hashes != null) other.hashes = hashes.clone();
            return other;
        } catch (CloneNotSupportedException e) {
            throw new ICUCloneNotSupportedException(e);
        }
    }

    /**
     * Compares the equality of two compact array objects.
     * @param obj the compact array object to be compared with this.
     * @return true if the current compact array object is the same
     * as the compact array object obj; false otherwise.
     * @deprecated This API is ICU internal only.
     * @hide draft / provisional / internal are hidden on Android
     */
    @Override
    @Deprecated
    public boolean equals(Object obj) {
        if (obj == null) return false;
        if (this == obj)                      // quick check
            return true;
        if (getClass() != obj.getClass())         // same class?
            return false;
        CompactCharArray other = (CompactCharArray) obj;
        for (int i = 0; i < UNICODECOUNT; i++) {
            // could be sped up later
            if (elementAt((char)i) != other.elementAt((char)i))
                return false;
        }
        return true; // we made it through the guantlet.
    }

    /**
     * Generates the hash code for the compact array object
     * @deprecated This API is ICU internal only.
     * @hide draft / provisional / internal are hidden on Android
     */
    @Override
    @Deprecated
    public int hashCode() {
        int result = 0;
        int increment = Math.min(3, values.length/16);
        for (int i = 0; i < values.length; i+= increment) {
            result = result * 37 + values[i];
        }
        return result;
    }


    // --------------------------------------------------------------
    // private
    // --------------------------------------------------------------

    /**
     * Expanding takes the array back to a 65536 element array.
     */
    private void expand()
    {
        int i;
        if (isCompact) {
            char[] tempArray;
            hashes = new int[INDEXCOUNT];
            tempArray = new char[UNICODECOUNT];
            for (i = 0; i < UNICODECOUNT; ++i) {
                tempArray[i] = elementAt((char)i);
            }
            for (i = 0; i < INDEXCOUNT; ++i) {
                indices[i] = (char)(i<<BLOCKSHIFT);
            }
            values = null;
            values = tempArray;
            isCompact = false;
        }
    }
    /**
     * @deprecated This API is ICU internal only.
     * @hide draft / provisional / internal are hidden on Android
     */
    @Deprecated
    public static  final int BLOCKSHIFT = 5; // NormalizerBuilder needs - liu
    static  final int BLOCKCOUNT =(1<<BLOCKSHIFT);
    static  final int INDEXSHIFT =(16-BLOCKSHIFT);
    static  final int INDEXCOUNT =(1<<INDEXSHIFT);
    static  final int BLOCKMASK = BLOCKCOUNT - 1;

    private char values[];
    private char indices[];
    private int[] hashes;
    private boolean isCompact;
    char defaultValue;
}
",blob
239,"@Mojo( name = ""check"", defaultPhase = LifecyclePhase.VERIFY, requiresDependencyResolution = ResolutionScope.TEST,
       threadSafe = true )
public class CheckstyleViolationCheckMojo
    extends AbstractMojo
{

    private static final String JAVA_FILES = ""**\\/*.java"";
    private static final String DEFAULT_CONFIG_LOCATION = ""sun_checks.xml"";

    /**
     * Specifies the path and filename to save the Checkstyle output. The format
     * of the output file is determined by the <code>outputFileFormat</code>
     * parameter.
     */
    @Parameter( property = ""checkstyle.output.file"", defaultValue = ""${project.build.directory}/checkstyle-result.xml"" )
    private File outputFile;

    /**
     * Specifies the format of the output to be used when writing to the output
     * file. Valid values are ""<code>plain</code>"" and ""<code>xml</code>"".
     */
    @Parameter( property = ""checkstyle.output.format"", defaultValue = ""xml"" )
    private String outputFileFormat;

    /**
     * Fail the build on a violation. The goal checks for the violations
     * after logging them (if {@link #logViolationsToConsole} is {@code true}).
     * Compare this to {@link #failsOnError} which fails the build immediately
     * before examining the output log.
     */
    @Parameter( property = ""checkstyle.failOnViolation"", defaultValue = ""true"" )
    private boolean failOnViolation;

    /**
     * The maximum number of allowed violations. The execution fails only if the
     * number of violations is above this limit.
     *
     * @since 2.3
     */
    @Parameter( property = ""checkstyle.maxAllowedViolations"", defaultValue = ""0"" )
    private int maxAllowedViolations;

    /**
     * The lowest severity level that is considered a violation.
     * Valid values are ""<code>error</code>"", ""<code>warning</code>"" and ""<code>info</code>"".
     *
     * @since 2.2
     */
    @Parameter( property = ""checkstyle.violationSeverity"", defaultValue = ""error"" )
    private String violationSeverity = ""error"";

    /**
     * Violations to ignore. This is a comma-separated list, each value being either
     * a rule name, a rule category or a java package name of rule class.
     *
     * @since 2.13
     */
    @Parameter( property = ""checkstyle.violation.ignore"" )
    private String violationIgnore;

    /**
     * Skip entire check.
     *
     * @since 2.2
     */
    @Parameter( property = ""checkstyle.skip"", defaultValue = ""false"" )
    private boolean skip;

    /**
     * Skip Checkstyle execution will only scan the outputFile.
     *
     * @since 2.5
     */
    @Parameter( property = ""checkstyle.skipExec"", defaultValue = ""false"" )
    private boolean skipExec;

    /**
     * Output the detected violations to the console.
     *
     * @since 2.3
     */
    @Parameter( property = ""checkstyle.console"", defaultValue = ""true"" )
    private boolean logViolationsToConsole;

    /**
     * Specifies the location of the resources to be used for Checkstyle.
     *
     * @since 2.11
     */
    @Parameter( defaultValue = ""${project.resources}"", readonly = true )
    protected List<Resource> resources;
    
    /**
     * Specifies the location of the test resources to be used for Checkstyle.
     *
     * @since 2.16
     */
    @Parameter( defaultValue = ""${project.testResources}"", readonly = true )
    protected List<Resource> testResources;

    /**
     * <p>
     * Specifies the location of the XML configuration to use.
     * <p>
     * Potential values are a filesystem path, a URL, or a classpath resource.
     * This parameter expects that the contents of the location conform to the
     * xml format (Checkstyle <a
     * href=""http://checkstyle.sourceforge.net/config.html#Modules"">Checker
     * module</a>) configuration of rulesets.
     * <p>
     * This parameter is resolved as resource, URL, then file. If successfully
     * resolved, the contents of the configuration is copied into the
     * <code>${project.build.directory}/checkstyle-configuration.xml</code>
     * file before being passed to Checkstyle as a configuration.
     * <p>
     * There are 2 predefined rulesets.
     * <ul>
     * <li><code>sun_checks.xml</code>: Sun Checks.</li>
     * <li><code>google_checks.xml</code>: Google Checks.</li>
     * </ul>
     *
     * @since 2.5
     */
    @Parameter( property = ""checkstyle.config.location"", defaultValue = DEFAULT_CONFIG_LOCATION )
    private String configLocation;

    /**
     * <p>
     * Specifies the location of the properties file.
     * <p>
     * This parameter is resolved as URL, File then resource. If successfully
     * resolved, the contents of the properties location is copied into the
     * <code>${project.build.directory}/checkstyle-checker.properties</code>
     * file before being passed to Checkstyle for loading.
     * <p>
     * The contents of the <code>propertiesLocation</code> will be made
     * available to Checkstyle for specifying values for parameters within the
     * xml configuration (specified in the <code>configLocation</code>
     * parameter).
     *
     * @since 2.5
     */
    @Parameter( property = ""checkstyle.properties.location"" )
    private String propertiesLocation;

    /**
     * Allows for specifying raw property expansion information.
     */
    @Parameter
    private String propertyExpansion;

    /**
     * <p>
     * Specifies the location of the License file (a.k.a. the header file) that
     * can be used by Checkstyle to verify that source code has the correct
     * license header.
     * <p>
     * You need to use <code>${checkstyle.header.file}</code> in your Checkstyle xml
     * configuration to reference the name of this header file.
     * <p>
     * For instance:
     * <pre>
     * &lt;module name=""RegexpHeader""&gt;
     *   &lt;property name=""headerFile"" value=""${checkstyle.header.file}""/&gt;
     * &lt;/module&gt;
     * </pre>
     *
     * @since 2.0-beta-2
     */
    @Parameter( property = ""checkstyle.header.file"", defaultValue = ""LICENSE.txt"" )
    private String headerLocation;

    /**
     * Specifies the cache file used to speed up Checkstyle on successive runs.
     */
    @Parameter( defaultValue = ""${project.build.directory}/checkstyle-cachefile"" )
    private String cacheFile;

    /**
     * The key to be used in the properties for the suppressions file.
     *
     * @since 2.1
     */
    @Parameter( property = ""checkstyle.suppression.expression"", defaultValue = ""checkstyle.suppressions.file"" )
    private String suppressionsFileExpression;

    /**
     * <p>
     * Specifies the location of the suppressions XML file to use.
     * <p>
     * This parameter is resolved as resource, URL, then file. If successfully
     * resolved, the contents of the suppressions XML is copied into the
     * <code>${project.build.directory}/checkstyle-suppressions.xml</code> file
     * before being passed to Checkstyle for loading.
     * <p>
     * See <code>suppressionsFileExpression</code> for the property that will
     * be made available to your Checkstyle configuration.
     *
     * @since 2.0-beta-2
     */
    @Parameter( property = ""checkstyle.suppressions.location"" )
    private String suppressionsLocation;

    /**
     * The file encoding to use when reading the source files. If the property <code>project.build.sourceEncoding</code>
     * is not set, the platform default encoding is used. <strong>Note:</strong> This parameter always overrides the
     * property <code>charset</code> from Checkstyle's <code>TreeWalker</code> module.
     *
     * @since 2.2
     */
    @Parameter( property = ""encoding"", defaultValue = ""${project.build.sourceEncoding}"" )
    private String encoding;

    /**
     * @since 2.5
     */
    @Component( role = CheckstyleExecutor.class, hint = ""default"" )
    protected CheckstyleExecutor checkstyleExecutor;

    /**
     * Output errors to console.
     */
    @Parameter( property = ""checkstyle.consoleOutput"", defaultValue = ""false"" )
    private boolean consoleOutput;

    /**
     * The Maven Project Object.
     */
    @Parameter ( defaultValue = ""${project}"", readonly = true, required = true )
    protected MavenProject project;
    
    /**
     * The Plugin Descriptor
     */
    @Parameter( defaultValue = ""${plugin}"", readonly = true, required = true )
    private PluginDescriptor plugin;

    /**
     * If <code>null</code>, the Checkstyle plugin will display violations on stdout.
     * Otherwise, a text file will be created with the violations.
     */
    @Parameter
    private File useFile;

    /**
     * Specifies the names filter of the source files to be excluded for
     * Checkstyle.
     */
    @Parameter( property = ""checkstyle.excludes"" )
    private String excludes;

    /**
     * Specifies the names filter of the source files to be used for Checkstyle.
     */
    @Parameter( property = ""checkstyle.includes"", defaultValue = JAVA_FILES, required = true )
    private String includes;

    /**
     * Specifies the names filter of the files to be excluded for
     * Checkstyle when checking resources.
     * @since 2.11
     */
    @Parameter( property = ""checkstyle.resourceExcludes"" )
    private String resourceExcludes;

    /**
     * Specifies the names filter of the files to be used for Checkstyle when checking resources.
     * @since 2.11
     */
    @Parameter( property = ""checkstyle.resourceIncludes"", defaultValue = ""**/*.properties"", required = true )
    private String resourceIncludes;

    /**
     * If this is true, and Checkstyle reported any violations or errors,
     * the build fails immediately after running Checkstyle, before checking the log
     * for {@link #logViolationsToConsole}. If you want to use {@link #logViolationsToConsole},
     * use {@link #failOnViolation} instead of this.
     */
    @Parameter( defaultValue = ""false"" )
    private boolean failsOnError;

    /**
     * Specifies the location of the test source directory to be used for Checkstyle.
     *
     * @since 2.2
     * @deprecated instead use {@link #testSourceDirectories}. For version 3.0.0, this parameter is only defined to
     *             break the build if you use it!
     */
    @Deprecated
    @Parameter
    private File testSourceDirectory;

    /**
     * Specifies the location of the test source directories to be used for Checkstyle.
     * Default value is <code>${project.testCompileSourceRoots}</code>.
     * @since 2.13
     */
    // Compatibility with all Maven 3: default of 'project.testCompileSourceRoots' is done manually because of MNG-5440
    @Parameter
    private List<String> testSourceDirectories;

    /**
     * Include or not the test source directory to be used for Checkstyle.
     *
     * @since 2.2
     */
    @Parameter( defaultValue = ""false"" )
    private boolean includeTestSourceDirectory;

    /**
     * Specifies the location of the source directory to be used for Checkstyle.
     * 
     * @deprecated instead use {@link #sourceDirectories}. For version 3.0.0, this parameter is only defined to break
     *             the build if you use it!
     */
    @Deprecated
    @Parameter
    private File sourceDirectory;

    /**
     * Specifies the location of the source directories to be used for Checkstyle.
     * Default value is <code>${project.compileSourceRoots}</code>.
     * @since 2.13
     */
    // Compatibility with all Maven 3: default of 'project.compileSourceRoots' is done manually because of MNG-5440
    @Parameter
    private List<String> sourceDirectories;

    /**
     * Whether to apply Checkstyle to resource directories.
     * @since 2.11
     */
    @Parameter( property = ""checkstyle.includeResources"", defaultValue = ""true"", required = true )
    private boolean includeResources = true;

    /**
     * Whether to apply Checkstyle to test resource directories.
     * @since 2.11
     */
    @Parameter( property = ""checkstyle.includeTestResources"", defaultValue = ""true"", required = true )
    private boolean includeTestResources = true;

    /**
     * By using this property, you can specify the whole Checkstyle rules
     * inline directly inside this pom.
     *
     * <pre>
     * &lt;plugin&gt;
     *   ...
     *   &lt;configuration&gt;
     *     &lt;checkstyleRules&gt;
     *       &lt;module name=""Checker""&gt;
     *         &lt;module name=""FileTabCharacter""&gt;
     *           &lt;property name=""eachLine"" value=""true"" /&gt;
     *         &lt;/module&gt;
     *         &lt;module name=""TreeWalker""&gt;
     *           &lt;module name=""EmptyBlock""/&gt;
     *         &lt;/module&gt;
     *       &lt;/module&gt;
     *     &lt;/checkstyleRules&gt;
     *   &lt;/configuration&gt;
     *   ...
     * </pre>
     *
     * @since 2.12
     */
    @Parameter
    private PlexusConfiguration checkstyleRules;

    /**
     * Dump file for inlined Checkstyle rules. 
     */
    @Parameter( property = ""checkstyle.output.rules.file"",
                    defaultValue = ""${project.build.directory}/checkstyle-rules.xml"" )
    private File rulesFiles;

    /**
     * The header to use for the inline configuration.
     * Only used when you specify {@code checkstyleRules}.
     */
    @Parameter( defaultValue = ""<?xml version=\""1.0\""?>\n""
            + ""<!DOCTYPE module PUBLIC \""-//Puppy Crawl//DTD Check Configuration 1.3//EN\""\n""
            + ""        \""http://www.puppycrawl.com/dtds/configuration_1_3.dtd\"">\n"" )
    private String checkstyleRulesHeader;

    /**
     * Specifies whether modules with a configured severity of <code>ignore</code> should be omitted during Checkstyle
     * invocation.
     * 
     * @since 3.0.0
     */
    @Parameter( defaultValue = ""false"" )
    private boolean omitIgnoredModules;

    private ByteArrayOutputStream stringOutputStream;

    private File outputXmlFile;

    /** {@inheritDoc} */
    public void execute()
        throws MojoExecutionException, MojoFailureException
    {
        checkDeprecatedParameterUsage( sourceDirectory, ""sourceDirectory"", ""sourceDirectories"" );
        checkDeprecatedParameterUsage( testSourceDirectory, ""testSourceDirectory"", ""testSourceDirectories"" );
        if ( skip )
        {
            return;
        }

        outputXmlFile = outputFile;

        if ( !skipExec )
        {
            if ( checkstyleRules != null )
            {
                if ( !DEFAULT_CONFIG_LOCATION.equals( configLocation ) )
                {
                    throw new MojoExecutionException( ""If you use inline configuration for rules, don't specify ""
                        + ""a configLocation"" );
                }
                if ( checkstyleRules.getChildCount() > 1 )
                {
                    throw new MojoExecutionException( ""Currently only one root module is supported"" );
                }

                PlexusConfiguration checkerModule = checkstyleRules.getChild( 0 );

                try
                {
                    FileUtils.forceMkdir( rulesFiles.getParentFile() );
                    FileUtils.fileWrite( rulesFiles, checkstyleRulesHeader + checkerModule.toString() );
                }
                catch ( final IOException e )
                {
                    throw new MojoExecutionException( e.getMessage(), e );
                }
                configLocation = rulesFiles.getAbsolutePath();
            }

            ClassLoader currentClassLoader = Thread.currentThread().getContextClassLoader();

            try
            {
                CheckstyleExecutorRequest request = new CheckstyleExecutorRequest();
                request.setConsoleListener( getConsoleListener() ).setConsoleOutput( consoleOutput )
                    .setExcludes( excludes ).setFailsOnError( failsOnError ).setIncludes( includes )
                    .setResourceIncludes( resourceIncludes )
                    .setResourceExcludes( resourceExcludes )
                    .setIncludeResources( includeResources )
                    .setIncludeTestResources( includeTestResources )
                    .setIncludeTestSourceDirectory( includeTestSourceDirectory ).setListener( getListener() )
                    .setProject( project ).setSourceDirectories( getSourceDirectories() )
                    .setResources( resources ).setTestResources( testResources )
                    .setStringOutputStream( stringOutputStream ).setSuppressionsLocation( suppressionsLocation )
                    .setTestSourceDirectories( getTestSourceDirectories() ).setConfigLocation( configLocation )
                    .setConfigurationArtifacts( collectArtifacts( ""config"" ) )
                    .setPropertyExpansion( propertyExpansion )
                    .setHeaderLocation( headerLocation ).setLicenseArtifacts( collectArtifacts( ""license"" ) )
                    .setCacheFile( cacheFile ).setSuppressionsFileExpression( suppressionsFileExpression )
                    .setEncoding( encoding ).setPropertiesLocation( propertiesLocation )
                    .setOmitIgnoredModules( omitIgnoredModules );
                checkstyleExecutor.executeCheckstyle( request );

            }
            catch ( CheckstyleException e )
            {
                throw new MojoExecutionException( ""Failed during checkstyle configuration"", e );
            }
            catch ( CheckstyleExecutorException e )
            {
                throw new MojoExecutionException( ""Failed during checkstyle execution"", e );
            }
            finally
            {
                //be sure to restore original context classloader
                Thread.currentThread().setContextClassLoader( currentClassLoader );
            }
        }

        if ( !""xml"".equals( outputFileFormat ) && skipExec )
        {
            throw new MojoExecutionException( ""Output format is '"" + outputFileFormat
                + ""', checkstyle:check requires format to be 'xml' when using skipExec."" );
        }

        if ( !outputXmlFile.exists() )
        {
            getLog().info( ""Unable to perform checkstyle:check, unable to find checkstyle:checkstyle outputFile."" );
            return;
        }

        try ( Reader reader = new BufferedReader( ReaderFactory.newXmlReader( outputXmlFile ) ) )
        {
            XmlPullParser xpp = new MXParser();
            xpp.setInput( reader );

            int violations = countViolations( xpp );

            if ( violations > maxAllowedViolations )
            {
                if ( failOnViolation )
                {
                    String msg =
                        ""You have "" + violations + "" Checkstyle violation"" + ( ( violations > 1 ) ? ""s"" : """" ) + ""."";
                    if ( maxAllowedViolations > 0 )
                    {
                        msg += "" The maximum number of allowed violations is "" + maxAllowedViolations + ""."";
                    }
                    throw new MojoFailureException( msg );
                }

                getLog().warn( ""checkstyle:check violations detected but failOnViolation set to false"" );
            }
        }
        catch ( IOException | XmlPullParserException e )
        {
            throw new MojoExecutionException( ""Unable to read Checkstyle results xml: ""
                + outputXmlFile.getAbsolutePath(), e );
        }
    }

    private void checkDeprecatedParameterUsage( Object parameter, String name, String replacement )
        throws MojoFailureException
    {
        if ( parameter != null )
        {
            throw new MojoFailureException( ""You are using '"" + name + ""' which has been removed""
                + "" from the maven-checkstyle-plugin. "" + ""Please use '"" + replacement
                + ""' and refer to the >>Major Version Upgrade to version 3.0.0<< "" + ""on the plugin site."" );
        }
    }

    private int countViolations( XmlPullParser xpp )
        throws XmlPullParserException, IOException
    {
        int count = 0;
        int ignoreCount = 0;
        List<RuleUtil.Matcher> ignores = violationIgnore == null ? Collections.<RuleUtil.Matcher>emptyList()
                        : RuleUtil.parseMatchers( violationIgnore.split( "","" ) );

        String basedir = project.getBasedir().getAbsolutePath();
        String file = """";
        for ( int eventType = xpp.getEventType(); eventType != XmlPullParser.END_DOCUMENT; eventType = xpp.next() )
        {
            if ( eventType != XmlPullParser.START_TAG )
            {
                continue;
            }
            else if ( ""file"".equals( xpp.getName() ) )
            {
                file = PathTool.getRelativeFilePath( basedir, xpp.getAttributeValue( """", ""name"" ) );
                //file = file.substring( file.lastIndexOf( File.separatorChar ) + 1 );
            }
            else if ( ""error"".equals( xpp.getName() ) )
            {
                String severity = xpp.getAttributeValue( """", ""severity"" );

                if ( !isViolation( severity ) )
                {
                    continue;
                }

                String source = xpp.getAttributeValue( """", ""source"" );

                if ( ignore( ignores, source ) )
                {
                    ignoreCount++;
                }
                else
                {
                    count++;

                    if ( logViolationsToConsole )
                    {
                        String line = xpp.getAttributeValue( """", ""line"" );
                        String column = xpp.getAttributeValue( """", ""column"" );
                        String message = xpp.getAttributeValue( """", ""message"" );
                        String rule = RuleUtil.getName( source );
                        String category = RuleUtil.getCategory( source );

                        log( severity, file + "":["" + line + ( ( column == null ) ? """" : ( ',' + column ) ) + ""] (""
                            + category + "") "" + rule + "": "" + message );
                    }
                }
            }
        }

        if ( ignoreCount > 0 )
        {
            getLog().info( ""Ignored "" + ignoreCount + "" error"" + ( ( ignoreCount > 1 ) ? ""s"" : """" ) + "", "" + count
                               + "" violation"" + ( ( count > 1 ) ? ""s"" : """" ) + "" remaining."" );
        }

        return count;
    }

    private void log( String severity, String message )
    {
        if ( ""info"".equals( severity ) )
        {
            getLog().info( message );
        }
        else if ( ""warning"".equals( severity ) )
        {
            getLog().warn( message );
        }
        else
        {
            getLog().error( message );
        }
    }

    /**
     * Checks if the given severity is considered a violation.
     *
     * @param severity The severity to check
     * @return <code>true</code> if the given severity is a violation, otherwise <code>false</code>
     */
    private boolean isViolation( String severity )
    {
        if ( ""error"".equals( severity ) )
        {
            return ""error"".equals( violationSeverity ) || ""warning"".equals( violationSeverity )
                || ""info"".equals( violationSeverity );
        }
        else if ( ""warning"".equals( severity ) )
        {
            return ""warning"".equals( violationSeverity ) || ""info"".equals( violationSeverity );
        }
        else if ( ""info"".equals( severity ) )
        {
            return ""info"".equals( violationSeverity );
        }
        else
        {
            return false;
        }
    }

    private boolean ignore( List<RuleUtil.Matcher> ignores, String source )
    {
        for ( RuleUtil.Matcher ignore : ignores )
        {
            if ( ignore.match( source ) )
            {
                return true;
            }
        }
        return false;
    }

    private DefaultLogger getConsoleListener()
        throws MojoExecutionException
    {
        DefaultLogger consoleListener;

        if ( useFile == null )
        {
            stringOutputStream = new ByteArrayOutputStream();
            consoleListener = new DefaultLogger( stringOutputStream, false );
        }
        else
        {
            OutputStream out = getOutputStream( useFile );

            consoleListener = new DefaultLogger( out, true );
        }

        return consoleListener;
    }

    private OutputStream getOutputStream( File file )
        throws MojoExecutionException
    {
        File parentFile = file.getAbsoluteFile().getParentFile();

        if ( !parentFile.exists() )
        {
            parentFile.mkdirs();
        }

        FileOutputStream fileOutputStream;
        try
        {
            fileOutputStream = new FileOutputStream( file );
        }
        catch ( FileNotFoundException e )
        {
            throw new MojoExecutionException( ""Unable to create output stream: "" + file, e );
        }
        return fileOutputStream;
    }

    private AuditListener getListener()
        throws MojoFailureException, MojoExecutionException
    {
        AuditListener listener = null;

        if ( StringUtils.isNotEmpty( outputFileFormat ) )
        {
            File resultFile = outputFile;

            OutputStream out = getOutputStream( resultFile );

            if ( ""xml"".equals( outputFileFormat ) )
            {
                listener = new XMLLogger( out, true );
            }
            else if ( ""plain"".equals( outputFileFormat ) )
            {
                try
                {
                    // Write a plain output file to the standard output file,
                    // and write an XML output file to the temp directory that can be used to count violations
                    outputXmlFile = File.createTempFile( ""checkstyle-result"", "".xml"" );
                    outputXmlFile.deleteOnExit();
                    OutputStream xmlOut = getOutputStream( outputXmlFile );
                    CompositeAuditListener compoundListener = new CompositeAuditListener();
                    compoundListener.addListener( new XMLLogger( xmlOut, true ) );
                    compoundListener.addListener( new DefaultLogger( out, true ) );
                    listener = compoundListener;
                }
                catch ( IOException e )
                {
                    throw new MojoExecutionException( ""Unable to create temporary file"", e );
                }
            }
            else
            {
                throw new MojoFailureException( ""Invalid output file format: ("" + outputFileFormat
                    + ""). Must be 'plain' or 'xml'."" );
            }
        }

        return listener;
    }
    
    private List<Artifact> collectArtifacts( String hint )
    {
        List<Artifact> artifacts = new ArrayList<>();

        PluginManagement pluginManagement = project.getBuild().getPluginManagement();
        if ( pluginManagement != null )
        {
            artifacts.addAll( getCheckstylePluginDependenciesAsArtifacts( pluginManagement.getPluginsAsMap(), hint ) );
        }

        artifacts.addAll( getCheckstylePluginDependenciesAsArtifacts( project.getBuild().getPluginsAsMap(), hint ) );

        return artifacts;
    }

    private List<Artifact> getCheckstylePluginDependenciesAsArtifacts( Map<String, Plugin> plugins, String hint )
    {
        List<Artifact> artifacts = new ArrayList<>();
        
        Plugin checkstylePlugin = plugins.get( plugin.getGroupId() + "":"" + plugin.getArtifactId() );
        if ( checkstylePlugin != null )
        {
            for ( Dependency dep : checkstylePlugin.getDependencies() )
            {
             // @todo if we can filter on hints, it should be done here...
                String depKey = dep.getGroupId() + "":"" + dep.getArtifactId();
                artifacts.add( (Artifact) plugin.getArtifactMap().get( depKey ) );
            }
        }
        return artifacts;
    }
    
    private List<File> getSourceDirectories()
    {
        if ( sourceDirectories == null )
        {
            sourceDirectories = project.getCompileSourceRoots();
        }
        List<File> sourceDirs = new ArrayList<>( sourceDirectories.size() );
        for ( String sourceDir : sourceDirectories )
        {
            sourceDirs.add( FileUtils.resolveFile( project.getBasedir(), sourceDir ) );
        }
        return sourceDirs;
    }
    
    private List<File> getTestSourceDirectories()
    {
        if ( testSourceDirectories == null )
        {
            testSourceDirectories = project.getTestCompileSourceRoots();
        }
        List<File> testSourceDirs = new ArrayList<>( testSourceDirectories.size() );
        for ( String testSourceDir : testSourceDirectories )
        {
            testSourceDirs.add( FileUtils.resolveFile( project.getBasedir(), testSourceDir ) );
        }
        return testSourceDirs;
    }
    
}
",blob
1044,"public final class ZoneOffsetTransitionRule implements Serializable {

    /**
     * Serialization version.
     */
    private static final long serialVersionUID = 6889046316657758795L;

    /**
     * The month of the month-day of the first day of the cutover week.
     * The actual date will be adjusted by the dowChange field.
     */
    private final Month month;
    /**
     * The day-of-month of the month-day of the cutover week.
     * If positive, it is the start of the week where the cutover can occur.
     * If negative, it represents the end of the week where cutover can occur.
     * The value is the number of days from the end of the month, such that
     * {@code -1} is the last day of the month, {@code -2} is the second
     * to last day, and so on.
     */
    private final byte dom;
    /**
     * The cutover day-of-week, null to retain the day-of-month.
     */
    private final DayOfWeek dow;
    /**
     * The cutover time in the 'before' offset.
     */
    private final LocalTime time;
    /**
     * Whether the cutover time is midnight at the end of day.
     */
    private final boolean timeEndOfDay;
    /**
     * The definition of how the local time should be interpreted.
     */
    private final TimeDefinition timeDefinition;
    /**
     * The standard offset at the cutover.
     */
    private final ZoneOffset standardOffset;
    /**
     * The offset before the cutover.
     */
    private final ZoneOffset offsetBefore;
    /**
     * The offset after the cutover.
     */
    private final ZoneOffset offsetAfter;

    /**
     * Obtains an instance defining the yearly rule to create transitions between two offsets.
     * <p>
     * Applications should normally obtain an instance from {@link ZoneRules}.
     * This factory is only intended for use when creating {@link ZoneRules}.
     *
     * @param month  the month of the month-day of the first day of the cutover week, not null
     * @param dayOfMonthIndicator  the day of the month-day of the cutover week, positive if the week is that
     *  day or later, negative if the week is that day or earlier, counting from the last day of the month,
     *  from -28 to 31 excluding 0
     * @param dayOfWeek  the required day-of-week, null if the month-day should not be changed
     * @param time  the cutover time in the 'before' offset, not null
     * @param timeEndOfDay  whether the time is midnight at the end of day
     * @param timeDefnition  how to interpret the cutover
     * @param standardOffset  the standard offset in force at the cutover, not null
     * @param offsetBefore  the offset before the cutover, not null
     * @param offsetAfter  the offset after the cutover, not null
     * @return the rule, not null
     * @throws IllegalArgumentException if the day of month indicator is invalid
     * @throws IllegalArgumentException if the end of day flag is true when the time is not midnight
     * @throws IllegalArgumentException if {@code time.getNano()} returns non-zero value
     */
    public static ZoneOffsetTransitionRule of(
            Month month,
            int dayOfMonthIndicator,
            DayOfWeek dayOfWeek,
            LocalTime time,
            boolean timeEndOfDay,
            TimeDefinition timeDefnition,
            ZoneOffset standardOffset,
            ZoneOffset offsetBefore,
            ZoneOffset offsetAfter) {
        Objects.requireNonNull(month, ""month"");
        Objects.requireNonNull(time, ""time"");
        Objects.requireNonNull(timeDefnition, ""timeDefnition"");
        Objects.requireNonNull(standardOffset, ""standardOffset"");
        Objects.requireNonNull(offsetBefore, ""offsetBefore"");
        Objects.requireNonNull(offsetAfter, ""offsetAfter"");
        if (dayOfMonthIndicator < -28 || dayOfMonthIndicator > 31 || dayOfMonthIndicator == 0) {
            throw new IllegalArgumentException(""Day of month indicator must be between -28 and 31 inclusive excluding zero"");
        }
        if (timeEndOfDay && time.equals(LocalTime.MIDNIGHT) == false) {
            throw new IllegalArgumentException(""Time must be midnight when end of day flag is true"");
        }
        if (time.getNano() != 0) {
            throw new IllegalArgumentException(""Time's nano-of-second must be zero"");
        }
        return new ZoneOffsetTransitionRule(month, dayOfMonthIndicator, dayOfWeek, time, timeEndOfDay, timeDefnition, standardOffset, offsetBefore, offsetAfter);
    }

    /**
     * Creates an instance defining the yearly rule to create transitions between two offsets.
     *
     * @param month  the month of the month-day of the first day of the cutover week, not null
     * @param dayOfMonthIndicator  the day of the month-day of the cutover week, positive if the week is that
     *  day or later, negative if the week is that day or earlier, counting from the last day of the month,
     *  from -28 to 31 excluding 0
     * @param dayOfWeek  the required day-of-week, null if the month-day should not be changed
     * @param time  the cutover time in the 'before' offset, not null
     * @param timeEndOfDay  whether the time is midnight at the end of day
     * @param timeDefnition  how to interpret the cutover
     * @param standardOffset  the standard offset in force at the cutover, not null
     * @param offsetBefore  the offset before the cutover, not null
     * @param offsetAfter  the offset after the cutover, not null
     * @throws IllegalArgumentException if the day of month indicator is invalid
     * @throws IllegalArgumentException if the end of day flag is true when the time is not midnight
     */
    ZoneOffsetTransitionRule(
            Month month,
            int dayOfMonthIndicator,
            DayOfWeek dayOfWeek,
            LocalTime time,
            boolean timeEndOfDay,
            TimeDefinition timeDefnition,
            ZoneOffset standardOffset,
            ZoneOffset offsetBefore,
            ZoneOffset offsetAfter) {
        assert time.getNano() == 0;
        this.month = month;
        this.dom = (byte) dayOfMonthIndicator;
        this.dow = dayOfWeek;
        this.time = time;
        this.timeEndOfDay = timeEndOfDay;
        this.timeDefinition = timeDefnition;
        this.standardOffset = standardOffset;
        this.offsetBefore = offsetBefore;
        this.offsetAfter = offsetAfter;
    }

    //-----------------------------------------------------------------------
    /**
     * Defend against malicious streams.
     *
     * @param s the stream to read
     * @throws InvalidObjectException always
     */
    private void readObject(ObjectInputStream s) throws InvalidObjectException {
        throw new InvalidObjectException(""Deserialization via serialization delegate"");
    }

    /**
     * Writes the object using a
     * <a href=""{@docRoot}/serialized-form.html#java.time.zone.Ser"">dedicated serialized form</a>.
     * @serialData
     * Refer to the serialized form of
     * <a href=""{@docRoot}/serialized-form.html#java.time.zone.ZoneRules"">ZoneRules.writeReplace</a>
     * for the encoding of epoch seconds and offsets.
     * <pre style=""font-size:1.0em"">{@code
     *
     *      out.writeByte(3);                // identifies a ZoneOffsetTransition
     *      final int timeSecs = (timeEndOfDay ? 86400 : time.toSecondOfDay());
     *      final int stdOffset = standardOffset.getTotalSeconds();
     *      final int beforeDiff = offsetBefore.getTotalSeconds() - stdOffset;
     *      final int afterDiff = offsetAfter.getTotalSeconds() - stdOffset;
     *      final int timeByte = (timeSecs % 3600 == 0 ? (timeEndOfDay ? 24 : time.getHour()) : 31);
     *      final int stdOffsetByte = (stdOffset % 900 == 0 ? stdOffset / 900 + 128 : 255);
     *      final int beforeByte = (beforeDiff == 0 || beforeDiff == 1800 || beforeDiff == 3600 ? beforeDiff / 1800 : 3);
     *      final int afterByte = (afterDiff == 0 || afterDiff == 1800 || afterDiff == 3600 ? afterDiff / 1800 : 3);
     *      final int dowByte = (dow == null ? 0 : dow.getValue());
     *      int b = (month.getValue() << 28) +          // 4 bits
     *              ((dom + 32) << 22) +                // 6 bits
     *              (dowByte << 19) +                   // 3 bits
     *              (timeByte << 14) +                  // 5 bits
     *              (timeDefinition.ordinal() << 12) +  // 2 bits
     *              (stdOffsetByte << 4) +              // 8 bits
     *              (beforeByte << 2) +                 // 2 bits
     *              afterByte;                          // 2 bits
     *      out.writeInt(b);
     *      if (timeByte == 31) {
     *          out.writeInt(timeSecs);
     *      }
     *      if (stdOffsetByte == 255) {
     *          out.writeInt(stdOffset);
     *      }
     *      if (beforeByte == 3) {
     *          out.writeInt(offsetBefore.getTotalSeconds());
     *      }
     *      if (afterByte == 3) {
     *          out.writeInt(offsetAfter.getTotalSeconds());
     *      }
     * }
     * </pre>
     *
     * @return the replacing object, not null
     */
    private Object writeReplace() {
        return new Ser(Ser.ZOTRULE, this);
    }

    /**
     * Writes the state to the stream.
     *
     * @param out  the output stream, not null
     * @throws IOException if an error occurs
     */
    void writeExternal(DataOutput out) throws IOException {
        final int timeSecs = (timeEndOfDay ? 86400 : time.toSecondOfDay());
        final int stdOffset = standardOffset.getTotalSeconds();
        final int beforeDiff = offsetBefore.getTotalSeconds() - stdOffset;
        final int afterDiff = offsetAfter.getTotalSeconds() - stdOffset;
        final int timeByte = (timeSecs % 3600 == 0 ? (timeEndOfDay ? 24 : time.getHour()) : 31);
        final int stdOffsetByte = (stdOffset % 900 == 0 ? stdOffset / 900 + 128 : 255);
        final int beforeByte = (beforeDiff == 0 || beforeDiff == 1800 || beforeDiff == 3600 ? beforeDiff / 1800 : 3);
        final int afterByte = (afterDiff == 0 || afterDiff == 1800 || afterDiff == 3600 ? afterDiff / 1800 : 3);
        final int dowByte = (dow == null ? 0 : dow.getValue());
        int b = (month.getValue() << 28) +          // 4 bits
                ((dom + 32) << 22) +                // 6 bits
                (dowByte << 19) +                   // 3 bits
                (timeByte << 14) +                  // 5 bits
                (timeDefinition.ordinal() << 12) +  // 2 bits
                (stdOffsetByte << 4) +              // 8 bits
                (beforeByte << 2) +                 // 2 bits
                afterByte;                          // 2 bits
        out.writeInt(b);
        if (timeByte == 31) {
            out.writeInt(timeSecs);
        }
        if (stdOffsetByte == 255) {
            out.writeInt(stdOffset);
        }
        if (beforeByte == 3) {
            out.writeInt(offsetBefore.getTotalSeconds());
        }
        if (afterByte == 3) {
            out.writeInt(offsetAfter.getTotalSeconds());
        }
    }

    /**
     * Reads the state from the stream.
     *
     * @param in  the input stream, not null
     * @return the created object, not null
     * @throws IOException if an error occurs
     */
    static ZoneOffsetTransitionRule readExternal(DataInput in) throws IOException {
        int data = in.readInt();
        Month month = Month.of(data >>> 28);
        int dom = ((data & (63 << 22)) >>> 22) - 32;
        int dowByte = (data & (7 << 19)) >>> 19;
        DayOfWeek dow = dowByte == 0 ? null : DayOfWeek.of(dowByte);
        int timeByte = (data & (31 << 14)) >>> 14;
        TimeDefinition defn = TimeDefinition.values()[(data & (3 << 12)) >>> 12];
        int stdByte = (data & (255 << 4)) >>> 4;
        int beforeByte = (data & (3 << 2)) >>> 2;
        int afterByte = (data & 3);
        LocalTime time = (timeByte == 31 ? LocalTime.ofSecondOfDay(in.readInt()) : LocalTime.of(timeByte % 24, 0));
        ZoneOffset std = (stdByte == 255 ? ZoneOffset.ofTotalSeconds(in.readInt()) : ZoneOffset.ofTotalSeconds((stdByte - 128) * 900));
        ZoneOffset before = (beforeByte == 3 ? ZoneOffset.ofTotalSeconds(in.readInt()) : ZoneOffset.ofTotalSeconds(std.getTotalSeconds() + beforeByte * 1800));
        ZoneOffset after = (afterByte == 3 ? ZoneOffset.ofTotalSeconds(in.readInt()) : ZoneOffset.ofTotalSeconds(std.getTotalSeconds() + afterByte * 1800));
        return ZoneOffsetTransitionRule.of(month, dom, dow, time, timeByte == 24, defn, std, before, after);
    }

    //-----------------------------------------------------------------------
    /**
     * Gets the month of the transition.
     * <p>
     * If the rule defines an exact date then the month is the month of that date.
     * <p>
     * If the rule defines a week where the transition might occur, then the month
     * if the month of either the earliest or latest possible date of the cutover.
     *
     * @return the month of the transition, not null
     */
    public Month getMonth() {
        return month;
    }

    /**
     * Gets the indicator of the day-of-month of the transition.
     * <p>
     * If the rule defines an exact date then the day is the month of that date.
     * <p>
     * If the rule defines a week where the transition might occur, then the day
     * defines either the start of the end of the transition week.
     * <p>
     * If the value is positive, then it represents a normal day-of-month, and is the
     * earliest possible date that the transition can be.
     * The date may refer to 29th February which should be treated as 1st March in non-leap years.
     * <p>
     * If the value is negative, then it represents the number of days back from the
     * end of the month where {@code -1} is the last day of the month.
     * In this case, the day identified is the latest possible date that the transition can be.
     *
     * @return the day-of-month indicator, from -28 to 31 excluding 0
     */
    public int getDayOfMonthIndicator() {
        return dom;
    }

    /**
     * Gets the day-of-week of the transition.
     * <p>
     * If the rule defines an exact date then this returns null.
     * <p>
     * If the rule defines a week where the cutover might occur, then this method
     * returns the day-of-week that the month-day will be adjusted to.
     * If the day is positive then the adjustment is later.
     * If the day is negative then the adjustment is earlier.
     *
     * @return the day-of-week that the transition occurs, null if the rule defines an exact date
     */
    public DayOfWeek getDayOfWeek() {
        return dow;
    }

    /**
     * Gets the local time of day of the transition which must be checked with
     * {@link #isMidnightEndOfDay()}.
     * <p>
     * The time is converted into an instant using the time definition.
     *
     * @return the local time of day of the transition, not null
     */
    public LocalTime getLocalTime() {
        return time;
    }

    /**
     * Is the transition local time midnight at the end of day.
     * <p>
     * The transition may be represented as occurring at 24:00.
     *
     * @return whether a local time of midnight is at the start or end of the day
     */
    public boolean isMidnightEndOfDay() {
        return timeEndOfDay;
    }

    /**
     * Gets the time definition, specifying how to convert the time to an instant.
     * <p>
     * The local time can be converted to an instant using the standard offset,
     * the wall offset or UTC.
     *
     * @return the time definition, not null
     */
    public TimeDefinition getTimeDefinition() {
        return timeDefinition;
    }

    /**
     * Gets the standard offset in force at the transition.
     *
     * @return the standard offset, not null
     */
    public ZoneOffset getStandardOffset() {
        return standardOffset;
    }

    /**
     * Gets the offset before the transition.
     *
     * @return the offset before, not null
     */
    public ZoneOffset getOffsetBefore() {
        return offsetBefore;
    }

    /**
     * Gets the offset after the transition.
     *
     * @return the offset after, not null
     */
    public ZoneOffset getOffsetAfter() {
        return offsetAfter;
    }

    //-----------------------------------------------------------------------
    /**
     * Creates a transition instance for the specified year.
     * <p>
     * Calculations are performed using the ISO-8601 chronology.
     *
     * @param year  the year to create a transition for, not null
     * @return the transition instance, not null
     */
    public ZoneOffsetTransition createTransition(int year) {
        LocalDate date;
        if (dom < 0) {
            date = LocalDate.of(year, month, month.length(IsoChronology.INSTANCE.isLeapYear(year)) + 1 + dom);
            if (dow != null) {
                date = date.with(previousOrSame(dow));
            }
        } else {
            date = LocalDate.of(year, month, dom);
            if (dow != null) {
                date = date.with(nextOrSame(dow));
            }
        }
        if (timeEndOfDay) {
            date = date.plusDays(1);
        }
        LocalDateTime localDT = LocalDateTime.of(date, time);
        LocalDateTime transition = timeDefinition.createDateTime(localDT, standardOffset, offsetBefore);
        return new ZoneOffsetTransition(transition, offsetBefore, offsetAfter);
    }

    //-----------------------------------------------------------------------
    /**
     * Checks if this object equals another.
     * <p>
     * The entire state of the object is compared.
     *
     * @param otherRule  the other object to compare to, null returns false
     * @return true if equal
     */
    @Override
    public boolean equals(Object otherRule) {
        if (otherRule == this) {
            return true;
        }
        if (otherRule instanceof ZoneOffsetTransitionRule) {
            ZoneOffsetTransitionRule other = (ZoneOffsetTransitionRule) otherRule;
            return month == other.month && dom == other.dom && dow == other.dow &&
                timeDefinition == other.timeDefinition &&
                time.equals(other.time) &&
                timeEndOfDay == other.timeEndOfDay &&
                standardOffset.equals(other.standardOffset) &&
                offsetBefore.equals(other.offsetBefore) &&
                offsetAfter.equals(other.offsetAfter);
        }
        return false;
    }

    /**
     * Returns a suitable hash code.
     *
     * @return the hash code
     */
    @Override
    public int hashCode() {
        int hash = ((time.toSecondOfDay() + (timeEndOfDay ? 1 : 0)) << 15) +
                (month.ordinal() << 11) + ((dom + 32) << 5) +
                ((dow == null ? 7 : dow.ordinal()) << 2) + (timeDefinition.ordinal());
        return hash ^ standardOffset.hashCode() ^
                offsetBefore.hashCode() ^ offsetAfter.hashCode();
    }

    //-----------------------------------------------------------------------
    /**
     * Returns a string describing this object.
     *
     * @return a string for debugging, not null
     */
    @Override
    public String toString() {
        StringBuilder buf = new StringBuilder();
        buf.append(""TransitionRule["")
            .append(offsetBefore.compareTo(offsetAfter) > 0 ? ""Gap "" : ""Overlap "")
            .append(offsetBefore).append("" to "").append(offsetAfter).append("", "");
        if (dow != null) {
            if (dom == -1) {
                buf.append(dow.name()).append("" on or before last day of "").append(month.name());
            } else if (dom < 0) {
                buf.append(dow.name()).append("" on or before last day minus "").append(-dom - 1).append("" of "").append(month.name());
            } else {
                buf.append(dow.name()).append("" on or after "").append(month.name()).append(' ').append(dom);
            }
        } else {
            buf.append(month.name()).append(' ').append(dom);
        }
        buf.append("" at "").append(timeEndOfDay ? ""24:00"" : time.toString())
            .append("" "").append(timeDefinition)
            .append("", standard offset "").append(standardOffset)
            .append(']');
        return buf.toString();
    }

    //-----------------------------------------------------------------------
    /**
     * A definition of the way a local time can be converted to the actual
     * transition date-time.
     * <p>
     * Time zone rules are expressed in one of three ways:
     * <ul>
     * <li>Relative to UTC</li>
     * <li>Relative to the standard offset in force</li>
     * <li>Relative to the wall offset (what you would see on a clock on the wall)</li>
     * </ul>
     */
    public static enum TimeDefinition {
        /** The local date-time is expressed in terms of the UTC offset. */
        UTC,
        /** The local date-time is expressed in terms of the wall offset. */
        WALL,
        /** The local date-time is expressed in terms of the standard offset. */
        STANDARD;

        /**
         * Converts the specified local date-time to the local date-time actually
         * seen on a wall clock.
         * <p>
         * This method converts using the type of this enum.
         * The output is defined relative to the 'before' offset of the transition.
         * <p>
         * The UTC type uses the UTC offset.
         * The STANDARD type uses the standard offset.
         * The WALL type returns the input date-time.
         * The result is intended for use with the wall-offset.
         *
         * @param dateTime  the local date-time, not null
         * @param standardOffset  the standard offset, not null
         * @param wallOffset  the wall offset, not null
         * @return the date-time relative to the wall/before offset, not null
         */
        public LocalDateTime createDateTime(LocalDateTime dateTime, ZoneOffset standardOffset, ZoneOffset wallOffset) {
            switch (this) {
                case UTC: {
                    int difference = wallOffset.getTotalSeconds() - ZoneOffset.UTC.getTotalSeconds();
                    return dateTime.plusSeconds(difference);
                }
                case STANDARD: {
                    int difference = wallOffset.getTotalSeconds() - standardOffset.getTotalSeconds();
                    return dateTime.plusSeconds(difference);
                }
                default:  // WALL
                    return dateTime;
            }
        }
    }

}
",blob
1319,"public class SchemaAndValue {
    private final Schema schema;
    private final Object value;

    public static final SchemaAndValue NULL = new SchemaAndValue(null, null);

    public SchemaAndValue(Schema schema, Object value) {
        this.value = value;
        this.schema = schema;
    }

    public Schema schema() {
        return schema;
    }

    public Object value() {
        return value;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        SchemaAndValue that = (SchemaAndValue) o;
        return Objects.equals(schema, that.schema) &&
                Objects.equals(value, that.value);
    }

    @Override
    public int hashCode() {
        return Objects.hash(schema, value);
    }

    @Override
    public String toString() {
        return ""SchemaAndValue{"" +
                ""schema="" + schema +
                "", value="" + value +
                '}';
    }
}
",data class
1444,"class Segment {
    private byte segmentType;

    Segment(byte segmentType) {
        this.segmentType = segmentType;
    }

    /**
     * Returns the segmentType value.
     * 
     * @return byte segmentType value.
     */
    public byte getSegmentType() {
        return segmentType;
    }
}
",data class
652,"    @Override
    public int setPath(Path2D path) {
        Rectangle2D bounds = path.getBounds2D();
        PathIterator it = path.getPathIterator(null);

        List<byte[]> segInfo = new ArrayList<>();
        List<Point2D.Double> pntInfo = new ArrayList<>();
        boolean isClosed = false;
        int numPoints = 0;
        while (!it.isDone()) {
            double[] vals = new double[6];
            int type = it.currentSegment(vals);
            switch (type) {
                case PathIterator.SEG_MOVETO:
                    pntInfo.add(new Point2D.Double(vals[0], vals[1]));
                    segInfo.add(SEGMENTINFO_MOVETO);
                    numPoints++;
                    break;
                case PathIterator.SEG_LINETO:
                    pntInfo.add(new Point2D.Double(vals[0], vals[1]));
                    segInfo.add(SEGMENTINFO_LINETO);
                    segInfo.add(SEGMENTINFO_ESCAPE);
                    numPoints++;
                    break;
                case PathIterator.SEG_CUBICTO:
                    pntInfo.add(new Point2D.Double(vals[0], vals[1]));
                    pntInfo.add(new Point2D.Double(vals[2], vals[3]));
                    pntInfo.add(new Point2D.Double(vals[4], vals[5]));
                    segInfo.add(SEGMENTINFO_CUBICTO);
                    segInfo.add(SEGMENTINFO_ESCAPE2);
                    numPoints++;
                    break;
                case PathIterator.SEG_QUADTO:
                    //TODO: figure out how to convert SEG_QUADTO into SEG_CUBICTO
                    LOG.log(POILogger.WARN, ""SEG_QUADTO is not supported"");
                    break;
                case PathIterator.SEG_CLOSE:
                    pntInfo.add(pntInfo.get(0));
                    segInfo.add(SEGMENTINFO_LINETO);
                    segInfo.add(SEGMENTINFO_ESCAPE);
                    segInfo.add(SEGMENTINFO_LINETO);
                    segInfo.add(SEGMENTINFO_CLOSE);
                    isClosed = true;
                    numPoints++;
                    break;
                default:
                    LOG.log(POILogger.WARN, ""Ignoring invalid segment type ""+type);
                    break;
            }

            it.next();
        }
        if(!isClosed) {
            segInfo.add(SEGMENTINFO_LINETO);
        }
        segInfo.add(SEGMENTINFO_END);

        AbstractEscherOptRecord opt = getEscherOptRecord();
        opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.GEOMETRY__SHAPEPATH, 0x4));

        EscherArrayProperty verticesProp = new EscherArrayProperty((short)(EscherProperties.GEOMETRY__VERTICES + 0x4000), false, null);
        verticesProp.setNumberOfElementsInArray(pntInfo.size());
        verticesProp.setNumberOfElementsInMemory(pntInfo.size());
        verticesProp.setSizeOfElements(8);
        for (int i = 0; i < pntInfo.size(); i++) {
            Point2D.Double pnt = pntInfo.get(i);
            byte[] data = new byte[8];
            LittleEndian.putInt(data, 0, Units.pointsToMaster(pnt.getX() - bounds.getX()));
            LittleEndian.putInt(data, 4, Units.pointsToMaster(pnt.getY() - bounds.getY()));
            verticesProp.setElement(i, data);
        }
        opt.addEscherProperty(verticesProp);

        EscherArrayProperty segmentsProp = new EscherArrayProperty((short)(EscherProperties.GEOMETRY__SEGMENTINFO + 0x4000), false, null);
        segmentsProp.setNumberOfElementsInArray(segInfo.size());
        segmentsProp.setNumberOfElementsInMemory(segInfo.size());
        segmentsProp.setSizeOfElements(0x2);
        for (int i = 0; i < segInfo.size(); i++) {
            byte[] seg = segInfo.get(i);
            segmentsProp.setElement(i, seg);
        }
        opt.addEscherProperty(segmentsProp);

        opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.GEOMETRY__RIGHT, Units.pointsToMaster(bounds.getWidth())));
        opt.addEscherProperty(new EscherSimpleProperty(EscherProperties.GEOMETRY__BOTTOM, Units.pointsToMaster(bounds.getHeight())));

        opt.sortProperties();

        setAnchor(bounds);

        return numPoints;
    }
",long method
229,"    public static Class<?> getPropertyEditorClass(final Object bean, final String name)
            throws IllegalAccessException, InvocationTargetException,
            NoSuchMethodException {

        return PropertyUtilsBean.getInstance().getPropertyEditorClass(bean, name);

    }
",feature envy
804,"  private static String normalizePath(String path) {
    // count the number of '/'s, to determine number of segments
    int index = -1;
    int pathlen = path.length();
    int size = 0;
    if (pathlen > 0 && path.charAt(0) != '/') {
      size++;
    }
    while ((index = path.indexOf('/', index + 1)) != -1) {
      if (index + 1 < pathlen && path.charAt(index + 1) != '/') {
        size++;
      }
    }

    String[] seglist = new String[size];
    boolean[] include = new boolean[size];

    // break the path into segments and store in the list
    int current = 0;
    int index2 = 0;
    index = (pathlen > 0 && path.charAt(0) == '/') ? 1 : 0;
    while ((index2 = path.indexOf('/', index + 1)) != -1) {
      seglist[current++] = path.substring(index, index2);
      index = index2 + 1;
    }

    // if current==size, then the last character was a slash
    // and there are no more segments
    if (current < size) {
      seglist[current] = path.substring(index);
    }

    // determine which segments get included in the normalized path
    for (int i = 0; i < size; i++) {
      include[i] = true;
      if (seglist[i].equals("".."")) { //$NON-NLS-1$
        int remove = i - 1;
        // search back to find a segment to remove, if possible
        while (remove > -1 && !include[remove]) {
          remove--;
        }
        // if we find a segment to remove, remove it and the ""..""
        // segment
        if (remove > -1 && !seglist[remove].equals("".."")) { //$NON-NLS-1$
          include[remove] = false;
          include[i] = false;
        }
      } else if (seglist[i].equals(""."")) { //$NON-NLS-1$
        include[i] = false;
      }
    }

    // put the path back together
    StringBuilder newpath = new StringBuilder();
    if (path.startsWith(""/"")) { //$NON-NLS-1$
      newpath.append('/');
    }

    for (int i = 0; i < seglist.length; i++) {
      if (include[i]) {
        newpath.append(seglist[i]);
        newpath.append('/');
      }
    }

    // if we used at least one segment and the path previously ended with
    // a slash and the last segment is still used, then delete the extra
    // trailing '/'
    if (!path.endsWith(""/"") && seglist.length > 0 //$NON-NLS-1$
        && include[seglist.length - 1]) {
      newpath.deleteCharAt(newpath.length() - 1);
    }

    String result = newpath.toString();

    // check for a ':' in the first segment if one exists,
    // prepend ""./"" to normalize
    index = result.indexOf(':');
    index2 = result.indexOf('/');
    if (index != -1 && (index < index2 || index2 == -1)) {
      newpath.insert(0, ""./""); //$NON-NLS-1$
      result = newpath.toString();
    }
    return result;
  }
",long method
1077,"    public final EObject ruleXOtherOperatorExpression() throws RecognitionException {
        EObject current = null;

        EObject this_XAdditiveExpression_0 = null;

        EObject lv_rightOperand_3_0 = null;



        	enterRule();

        try {
            // InternalXbase.g:873:2: ( (this_XAdditiveExpression_0= ruleXAdditiveExpression ( ( ( ( () ( ( ruleOpOther ) ) ) )=> ( () ( ( ruleOpOther ) ) ) ) ( (lv_rightOperand_3_0= ruleXAdditiveExpression ) ) )* ) )
            // InternalXbase.g:874:2: (this_XAdditiveExpression_0= ruleXAdditiveExpression ( ( ( ( () ( ( ruleOpOther ) ) ) )=> ( () ( ( ruleOpOther ) ) ) ) ( (lv_rightOperand_3_0= ruleXAdditiveExpression ) ) )* )
            {
            // InternalXbase.g:874:2: (this_XAdditiveExpression_0= ruleXAdditiveExpression ( ( ( ( () ( ( ruleOpOther ) ) ) )=> ( () ( ( ruleOpOther ) ) ) ) ( (lv_rightOperand_3_0= ruleXAdditiveExpression ) ) )* )
            // InternalXbase.g:875:3: this_XAdditiveExpression_0= ruleXAdditiveExpression ( ( ( ( () ( ( ruleOpOther ) ) ) )=> ( () ( ( ruleOpOther ) ) ) ) ( (lv_rightOperand_3_0= ruleXAdditiveExpression ) ) )*
            {
            if ( state.backtracking==0 ) {

              			newCompositeNode(grammarAccess.getXOtherOperatorExpressionAccess().getXAdditiveExpressionParserRuleCall_0());
              		
            }
            pushFollow(FOLLOW_14);
            this_XAdditiveExpression_0=ruleXAdditiveExpression();

            state._fsp--;
            if (state.failed) return current;
            if ( state.backtracking==0 ) {

              			current = this_XAdditiveExpression_0;
              			afterParserOrEnumRuleCall();
              		
            }
            // InternalXbase.g:883:3: ( ( ( ( () ( ( ruleOpOther ) ) ) )=> ( () ( ( ruleOpOther ) ) ) ) ( (lv_rightOperand_3_0= ruleXAdditiveExpression ) ) )*
            loop11:
            do {
                int alt11=2;
                alt11 = dfa11.predict(input);
                switch (alt11) {
            	case 1 :
            	    // InternalXbase.g:884:4: ( ( ( () ( ( ruleOpOther ) ) ) )=> ( () ( ( ruleOpOther ) ) ) ) ( (lv_rightOperand_3_0= ruleXAdditiveExpression ) )
            	    {
            	    // InternalXbase.g:884:4: ( ( ( () ( ( ruleOpOther ) ) ) )=> ( () ( ( ruleOpOther ) ) ) )
            	    // InternalXbase.g:885:5: ( ( () ( ( ruleOpOther ) ) ) )=> ( () ( ( ruleOpOther ) ) )
            	    {
            	    // InternalXbase.g:895:5: ( () ( ( ruleOpOther ) ) )
            	    // InternalXbase.g:896:6: () ( ( ruleOpOther ) )
            	    {
            	    // InternalXbase.g:896:6: ()
            	    // InternalXbase.g:897:7: 
            	    {
            	    if ( state.backtracking==0 ) {

            	      							current = forceCreateModelElementAndSet(
            	      								grammarAccess.getXOtherOperatorExpressionAccess().getXBinaryOperationLeftOperandAction_1_0_0_0(),
            	      								current);
            	      						
            	    }

            	    }

            	    // InternalXbase.g:903:6: ( ( ruleOpOther ) )
            	    // InternalXbase.g:904:7: ( ruleOpOther )
            	    {
            	    // InternalXbase.g:904:7: ( ruleOpOther )
            	    // InternalXbase.g:905:8: ruleOpOther
            	    {
            	    if ( state.backtracking==0 ) {

            	      								if (current==null) {
            	      									current = createModelElement(grammarAccess.getXOtherOperatorExpressionRule());
            	      								}
            	      							
            	    }
            	    if ( state.backtracking==0 ) {

            	      								newCompositeNode(grammarAccess.getXOtherOperatorExpressionAccess().getFeatureJvmIdentifiableElementCrossReference_1_0_0_1_0());
            	      							
            	    }
            	    pushFollow(FOLLOW_4);
            	    ruleOpOther();

            	    state._fsp--;
            	    if (state.failed) return current;
            	    if ( state.backtracking==0 ) {

            	      								afterParserOrEnumRuleCall();
            	      							
            	    }

            	    }


            	    }


            	    }


            	    }

            	    // InternalXbase.g:921:4: ( (lv_rightOperand_3_0= ruleXAdditiveExpression ) )
            	    // InternalXbase.g:922:5: (lv_rightOperand_3_0= ruleXAdditiveExpression )
            	    {
            	    // InternalXbase.g:922:5: (lv_rightOperand_3_0= ruleXAdditiveExpression )
            	    // InternalXbase.g:923:6: lv_rightOperand_3_0= ruleXAdditiveExpression
            	    {
            	    if ( state.backtracking==0 ) {

            	      						newCompositeNode(grammarAccess.getXOtherOperatorExpressionAccess().getRightOperandXAdditiveExpressionParserRuleCall_1_1_0());
            	      					
            	    }
            	    pushFollow(FOLLOW_14);
            	    lv_rightOperand_3_0=ruleXAdditiveExpression();

            	    state._fsp--;
            	    if (state.failed) return current;
            	    if ( state.backtracking==0 ) {

            	      						if (current==null) {
            	      							current = createModelElementForParent(grammarAccess.getXOtherOperatorExpressionRule());
            	      						}
            	      						set(
            	      							current,
            	      							""rightOperand"",
            	      							lv_rightOperand_3_0,
            	      							""org.eclipse.xtext.xbase.Xbase.XAdditiveExpression"");
            	      						afterParserOrEnumRuleCall();
            	      					
            	    }

            	    }


            	    }


            	    }
            	    break;

            	default :
            	    break loop11;
                }
            } while (true);


            }


            }

            if ( state.backtracking==0 ) {

              	leaveRule();

            }
        }

            catch (RecognitionException re) {
                recover(input,re);
                appendSkippedTokens();
            }
        finally {
        }
        return current;
    }
",long method
169,"      @AutoValue
      public abstract static class CreatePayload {

         public abstract String name();

         public abstract Location location();

      }
",data class
48,"    public static class State {
        public Map<String, String> properties = new HashMap<String, String>();
        public Map<String, String[]> array_properties = new HashMap<String, String[]>();
    }
",data class
662,"	public static Dataset[] generateCoordinates(Dataset angles, final double[] geometricParameters) {
		if (geometricParameters.length != PARAMETERS)
			throw new IllegalArgumentException(""Need "" + PARAMETERS + "" parameters"");

		Dataset[] coords = new Dataset[2];

		DoubleDataset x = DatasetFactory.zeros(DoubleDataset.class, angles.getShape());
		DoubleDataset y = DatasetFactory.zeros(DoubleDataset.class, angles.getShape());
		coords[0] = x;
		coords[1] = y;

		final double ca = Math.cos(geometricParameters[2]);
		final double sa = Math.sin(geometricParameters[2]);
		final IndexIterator it = angles.getIterator();

		int i = 0;
		
		while (it.hasNext()) {
			final double t = angles.getElementDoubleAbs(it.index);
			final double ct = Math.cos(t);
			final double st = Math.sin(t);
			x.setAbs(i, geometricParameters[3] + geometricParameters[0]*ca*ct - geometricParameters[1]*sa*st);
			y.setAbs(i, geometricParameters[4] + geometricParameters[0]*sa*ct + geometricParameters[1]*ca*st);
			i++;
		}
		return coords;
	}
",feature envy
840,"@javax.annotation.Generated(value = ""OracleSDKGenerator"", comments = ""API Version: 20180115"")
@lombok.AllArgsConstructor(onConstructor = @__({@Deprecated}))
@lombok.Value
@com.fasterxml.jackson.databind.annotation.JsonDeserialize(
    builder = CreateZoneDetails.Builder.class
)
@com.fasterxml.jackson.annotation.JsonFilter(com.oracle.bmc.http.internal.ExplicitlySetFilter.NAME)
public class CreateZoneDetails {
    @com.fasterxml.jackson.databind.annotation.JsonPOJOBuilder(withPrefix = """")
    @lombok.experimental.Accessors(fluent = true)
    public static class Builder {
        @com.fasterxml.jackson.annotation.JsonProperty(""name"")
        private String name;

        public Builder name(String name) {
            this.name = name;
            this.__explicitlySet__.add(""name"");
            return this;
        }

        @com.fasterxml.jackson.annotation.JsonProperty(""zoneType"")
        private ZoneType zoneType;

        public Builder zoneType(ZoneType zoneType) {
            this.zoneType = zoneType;
            this.__explicitlySet__.add(""zoneType"");
            return this;
        }

        @com.fasterxml.jackson.annotation.JsonProperty(""compartmentId"")
        private String compartmentId;

        public Builder compartmentId(String compartmentId) {
            this.compartmentId = compartmentId;
            this.__explicitlySet__.add(""compartmentId"");
            return this;
        }

        @com.fasterxml.jackson.annotation.JsonProperty(""freeformTags"")
        private java.util.Map<String, String> freeformTags;

        public Builder freeformTags(java.util.Map<String, String> freeformTags) {
            this.freeformTags = freeformTags;
            this.__explicitlySet__.add(""freeformTags"");
            return this;
        }

        @com.fasterxml.jackson.annotation.JsonProperty(""definedTags"")
        private java.util.Map<String, java.util.Map<String, Object>> definedTags;

        public Builder definedTags(
                java.util.Map<String, java.util.Map<String, Object>> definedTags) {
            this.definedTags = definedTags;
            this.__explicitlySet__.add(""definedTags"");
            return this;
        }

        @com.fasterxml.jackson.annotation.JsonProperty(""externalMasters"")
        private java.util.List<ExternalMaster> externalMasters;

        public Builder externalMasters(java.util.List<ExternalMaster> externalMasters) {
            this.externalMasters = externalMasters;
            this.__explicitlySet__.add(""externalMasters"");
            return this;
        }

        @com.fasterxml.jackson.annotation.JsonIgnore
        private final java.util.Set<String> __explicitlySet__ = new java.util.HashSet<String>();

        public CreateZoneDetails build() {
            CreateZoneDetails __instance__ =
                    new CreateZoneDetails(
                            name,
                            zoneType,
                            compartmentId,
                            freeformTags,
                            definedTags,
                            externalMasters);
            __instance__.__explicitlySet__.addAll(__explicitlySet__);
            return __instance__;
        }

        @com.fasterxml.jackson.annotation.JsonIgnore
        public Builder copy(CreateZoneDetails o) {
            Builder copiedBuilder =
                    name(o.getName())
                            .zoneType(o.getZoneType())
                            .compartmentId(o.getCompartmentId())
                            .freeformTags(o.getFreeformTags())
                            .definedTags(o.getDefinedTags())
                            .externalMasters(o.getExternalMasters());

            copiedBuilder.__explicitlySet__.retainAll(o.__explicitlySet__);
            return copiedBuilder;
        }
    }

    /**
     * Create a new builder.
     */
    public static Builder builder() {
        return new Builder();
    }

    /**
     * The name of the zone.
     **/
    @com.fasterxml.jackson.annotation.JsonProperty(""name"")
    String name;
    /**
     * The type of the zone. Must be either `PRIMARY` or `SECONDARY`.
     *
     **/
    public enum ZoneType {
        Primary(""PRIMARY""),
        Secondary(""SECONDARY""),
        ;

        private final String value;
        private static java.util.Map<String, ZoneType> map;

        static {
            map = new java.util.HashMap<>();
            for (ZoneType v : ZoneType.values()) {
                map.put(v.getValue(), v);
            }
        }

        ZoneType(String value) {
            this.value = value;
        }

        @com.fasterxml.jackson.annotation.JsonValue
        public String getValue() {
            return value;
        }

        @com.fasterxml.jackson.annotation.JsonCreator
        public static ZoneType create(String key) {
            if (map.containsKey(key)) {
                return map.get(key);
            }
            throw new RuntimeException(""Invalid ZoneType: "" + key);
        }
    };
    /**
     * The type of the zone. Must be either `PRIMARY` or `SECONDARY`.
     *
     **/
    @com.fasterxml.jackson.annotation.JsonProperty(""zoneType"")
    ZoneType zoneType;

    /**
     * The OCID of the compartment containing the zone.
     **/
    @com.fasterxml.jackson.annotation.JsonProperty(""compartmentId"")
    String compartmentId;

    /**
     * Simple key-value pair that is applied without any predefined name, type, or scope.
     * For more information, see [Resource Tags](https://docs.cloud.oracle.com/Content/General/Concepts/resourcetags.htm).
     * Example: `{\""bar-key\"": \""value\""}`
     *
     **/
    @com.fasterxml.jackson.annotation.JsonProperty(""freeformTags"")
    java.util.Map<String, String> freeformTags;

    /**
     * Usage of predefined tag keys. These predefined keys are scoped to a namespace.
     * Example: `{\""foo-namespace\"": {\""bar-key\"": \""value\""}}`
     *
     **/
    @com.fasterxml.jackson.annotation.JsonProperty(""definedTags"")
    java.util.Map<String, java.util.Map<String, Object>> definedTags;

    /**
     * External master servers for the zone. `externalMasters` becomes a
     * required parameter when the `zoneType` value is `SECONDARY`.
     *
     **/
    @com.fasterxml.jackson.annotation.JsonProperty(""externalMasters"")
    java.util.List<ExternalMaster> externalMasters;

    @com.fasterxml.jackson.annotation.JsonIgnore
    private final java.util.Set<String> __explicitlySet__ = new java.util.HashSet<String>();
}
",data class
1372,"public class DataSourceLoginService extends AbstractLoginService
{
    private static final Logger LOG = Log.getLogger(DataSourceLoginService.class);

    private String _jndiName = ""javax.sql.DataSource/default"";
    private DataSource _datasource;
    private Server _server;
    private String _userTableName = ""users"";
    private String _userTableKey = ""id"";
    private String _userTableUserField = ""username"";
    private String _userTablePasswordField = ""pwd"";
    private String _roleTableName = ""roles"";
    private String _roleTableKey = ""id"";
    private String _roleTableRoleField = ""role"";
    private String _userRoleTableName = ""user_roles"";
    private String _userRoleTableUserKey = ""user_id"";
    private String _userRoleTableRoleKey = ""role_id"";
    private String _userSql;
    private String _roleSql;
    private boolean _createTables = false;
    
    
    /**
     * DBUser
     */
    public class DBUserPrincipal extends UserPrincipal
    {
        private int _key;
        
        public DBUserPrincipal(String name, Credential credential, int key)
        {
            super(name, credential);
            _key = key;
        }
        
        public int getKey ()
        {
            return _key;
        }
        
    }

    /* ------------------------------------------------------------ */
    public DataSourceLoginService()
    {
    }

    /* ------------------------------------------------------------ */
    public DataSourceLoginService(String name)
    {
        setName(name);
    }

    /* ------------------------------------------------------------ */
    public DataSourceLoginService(String name, IdentityService identityService)
    {
        setName(name);
        setIdentityService(identityService);
    }

    /* ------------------------------------------------------------ */
    public void setJndiName (String jndi)
    {
        _jndiName = jndi;
    }

    /* ------------------------------------------------------------ */
    public String getJndiName ()
    {
        return _jndiName;
    }

    /* ------------------------------------------------------------ */
    public void setServer (Server server)
    {
        _server=server;
    }

    /* ------------------------------------------------------------ */
    public Server getServer()
    {
        return _server;
    }

    /* ------------------------------------------------------------ */
    public void setCreateTables(boolean createTables)
    {
        _createTables = createTables;
    }

    /* ------------------------------------------------------------ */
    public boolean getCreateTables()
    {
        return _createTables;
    }

    /* ------------------------------------------------------------ */
    public void setUserTableName (String name)
    {
        _userTableName=name;
    }

    /* ------------------------------------------------------------ */
    public String getUserTableName()
    {
        return _userTableName;
    }

    /* ------------------------------------------------------------ */
    public String getUserTableKey()
    {
        return _userTableKey;
    }


    /* ------------------------------------------------------------ */
    public void setUserTableKey(String tableKey)
    {
        _userTableKey = tableKey;
    }


    /* ------------------------------------------------------------ */
    public String getUserTableUserField()
    {
        return _userTableUserField;
    }


    /* ------------------------------------------------------------ */
    public void setUserTableUserField(String tableUserField)
    {
        _userTableUserField = tableUserField;
    }


    /* ------------------------------------------------------------ */
    public String getUserTablePasswordField()
    {
        return _userTablePasswordField;
    }


    /* ------------------------------------------------------------ */
    public void setUserTablePasswordField(String tablePasswordField)
    {
        _userTablePasswordField = tablePasswordField;
    }


    /* ------------------------------------------------------------ */
    public String getRoleTableName()
    {
        return _roleTableName;
    }


    /* ------------------------------------------------------------ */
    public void setRoleTableName(String tableName)
    {
        _roleTableName = tableName;
    }


    /* ------------------------------------------------------------ */
    public String getRoleTableKey()
    {
        return _roleTableKey;
    }


    /* ------------------------------------------------------------ */
    public void setRoleTableKey(String tableKey)
    {
        _roleTableKey = tableKey;
    }


    /* ------------------------------------------------------------ */
    public String getRoleTableRoleField()
    {
        return _roleTableRoleField;
    }


    /* ------------------------------------------------------------ */
    public void setRoleTableRoleField(String tableRoleField)
    {
        _roleTableRoleField = tableRoleField;
    }


    /* ------------------------------------------------------------ */
    public String getUserRoleTableName()
    {
        return _userRoleTableName;
    }


    /* ------------------------------------------------------------ */
    public void setUserRoleTableName(String roleTableName)
    {
        _userRoleTableName = roleTableName;
    }


    /* ------------------------------------------------------------ */
    public String getUserRoleTableUserKey()
    {
        return _userRoleTableUserKey;
    }


    /* ------------------------------------------------------------ */
    public void setUserRoleTableUserKey(String roleTableUserKey)
    {
        _userRoleTableUserKey = roleTableUserKey;
    }


    /* ------------------------------------------------------------ */
    public String getUserRoleTableRoleKey()
    {
        return _userRoleTableRoleKey;
    }


    /* ------------------------------------------------------------ */
    public void setUserRoleTableRoleKey(String roleTableRoleKey)
    {
        _userRoleTableRoleKey = roleTableRoleKey;
    }

  
    
    /* ------------------------------------------------------------ */
    @Override
    public UserPrincipal loadUserInfo (String username)
    {
        try
        {
            try (Connection connection = getConnection();
                    PreparedStatement statement1 = connection.prepareStatement(_userSql))
            {
                statement1.setObject(1, username);
                try (ResultSet rs1 = statement1.executeQuery())
                {
                    if (rs1.next())
                    {
                        int key = rs1.getInt(_userTableKey);
                        String credentials = rs1.getString(_userTablePasswordField);
                        
                        return new DBUserPrincipal(username, Credential.getCredential(credentials), key);
                    }
                }
            }
        }
        catch (NamingException e)
        {
            LOG.warn(""No datasource for ""+_jndiName, e);
        }
        catch (SQLException e)
        {
            LOG.warn(""Problem loading user info for ""+username, e);
        }
        return null;
    }
    
    
    /* ------------------------------------------------------------ */
    @Override
    public String[] loadRoleInfo (UserPrincipal user)
    {
        DBUserPrincipal dbuser = (DBUserPrincipal)user;

        try
        {
            try (Connection connection = getConnection();
                    PreparedStatement statement2 = connection.prepareStatement(_roleSql))
            {

                List<String> roles = new ArrayList<String>();

                statement2.setInt(1, dbuser.getKey());
                try (ResultSet rs2 = statement2.executeQuery())
                {
                    while (rs2.next())
                    {
                        roles.add(rs2.getString(_roleTableRoleField));
                    }
                    
                    return roles.toArray(new String[roles.size()]);
                }
            }
        }
        catch (NamingException e)
        {
            LOG.warn(""No datasource for ""+_jndiName, e);
        }
        catch (SQLException e)
        {
            LOG.warn(""Problem loading user info for ""+user.getName(), e);
        }
        return null;
    }
    
 

    /* ------------------------------------------------------------ */
    /**
     * Lookup the datasource for the jndiName and formulate the
     * necessary sql query strings based on the configured table
     * and column names.
     *
     * @throws NamingException if unable to init jndi
     * @throws SQLException if unable to init database
     */
    public void initDb() throws NamingException, SQLException
    {
        if (_datasource != null)
            return;

        @SuppressWarnings(""unused"")
        InitialContext ic = new InitialContext();
        assert ic!=null;

        // TODO Should we try webapp scope too?

        // try finding the datasource in the Server scope
        if (_server != null)
        {
            try
            {
                _datasource = (DataSource)NamingEntryUtil.lookup(_server, _jndiName);
            }
            catch (NameNotFoundException e)
            {
                //next try the jvm scope
            }
        }


        //try finding the datasource in the jvm scope
        if (_datasource==null)
        {
            _datasource = (DataSource)NamingEntryUtil.lookup(null, _jndiName);
        }

        // set up the select statements based on the table and column names configured
        _userSql = ""select "" + _userTableKey + "","" + _userTablePasswordField
                  + "" from "" + _userTableName
                  + "" where ""+ _userTableUserField + "" = ?"";

        _roleSql = ""select r."" + _roleTableRoleField
                  + "" from "" + _roleTableName + "" r, "" + _userRoleTableName
                  + "" u where u.""+ _userRoleTableUserKey + "" = ?""
                  + "" and r."" + _roleTableKey + "" = u."" + _userRoleTableRoleKey;

        prepareTables();
    }

    /* ------------------------------------------------------------ */
    /**
     * @throws NamingException
     * @throws SQLException
     */
    private void prepareTables()
    throws NamingException, SQLException
    {
        if (_createTables)
        {
            boolean autocommit = true;
            Connection connection = getConnection();
            try (Statement stmt = connection.createStatement())
            {
                autocommit = connection.getAutoCommit();
                connection.setAutoCommit(false);
                DatabaseMetaData metaData = connection.getMetaData();

                //check if tables exist
                String tableName = (metaData.storesLowerCaseIdentifiers()? _userTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_userTableName.toUpperCase(Locale.ENGLISH): _userTableName));
                try (ResultSet result = metaData.getTables(null, null, tableName, null))
                {
                    if (!result.next())
                    {
                        //user table default
                        /*
                         * create table _userTableName (_userTableKey integer,
                         * _userTableUserField varchar(100) not null unique,
                         * _userTablePasswordField varchar(20) not null, primary key(_userTableKey));
                         */
                        stmt.executeUpdate(""create table ""+_userTableName+ ""(""+_userTableKey+"" integer,""+
                                _userTableUserField+"" varchar(100) not null unique,""+
                                _userTablePasswordField+"" varchar(20) not null, primary key(""+_userTableKey+""))"");
                        if (LOG.isDebugEnabled()) LOG.debug(""Created table ""+_userTableName);
                    }
                }

                tableName = (metaData.storesLowerCaseIdentifiers()? _roleTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_roleTableName.toUpperCase(Locale.ENGLISH): _roleTableName));
                try (ResultSet result = metaData.getTables(null, null, tableName, null))
                {
                    if (!result.next())
                    {
                        //role table default
                        /*
                         * create table _roleTableName (_roleTableKey integer,
                         * _roleTableRoleField varchar(100) not null unique, primary key(_roleTableKey));
                         */
                        String str = ""create table ""+_roleTableName+"" (""+_roleTableKey+"" integer, ""+
                        _roleTableRoleField+"" varchar(100) not null unique, primary key(""+_roleTableKey+""))"";
                        stmt.executeUpdate(str);
                        if (LOG.isDebugEnabled()) LOG.debug(""Created table ""+_roleTableName);
                    }
                }

                tableName = (metaData.storesLowerCaseIdentifiers()? _userRoleTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_userRoleTableName.toUpperCase(Locale.ENGLISH): _userRoleTableName));
                try (ResultSet result = metaData.getTables(null, null, tableName, null))
                {
                    if (!result.next())
                    {
                        //user-role table
                        /*
                         * create table _userRoleTableName (_userRoleTableUserKey integer,
                         * _userRoleTableRoleKey integer,
                         * primary key (_userRoleTableUserKey, _userRoleTableRoleKey));
                         *
                         * create index idx_user_role on _userRoleTableName (_userRoleTableUserKey);
                         */
                        stmt.executeUpdate(""create table ""+_userRoleTableName+"" (""+_userRoleTableUserKey+"" integer, ""+
                                _userRoleTableRoleKey+"" integer, ""+
                                ""primary key (""+_userRoleTableUserKey+"", ""+_userRoleTableRoleKey+""))"");
                        stmt.executeUpdate(""create index indx_user_role on ""+_userRoleTableName+""(""+_userRoleTableUserKey+"")"");
                        if (LOG.isDebugEnabled()) LOG.debug(""Created table ""+_userRoleTableName +"" and index"");
                    }
                }
                connection.commit();
            }
            finally
            {
                try
                {
                    connection.setAutoCommit(autocommit);
                }
                catch (SQLException e)
                {
                    if (LOG.isDebugEnabled()) LOG.debug(""Prepare tables"", e);
                }
                finally
                {
                    try
                    {
                        connection.close();
                    }
                    catch (SQLException e)
                    {
                        if (LOG.isDebugEnabled()) LOG.debug(""Prepare tables"", e);
                    }
                }
            }
        }
        else if (LOG.isDebugEnabled())
        {
            LOG.debug(""createTables false"");
        }
    }

    /* ------------------------------------------------------------ */
    /**
     * @return
     * @throws NamingException
     * @throws SQLException
     */
    private Connection getConnection ()
    throws NamingException, SQLException
    {
        initDb();
        return _datasource.getConnection();
    }
}
",blob
401,"    protected SQLBuffer toBulkOperation(ClassMapping mapping, Select sel,
        JDBCStore store, Object[] params, Map updateParams) {
        SQLBuffer sql = new SQLBuffer(this);
        if (updateParams == null) {
          if (requiresTargetForDelete) {
            sql.append(""DELETE "");
            SQLBuffer deleteTargets = getDeleteTargets(sel);
            sql.append(deleteTargets);
            sql.append("" FROM "");
          } else {
            sql.append(""DELETE FROM "");
          }
        }
        else
            sql.append(""UPDATE "");
        sel.addJoinClassConditions();

        // if there is only a single table in the select, then we can
        // just issue a single DELETE FROM TABLE WHERE <conditions>
        // statement; otherwise, since SQL doesn't allow deleting
        // from one of a multi-table select, we need to issue a subselect
        // like DELETE FROM TABLE WHERE EXISTS
        // (SELECT 1 FROM TABLE t0 WHERE t0.ID = TABLE.ID); also, some
        // databases do not allow aliases in delete statements, which
        // also causes us to use a subselect
        Collection<String> selectedTables = getSelectTableAliases(sel);
        if (selectedTables.size() == 1 && supportsSubselect
            && allowsAliasInBulkClause) {
            SQLBuffer from;
            if (sel.getFromSelect() != null)
                from = getFromSelect(sel, false);
            else
                from = getFrom(sel, false);

            sql.append(from);
            appendUpdates(sel, store, sql, params, updateParams,
                allowsAliasInBulkClause);

            SQLBuffer where = sel.getWhere();
            if (where != null && !where.isEmpty()) {
                sql.append("" WHERE "");
                sql.append(where);
            }
            return sql;
        }

        Table table = mapping.getTable();
        String tableName = getFullName(table, false);

        // only use a  subselect if the where is not empty; otherwise
        // an unqualified delete or update will work
        if (sel.getWhere() == null || sel.getWhere().isEmpty()) {
            sql.append(tableName);
            appendUpdates(sel, store, sql, params, updateParams, false);
            return sql;
        }

        // we need to use a subselect if we are to bulk delete where
        // the select includes multiple tables; if the database
        // doesn't support it, then we need to signal this by returning null
        if (!supportsSubselect || !supportsCorrelatedSubselect)
            return null;

        Column[] pks = mapping.getPrimaryKeyColumns();
        sel.clearSelects();
        sel.setDistinct(true);

        // if we have only a single PK, we can use a non-correlated
        // subquery (using an IN statement), which is much faster than
        // a correlated subquery (since a correlated subquery needs
        // to be executed once for each row in the table)
        if (pks.length == 1) {
            sel.select(pks[0]);
            sql.append(tableName);
            appendUpdates(sel, store, sql, params, updateParams, false);
            sql.append("" WHERE "").
                append(pks[0]).append("" IN ("").
                append(sel.toSelect(false, null)).append("")"");
        } else {
            sel.clearSelects();
            sel.setDistinct(false);

            // since the select is using a correlated subquery, we
            // only need to select a bogus virtual column
            sel.select(""1"", null);

            // add in the joins to the table
            Column[] cols = table.getPrimaryKey().getColumns();
            SQLBuffer buf = new SQLBuffer(this);
            buf.append(""("");
            for (int i = 0; i < cols.length; i++) {
                if (i > 0)
                    buf.append("" AND "");

                // add in ""t0.PK = MYTABLE.PK""
                buf.append(sel.getColumnAlias(cols[i])).append("" = "").
                    append(table).append(catalogSeparator).append(cols[i]);
            }
            buf.append("")"");
            sel.where(buf, null);

            sql.append(tableName);
            appendUpdates(sel, store, sql, params, updateParams, false);
            sql.append("" WHERE EXISTS ("").
                append(sel.toSelect(false, null)).append("")"");
        }
        return sql;
    }
",long method
67,"public abstract class BaseObject {

	/** Type identifier of the object */
	public String type;

	/**
	 * Constructs an empty object
	 */
	public BaseObject() {
		type = this.getClass().getCanonicalName();
	}

	/**
	 * Constructs object with a given type
	 * @param type the type identifier
	 */
	public BaseObject(String type) {
		this.type = type;
	}

	/**
	 * Get type of this object.
	 * @return type of the object
	 */
	public String getType() {
		return type;
	}

}
",data class
1494,"public class DataSourceLoginService extends AbstractLoginService
{
    private static final Logger LOG = Log.getLogger(DataSourceLoginService.class);

    private String _jndiName = ""javax.sql.DataSource/default"";
    private DataSource _datasource;
    private Server _server;
    private String _userTableName = ""users"";
    private String _userTableKey = ""id"";
    private String _userTableUserField = ""username"";
    private String _userTablePasswordField = ""pwd"";
    private String _roleTableName = ""roles"";
    private String _roleTableKey = ""id"";
    private String _roleTableRoleField = ""role"";
    private String _userRoleTableName = ""user_roles"";
    private String _userRoleTableUserKey = ""user_id"";
    private String _userRoleTableRoleKey = ""role_id"";
    private String _userSql;
    private String _roleSql;
    private boolean _createTables = false;
    
    
    /**
     * DBUser
     */
    public class DBUserPrincipal extends UserPrincipal
    {
        private int _key;
        
        public DBUserPrincipal(String name, Credential credential, int key)
        {
            super(name, credential);
            _key = key;
        }
        
        public int getKey ()
        {
            return _key;
        }
        
    }

    /* ------------------------------------------------------------ */
    public DataSourceLoginService()
    {
    }

    /* ------------------------------------------------------------ */
    public DataSourceLoginService(String name)
    {
        setName(name);
    }

    /* ------------------------------------------------------------ */
    public DataSourceLoginService(String name, IdentityService identityService)
    {
        setName(name);
        setIdentityService(identityService);
    }

    /* ------------------------------------------------------------ */
    public void setJndiName (String jndi)
    {
        _jndiName = jndi;
    }

    /* ------------------------------------------------------------ */
    public String getJndiName ()
    {
        return _jndiName;
    }

    /* ------------------------------------------------------------ */
    public void setServer (Server server)
    {
        _server=server;
    }

    /* ------------------------------------------------------------ */
    public Server getServer()
    {
        return _server;
    }

    /* ------------------------------------------------------------ */
    public void setCreateTables(boolean createTables)
    {
        _createTables = createTables;
    }

    /* ------------------------------------------------------------ */
    public boolean getCreateTables()
    {
        return _createTables;
    }

    /* ------------------------------------------------------------ */
    public void setUserTableName (String name)
    {
        _userTableName=name;
    }

    /* ------------------------------------------------------------ */
    public String getUserTableName()
    {
        return _userTableName;
    }

    /* ------------------------------------------------------------ */
    public String getUserTableKey()
    {
        return _userTableKey;
    }


    /* ------------------------------------------------------------ */
    public void setUserTableKey(String tableKey)
    {
        _userTableKey = tableKey;
    }


    /* ------------------------------------------------------------ */
    public String getUserTableUserField()
    {
        return _userTableUserField;
    }


    /* ------------------------------------------------------------ */
    public void setUserTableUserField(String tableUserField)
    {
        _userTableUserField = tableUserField;
    }


    /* ------------------------------------------------------------ */
    public String getUserTablePasswordField()
    {
        return _userTablePasswordField;
    }


    /* ------------------------------------------------------------ */
    public void setUserTablePasswordField(String tablePasswordField)
    {
        _userTablePasswordField = tablePasswordField;
    }


    /* ------------------------------------------------------------ */
    public String getRoleTableName()
    {
        return _roleTableName;
    }


    /* ------------------------------------------------------------ */
    public void setRoleTableName(String tableName)
    {
        _roleTableName = tableName;
    }


    /* ------------------------------------------------------------ */
    public String getRoleTableKey()
    {
        return _roleTableKey;
    }


    /* ------------------------------------------------------------ */
    public void setRoleTableKey(String tableKey)
    {
        _roleTableKey = tableKey;
    }


    /* ------------------------------------------------------------ */
    public String getRoleTableRoleField()
    {
        return _roleTableRoleField;
    }


    /* ------------------------------------------------------------ */
    public void setRoleTableRoleField(String tableRoleField)
    {
        _roleTableRoleField = tableRoleField;
    }


    /* ------------------------------------------------------------ */
    public String getUserRoleTableName()
    {
        return _userRoleTableName;
    }


    /* ------------------------------------------------------------ */
    public void setUserRoleTableName(String roleTableName)
    {
        _userRoleTableName = roleTableName;
    }


    /* ------------------------------------------------------------ */
    public String getUserRoleTableUserKey()
    {
        return _userRoleTableUserKey;
    }


    /* ------------------------------------------------------------ */
    public void setUserRoleTableUserKey(String roleTableUserKey)
    {
        _userRoleTableUserKey = roleTableUserKey;
    }


    /* ------------------------------------------------------------ */
    public String getUserRoleTableRoleKey()
    {
        return _userRoleTableRoleKey;
    }


    /* ------------------------------------------------------------ */
    public void setUserRoleTableRoleKey(String roleTableRoleKey)
    {
        _userRoleTableRoleKey = roleTableRoleKey;
    }

  
    
    /* ------------------------------------------------------------ */
    @Override
    public UserPrincipal loadUserInfo (String username)
    {
        try
        {
            try (Connection connection = getConnection();
                    PreparedStatement statement1 = connection.prepareStatement(_userSql))
            {
                statement1.setObject(1, username);
                try (ResultSet rs1 = statement1.executeQuery())
                {
                    if (rs1.next())
                    {
                        int key = rs1.getInt(_userTableKey);
                        String credentials = rs1.getString(_userTablePasswordField);
                        
                        return new DBUserPrincipal(username, Credential.getCredential(credentials), key);
                    }
                }
            }
        }
        catch (NamingException e)
        {
            LOG.warn(""No datasource for ""+_jndiName, e);
        }
        catch (SQLException e)
        {
            LOG.warn(""Problem loading user info for ""+username, e);
        }
        return null;
    }
    
    
    /* ------------------------------------------------------------ */
    @Override
    public String[] loadRoleInfo (UserPrincipal user)
    {
        DBUserPrincipal dbuser = (DBUserPrincipal)user;

        try
        {
            try (Connection connection = getConnection();
                    PreparedStatement statement2 = connection.prepareStatement(_roleSql))
            {

                List<String> roles = new ArrayList<String>();

                statement2.setInt(1, dbuser.getKey());
                try (ResultSet rs2 = statement2.executeQuery())
                {
                    while (rs2.next())
                    {
                        roles.add(rs2.getString(_roleTableRoleField));
                    }
                    
                    return roles.toArray(new String[roles.size()]);
                }
            }
        }
        catch (NamingException e)
        {
            LOG.warn(""No datasource for ""+_jndiName, e);
        }
        catch (SQLException e)
        {
            LOG.warn(""Problem loading user info for ""+user.getName(), e);
        }
        return null;
    }
    
 

    /* ------------------------------------------------------------ */
    /**
     * Lookup the datasource for the jndiName and formulate the
     * necessary sql query strings based on the configured table
     * and column names.
     *
     * @throws NamingException if unable to init jndi
     * @throws SQLException if unable to init database
     */
    public void initDb() throws NamingException, SQLException
    {
        if (_datasource != null)
            return;

        @SuppressWarnings(""unused"")
        InitialContext ic = new InitialContext();
        assert ic!=null;

        // TODO Should we try webapp scope too?

        // try finding the datasource in the Server scope
        if (_server != null)
        {
            try
            {
                _datasource = (DataSource)NamingEntryUtil.lookup(_server, _jndiName);
            }
            catch (NameNotFoundException e)
            {
                //next try the jvm scope
            }
        }


        //try finding the datasource in the jvm scope
        if (_datasource==null)
        {
            _datasource = (DataSource)NamingEntryUtil.lookup(null, _jndiName);
        }

        // set up the select statements based on the table and column names configured
        _userSql = ""select "" + _userTableKey + "","" + _userTablePasswordField
                  + "" from "" + _userTableName
                  + "" where ""+ _userTableUserField + "" = ?"";

        _roleSql = ""select r."" + _roleTableRoleField
                  + "" from "" + _roleTableName + "" r, "" + _userRoleTableName
                  + "" u where u.""+ _userRoleTableUserKey + "" = ?""
                  + "" and r."" + _roleTableKey + "" = u."" + _userRoleTableRoleKey;

        prepareTables();
    }

    /* ------------------------------------------------------------ */
    /**
     * @throws NamingException
     * @throws SQLException
     */
    private void prepareTables()
    throws NamingException, SQLException
    {
        if (_createTables)
        {
            boolean autocommit = true;
            Connection connection = getConnection();
            try (Statement stmt = connection.createStatement())
            {
                autocommit = connection.getAutoCommit();
                connection.setAutoCommit(false);
                DatabaseMetaData metaData = connection.getMetaData();

                //check if tables exist
                String tableName = (metaData.storesLowerCaseIdentifiers()? _userTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_userTableName.toUpperCase(Locale.ENGLISH): _userTableName));
                try (ResultSet result = metaData.getTables(null, null, tableName, null))
                {
                    if (!result.next())
                    {
                        //user table default
                        /*
                         * create table _userTableName (_userTableKey integer,
                         * _userTableUserField varchar(100) not null unique,
                         * _userTablePasswordField varchar(20) not null, primary key(_userTableKey));
                         */
                        stmt.executeUpdate(""create table ""+_userTableName+ ""(""+_userTableKey+"" integer,""+
                                _userTableUserField+"" varchar(100) not null unique,""+
                                _userTablePasswordField+"" varchar(20) not null, primary key(""+_userTableKey+""))"");
                        if (LOG.isDebugEnabled()) LOG.debug(""Created table ""+_userTableName);
                    }
                }

                tableName = (metaData.storesLowerCaseIdentifiers()? _roleTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_roleTableName.toUpperCase(Locale.ENGLISH): _roleTableName));
                try (ResultSet result = metaData.getTables(null, null, tableName, null))
                {
                    if (!result.next())
                    {
                        //role table default
                        /*
                         * create table _roleTableName (_roleTableKey integer,
                         * _roleTableRoleField varchar(100) not null unique, primary key(_roleTableKey));
                         */
                        String str = ""create table ""+_roleTableName+"" (""+_roleTableKey+"" integer, ""+
                        _roleTableRoleField+"" varchar(100) not null unique, primary key(""+_roleTableKey+""))"";
                        stmt.executeUpdate(str);
                        if (LOG.isDebugEnabled()) LOG.debug(""Created table ""+_roleTableName);
                    }
                }

                tableName = (metaData.storesLowerCaseIdentifiers()? _userRoleTableName.toLowerCase(Locale.ENGLISH): (metaData.storesUpperCaseIdentifiers()?_userRoleTableName.toUpperCase(Locale.ENGLISH): _userRoleTableName));
                try (ResultSet result = metaData.getTables(null, null, tableName, null))
                {
                    if (!result.next())
                    {
                        //user-role table
                        /*
                         * create table _userRoleTableName (_userRoleTableUserKey integer,
                         * _userRoleTableRoleKey integer,
                         * primary key (_userRoleTableUserKey, _userRoleTableRoleKey));
                         *
                         * create index idx_user_role on _userRoleTableName (_userRoleTableUserKey);
                         */
                        stmt.executeUpdate(""create table ""+_userRoleTableName+"" (""+_userRoleTableUserKey+"" integer, ""+
                                _userRoleTableRoleKey+"" integer, ""+
                                ""primary key (""+_userRoleTableUserKey+"", ""+_userRoleTableRoleKey+""))"");
                        stmt.executeUpdate(""create index indx_user_role on ""+_userRoleTableName+""(""+_userRoleTableUserKey+"")"");
                        if (LOG.isDebugEnabled()) LOG.debug(""Created table ""+_userRoleTableName +"" and index"");
                    }
                }
                connection.commit();
            }
            finally
            {
                try
                {
                    connection.setAutoCommit(autocommit);
                }
                catch (SQLException e)
                {
                    if (LOG.isDebugEnabled()) LOG.debug(""Prepare tables"", e);
                }
                finally
                {
                    try
                    {
                        connection.close();
                    }
                    catch (SQLException e)
                    {
                        if (LOG.isDebugEnabled()) LOG.debug(""Prepare tables"", e);
                    }
                }
            }
        }
        else if (LOG.isDebugEnabled())
        {
            LOG.debug(""createTables false"");
        }
    }

    /* ------------------------------------------------------------ */
    /**
     * @return
     * @throws NamingException
     * @throws SQLException
     */
    private Connection getConnection ()
    throws NamingException, SQLException
    {
        initDb();
        return _datasource.getConnection();
    }
}
",data class
1053,"public class DruidPooledCallableStatement extends DruidPooledPreparedStatement implements CallableStatement {

    private CallableStatement stmt;

    public DruidPooledCallableStatement(DruidPooledConnection conn, PreparedStatementHolder holder) throws SQLException{
        super(conn, holder);
        this.stmt = (CallableStatement) holder.statement;
    }

    public CallableStatement getCallableStatementRaw() {
        return stmt;
    }

    @Override
    public void registerOutParameter(int parameterIndex, int sqlType) throws SQLException {
        try {
            stmt.registerOutParameter(parameterIndex, sqlType);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void registerOutParameter(int parameterIndex, int sqlType, int scale) throws SQLException {
        try {
            stmt.registerOutParameter(parameterIndex, sqlType, scale);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public boolean wasNull() throws SQLException {
        try {
            return stmt.wasNull();
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public String getString(int parameterIndex) throws SQLException {
        try {
            return stmt.getString(parameterIndex);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public boolean getBoolean(int parameterIndex) throws SQLException {
        try {
            return stmt.getBoolean(parameterIndex);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public byte getByte(int parameterIndex) throws SQLException {
        try {
            return stmt.getByte(parameterIndex);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public short getShort(int parameterIndex) throws SQLException {
        try {
            return stmt.getShort(parameterIndex);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public int getInt(int parameterIndex) throws SQLException {
        try {
            return stmt.getInt(parameterIndex);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public long getLong(int parameterIndex) throws SQLException {
        try {
            return stmt.getLong(parameterIndex);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public float getFloat(int parameterIndex) throws SQLException {
        try {
            return stmt.getFloat(parameterIndex);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public double getDouble(int parameterIndex) throws SQLException {
        try {
            return stmt.getDouble(parameterIndex);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    @Deprecated
    public BigDecimal getBigDecimal(int parameterIndex, int scale) throws SQLException {
        try {
            return stmt.getBigDecimal(parameterIndex, scale);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public byte[] getBytes(int parameterIndex) throws SQLException {
        try {
            return stmt.getBytes(parameterIndex);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public java.sql.Date getDate(int parameterIndex) throws SQLException {
        try {
            return stmt.getDate(parameterIndex);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public java.sql.Time getTime(int parameterIndex) throws SQLException {
        try {
            return stmt.getTime(parameterIndex);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public java.sql.Timestamp getTimestamp(int parameterIndex) throws SQLException {
        try {
            return stmt.getTimestamp(parameterIndex);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public Object getObject(int parameterIndex) throws SQLException {
        try {
            Object obj = stmt.getObject(parameterIndex);
            return wrapObject(obj);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    private Object wrapObject(Object obj) {
        if (obj instanceof ResultSet) {
            ResultSet rs = (ResultSet) obj;
            
            DruidPooledResultSet poolableResultSet = new DruidPooledResultSet(this, rs);
            addResultSetTrace(poolableResultSet);
            
            obj = poolableResultSet;
        }
        
        return obj;
    }

    @Override
    public BigDecimal getBigDecimal(int parameterIndex) throws SQLException {
        try {
            return stmt.getBigDecimal(parameterIndex);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public Object getObject(int parameterIndex, java.util.Map<String, Class<?>> map) throws SQLException {
        try {
            Object obj = stmt.getObject(parameterIndex, map);
            return wrapObject(obj);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public Ref getRef(int parameterIndex) throws SQLException {
        try {
            return stmt.getRef(parameterIndex);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public Blob getBlob(int parameterIndex) throws SQLException {
        try {
            return stmt.getBlob(parameterIndex);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public Clob getClob(int parameterIndex) throws SQLException {
        try {
            return stmt.getClob(parameterIndex);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public Array getArray(int parameterIndex) throws SQLException {
        try {
            return stmt.getArray(parameterIndex);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public java.sql.Date getDate(int parameterIndex, Calendar cal) throws SQLException {
        try {
            return stmt.getDate(parameterIndex, cal);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public java.sql.Time getTime(int parameterIndex, Calendar cal) throws SQLException {
        try {
            return stmt.getTime(parameterIndex, cal);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public java.sql.Timestamp getTimestamp(int parameterIndex, Calendar cal) throws SQLException {
        try {
            return stmt.getTimestamp(parameterIndex, cal);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void registerOutParameter(int parameterIndex, int sqlType, String typeName) throws SQLException {
        try {
            stmt.registerOutParameter(parameterIndex, sqlType, typeName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void registerOutParameter(String parameterName, int sqlType) throws SQLException {
        try {
            stmt.registerOutParameter(parameterName, sqlType);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void registerOutParameter(String parameterName, int sqlType, int scale) throws SQLException {
        try {
            stmt.registerOutParameter(parameterName, sqlType, scale);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void registerOutParameter(String parameterName, int sqlType, String typeName) throws SQLException {
        try {
            stmt.registerOutParameter(parameterName, sqlType, typeName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public java.net.URL getURL(int parameterIndex) throws SQLException {
        try {
            return stmt.getURL(parameterIndex);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setURL(String parameterName, java.net.URL val) throws SQLException {
        try {
            stmt.setURL(parameterName, val);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setNull(String parameterName, int sqlType) throws SQLException {
        try {
            stmt.setNull(parameterName, sqlType);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setBoolean(String parameterName, boolean x) throws SQLException {
        try {
            stmt.setBoolean(parameterName, x);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setByte(String parameterName, byte x) throws SQLException {
        try {
            stmt.setByte(parameterName, x);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setShort(String parameterName, short x) throws SQLException {
        try {
            stmt.setShort(parameterName, x);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setInt(String parameterName, int x) throws SQLException {
        try {
            stmt.setInt(parameterName, x);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setLong(String parameterName, long x) throws SQLException {
        try {
            stmt.setLong(parameterName, x);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setFloat(String parameterName, float x) throws SQLException {
        try {
            stmt.setFloat(parameterName, x);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setDouble(String parameterName, double x) throws SQLException {
        try {
            stmt.setDouble(parameterName, x);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setBigDecimal(String parameterName, BigDecimal x) throws SQLException {
        try {
            stmt.setBigDecimal(parameterName, x);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setString(String parameterName, String x) throws SQLException {
        try {
            stmt.setString(parameterName, x);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setBytes(String parameterName, byte x[]) throws SQLException {
        try {
            stmt.setBytes(parameterName, x);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setDate(String parameterName, java.sql.Date x) throws SQLException {
        try {
            stmt.setDate(parameterName, x);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setTime(String parameterName, java.sql.Time x) throws SQLException {
        try {
            stmt.setTime(parameterName, x);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setTimestamp(String parameterName, java.sql.Timestamp x) throws SQLException {
        try {
            stmt.setTimestamp(parameterName, x);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setAsciiStream(String parameterName, java.io.InputStream x, int length) throws SQLException {
        try {
            stmt.setAsciiStream(parameterName, x, length);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setBinaryStream(String parameterName, java.io.InputStream x, int length) throws SQLException {
        try {
            stmt.setBinaryStream(parameterName, x, length);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setObject(String parameterName, Object x, int targetSqlType, int scale) throws SQLException {
        try {
            stmt.setObject(parameterName, x, targetSqlType, scale);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setObject(String parameterName, Object x, int targetSqlType) throws SQLException {
        try {
            stmt.setObject(parameterName, x, targetSqlType);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setObject(String parameterName, Object x) throws SQLException {
        try {
            stmt.setObject(parameterName, x);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setCharacterStream(String parameterName, java.io.Reader reader, int length) throws SQLException {
        try {
            stmt.setCharacterStream(parameterName, reader, length);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setDate(String parameterName, java.sql.Date x, Calendar cal) throws SQLException {
        try {
            stmt.setDate(parameterName, x, cal);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setTime(String parameterName, java.sql.Time x, Calendar cal) throws SQLException {
        try {
            stmt.setTime(parameterName, x, cal);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setTimestamp(String parameterName, java.sql.Timestamp x, Calendar cal) throws SQLException {
        try {
            stmt.setTimestamp(parameterName, x, cal);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setNull(String parameterName, int sqlType, String typeName) throws SQLException {
        try {
            stmt.setNull(parameterName, sqlType, typeName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public String getString(String parameterName) throws SQLException {
        try {
            return stmt.getString(parameterName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public boolean getBoolean(String parameterName) throws SQLException {
        try {
            return stmt.getBoolean(parameterName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public byte getByte(String parameterName) throws SQLException {
        try {
            return stmt.getByte(parameterName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public short getShort(String parameterName) throws SQLException {
        try {
            return stmt.getShort(parameterName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public int getInt(String parameterName) throws SQLException {
        try {
            return stmt.getInt(parameterName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public long getLong(String parameterName) throws SQLException {
        try {
            return stmt.getLong(parameterName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public float getFloat(String parameterName) throws SQLException {
        try {
            return stmt.getFloat(parameterName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public double getDouble(String parameterName) throws SQLException {
        try {
            return stmt.getDouble(parameterName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public byte[] getBytes(String parameterName) throws SQLException {
        try {
            return stmt.getBytes(parameterName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public java.sql.Date getDate(String parameterName) throws SQLException {
        try {
            return stmt.getDate(parameterName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public java.sql.Time getTime(String parameterName) throws SQLException {
        try {
            return stmt.getTime(parameterName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public java.sql.Timestamp getTimestamp(String parameterName) throws SQLException {
        try {
            return stmt.getTimestamp(parameterName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public Object getObject(String parameterName) throws SQLException {
        try {
            Object obj = stmt.getObject(parameterName);
            return wrapObject(obj);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public BigDecimal getBigDecimal(String parameterName) throws SQLException {
        try {
            return stmt.getBigDecimal(parameterName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public Object getObject(String parameterName, java.util.Map<String, Class<?>> map) throws SQLException {
        try {
            Object obj = stmt.getObject(parameterName, map);
            return wrapObject(obj);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public Ref getRef(String parameterName) throws SQLException {
        try {
            return stmt.getRef(parameterName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public Blob getBlob(String parameterName) throws SQLException {
        try {
            return stmt.getBlob(parameterName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public Clob getClob(String parameterName) throws SQLException {
        try {
            return stmt.getClob(parameterName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public Array getArray(String parameterName) throws SQLException {
        try {
            return stmt.getArray(parameterName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public java.sql.Date getDate(String parameterName, Calendar cal) throws SQLException {
        try {
            return stmt.getDate(parameterName, cal);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public java.sql.Time getTime(String parameterName, Calendar cal) throws SQLException {
        try {
            return stmt.getTime(parameterName, cal);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public java.sql.Timestamp getTimestamp(String parameterName, Calendar cal) throws SQLException {
        try {
            return stmt.getTimestamp(parameterName, cal);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public java.net.URL getURL(String parameterName) throws SQLException {
        try {
            return stmt.getURL(parameterName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public RowId getRowId(int parameterIndex) throws SQLException {
        try {
            return stmt.getRowId(parameterIndex);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public RowId getRowId(String parameterName) throws SQLException {
        try {
            return stmt.getRowId(parameterName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setRowId(String parameterName, RowId x) throws SQLException {
        try {
            stmt.setRowId(parameterName, x);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setNString(String parameterName, String value) throws SQLException {
        try {
            stmt.setNString(parameterName, value);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setNCharacterStream(String parameterName, Reader value, long length) throws SQLException {
        try {
            stmt.setNCharacterStream(parameterName, value, length);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setNClob(String parameterName, NClob value) throws SQLException {
        try {
            stmt.setNClob(parameterName, value);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setClob(String parameterName, Reader reader, long length) throws SQLException {
        try {
            stmt.setClob(parameterName, reader, length);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setBlob(String parameterName, InputStream inputStream, long length) throws SQLException {
        try {
            stmt.setBlob(parameterName, inputStream, length);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setNClob(String parameterName, Reader reader, long length) throws SQLException {
        try {
            stmt.setNClob(parameterName, reader, length);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public NClob getNClob(int parameterIndex) throws SQLException {
        try {
            return stmt.getNClob(parameterIndex);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public NClob getNClob(String parameterName) throws SQLException {
        try {
            return stmt.getNClob(parameterName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setSQLXML(String parameterName, SQLXML xmlObject) throws SQLException {
        try {
            stmt.setSQLXML(parameterName, xmlObject);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public SQLXML getSQLXML(int parameterIndex) throws SQLException {
        try {
            return stmt.getSQLXML(parameterIndex);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public SQLXML getSQLXML(String parameterName) throws SQLException {
        try {
            return stmt.getSQLXML(parameterName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public String getNString(int parameterIndex) throws SQLException {
        try {
            return stmt.getNString(parameterIndex);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public String getNString(String parameterName) throws SQLException {
        try {
            return stmt.getNString(parameterName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public java.io.Reader getNCharacterStream(int parameterIndex) throws SQLException {
        try {
            return stmt.getNCharacterStream(parameterIndex);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public java.io.Reader getNCharacterStream(String parameterName) throws SQLException {
        try {
            return stmt.getNCharacterStream(parameterName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public java.io.Reader getCharacterStream(int parameterIndex) throws SQLException {
        try {
            return stmt.getCharacterStream(parameterIndex);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public java.io.Reader getCharacterStream(String parameterName) throws SQLException {
        try {
            return stmt.getCharacterStream(parameterName);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setBlob(String parameterName, Blob x) throws SQLException {
        try {
            stmt.setBlob(parameterName, x);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setClob(String parameterName, Clob x) throws SQLException {
        try {
            stmt.setClob(parameterName, x);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setAsciiStream(String parameterName, java.io.InputStream x, long length) throws SQLException {
        try {
            stmt.setAsciiStream(parameterName, x, length);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setBinaryStream(String parameterName, java.io.InputStream x, long length) throws SQLException {
        try {
            stmt.setBinaryStream(parameterName, x, length);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setCharacterStream(String parameterName, java.io.Reader reader, long length) throws SQLException {
        try {
            stmt.setCharacterStream(parameterName, reader, length);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setAsciiStream(String parameterName, java.io.InputStream x) throws SQLException {
        try {
            stmt.setAsciiStream(parameterName, x);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setBinaryStream(String parameterName, java.io.InputStream x) throws SQLException {
        try {
            stmt.setBinaryStream(parameterName, x);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setCharacterStream(String parameterName, java.io.Reader reader) throws SQLException {
        try {
            stmt.setCharacterStream(parameterName, reader);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setNCharacterStream(String parameterName, Reader value) throws SQLException {
        try {
            stmt.setNCharacterStream(parameterName, value);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setClob(String parameterName, Reader reader) throws SQLException {
        try {
            stmt.setClob(parameterName, reader);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setBlob(String parameterName, InputStream inputStream) throws SQLException {
        try {
            stmt.setBlob(parameterName, inputStream);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    @Override
    public void setNClob(String parameterName, Reader reader) throws SQLException {
        try {
            stmt.setNClob(parameterName, reader);
        } catch (Throwable t) {
            throw checkException(t);
        }
    }

    public <T> T getObject(int parameterIndex, Class<T> type) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    public <T> T getObject(String parameterName, Class<T> type) throws SQLException {
        throw new SQLFeatureNotSupportedException();
    }

    @SuppressWarnings(""unchecked"")
    public <T> T unwrap(Class<T> iface) throws SQLException {
        if (iface == CallableStatement.class || iface == PreparedStatement.class) {
            if (stmt instanceof CallableStatementProxy) {
                return stmt.unwrap(iface);
            }
            return (T) stmt;
        }
        
        return super.unwrap(iface);
    }
}
",data class
44,"    static class Solaris extends OperatingSystem.Unix {
        @Override
        public String getFamilyName() {
            return ""solaris"";
        }

        @Override
        protected String getOsPrefix() {
            return ""sunos"";
        }

        @Override
        protected String getArch() {
            String arch = System.getProperty(""os.arch"");
            if (arch.equals(""i386"") || arch.equals(""x86"")) {
                return ""x86"";
            }
            return super.getArch();
        }
    }
",data class
612,"    public static List<Map<String, Object>> getFacilityContactMechValueMaps(Delegator delegator, String facilityId, boolean showOld, String contactMechTypeId) {
        List<Map<String, Object>> facilityContactMechValueMaps = new LinkedList<Map<String,Object>>();

        List<GenericValue> allFacilityContactMechs = null;

        try {
            List<GenericValue> tempCol = EntityQuery.use(delegator).from(""FacilityContactMech"").where(""facilityId"", facilityId).queryList();
            if (contactMechTypeId != null) {
                List<GenericValue> tempColTemp = new LinkedList<GenericValue>();
                for (GenericValue partyContactMech: tempCol) {
                    GenericValue contactMech = delegator.getRelatedOne(""ContactMech"", partyContactMech, false);
                    if (contactMech != null && contactMechTypeId.equals(contactMech.getString(""contactMechTypeId""))) {
                        tempColTemp.add(partyContactMech);
                    }

                }
                tempCol = tempColTemp;
            }
            if (!showOld) tempCol = EntityUtil.filterByDate(tempCol, true);
            allFacilityContactMechs = tempCol;
        } catch (GenericEntityException e) {
            Debug.logWarning(e, module);
        }

        if (allFacilityContactMechs == null) return facilityContactMechValueMaps;

        for (GenericValue facilityContactMech: allFacilityContactMechs) {
            GenericValue contactMech = null;

            try {
                contactMech = facilityContactMech.getRelatedOne(""ContactMech"", false);
            } catch (GenericEntityException e) {
                Debug.logWarning(e, module);
            }
            if (contactMech != null) {
                Map<String, Object> facilityContactMechValueMap = new HashMap<String, Object>();

                facilityContactMechValueMaps.add(facilityContactMechValueMap);
                facilityContactMechValueMap.put(""contactMech"", contactMech);
                facilityContactMechValueMap.put(""facilityContactMech"", facilityContactMech);

                try {
                    facilityContactMechValueMap.put(""contactMechType"", contactMech.getRelatedOne(""ContactMechType"", true));
                } catch (GenericEntityException e) {
                    Debug.logWarning(e, module);
                }

                try {
                    List<GenericValue> facilityContactMechPurposes = facilityContactMech.getRelated(""FacilityContactMechPurpose"", null, null, false);

                    if (!showOld) facilityContactMechPurposes = EntityUtil.filterByDate(facilityContactMechPurposes, true);
                    facilityContactMechValueMap.put(""facilityContactMechPurposes"", facilityContactMechPurposes);
                } catch (GenericEntityException e) {
                    Debug.logWarning(e, module);
                }

                try {
                    if (""POSTAL_ADDRESS"".equals(contactMech.getString(""contactMechTypeId""))) {
                        facilityContactMechValueMap.put(""postalAddress"", contactMech.getRelatedOne(""PostalAddress"", false));
                    } else if (""TELECOM_NUMBER"".equals(contactMech.getString(""contactMechTypeId""))) {
                        facilityContactMechValueMap.put(""telecomNumber"", contactMech.getRelatedOne(""TelecomNumber"", false));
                    }
                } catch (GenericEntityException e) {
                    Debug.logWarning(e, module);
                }
            }
        }

        return facilityContactMechValueMaps;
    }
",long method
392,"    private boolean configureHA(final Long resourceId, final HAResource.ResourceType resourceType, final Boolean enable, final String haProvider) {
        return Transaction.execute(new TransactionCallback<Boolean>() {
            @Override
            public Boolean doInTransaction(TransactionStatus status) {
                HAConfigVO haConfig = (HAConfigVO) haConfigDao.findHAResource(resourceId, resourceType);
                if (haConfig == null) {
                    haConfig = new HAConfigVO();
                    if (haProvider != null) {
                        haConfig.setHaProvider(haProvider);
                    }
                    if (enable != null) {
                        haConfig.setEnabled(enable);
                        haConfig.setManagementServerId(ManagementServerNode.getManagementServerId());
                    }
                    haConfig.setResourceId(resourceId);
                    haConfig.setResourceType(resourceType);
                    if (Strings.isNullOrEmpty(haConfig.getHaProvider())) {
                        throw new ServerApiException(ApiErrorCode.PARAM_ERROR, ""HAProvider is not provided for the resource, failing configuration."");
                    }
                    if (haConfigDao.persist(haConfig) != null) {
                        return true;
                    }
                } else {
                    if (enable != null) {
                        haConfig.setEnabled(enable);
                    }
                    if (haProvider != null) {
                        haConfig.setHaProvider(haProvider);
                    }
                    if (Strings.isNullOrEmpty(haConfig.getHaProvider())) {
                        throw new ServerApiException(ApiErrorCode.PARAM_ERROR, ""HAProvider is not provided for the resource, failing configuration."");
                    }
                    return haConfigDao.update(haConfig.getId(), haConfig);
                }
                return false;
            }
        });
    }
",feature envy
1107,"    private synchronized void checkHealth() {
        CalculatedStatus status = calculateStatus();
        boolean healthy = status.isHealthy();
        long now = System.currentTimeMillis();

        if (healthy) {
            stateLastGood.set(now);
            if (lastPublished == LastPublished.FAILED) {
                if (currentRecoveryStartTime == null) {
                    LOG.info(""{} check for {}, now recovering: {}"", new Object[] {this, entity, getDescription(status)});
                    currentRecoveryStartTime = now;
                    schedulePublish();
                } else {
                    if (LOG.isTraceEnabled()) LOG.trace(""{} check for {}, continuing recovering: {}"", new Object[] {this, entity, getDescription(status)});
                }
            } else {
                if (currentFailureStartTime != null) {
                    LOG.info(""{} check for {}, now healthy: {}"", new Object[] {this, entity, getDescription(status)});
                    currentFailureStartTime = null;
                } else {
                    if (LOG.isTraceEnabled()) LOG.trace(""{} check for {}, still healthy: {}"", new Object[] {this, entity, getDescription(status)});
                }
            }
        } else {
            stateLastFail.set(now);
            if (lastPublished != LastPublished.FAILED) {
                if (currentFailureStartTime == null) {
                    LOG.info(""{} check for {}, now failing: {}"", new Object[] {this, entity, getDescription(status)});
                    currentFailureStartTime = now;
                    schedulePublish();
                } else {
                    if (LOG.isTraceEnabled()) LOG.trace(""{} check for {}, continuing failing: {}"", new Object[] {this, entity, getDescription(status)});
                }
            } else {
                if (currentRecoveryStartTime != null) {
                    LOG.info(""{} check for {}, now failing: {}"", new Object[] {this, entity, getDescription(status)});
                    currentRecoveryStartTime = null;
                } else {
                    if (LOG.isTraceEnabled()) LOG.trace(""{} check for {}, still failed: {}"", new Object[] {this, entity, getDescription(status)});
                }
            }
        }
    }
",long method
115,,blob
1086,"public class ElasticsearchClientFactory {

  private static final Logger LOG = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
  private static final String ES_SETTINGS_KEY = ""es.client.settings""; // es config key in global config

  /**
   * Creates an Elasticsearch client from settings provided via the global config.
   *
   * @return new client
   */
  public static ElasticsearchClient create(Map<String, Object> globalConfig) {
    ElasticsearchClientConfig esClientConfig = new ElasticsearchClientConfig(
        getEsSettings(globalConfig));
    HttpHost[] httpHosts = getHttpHosts(globalConfig, esClientConfig.getConnectionScheme());
    RestClientBuilder builder = RestClient.builder(httpHosts);

    builder.setRequestConfigCallback(reqConfigBuilder -> {
      // Modifies request config builder with connection and socket timeouts.
      // https://www.elastic.co/guide/en/elasticsearch/client/java-rest/5.6/_timeouts.html
      reqConfigBuilder.setConnectTimeout(esClientConfig.getConnectTimeoutMillis());
      reqConfigBuilder.setSocketTimeout(esClientConfig.getSocketTimeoutMillis());
      return reqConfigBuilder;
    });
    builder.setMaxRetryTimeoutMillis(esClientConfig.getMaxRetryTimeoutMillis());

    builder.setHttpClientConfigCallback(clientBuilder -> {
      clientBuilder.setDefaultIOReactorConfig(getIOReactorConfig(esClientConfig));
      clientBuilder.setDefaultCredentialsProvider(getCredentialsProvider(esClientConfig));
      clientBuilder.setSSLContext(getSSLContext(esClientConfig));
      return clientBuilder;
    });

    RestClient lowLevelClient = builder.build();
    RestHighLevelClient client = new RestHighLevelClient(lowLevelClient);
    return new ElasticsearchClient(lowLevelClient, client);
  }

  private static Map<String, Object> getEsSettings(Map<String, Object> globalConfig) {
    return (Map<String, Object>) globalConfig.getOrDefault(ES_SETTINGS_KEY, new HashMap<>());
  }

  private static HttpHost[] getHttpHosts(Map<String, Object> globalConfiguration, String scheme) {
    List<HostnamePort> hps = ElasticsearchUtils.getIps(globalConfiguration);
    HttpHost[] httpHosts = new HttpHost[hps.size()];
    int i = 0;
    for (HostnamePort hp : hps) {
      httpHosts[i++] = new HttpHost(hp.hostname, hp.port, scheme);
    }
    return httpHosts;
  }

  /**
   * Creates config with setting for num connection threads. Default is ES client default,
   * which is 1 to num processors per the documentation.
   * https://www.elastic.co/guide/en/elasticsearch/client/java-rest/5.6/_number_of_threads.html
   */
  private static IOReactorConfig getIOReactorConfig(ElasticsearchClientConfig esClientConfig) {
    if (esClientConfig.getNumClientConnectionThreads().isPresent()) {
      Integer numThreads = esClientConfig.getNumClientConnectionThreads().get();
      LOG.info(""Setting number of client connection threads: {}"", numThreads);
      return IOReactorConfig.custom().setIoThreadCount(numThreads).build();
    } else {
      return IOReactorConfig.DEFAULT;
    }
  }

  private static CredentialsProvider getCredentialsProvider(
      ElasticsearchClientConfig esClientConfig) {
    Optional<Entry<String, String>> credentials = esClientConfig.getCredentials();
    if (credentials.isPresent()) {
      LOG.info(
          ""Found auth credentials - setting up user/pass authenticated client connection for ES."");
      final CredentialsProvider credentialsProvider = new BasicCredentialsProvider();
      UsernamePasswordCredentials upcredentials = new UsernamePasswordCredentials(
          credentials.get().getKey(), credentials.get().getValue());
      credentialsProvider.setCredentials(AuthScope.ANY, upcredentials);
      return credentialsProvider;
    } else {
      LOG.info(
          ""Elasticsearch client credentials not provided. Defaulting to non-authenticated client connection."");
      return null;
    }
  }

  /**
   * <p>Setup connection encryption details (SSL) if applicable.
   * If ssl.enabled=true, sets up SSL connection. If enabled, keystore.path is required. User can
   * also optionally set keystore.password and keystore.type.
   * https://www.elastic.co/guide/en/elasticsearch/client/java-rest/5.6/_encrypted_communication.html
   * <p>
   * <p>Other guidance on the HTTP Component library and configuring SSL connections.
   * http://www.robinhowlett.com/blog/2016/01/05/everything-you-ever-wanted-to-know-about-ssl-but-were-afraid-to-ask.
   * <p>
   * <p>JSSE docs - https://docs.oracle.com/javase/8/docs/technotes/guides/security/jsse/JSSERefGuide.html
   * <p>
   * <p>Additional guidance for configuring Elasticsearch for SSL can be found here - https://www.elastic.co/guide/en/x-pack/5.6/ssl-tls.html
   */
  private static SSLContext getSSLContext(ElasticsearchClientConfig esClientConfig) {
    if (esClientConfig.isSSLEnabled()) {
      LOG.info(""Configuring client for SSL connection."");
      if (!esClientConfig.getKeyStorePath().isPresent()) {
        throw new IllegalStateException(""KeyStore path must be provided for SSL connection."");
      }
      Optional<String> optKeyStorePass = esClientConfig.getKeyStorePassword();
      char[] keyStorePass = optKeyStorePass.map(String::toCharArray).orElse(null);
      KeyStore trustStore = getStore(esClientConfig.getKeyStoreType(),
          esClientConfig.getKeyStorePath().get(), keyStorePass);
      try {
        SSLContextBuilder sslBuilder = SSLContexts.custom().loadTrustMaterial(trustStore, null);
        return sslBuilder.build();
      } catch (NoSuchAlgorithmException | KeyStoreException | KeyManagementException e) {
        throw new IllegalStateException(""Unable to load truststore."", e);
      }
    }
    return null;
  }

  private static KeyStore getStore(String type, Path path, char[] pass) {
    KeyStore store;
    try {
      store = KeyStore.getInstance(type);
    } catch (KeyStoreException e) {
      throw new IllegalStateException(""Unable to get keystore type '"" + type + ""'"", e);
    }
    try (InputStream is = Files.newInputStream(path)) {
      store.load(is, pass);
    } catch (IOException | NoSuchAlgorithmException | CertificateException e) {
      throw new IllegalStateException(""Unable to load keystore from path '"" + path + ""'"", e);
    }
    return store;
  }

}
",blob
250,"@SuppressWarnings(""serial"")
public class GitHubUser implements Serializable {

	private final long id;

	private final String url;

	private final String login;

	private final String avatarUrl;

	private final String gravatarId;

	private String name;

	private String email;

    public GitHubUser(long id, String url, String login, String avatarUrl, String gravatarId) {
        this.id = id;
        this.url = url;
        this.login = login;
        this.avatarUrl = avatarUrl;
        this.gravatarId = gravatarId;
    }

    public Long getId() { return id; }
	
	public String getUrl() { return url; }

	public String getLogin() { return login; }

	public String getAvatarUrl() { return avatarUrl; }

	public String getGravatarId() { return gravatarId; }
	
	public String getName() { return name; }
	
	public void setName(String name) { this.name = name; }
	
	public String getEmail() { return email; }
	
	public void setEmail(String email) { this.email = email; }
}
",data class
1281,"public class SQLDropTableStatement extends SQLStatementImpl implements SQLDropStatement {
    private List<SQLCommentHint> hints;

    protected List<SQLExprTableSource> tableSources = new ArrayList<SQLExprTableSource>();

    private boolean                    purge;

    protected boolean                  cascade      = false;
    protected boolean                  restrict     = false;
    protected boolean                  ifExists     = false;
    private boolean                    temporary    = false;

    public SQLDropTableStatement(){

    }
    
    public SQLDropTableStatement(String dbType){
        super (dbType);
    }

    public SQLDropTableStatement(SQLName name, String dbType){
        this(new SQLExprTableSource(name), dbType);
    }
    
    public SQLDropTableStatement(SQLName name){
        this (name, null);
    }
    
    public SQLDropTableStatement(SQLExprTableSource tableSource){
        this (tableSource, null);
    }

    public SQLDropTableStatement(SQLExprTableSource tableSource, String dbType){
        this (dbType);
        this.tableSources.add(tableSource);
    }

    public List<SQLExprTableSource> getTableSources() {
        return tableSources;
    }
    
    public void addPartition(SQLExprTableSource tableSource) {
        if (tableSource != null) {
            tableSource.setParent(this);
        }
        this.tableSources.add(tableSource);
    }

    public void setName(SQLName name) {
        this.addTableSource(new SQLExprTableSource(name));
    }

    public void addTableSource(SQLName name) {
        this.addTableSource(new SQLExprTableSource(name));
    }

    public void addTableSource(SQLExprTableSource tableSource) {
        tableSources.add(tableSource);
    }

    @Override
    protected void accept0(SQLASTVisitor visitor) {
        if (visitor.visit(this)) {
            this.acceptChild(visitor, tableSources);
        }
        visitor.endVisit(this);
    }

    @Override
    public List getChildren() {
        return this.tableSources;
    }

    public boolean isPurge() {
        return purge;
    }

    public void setPurge(boolean purge) {
        this.purge = purge;
    }

    public boolean isIfExists() {
        return ifExists;
    }

    public void setIfExists(boolean ifExists) {
        this.ifExists = ifExists;
    }

    public boolean isCascade() {
        return cascade;
    }

    public void setCascade(boolean cascade) {
        this.cascade = cascade;
    }

    public boolean isRestrict() {
        return restrict;
    }

    public void setRestrict(boolean restrict) {
        this.restrict = restrict;
    }

    public boolean isTemporary() {
        return temporary;
    }

    public void setTemporary(boolean temporary) {
        this.temporary = temporary;
    }

    public List<SQLCommentHint> getHints() {
        return hints;
    }

    public void setHints(List<SQLCommentHint> hints) {
        this.hints = hints;
    }
}
",data class
515,"public class DebugTraceBasedRegion extends AbstractTraceRegion {

	private final DebugTraceRegion delegate;

	protected DebugTraceBasedRegion(AbstractTraceRegion parent, DebugTraceRegion delegate) {
		super(parent);
		this.delegate = delegate;
		for (DebugTraceRegion child : delegate.getNestedRegions())
			new DebugTraceBasedRegion(this, child);
	}

	private LocationData convert(DebugLocationData data) {
		SourceRelativeURI uri = data.getPath() != null ? new SourceRelativeURI(data.getPath()) : null;
		return new LocationData(data.getOffset(), data.getLength(), data.getLineNumber(), data.getEndLineNumber(), uri);
	}

	@Override
	public List<ILocationData> getAssociatedLocations() {
		List<ILocationData> result = Lists.newArrayListWithCapacity(delegate.getAssociations().size());
		for (DebugLocationData data : delegate.getAssociations())
			result.add(convert(data));
		return result;
	}

	@Override
	public SourceRelativeURI getAssociatedSrcRelativePath() {
		SourceRelativeURI path = super.getAssociatedSrcRelativePath();
		if (path != null)
			return path;
		return getAssociatedSrcRelativePath(delegate);
	}

	protected SourceRelativeURI getAssociatedSrcRelativePath(DebugTraceRegion region) {
		for (DebugLocationData associated : region.getAssociations()) {
			URI uri = associated.getPath();
			if (uri != null)
				return new SourceRelativeURI(uri);
		}
		EObject container = region.eContainer();
		if (container instanceof DebugTraceRegion)
			return getAssociatedSrcRelativePath((DebugTraceRegion) container);
		return null;
	}

	@Override
	public int getMyEndLineNumber() {
		return delegate.getMyEndLineNumber();
	}

	@Override
	public int getMyLength() {
		return delegate.getMyLength();
	}

	@Override
	public int getMyLineNumber() {
		return delegate.getMyLineNumber();
	}

	@Override
	public int getMyOffset() {
		return delegate.getMyOffset();
	}

	@Override
	public boolean isUseForDebugging() {
		return delegate.isUseForDebugging();
	}

}
",data class
446,"public class PeriodFormatterData {
  final DataRecord dr;
  String localeName;

  // debug
  public static boolean trace = false;

  public PeriodFormatterData(String localeName, DataRecord dr) {
    this.dr = dr;
    this.localeName = localeName;
    if(localeName == null) {
        throw new NullPointerException(""localename is null"");
    }
//    System.err.println(""** localeName is "" + localeName);
    if (dr == null) {
//      Thread.dumpStack();
      throw new NullPointerException(""data record is null"");
    }
  }

  // none - chinese (all forms the same)
  // plural - english, special form for 1
  // dual - special form for 1 and 2
  // paucal - russian, special form for 1, for 2-4 and n > 20 && n % 10 == 2-4
  // rpt_dual_few - slovenian, special form for 1, 2, 3-4 and n as above
  // hebrew, dual plus singular form for years > 11
  // arabic, dual, plus singular form for all terms > 10

  /**
   * Return the pluralization format used by this locale.
   * @return the pluralization format
   */
  public int pluralization() {
    return dr.pl;
  }

  /**
   * Return true if zeros are allowed in the display.
   * @return true if zeros should be allowed
   */
  public boolean allowZero() {
    return dr.allowZero;
  }

  public boolean weeksAloneOnly() {
    return dr.weeksAloneOnly;
  }

  public int useMilliseconds() {
    return dr.useMilliseconds;
  }

  /**
   * Append the appropriate prefix to the string builder, depending on whether and
   * how a limit and direction are to be displayed.
   *
   * @param tl how and whether to display the time limit
   * @param td how and whether to display the time direction
   * @param sb the string builder to which to append the text
   * @return true if a following digit will require a digit prefix
   */
  public boolean appendPrefix(int tl, int td, StringBuffer sb) {
    if (dr.scopeData != null) {
      int ix = tl * 3 + td;
      ScopeData sd = dr.scopeData[ix];
      if (sd != null) {
        String prefix = sd.prefix;
        if (prefix != null) {
          sb.append(prefix);
          return sd.requiresDigitPrefix;
        }
      }
    }
    return false;
  }

  /**
   * Append the appropriate suffix to the string builder, depending on whether and
   * how a limit and direction are to be displayed.
   *
   * @param tl how and whether to display the time limit
   * @param td how and whether to display the time direction
   * @param sb the string builder to which to append the text
   */
  public void appendSuffix(int tl, int td, StringBuffer sb) {
    if (dr.scopeData != null) {
      int ix = tl * 3 + td;
      ScopeData sd = dr.scopeData[ix];
      if (sd != null) {
        String suffix = sd.suffix;
        if (suffix != null) {
          if (trace) {
            System.out.println(""appendSuffix '"" + suffix + ""'"");
          }
          sb.append(suffix);
        }
      }
    }
  }

  /**
   * Append the count and unit to the string builder.
   *
   * @param unit the unit to append
   * @param count the count of units, * 1000
   * @param cv the format to use for displaying the count
   * @param uv the format to use for displaying the unit
   * @param useCountSep if false, force no separator between count and unit
   * @param useDigitPrefix if true, use the digit prefix
   * @param multiple true if there are multiple units in this string
   * @param last true if this is the last unit
   * @param wasSkipped true if the unit(s) before this were skipped
   * @param sb the string builder to which to append the text
   * @return true if will require skip marker
   */
  @SuppressWarnings(""fallthrough"")
  public boolean appendUnit(TimeUnit unit, int count, int cv, 
                            int uv, boolean useCountSep, 
                            boolean useDigitPrefix, boolean multiple, 
                            boolean last, boolean wasSkipped, 
                            StringBuffer sb) {
    int px = unit.ordinal();

    boolean willRequireSkipMarker = false;
    if (dr.requiresSkipMarker != null && dr.requiresSkipMarker[px] && 
        dr.skippedUnitMarker != null) {
      if (!wasSkipped && last) {
        sb.append(dr.skippedUnitMarker);
      }
      willRequireSkipMarker = true;
    }

    if (uv != EUnitVariant.PLURALIZED) {
      boolean useMedium = uv == EUnitVariant.MEDIUM; 
      String[] names = useMedium ? dr.mediumNames : dr.shortNames;
      if (names == null || names[px] == null) {
        names = useMedium ? dr.shortNames : dr.mediumNames;
      }
      if (names != null && names[px] != null) {
        appendCount(unit, false, false, count, cv, useCountSep, 
                    names[px], last, sb); // omit suffix, ok?
        return false; // omit skip marker
      }
    }

    // check cv
    if (cv == ECountVariant.HALF_FRACTION && dr.halfSupport != null) {
      switch (dr.halfSupport[px]) {
        case EHalfSupport.YES: break;
        case EHalfSupport.ONE_PLUS:
          if (count > 1000) {
            break;
          }
          // else fall through to decimal
        case EHalfSupport.NO: {
          count = (count / 500) * 500;  // round to 1/2
          cv = ECountVariant.DECIMAL1; 
        } break;
      }
    }
          
    String name = null;
    int form = computeForm(unit, count, cv, multiple && last);
    if (form == FORM_SINGULAR_SPELLED) {
      if (dr.singularNames == null) {
        form = FORM_SINGULAR;
        name = dr.pluralNames[px][form];
      } else {
        name = dr.singularNames[px];
      }
    } else if (form == FORM_SINGULAR_NO_OMIT) {
      name = dr.pluralNames[px][FORM_SINGULAR];
    } else if (form == FORM_HALF_SPELLED) {
      name = dr.halfNames[px];
    } else { 
      try {
        name = dr.pluralNames[px][form];
      } catch (NullPointerException e) {
        System.out.println(""Null Pointer in PeriodFormatterData[""+localeName+""].au px: "" + px + "" form: "" + form + "" pn: "" + Arrays.toString(dr.pluralNames));
        throw e;
      }
    }
    if (name == null) {
      form = FORM_PLURAL;
      name = dr.pluralNames[px][form];
    }

    boolean omitCount =
      (form == FORM_SINGULAR_SPELLED || form == FORM_HALF_SPELLED) ||
      (dr.omitSingularCount && form == FORM_SINGULAR) ||
      (dr.omitDualCount && form == FORM_DUAL);

    int suffixIndex = appendCount(unit, omitCount, useDigitPrefix, count, cv, 
                                  useCountSep, name, last, sb);
    if (last && suffixIndex >= 0) {
      String suffix = null;
      if (dr.rqdSuffixes != null && suffixIndex < dr.rqdSuffixes.length) {
        suffix = dr.rqdSuffixes[suffixIndex];
      }
      if (suffix == null && dr.optSuffixes != null && 
          suffixIndex < dr.optSuffixes.length) {
        suffix = dr.optSuffixes[suffixIndex];
      }
      if (suffix != null) {
        sb.append(suffix);
      }
    }
    return willRequireSkipMarker;
  }

  /**
   * Append a count to the string builder.
   *
   * @param unit the unit
   * @param count the count
   * @param cv the format to use for displaying the count
   * @param useSep whether to use the count separator, if available
   * @param name the term name
   * @param last true if this is the last unit to be formatted
   * @param sb the string builder to which to append the text
   * @return index to use if might have required or optional suffix, or -1 if none required
   */
  public int appendCount(TimeUnit unit, boolean omitCount, 
                         boolean useDigitPrefix, 
                         int count, int cv, boolean useSep, 
                         String name, boolean last, StringBuffer sb) {
    if (cv == ECountVariant.HALF_FRACTION && dr.halves == null) {
      cv = ECountVariant.INTEGER;
    }

    if (!omitCount && useDigitPrefix && dr.digitPrefix != null) {
      sb.append(dr.digitPrefix);
    }

    int index = unit.ordinal();
    switch (cv) {
      case ECountVariant.INTEGER: {
        if (!omitCount) {
          appendInteger(count/1000, 1, 10, sb);
        }
      } break;

      case ECountVariant.INTEGER_CUSTOM: {
        int val = count / 1000;
        // only custom names we have for now
        if (unit == TimeUnit.MINUTE && 
            (dr.fiveMinutes != null || dr.fifteenMinutes != null)) {
          if (val != 0 && val % 5 == 0) {
            if (dr.fifteenMinutes != null && (val == 15 || val == 45)) {
              val = val == 15 ? 1 : 3;
              if (!omitCount) appendInteger(val, 1, 10, sb);
              name = dr.fifteenMinutes;
              index = 8; // hack
              break;
            }
            if (dr.fiveMinutes != null) {
              val = val / 5;
              if (!omitCount) appendInteger(val, 1, 10, sb);
              name = dr.fiveMinutes;
              index = 9; // hack
              break;
            }
          }
        }
        if (!omitCount) appendInteger(val, 1, 10, sb);
      } break;

      case ECountVariant.HALF_FRACTION: {
        // 0, 1/2, 1, 1-1/2...
        int v = count / 500;
        if (v != 1) {
          if (!omitCount) appendCountValue(count, 1, 0, sb);
        }
        if ((v & 0x1) == 1) {
          // hack, using half name
          if (v == 1 && dr.halfNames != null && dr.halfNames[index] != null) {
            sb.append(name);
            return last ? index : -1;
          }

          int solox = v == 1 ? 0 : 1;
          if (dr.genders != null && dr.halves.length > 2) {
            if (dr.genders[index] == EGender.F) {
              solox += 2;
            }
          }
          int hp = dr.halfPlacements == null 
              ? EHalfPlacement.PREFIX
              : dr.halfPlacements[solox & 0x1];
          String half = dr.halves[solox];
          String measure = dr.measures == null ? null : dr.measures[index];
          switch (hp) {
            case EHalfPlacement.PREFIX:
              sb.append(half);
              break;
            case EHalfPlacement.AFTER_FIRST: {
              if (measure != null) {
                sb.append(measure);
                sb.append(half);
                if (useSep && !omitCount) {
                  sb.append(dr.countSep);
                } 
                sb.append(name);
              } else { // ignore sep completely
                sb.append(name);
                sb.append(half);
                return last ? index : -1; // might use suffix
              }
            } return -1; // exit early
            case EHalfPlacement.LAST: {
              if (measure != null) {
                sb.append(measure);
              }
              if (useSep && !omitCount) {
                sb.append(dr.countSep);
              }
              sb.append(name);
              sb.append(half);
            } return last ? index : -1; // might use suffix
          }
        }
      } break;
      default: {
        int decimals = 1;
        switch (cv) {
          case ECountVariant.DECIMAL2: decimals = 2; break;
          case ECountVariant.DECIMAL3: decimals = 3; break;
          default: break;
        }
        if (!omitCount) appendCountValue(count, 1, decimals, sb);
      } break;
    }
    if (!omitCount && useSep) {
      sb.append(dr.countSep);
    }
    if (!omitCount && dr.measures != null && index < dr.measures.length) {
      String measure = dr.measures[index];
      if (measure != null) {
        sb.append(measure);
      }
    }
    sb.append(name);
    return last ? index : -1;
  }

  /**
   * Append a count value to the builder.
   *
   * @param count the count
   * @param integralDigits the number of integer digits to display
   * @param decimalDigits the number of decimal digits to display, <= 3
   * @param sb the string builder to which to append the text
   */
  public void appendCountValue(int count, int integralDigits, 
                               int decimalDigits, StringBuffer sb) {
    int ival = count / 1000;
    if (decimalDigits == 0) {
      appendInteger(ival, integralDigits, 10, sb);
      return;
    }

    if (dr.requiresDigitSeparator && sb.length() > 0) {
      sb.append(' ');
    }
    appendDigits(ival, integralDigits, 10, sb);
    int dval = count % 1000;
    if (decimalDigits == 1) {
      dval /= 100;
    } else if (decimalDigits == 2) {
      dval /= 10;
    }
    sb.append(dr.decimalSep);
    appendDigits(dval, decimalDigits, decimalDigits, sb);
    if (dr.requiresDigitSeparator) {
      sb.append(' ');
    }
  }

  public void appendInteger(int num, int mindigits, int maxdigits, 
                            StringBuffer sb) {
    if (dr.numberNames != null && num < dr.numberNames.length) {
      String name = dr.numberNames[num];
      if (name != null) {
        sb.append(name);
        return;
      }
    }

    if (dr.requiresDigitSeparator && sb.length() > 0) {
      sb.append(' ');
    }
    switch (dr.numberSystem) {
      case ENumberSystem.DEFAULT: appendDigits(num, mindigits, maxdigits, sb); break;
      case ENumberSystem.CHINESE_TRADITIONAL: sb.append(
          Utils.chineseNumber(num, Utils.ChineseDigits.TRADITIONAL)); break;
      case ENumberSystem.CHINESE_SIMPLIFIED: sb.append(
          Utils.chineseNumber(num, Utils.ChineseDigits.SIMPLIFIED)); break;
      case ENumberSystem.KOREAN: sb.append(
          Utils.chineseNumber(num, Utils.ChineseDigits.KOREAN)); break;
    }
    if (dr.requiresDigitSeparator) {
      sb.append(' ');
    }
  }

  /**
   * Append digits to the string builder, using this.zero for '0' etc.
   *
   * @param num the integer to append
   * @param mindigits the minimum number of digits to append
   * @param maxdigits the maximum number of digits to append
   * @param sb the string builder to which to append the text
   */
  public void appendDigits(long num, int mindigits, int maxdigits,  
                           StringBuffer sb) {
    char[] buf = new char[maxdigits];
    int ix = maxdigits;
    while (ix > 0 && num > 0) {
      buf[--ix] = (char)(dr.zero + (num % 10));
      num /= 10;
    }
    for (int e = maxdigits - mindigits; ix > e;) {
      buf[--ix] = dr.zero;
    }
    sb.append(buf, ix, maxdigits - ix);
  }

  /**
   * Append a marker for skipped units internal to a string.
   * @param sb the string builder to which to append the text
   */
  public void appendSkippedUnit(StringBuffer sb) {
    if (dr.skippedUnitMarker != null) {
      sb.append(dr.skippedUnitMarker);
    }
  }

  /**
   * Append the appropriate separator between units
   *
   * @param unit the unit to which to append the separator
   * @param afterFirst true if this is the first unit formatted
   * @param beforeLast true if this is the next-to-last unit to be formatted
   * @param sb the string builder to which to append the text
   * @return true if a prefix will be required before a following unit
   */
  public boolean appendUnitSeparator(TimeUnit unit, boolean longSep, 
                                     boolean afterFirst, boolean beforeLast, 
                                     StringBuffer sb) {
    // long seps
    // false, false ""...b', '...d""
    // false, true  ""...', and 'c""
    // true, false - ""a', '...c""
    // true, true - ""a' and 'b""
    if ((longSep && dr.unitSep != null) || dr.shortUnitSep != null) {
      if (longSep && dr.unitSep != null) {
        int ix = (afterFirst ? 2 : 0) + (beforeLast ? 1 : 0);
        sb.append(dr.unitSep[ix]);
        return dr.unitSepRequiresDP != null && dr.unitSepRequiresDP[ix];
      }
      sb.append(dr.shortUnitSep); // todo: investigate whether DP is required
    }
    return false;
  }

  private static final int 
    FORM_PLURAL = 0,
    FORM_SINGULAR = 1,
    FORM_DUAL = 2,
    FORM_PAUCAL = 3,
    FORM_SINGULAR_SPELLED = 4, // following are not in the pluralization list
    FORM_SINGULAR_NO_OMIT = 5, // a hack
    FORM_HALF_SPELLED = 6;

  private int computeForm(TimeUnit unit, int count, int cv, 
                          boolean lastOfMultiple) {
    // first check if a particular form is forced by the countvariant.  if
    // SO, just return that.  otherwise convert the count to an integer
    // and use pluralization rules to determine which form to use.
    // careful, can't assume any forms but plural exist.

    if (trace) {
      System.err.println(""pfd.cf unit: "" + unit + "" count: "" + count + "" cv: "" + cv + "" dr.pl: "" + dr.pl);
      Thread.dumpStack();
    }
    if (dr.pl == EPluralization.NONE) {
      return FORM_PLURAL;
    }
    // otherwise, assume we have at least a singular and plural form

    int val = count/1000;

    switch (cv) {
      case ECountVariant.INTEGER: 
      case ECountVariant.INTEGER_CUSTOM: {
        // do more analysis based on floor of count
      } break;
      case ECountVariant.HALF_FRACTION: {
        switch (dr.fractionHandling) {
          case EFractionHandling.FPLURAL:
            return FORM_PLURAL;

          case EFractionHandling.FSINGULAR_PLURAL_ANDAHALF:
          case EFractionHandling.FSINGULAR_PLURAL: {
            // if half-floor is 1/2, use singular
            // else if half-floor is not integral, use plural
            // else do more analysis
            int v = count / 500;
            if (v == 1) {
              if (dr.halfNames != null && dr.halfNames[unit.ordinal()] != null) {
                return FORM_HALF_SPELLED;
              }
              return FORM_SINGULAR_NO_OMIT;
            }
            if ((v & 0x1) == 1) {
              if (dr.pl == EPluralization.ARABIC && v > 21) { // hack
                return FORM_SINGULAR_NO_OMIT;
              }
              if (v == 3 && dr.pl == EPluralization.PLURAL &&
                  dr.fractionHandling != EFractionHandling.FSINGULAR_PLURAL_ANDAHALF) {
                return FORM_PLURAL;
              }
            }
            
            // it will display like an integer, so do more analysis
          } break;

          case EFractionHandling.FPAUCAL: {
            int v = count / 500;
            if (v == 1 || v == 3) {
              return FORM_PAUCAL;
            }
            // else use integral form
          } break;

          default:
            throw new IllegalStateException();
        }
      } break;
      default: { // for all decimals
        switch (dr.decimalHandling) {
          case EDecimalHandling.DPLURAL: break;
          case EDecimalHandling.DSINGULAR: return FORM_SINGULAR_NO_OMIT;
          case EDecimalHandling.DSINGULAR_SUBONE:
            if (count < 1000) {
              return FORM_SINGULAR_NO_OMIT;
            }
            break;
          case EDecimalHandling.DPAUCAL:
            if (dr.pl == EPluralization.PAUCAL) {
              return FORM_PAUCAL;
            }
            break;
          default:
            break;
        }
        return FORM_PLURAL;
      }
    }

    // select among pluralization forms
    if (trace && count == 0) {
      System.err.println(""EZeroHandling = "" + dr.zeroHandling);
    }
    if (count == 0 && dr.zeroHandling == EZeroHandling.ZSINGULAR) {
      return FORM_SINGULAR_SPELLED;
    }

    int form = FORM_PLURAL;
    switch(dr.pl) {
      case EPluralization.NONE: break; // never get here
      case EPluralization.PLURAL: {
        if (val == 1) { 
          form = FORM_SINGULAR_SPELLED; // defaults to form_singular if no spelled forms
        } 
      } break;
      case EPluralization.DUAL: {
        if (val == 2) {
          form = FORM_DUAL; 
        } else if (val == 1) {
          form = FORM_SINGULAR; 
        } 
      } break;
      case EPluralization.PAUCAL: {
        int v = val;
        v = v % 100;
        if (v > 20) {
          v = v % 10;
        }
        if (v == 1) {
          form = FORM_SINGULAR;
        } else if (v > 1 && v < 5) {
          form = FORM_PAUCAL;
        }
      } break;
        /*
      case EPluralization.RPT_DUAL_FEW: {
        int v = val;
        if (v > 20) {
          v = v % 10;
        }
        if (v == 1) {
          form = FORM_SINGULAR;
        } else if (v == 2) {
          form = FORM_DUAL;
        } else if (v > 2 && v < 5) {
          form = FORM_PAUCAL;
        }
      } break;
        */
      case EPluralization.HEBREW: {
        if (val == 2) {
          form = FORM_DUAL;
        } else if (val == 1) {
          if (lastOfMultiple) {
            form = FORM_SINGULAR_SPELLED;
          } else {
            form = FORM_SINGULAR;
          } 
        } else if (unit == TimeUnit.YEAR && val > 11) {
          form = FORM_SINGULAR_NO_OMIT;
        }
      } break;
      case EPluralization.ARABIC: {
        if (val == 2) {
          form = FORM_DUAL;
        } else if (val == 1) {
          form = FORM_SINGULAR;
        } else if (val > 10) {
          form = FORM_SINGULAR_NO_OMIT;
        }
      } break;
      default: 
        System.err.println(""dr.pl is "" + dr.pl);
        throw new IllegalStateException();
    }

    return form;
  }
}
",blob
1006,"public class MetadataTableUtil {

  private static final Text EMPTY_TEXT = new Text();
  private static final byte[] EMPTY_BYTES = new byte[0];
  private static Map<Credentials,Writer> root_tables = new HashMap<>();
  private static Map<Credentials,Writer> metadata_tables = new HashMap<>();
  private static final Logger log = LoggerFactory.getLogger(MetadataTableUtil.class);

  private MetadataTableUtil() {}

  public static synchronized Writer getMetadataTable(ServerContext context) {
    Credentials credentials = context.getCredentials();
    Writer metadataTable = metadata_tables.get(credentials);
    if (metadataTable == null) {
      metadataTable = new Writer(context, MetadataTable.ID);
      metadata_tables.put(credentials, metadataTable);
    }
    return metadataTable;
  }

  public static synchronized Writer getRootTable(ServerContext context) {
    Credentials credentials = context.getCredentials();
    Writer rootTable = root_tables.get(credentials);
    if (rootTable == null) {
      rootTable = new Writer(context, RootTable.ID);
      root_tables.put(credentials, rootTable);
    }
    return rootTable;
  }

  public static void putLockID(ServerContext context, ZooLock zooLock, Mutation m) {
    TabletsSection.ServerColumnFamily.LOCK_COLUMN.put(m,
        new Value(zooLock.getLockID().serialize(context.getZooKeeperRoot() + ""/"").getBytes(UTF_8)));
  }

  private static void update(ServerContext context, Mutation m, KeyExtent extent) {
    update(context, null, m, extent);
  }

  public static void update(ServerContext context, ZooLock zooLock, Mutation m, KeyExtent extent) {
    Writer t = extent.isMeta() ? getRootTable(context) : getMetadataTable(context);
    update(context, t, zooLock, m);
  }

  public static void update(ServerContext context, Writer t, ZooLock zooLock, Mutation m) {
    if (zooLock != null)
      putLockID(context, zooLock, m);
    while (true) {
      try {
        t.update(m);
        return;
      } catch (AccumuloException | TableNotFoundException | AccumuloSecurityException e) {
        log.error(""{}"", e.getMessage(), e);
      } catch (ConstraintViolationException e) {
        log.error(""{}"", e.getMessage(), e);
        // retrying when a CVE occurs is probably futile and can cause problems, see ACCUMULO-3096
        throw new RuntimeException(e);
      }
      sleepUninterruptibly(1, TimeUnit.SECONDS);
    }
  }

  public static void updateTabletFlushID(KeyExtent extent, long flushID, ServerContext context,
      ZooLock zooLock) {
    if (!extent.isRootTablet()) {
      Mutation m = new Mutation(extent.getMetadataEntry());
      TabletsSection.ServerColumnFamily.FLUSH_COLUMN.put(m,
          new Value((flushID + """").getBytes(UTF_8)));
      update(context, zooLock, m, extent);
    }
  }

  public static void updateTabletCompactID(KeyExtent extent, long compactID, ServerContext context,
      ZooLock zooLock) {
    if (!extent.isRootTablet()) {
      Mutation m = new Mutation(extent.getMetadataEntry());
      TabletsSection.ServerColumnFamily.COMPACT_COLUMN.put(m,
          new Value((compactID + """").getBytes(UTF_8)));
      update(context, zooLock, m, extent);
    }
  }

  public static void updateTabletDataFile(long tid, KeyExtent extent,
      Map<FileRef,DataFileValue> estSizes, String time, ServerContext context, ZooLock zooLock) {
    Mutation m = new Mutation(extent.getMetadataEntry());
    byte[] tidBytes = Long.toString(tid).getBytes(UTF_8);

    for (Entry<FileRef,DataFileValue> entry : estSizes.entrySet()) {
      Text file = entry.getKey().meta();
      m.put(DataFileColumnFamily.NAME, file, new Value(entry.getValue().encode()));
      m.put(TabletsSection.BulkFileColumnFamily.NAME, file, new Value(tidBytes));
    }
    TabletsSection.ServerColumnFamily.TIME_COLUMN.put(m, new Value(time.getBytes(UTF_8)));
    update(context, zooLock, m, extent);
  }

  public static void updateTabletDir(KeyExtent extent, String newDir, ServerContext context,
      ZooLock lock) {
    Mutation m = new Mutation(extent.getMetadataEntry());
    TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.put(m, new Value(newDir.getBytes(UTF_8)));
    update(context, lock, m, extent);
  }

  public static void addTablet(KeyExtent extent, String path, ServerContext context, char timeType,
      ZooLock lock) {
    Mutation m = extent.getPrevRowUpdateMutation();

    TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.put(m, new Value(path.getBytes(UTF_8)));
    TabletsSection.ServerColumnFamily.TIME_COLUMN.put(m,
        new Value((timeType + ""0"").getBytes(UTF_8)));

    update(context, lock, m, extent);
  }

  public static void updateTabletVolumes(KeyExtent extent, List<LogEntry> logsToRemove,
      List<LogEntry> logsToAdd, List<FileRef> filesToRemove,
      SortedMap<FileRef,DataFileValue> filesToAdd, String newDir, ZooLock zooLock,
      ServerContext context) {

    if (extent.isRootTablet()) {
      if (newDir != null)
        throw new IllegalArgumentException(""newDir not expected for "" + extent);

      if (filesToRemove.size() != 0 || filesToAdd.size() != 0)
        throw new IllegalArgumentException(""files not expected for "" + extent);

      // add before removing in case of process death
      for (LogEntry logEntry : logsToAdd)
        addRootLogEntry(context, zooLock, logEntry);

      removeUnusedWALEntries(context, extent, logsToRemove, zooLock);
    } else {
      Mutation m = new Mutation(extent.getMetadataEntry());

      for (LogEntry logEntry : logsToRemove)
        m.putDelete(logEntry.getColumnFamily(), logEntry.getColumnQualifier());

      for (LogEntry logEntry : logsToAdd)
        m.put(logEntry.getColumnFamily(), logEntry.getColumnQualifier(), logEntry.getValue());

      for (FileRef fileRef : filesToRemove)
        m.putDelete(DataFileColumnFamily.NAME, fileRef.meta());

      for (Entry<FileRef,DataFileValue> entry : filesToAdd.entrySet())
        m.put(DataFileColumnFamily.NAME, entry.getKey().meta(),
            new Value(entry.getValue().encode()));

      if (newDir != null)
        ServerColumnFamily.DIRECTORY_COLUMN.put(m, new Value(newDir.getBytes(UTF_8)));

      update(context, m, extent);
    }
  }

  private interface ZooOperation {
    void run(IZooReaderWriter rw) throws KeeperException, InterruptedException, IOException;
  }

  private static void retryZooKeeperUpdate(ServerContext context, ZooLock zooLock,
      ZooOperation op) {
    while (true) {
      try {
        IZooReaderWriter zoo = context.getZooReaderWriter();
        if (zoo.isLockHeld(zooLock.getLockID())) {
          op.run(zoo);
        }
        break;
      } catch (Exception e) {
        log.error(""Unexpected exception {}"", e.getMessage(), e);
      }
      sleepUninterruptibly(1, TimeUnit.SECONDS);
    }
  }

  private static void addRootLogEntry(ServerContext context, ZooLock zooLock,
      final LogEntry entry) {
    retryZooKeeperUpdate(context, zooLock, new ZooOperation() {
      @Override
      public void run(IZooReaderWriter rw)
          throws KeeperException, InterruptedException, IOException {
        String root = getZookeeperLogLocation(context);
        rw.putPersistentData(root + ""/"" + entry.getUniqueID(), entry.toBytes(),
            NodeExistsPolicy.OVERWRITE);
      }
    });
  }

  public static SortedMap<FileRef,DataFileValue> getDataFileSizes(KeyExtent extent,
      ServerContext context) {
    TreeMap<FileRef,DataFileValue> sizes = new TreeMap<>();

    try (Scanner mdScanner = new ScannerImpl(context, MetadataTable.ID, Authorizations.EMPTY)) {
      mdScanner.fetchColumnFamily(DataFileColumnFamily.NAME);
      Text row = extent.getMetadataEntry();

      Key endKey = new Key(row, DataFileColumnFamily.NAME, new Text(""""));
      endKey = endKey.followingKey(PartialKey.ROW_COLFAM);

      mdScanner.setRange(new Range(new Key(row), endKey));
      for (Entry<Key,Value> entry : mdScanner) {

        if (!entry.getKey().getRow().equals(row))
          break;
        DataFileValue dfv = new DataFileValue(entry.getValue().get());
        sizes.put(new FileRef(context.getVolumeManager(), entry.getKey()), dfv);
      }

      return sizes;
    }
  }

  public static void rollBackSplit(Text metadataEntry, Text oldPrevEndRow, ServerContext context,
      ZooLock zooLock) {
    KeyExtent ke = new KeyExtent(metadataEntry, oldPrevEndRow);
    Mutation m = ke.getPrevRowUpdateMutation();
    TabletsSection.TabletColumnFamily.SPLIT_RATIO_COLUMN.putDelete(m);
    TabletsSection.TabletColumnFamily.OLD_PREV_ROW_COLUMN.putDelete(m);
    update(context, zooLock, m, new KeyExtent(metadataEntry, (Text) null));
  }

  public static void splitTablet(KeyExtent extent, Text oldPrevEndRow, double splitRatio,
      ServerContext context, ZooLock zooLock) {
    Mutation m = extent.getPrevRowUpdateMutation(); //

    TabletsSection.TabletColumnFamily.SPLIT_RATIO_COLUMN.put(m,
        new Value(Double.toString(splitRatio).getBytes(UTF_8)));

    TabletsSection.TabletColumnFamily.OLD_PREV_ROW_COLUMN.put(m,
        KeyExtent.encodePrevEndRow(oldPrevEndRow));
    ChoppedColumnFamily.CHOPPED_COLUMN.putDelete(m);
    update(context, zooLock, m, extent);
  }

  public static void finishSplit(Text metadataEntry, Map<FileRef,DataFileValue> datafileSizes,
      List<FileRef> highDatafilesToRemove, final ServerContext context, ZooLock zooLock) {
    Mutation m = new Mutation(metadataEntry);
    TabletsSection.TabletColumnFamily.SPLIT_RATIO_COLUMN.putDelete(m);
    TabletsSection.TabletColumnFamily.OLD_PREV_ROW_COLUMN.putDelete(m);
    ChoppedColumnFamily.CHOPPED_COLUMN.putDelete(m);

    for (Entry<FileRef,DataFileValue> entry : datafileSizes.entrySet()) {
      m.put(DataFileColumnFamily.NAME, entry.getKey().meta(), new Value(entry.getValue().encode()));
    }

    for (FileRef pathToRemove : highDatafilesToRemove) {
      m.putDelete(DataFileColumnFamily.NAME, pathToRemove.meta());
    }

    update(context, zooLock, m, new KeyExtent(metadataEntry, (Text) null));
  }

  public static void finishSplit(KeyExtent extent, Map<FileRef,DataFileValue> datafileSizes,
      List<FileRef> highDatafilesToRemove, ServerContext context, ZooLock zooLock) {
    finishSplit(extent.getMetadataEntry(), datafileSizes, highDatafilesToRemove, context, zooLock);
  }

  public static void addDeleteEntries(KeyExtent extent, Set<FileRef> datafilesToDelete,
      ServerContext context) {

    TableId tableId = extent.getTableId();

    // TODO could use batch writer,would need to handle failure and retry like update does -
    // ACCUMULO-1294
    for (FileRef pathToRemove : datafilesToDelete) {
      update(context, createDeleteMutation(context, tableId, pathToRemove.path().toString()),
          extent);
    }
  }

  public static void addDeleteEntry(ServerContext context, TableId tableId, String path) {
    update(context, createDeleteMutation(context, tableId, path),
        new KeyExtent(tableId, null, null));
  }

  public static Mutation createDeleteMutation(ServerContext context, TableId tableId,
      String pathToRemove) {
    Path path = context.getVolumeManager().getFullPath(tableId, pathToRemove);
    Mutation delFlag = new Mutation(new Text(MetadataSchema.DeletesSection.getRowPrefix() + path));
    delFlag.put(EMPTY_TEXT, EMPTY_TEXT, new Value(new byte[] {}));
    return delFlag;
  }

  public static void removeScanFiles(KeyExtent extent, Set<FileRef> scanFiles,
      ServerContext context, ZooLock zooLock) {
    Mutation m = new Mutation(extent.getMetadataEntry());

    for (FileRef pathToRemove : scanFiles)
      m.putDelete(ScanFileColumnFamily.NAME, pathToRemove.meta());

    update(context, zooLock, m, extent);
  }

  public static void splitDatafiles(Text midRow, double splitRatio,
      Map<FileRef,FileUtil.FileInfo> firstAndLastRows, SortedMap<FileRef,DataFileValue> datafiles,
      SortedMap<FileRef,DataFileValue> lowDatafileSizes,
      SortedMap<FileRef,DataFileValue> highDatafileSizes, List<FileRef> highDatafilesToRemove) {

    for (Entry<FileRef,DataFileValue> entry : datafiles.entrySet()) {

      Text firstRow = null;
      Text lastRow = null;

      boolean rowsKnown = false;

      FileUtil.FileInfo mfi = firstAndLastRows.get(entry.getKey());

      if (mfi != null) {
        firstRow = mfi.getFirstRow();
        lastRow = mfi.getLastRow();
        rowsKnown = true;
      }

      if (rowsKnown && firstRow.compareTo(midRow) > 0) {
        // only in high
        long highSize = entry.getValue().getSize();
        long highEntries = entry.getValue().getNumEntries();
        highDatafileSizes.put(entry.getKey(),
            new DataFileValue(highSize, highEntries, entry.getValue().getTime()));
      } else if (rowsKnown && lastRow.compareTo(midRow) <= 0) {
        // only in low
        long lowSize = entry.getValue().getSize();
        long lowEntries = entry.getValue().getNumEntries();
        lowDatafileSizes.put(entry.getKey(),
            new DataFileValue(lowSize, lowEntries, entry.getValue().getTime()));

        highDatafilesToRemove.add(entry.getKey());
      } else {
        long lowSize = (long) Math.floor((entry.getValue().getSize() * splitRatio));
        long lowEntries = (long) Math.floor((entry.getValue().getNumEntries() * splitRatio));
        lowDatafileSizes.put(entry.getKey(),
            new DataFileValue(lowSize, lowEntries, entry.getValue().getTime()));

        long highSize = (long) Math.ceil((entry.getValue().getSize() * (1.0 - splitRatio)));
        long highEntries = (long) Math
            .ceil((entry.getValue().getNumEntries() * (1.0 - splitRatio)));
        highDatafileSizes.put(entry.getKey(),
            new DataFileValue(highSize, highEntries, entry.getValue().getTime()));
      }
    }
  }

  public static void deleteTable(TableId tableId, boolean insertDeletes, ServerContext context,
      ZooLock lock) throws AccumuloException {
    try (Scanner ms = new ScannerImpl(context, MetadataTable.ID, Authorizations.EMPTY);
        BatchWriter bw = new BatchWriterImpl(context, MetadataTable.ID,
            new BatchWriterConfig().setMaxMemory(1000000)
                .setMaxLatency(120000L, TimeUnit.MILLISECONDS).setMaxWriteThreads(2))) {

      // scan metadata for our table and delete everything we find
      Mutation m = null;
      ms.setRange(new KeyExtent(tableId, null, null).toMetadataRange());

      // insert deletes before deleting data from metadata... this makes the code fault tolerant
      if (insertDeletes) {

        ms.fetchColumnFamily(DataFileColumnFamily.NAME);
        TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.fetch(ms);

        for (Entry<Key,Value> cell : ms) {
          Key key = cell.getKey();

          if (key.getColumnFamily().equals(DataFileColumnFamily.NAME)) {
            FileRef ref = new FileRef(context.getVolumeManager(), key);
            bw.addMutation(createDeleteMutation(context, tableId, ref.meta().toString()));
          }

          if (TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.hasColumns(key)) {
            bw.addMutation(createDeleteMutation(context, tableId, cell.getValue().toString()));
          }
        }

        bw.flush();

        ms.clearColumns();
      }

      for (Entry<Key,Value> cell : ms) {
        Key key = cell.getKey();

        if (m == null) {
          m = new Mutation(key.getRow());
          if (lock != null)
            putLockID(context, lock, m);
        }

        if (key.getRow().compareTo(m.getRow(), 0, m.getRow().length) != 0) {
          bw.addMutation(m);
          m = new Mutation(key.getRow());
          if (lock != null)
            putLockID(context, lock, m);
        }
        m.putDelete(key.getColumnFamily(), key.getColumnQualifier());
      }

      if (m != null)
        bw.addMutation(m);
    }
  }

  static String getZookeeperLogLocation(ServerContext context) {
    return context.getZooKeeperRoot() + RootTable.ZROOT_TABLET_WALOGS;
  }

  public static void setRootTabletDir(ServerContext context, String dir) throws IOException {
    IZooReaderWriter zoo = context.getZooReaderWriter();
    String zpath = context.getZooKeeperRoot() + RootTable.ZROOT_TABLET_PATH;
    try {
      zoo.putPersistentData(zpath, dir.getBytes(UTF_8), -1, NodeExistsPolicy.OVERWRITE);
    } catch (KeeperException e) {
      throw new IOException(e);
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new IOException(e);
    }
  }

  public static String getRootTabletDir(ServerContext context) throws IOException {
    IZooReaderWriter zoo = context.getZooReaderWriter();
    String zpath = context.getZooKeeperRoot() + RootTable.ZROOT_TABLET_PATH;
    try {
      return new String(zoo.getData(zpath, null), UTF_8);
    } catch (KeeperException e) {
      throw new IOException(e);
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new IOException(e);
    }
  }

  public static Pair<List<LogEntry>,SortedMap<FileRef,DataFileValue>> getFileAndLogEntries(
      ServerContext context, KeyExtent extent)
      throws KeeperException, InterruptedException, IOException {
    ArrayList<LogEntry> result = new ArrayList<>();
    TreeMap<FileRef,DataFileValue> sizes = new TreeMap<>();

    VolumeManager fs = context.getVolumeManager();
    if (extent.isRootTablet()) {
      getRootLogEntries(context, result);
      Path rootDir = new Path(getRootTabletDir(context));
      FileStatus[] files = fs.listStatus(rootDir);
      for (FileStatus fileStatus : files) {
        if (fileStatus.getPath().toString().endsWith(""_tmp"")) {
          continue;
        }
        DataFileValue dfv = new DataFileValue(0, 0);
        sizes.put(new FileRef(fileStatus.getPath().toString(), fileStatus.getPath()), dfv);
      }

    } else {
      try (TabletsMetadata tablets = TabletsMetadata.builder().forTablet(extent).fetchFiles()
          .fetchLogs().fetchPrev().build(context)) {

        TabletMetadata tablet = Iterables.getOnlyElement(tablets);

        if (!tablet.getExtent().equals(extent))
          throw new RuntimeException(
              ""Unexpected extent "" + tablet.getExtent() + "" expected "" + extent);

        result.addAll(tablet.getLogs());
        tablet.getFilesMap().forEach((k, v) -> {
          sizes.put(new FileRef(k, fs.getFullPath(tablet.getTableId(), k)), v);
        });
      }
    }

    return new Pair<>(result, sizes);
  }

  public static List<LogEntry> getLogEntries(ServerContext context, KeyExtent extent)
      throws IOException, KeeperException, InterruptedException {
    log.info(""Scanning logging entries for {}"", extent);
    ArrayList<LogEntry> result = new ArrayList<>();
    if (extent.equals(RootTable.EXTENT)) {
      log.info(""Getting logs for root tablet from zookeeper"");
      getRootLogEntries(context, result);
    } else {
      log.info(""Scanning metadata for logs used for tablet {}"", extent);
      Scanner scanner = getTabletLogScanner(context, extent);
      Text pattern = extent.getMetadataEntry();
      for (Entry<Key,Value> entry : scanner) {
        Text row = entry.getKey().getRow();
        if (entry.getKey().getColumnFamily().equals(LogColumnFamily.NAME)) {
          if (row.equals(pattern)) {
            result.add(LogEntry.fromKeyValue(entry.getKey(), entry.getValue()));
          }
        }
      }
    }

    log.info(""Returning logs {} for extent {}"", result, extent);
    return result;
  }

  static void getRootLogEntries(ServerContext context, final ArrayList<LogEntry> result)
      throws KeeperException, InterruptedException, IOException {
    IZooReaderWriter zoo = context.getZooReaderWriter();
    String root = getZookeeperLogLocation(context);
    // there's a little race between getting the children and fetching
    // the data. The log can be removed in between.
    while (true) {
      result.clear();
      for (String child : zoo.getChildren(root)) {
        try {
          LogEntry e = LogEntry.fromBytes(zoo.getData(root + ""/"" + child, null));
          // upgrade from !0;!0<< -> +r<<
          e = new LogEntry(RootTable.EXTENT, 0, e.server, e.filename);
          result.add(e);
        } catch (KeeperException.NoNodeException ex) {
          continue;
        }
      }
      break;
    }
  }

  private static Scanner getTabletLogScanner(ServerContext context, KeyExtent extent) {
    TableId tableId = MetadataTable.ID;
    if (extent.isMeta())
      tableId = RootTable.ID;
    Scanner scanner = new ScannerImpl(context, tableId, Authorizations.EMPTY);
    scanner.fetchColumnFamily(LogColumnFamily.NAME);
    Text start = extent.getMetadataEntry();
    Key endKey = new Key(start, LogColumnFamily.NAME);
    endKey = endKey.followingKey(PartialKey.ROW_COLFAM);
    scanner.setRange(new Range(new Key(start), endKey));
    return scanner;
  }

  private static class LogEntryIterator implements Iterator<LogEntry> {

    Iterator<LogEntry> zookeeperEntries = null;
    Iterator<LogEntry> rootTableEntries = null;
    Iterator<Entry<Key,Value>> metadataEntries = null;

    LogEntryIterator(ServerContext context)
        throws IOException, KeeperException, InterruptedException {
      zookeeperEntries = getLogEntries(context, RootTable.EXTENT).iterator();
      rootTableEntries = getLogEntries(context, new KeyExtent(MetadataTable.ID, null, null))
          .iterator();
      try {
        Scanner scanner = context.createScanner(MetadataTable.NAME, Authorizations.EMPTY);
        log.info(""Setting range to {}"", MetadataSchema.TabletsSection.getRange());
        scanner.setRange(MetadataSchema.TabletsSection.getRange());
        scanner.fetchColumnFamily(LogColumnFamily.NAME);
        metadataEntries = scanner.iterator();
      } catch (Exception ex) {
        throw new IOException(ex);
      }
    }

    @Override
    public boolean hasNext() {
      return zookeeperEntries.hasNext() || rootTableEntries.hasNext() || metadataEntries.hasNext();
    }

    @Override
    public LogEntry next() {
      if (zookeeperEntries.hasNext()) {
        return zookeeperEntries.next();
      }
      if (rootTableEntries.hasNext()) {
        return rootTableEntries.next();
      }
      Entry<Key,Value> entry = metadataEntries.next();
      return LogEntry.fromKeyValue(entry.getKey(), entry.getValue());
    }

    @Override
    public void remove() {
      throw new UnsupportedOperationException();
    }
  }

  public static Iterator<LogEntry> getLogEntries(ServerContext context)
      throws IOException, KeeperException, InterruptedException {
    return new LogEntryIterator(context);
  }

  public static void removeUnusedWALEntries(ServerContext context, KeyExtent extent,
      final List<LogEntry> entries, ZooLock zooLock) {
    if (extent.isRootTablet()) {
      retryZooKeeperUpdate(context, zooLock, new ZooOperation() {
        @Override
        public void run(IZooReaderWriter rw) throws KeeperException, InterruptedException {
          String root = getZookeeperLogLocation(context);
          for (LogEntry entry : entries) {
            String path = root + ""/"" + entry.getUniqueID();
            log.debug(""Removing "" + path + "" from zookeeper"");
            rw.recursiveDelete(path, NodeMissingPolicy.SKIP);
          }
        }
      });
    } else {
      Mutation m = new Mutation(extent.getMetadataEntry());
      for (LogEntry entry : entries) {
        m.putDelete(entry.getColumnFamily(), entry.getColumnQualifier());
      }
      update(context, zooLock, m, extent);
    }
  }

  private static void getFiles(Set<String> files, Collection<String> tabletFiles,
      TableId srcTableId) {
    for (String file : tabletFiles) {
      if (srcTableId != null && !file.startsWith(""../"") && !file.contains("":"")) {
        file = ""../"" + srcTableId + file;
      }
      files.add(file);
    }
  }

  private static Mutation createCloneMutation(TableId srcTableId, TableId tableId,
      Map<Key,Value> tablet) {

    KeyExtent ke = new KeyExtent(tablet.keySet().iterator().next().getRow(), (Text) null);
    Mutation m = new Mutation(TabletsSection.getRow(tableId, ke.getEndRow()));

    for (Entry<Key,Value> entry : tablet.entrySet()) {
      if (entry.getKey().getColumnFamily().equals(DataFileColumnFamily.NAME)) {
        String cf = entry.getKey().getColumnQualifier().toString();
        if (!cf.startsWith(""../"") && !cf.contains("":""))
          cf = ""../"" + srcTableId + entry.getKey().getColumnQualifier();
        m.put(entry.getKey().getColumnFamily(), new Text(cf), entry.getValue());
      } else if (entry.getKey().getColumnFamily()
          .equals(TabletsSection.CurrentLocationColumnFamily.NAME)) {
        m.put(TabletsSection.LastLocationColumnFamily.NAME, entry.getKey().getColumnQualifier(),
            entry.getValue());
      } else if (entry.getKey().getColumnFamily()
          .equals(TabletsSection.LastLocationColumnFamily.NAME)) {
        // skip
      } else {
        m.put(entry.getKey().getColumnFamily(), entry.getKey().getColumnQualifier(),
            entry.getValue());
      }
    }
    return m;
  }

  private static Iterable<TabletMetadata> createCloneScanner(String testTableName, TableId tableId,
      AccumuloClient client) throws TableNotFoundException {

    String tableName;
    Range range;

    if (testTableName != null) {
      tableName = testTableName;
      range = TabletsSection.getRange(tableId);
    } else if (tableId.equals(MetadataTable.ID)) {
      tableName = RootTable.NAME;
      range = TabletsSection.getRange();
    } else {
      tableName = MetadataTable.NAME;
      range = TabletsSection.getRange(tableId);
    }

    return TabletsMetadata.builder().scanTable(tableName).overRange(range).checkConsistency()
        .saveKeyValues().fetchFiles().fetchLocation().fetchLast().fetchCloned().fetchPrev()
        .fetchTime().build(client);
  }

  @VisibleForTesting
  public static void initializeClone(String testTableName, TableId srcTableId, TableId tableId,
      AccumuloClient client, BatchWriter bw)
      throws TableNotFoundException, MutationsRejectedException {

    Iterator<TabletMetadata> ti = createCloneScanner(testTableName, srcTableId, client).iterator();

    if (!ti.hasNext())
      throw new RuntimeException("" table deleted during clone?  srcTableId = "" + srcTableId);

    while (ti.hasNext())
      bw.addMutation(createCloneMutation(srcTableId, tableId, ti.next().getKeyValues()));

    bw.flush();
  }

  private static int compareEndRows(Text endRow1, Text endRow2) {
    return new KeyExtent(TableId.of(""0""), endRow1, null)
        .compareTo(new KeyExtent(TableId.of(""0""), endRow2, null));
  }

  @VisibleForTesting
  public static int checkClone(String testTableName, TableId srcTableId, TableId tableId,
      AccumuloClient client, BatchWriter bw)
      throws TableNotFoundException, MutationsRejectedException {

    Iterator<TabletMetadata> srcIter = createCloneScanner(testTableName, srcTableId, client)
        .iterator();
    Iterator<TabletMetadata> cloneIter = createCloneScanner(testTableName, tableId, client)
        .iterator();

    if (!cloneIter.hasNext() || !srcIter.hasNext())
      throw new RuntimeException(
          "" table deleted during clone?  srcTableId = "" + srcTableId + "" tableId="" + tableId);

    int rewrites = 0;

    while (cloneIter.hasNext()) {
      TabletMetadata cloneTablet = cloneIter.next();
      Text cloneEndRow = cloneTablet.getEndRow();
      HashSet<String> cloneFiles = new HashSet<>();

      boolean cloneSuccessful = cloneTablet.getCloned() != null;

      if (!cloneSuccessful)
        getFiles(cloneFiles, cloneTablet.getFiles(), null);

      List<TabletMetadata> srcTablets = new ArrayList<>();
      TabletMetadata srcTablet = srcIter.next();
      srcTablets.add(srcTablet);

      Text srcEndRow = srcTablet.getEndRow();
      int cmp = compareEndRows(cloneEndRow, srcEndRow);
      if (cmp < 0)
        throw new TabletDeletedException(
            ""Tablets deleted from src during clone : "" + cloneEndRow + "" "" + srcEndRow);

      HashSet<String> srcFiles = new HashSet<>();
      if (!cloneSuccessful)
        getFiles(srcFiles, srcTablet.getFiles(), srcTableId);

      while (cmp > 0) {
        srcTablet = srcIter.next();
        srcTablets.add(srcTablet);
        srcEndRow = srcTablet.getEndRow();
        cmp = compareEndRows(cloneEndRow, srcEndRow);
        if (cmp < 0)
          throw new TabletDeletedException(
              ""Tablets deleted from src during clone : "" + cloneEndRow + "" "" + srcEndRow);

        if (!cloneSuccessful)
          getFiles(srcFiles, srcTablet.getFiles(), srcTableId);
      }

      if (cloneSuccessful)
        continue;

      if (!srcFiles.containsAll(cloneFiles)) {
        // delete existing cloned tablet entry
        Mutation m = new Mutation(cloneTablet.getExtent().getMetadataEntry());

        for (Entry<Key,Value> entry : cloneTablet.getKeyValues().entrySet()) {
          Key k = entry.getKey();
          m.putDelete(k.getColumnFamily(), k.getColumnQualifier(), k.getTimestamp());
        }

        bw.addMutation(m);

        for (TabletMetadata st : srcTablets)
          bw.addMutation(createCloneMutation(srcTableId, tableId, st.getKeyValues()));

        rewrites++;
      } else {
        // write out marker that this tablet was successfully cloned
        Mutation m = new Mutation(cloneTablet.getExtent().getMetadataEntry());
        m.put(ClonedColumnFamily.NAME, new Text(""""), new Value(""OK"".getBytes(UTF_8)));
        bw.addMutation(m);
      }
    }

    bw.flush();
    return rewrites;
  }

  public static void cloneTable(ServerContext context, TableId srcTableId, TableId tableId,
      VolumeManager volumeManager) throws Exception {

    try (BatchWriter bw = context.createBatchWriter(MetadataTable.NAME, new BatchWriterConfig())) {

      while (true) {

        try {
          initializeClone(null, srcTableId, tableId, context, bw);

          // the following loop looks changes in the file that occurred during the copy.. if files
          // were dereferenced then they could have been GCed

          while (true) {
            int rewrites = checkClone(null, srcTableId, tableId, context, bw);

            if (rewrites == 0)
              break;
          }

          bw.flush();
          break;

        } catch (TabletDeletedException tde) {
          // tablets were merged in the src table
          bw.flush();

          // delete what we have cloned and try again
          deleteTable(tableId, false, context, null);

          log.debug(""Tablets merged in table {} while attempting to clone, trying again"",
              srcTableId);

          sleepUninterruptibly(100, TimeUnit.MILLISECONDS);
        }
      }

      // delete the clone markers and create directory entries
      Scanner mscanner = context.createScanner(MetadataTable.NAME, Authorizations.EMPTY);
      mscanner.setRange(new KeyExtent(tableId, null, null).toMetadataRange());
      mscanner.fetchColumnFamily(ClonedColumnFamily.NAME);

      int dirCount = 0;

      for (Entry<Key,Value> entry : mscanner) {
        Key k = entry.getKey();
        Mutation m = new Mutation(k.getRow());
        m.putDelete(k.getColumnFamily(), k.getColumnQualifier());
        VolumeChooserEnvironment chooserEnv = new VolumeChooserEnvironmentImpl(tableId,
            new KeyExtent(k.getRow(), (Text) null).getEndRow(), context);
        String dir = volumeManager.choose(chooserEnv, ServerConstants.getBaseUris(context))
            + Constants.HDFS_TABLES_DIR + Path.SEPARATOR + tableId + Path.SEPARATOR + new String(
                FastFormat.toZeroPaddedString(dirCount++, 8, 16, Constants.CLONE_PREFIX_BYTES));
        TabletsSection.ServerColumnFamily.DIRECTORY_COLUMN.put(m, new Value(dir.getBytes(UTF_8)));

        bw.addMutation(m);
      }
    }
  }

  public static void chopped(ServerContext context, KeyExtent extent, ZooLock zooLock) {
    Mutation m = new Mutation(extent.getMetadataEntry());
    ChoppedColumnFamily.CHOPPED_COLUMN.put(m, new Value(""chopped"".getBytes(UTF_8)));
    update(context, zooLock, m, extent);
  }

  public static void removeBulkLoadEntries(AccumuloClient client, TableId tableId, long tid)
      throws Exception {
    try (
        Scanner mscanner = new IsolatedScanner(
            client.createScanner(MetadataTable.NAME, Authorizations.EMPTY));
        BatchWriter bw = client.createBatchWriter(MetadataTable.NAME, new BatchWriterConfig())) {
      mscanner.setRange(new KeyExtent(tableId, null, null).toMetadataRange());
      mscanner.fetchColumnFamily(TabletsSection.BulkFileColumnFamily.NAME);
      byte[] tidAsBytes = Long.toString(tid).getBytes(UTF_8);
      for (Entry<Key,Value> entry : mscanner) {
        log.trace(""Looking at entry {} with tid {}"", entry, tid);
        if (Arrays.equals(entry.getValue().get(), tidAsBytes)) {
          log.trace(""deleting entry {}"", entry);
          Key key = entry.getKey();
          Mutation m = new Mutation(key.getRow());
          m.putDelete(key.getColumnFamily(), key.getColumnQualifier());
          bw.addMutation(m);
        }
      }
    }
  }

  public static List<FileRef> getBulkFilesLoaded(ServerContext context, AccumuloClient client,
      KeyExtent extent, long tid) {
    List<FileRef> result = new ArrayList<>();
    try (Scanner mscanner = new IsolatedScanner(client.createScanner(
        extent.isMeta() ? RootTable.NAME : MetadataTable.NAME, Authorizations.EMPTY))) {
      VolumeManager fs = context.getVolumeManager();
      mscanner.setRange(extent.toMetadataRange());
      mscanner.fetchColumnFamily(TabletsSection.BulkFileColumnFamily.NAME);
      for (Entry<Key,Value> entry : mscanner) {
        if (Long.parseLong(entry.getValue().toString()) == tid) {
          result.add(new FileRef(fs, entry.getKey()));
        }
      }

      return result;
    } catch (TableNotFoundException ex) {
      // unlikely
      throw new RuntimeException(""Onos! teh metadata table has vanished!!"");
    }
  }

  public static Map<Long,? extends Collection<FileRef>> getBulkFilesLoaded(ServerContext context,
      KeyExtent extent) {
    Text metadataRow = extent.getMetadataEntry();
    Map<Long,List<FileRef>> result = new HashMap<>();

    VolumeManager fs = context.getVolumeManager();
    try (Scanner scanner = new ScannerImpl(context,
        extent.isMeta() ? RootTable.ID : MetadataTable.ID, Authorizations.EMPTY)) {
      scanner.setRange(new Range(metadataRow));
      scanner.fetchColumnFamily(TabletsSection.BulkFileColumnFamily.NAME);
      for (Entry<Key,Value> entry : scanner) {
        Long tid = Long.parseLong(entry.getValue().toString());
        List<FileRef> lst = result.get(tid);
        if (lst == null) {
          result.put(tid, lst = new ArrayList<>());
        }
        lst.add(new FileRef(fs, entry.getKey()));
      }
    }
    return result;
  }

  public static void addBulkLoadInProgressFlag(ServerContext context, String path) {

    Mutation m = new Mutation(MetadataSchema.BlipSection.getRowPrefix() + path);
    m.put(EMPTY_TEXT, EMPTY_TEXT, new Value(new byte[] {}));

    // new KeyExtent is only added to force update to write to the metadata table, not the root
    // table
    // because bulk loads aren't supported to the metadata table
    update(context, m, new KeyExtent(TableId.of(""anythingNotMetadata""), null, null));
  }

  public static void removeBulkLoadInProgressFlag(ServerContext context, String path) {

    Mutation m = new Mutation(MetadataSchema.BlipSection.getRowPrefix() + path);
    m.putDelete(EMPTY_TEXT, EMPTY_TEXT);

    // new KeyExtent is only added to force update to write to the metadata table, not the root
    // table
    // because bulk loads aren't supported to the metadata table
    update(context, m, new KeyExtent(TableId.of(""anythingNotMetadata""), null, null));
  }

  /**
   * During an upgrade from 1.6 to 1.7, we need to add the replication table
   */
  public static void createReplicationTable(ServerContext context) {

    VolumeChooserEnvironment chooserEnv = new VolumeChooserEnvironmentImpl(ReplicationTable.ID,
        null, context);
    String dir = context.getVolumeManager().choose(chooserEnv, ServerConstants.getBaseUris(context))
        + Constants.HDFS_TABLES_DIR + Path.SEPARATOR + ReplicationTable.ID
        + Constants.DEFAULT_TABLET_LOCATION;

    Mutation m = new Mutation(new Text(TabletsSection.getRow(ReplicationTable.ID, null)));
    m.put(DIRECTORY_COLUMN.getColumnFamily(), DIRECTORY_COLUMN.getColumnQualifier(), 0,
        new Value(dir.getBytes(UTF_8)));
    m.put(TIME_COLUMN.getColumnFamily(), TIME_COLUMN.getColumnQualifier(), 0,
        new Value((TabletTime.LOGICAL_TIME_ID + ""0"").getBytes(UTF_8)));
    m.put(PREV_ROW_COLUMN.getColumnFamily(), PREV_ROW_COLUMN.getColumnQualifier(), 0,
        KeyExtent.encodePrevEndRow(null));
    update(context, getMetadataTable(context), null, m);
  }

  /**
   * During an upgrade we need to move deletion requests for files under the !METADATA table to the
   * root tablet.
   */
  public static void moveMetaDeleteMarkers(ServerContext context) {
    String oldDeletesPrefix = ""!!~del"";
    Range oldDeletesRange = new Range(oldDeletesPrefix, true, ""!!~dem"", false);

    // move old delete markers to new location, to standardize table schema between all metadata
    // tables
    try (Scanner scanner = new ScannerImpl(context, RootTable.ID, Authorizations.EMPTY)) {
      scanner.setRange(oldDeletesRange);
      for (Entry<Key,Value> entry : scanner) {
        String row = entry.getKey().getRow().toString();
        if (row.startsWith(oldDeletesPrefix)) {
          moveDeleteEntry(context, RootTable.OLD_EXTENT, entry, row, oldDeletesPrefix);
        } else {
          break;
        }
      }
    }
  }

  public static void moveMetaDeleteMarkersFrom14(ServerContext context) {
    // new KeyExtent is only added to force update to write to the metadata table, not the root
    // table
    KeyExtent notMetadata = new KeyExtent(TableId.of(""anythingNotMetadata""), null, null);

    // move delete markers from the normal delete keyspace to the root tablet delete keyspace if the
    // files are for the !METADATA table
    try (Scanner scanner = new ScannerImpl(context, MetadataTable.ID, Authorizations.EMPTY)) {
      scanner.setRange(MetadataSchema.DeletesSection.getRange());
      for (Entry<Key,Value> entry : scanner) {
        String row = entry.getKey().getRow().toString();
        if (row.startsWith(MetadataSchema.DeletesSection.getRowPrefix() + ""/"" + MetadataTable.ID)) {
          moveDeleteEntry(context, notMetadata, entry, row,
              MetadataSchema.DeletesSection.getRowPrefix());
        } else {
          break;
        }
      }
    }
  }

  private static void moveDeleteEntry(ServerContext context, KeyExtent oldExtent,
      Entry<Key,Value> entry, String rowID, String prefix) {
    String filename = rowID.substring(prefix.length());

    // add the new entry first
    log.info(""Moving {} marker in {}"", filename, RootTable.NAME);
    Mutation m = new Mutation(MetadataSchema.DeletesSection.getRowPrefix() + filename);
    m.put(EMPTY_BYTES, EMPTY_BYTES, EMPTY_BYTES);
    update(context, m, RootTable.EXTENT);

    // then remove the old entry
    m = new Mutation(entry.getKey().getRow());
    m.putDelete(EMPTY_BYTES, EMPTY_BYTES);
    update(context, m, oldExtent);
  }

  public static SortedMap<Text,SortedMap<ColumnFQ,Value>> getTabletEntries(
      SortedMap<Key,Value> tabletKeyValues, List<ColumnFQ> columns) {
    TreeMap<Text,SortedMap<ColumnFQ,Value>> tabletEntries = new TreeMap<>();

    HashSet<ColumnFQ> colSet = null;
    if (columns != null) {
      colSet = new HashSet<>(columns);
    }

    for (Entry<Key,Value> entry : tabletKeyValues.entrySet()) {
      ColumnFQ currentKey = new ColumnFQ(entry.getKey());
      if (columns != null && !colSet.contains(currentKey)) {
        continue;
      }

      Text row = entry.getKey().getRow();

      SortedMap<ColumnFQ,Value> colVals = tabletEntries.get(row);
      if (colVals == null) {
        colVals = new TreeMap<>();
        tabletEntries.put(row, colVals);
      }

      colVals.put(currentKey, entry.getValue());
    }

    return tabletEntries;
  }

}
",blob
551,"public class Builder {

	public static boolean isForced(Map<?, ?> options) {
		return Boolean.TRUE.equals(options.get(""force""));
	}

	private Properties options = new Properties();
	private BuilderExtension[] extensions = new BuilderExtension[0];

	private Logger logger = new NullLogger();
	private ConfigurationRegistry registry;
	private ConfigObject configObject = null;
	private boolean isIncremental = false;
	private boolean enabledMetadata = false;

	private File sourceDir = null;

	/**
	 * The value is a String[] containing the relative paths of all of the build
	 * files for a given sourceDir.
	 */
	private final Map<File, String[]> buildFilesBySourceDir = new HashMap<>();
	/*[PR 118220] Incremental builder is not called when file is deleted in base library*/
	private final Map<File, List<String>> deleteFilesBySourceDir = new HashMap<>();
	private final Map<File, List<String>> buildResourcesBySourceDir = new HashMap<>();

	private int buildFileCount = 0;
	private int deleteFileCount = 0;
	private int builtFileCount = 0;
	private int buildResourcesCount = 0;
	private File outputDir = null;
	private boolean verdict = false;
	private boolean includeIfUnsure = false;
	/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/
	private boolean isTestsBootPath = false;
	private boolean noWarnIncludeIf = false;
	private boolean noWarnInvalidFlags = false;
	private boolean multipleSources = false;
	private boolean updateAllCopyrights = false;

	/**
	 * J9 JCL Preprocessor builder constructor.  Initializes the needed extensions.
	 */
	public Builder() {
		addExtension(new ExternalMessagesExtension());
		addExtension(new MacroExtension());
		addExtension(new JxeRulesExtension());
		addExtension(new EclipseMetadataExtension());
		addExtension(new JitAttributesExtension());
		addExtension(new TagExtension());
	}

	/**
	 * Sets the preprocess options.
	 *
	 * @param 		options		the preprocess options
	 */
	public void setOptions(Properties options) {
		if (options != null) {
			this.options.putAll(options);
		}
		this.options = options;
	}

	/**
	 * Returns the preprocess options for this builder.
	 *
	 * @return		the preprocess options
	 */
	public Properties getOptions() {
		return this.options;
	}

	/**
	 * Adds an extension to the builder.
	 *
	 * @param 		extension	the extension to add
	 */
	public void addExtension(BuilderExtension extension) {
		if (extension == null) {
			throw new NullPointerException();
		}

		BuilderExtension[] newExtensions = new BuilderExtension[extensions.length + 1];
		if (extensions.length > 0) {
			System.arraycopy(extensions, 0, newExtensions, 0, extensions.length);
		}
		newExtensions[newExtensions.length - 1] = extension;
		this.extensions = newExtensions;

		extension.setBuilder(this);
	}

	/**
	 * Returns the builder extensions/
	 *
	 * @return		the builder extensions
	 */
	public BuilderExtension[] getExtensions() {
		return extensions;
	}

	/**
	 * Returns the logger associated with this builder.
	 *
	 * @return		the logger
	 */
	public Logger getLogger() {
		return logger;
	}

	/**
	 * Sets this builder's logger.
	 *
	 * @param 		logger		the new logger
	 */
	public void setLogger(Logger logger) {
		this.logger = logger;
	}

	/**
	 * Sets whether the build is incremental or not.
	 *
	 * @param 		isIncremental	<code>true</code> if the build is incremental, <code>false</code> otherwise
	 */
	public void setIncremental(boolean isIncremental) {
		this.isIncremental = isIncremental;
	}

	/**
	 * Returns wheter or not this builder will only do an incremental build.
	 *
	 * @return		<code>true</code> if the build is incremental, <code>false</code> otherwise
	 */
	public boolean isIncremental() {
		return this.isIncremental;
	}

	/**
	 * Sets whether or not preprocessor metadata will be generated.
	 *
	 * @param 		enabledMetadata		<code>true</code> if metadata is to be generated,
	 * 									<code>false</code> otherwise
	 */
	public void setMetadata(boolean enabledMetadata) {
		this.enabledMetadata = enabledMetadata;
	}

	/**
	 * Returns whether or not preprocessor metadata is enabled.
	 *
	 * @return		<code>true</code> if metadata will be written, <code>false</code> otherwise
	 */
	public boolean isMetadataEnabled() {
		return this.enabledMetadata;
	}

	/**
	 * Sets whether or not the preprocessor should include files that do not
	 * have a INCLUDE-IF tag.
	 *
	 * @param 		include		<code>true</code> if files with no INCLUDE-IF should
	 * 							be included, <code>false</code> otherwise
	 */
	public void setIncludeIfUnsure(boolean include) {
		this.includeIfUnsure = include;
	}

	/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/
	/**
	 * Sets whether or not the preprocessor is running to generate Tests Boot Path project
	 *
	 * @param 	isTestsBoot		<code>true</code> if preprocessor is running to generate Tests Boot Path project,
	 * 							<code>false</code> otherwise
	 */
	public void setIsTestsBoot(boolean isTestsBoot) {
		this.isTestsBootPath = isTestsBoot;
	}

	/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/
	/**
	 * Sets whether or not the preprocessor should give warningsor errors about the files that do not
	 * have a INCLUDE-IF tag.
	 *
	 * @param 		warning		<code>true</code> if files with no INCLUDE-IF should
	 * 							be marked with warning or error, <code>false</code> otherwise
	 */
	public void setNoWarnIncludeIf(boolean warning) {
		this.noWarnIncludeIf = warning;
	}

	/**
	 * Sets the configuration to preprocess.
	 *
	 * @param 		config		the configuration to preprocess
	 */
	public void setConfiguration(ConfigObject config) {
		if (config.isSet()) {
			System.err.println(""Warning: Builder is using "" + config + "", a set, not a configuration."");
		}
		this.configObject = config;
		this.registry = config.getRegistry();
		this.outputDir = config.getOutputDir();
	}

	/**
	 * Returns this builder's output directory.
	 *
	 * @return		the output directory
	 */
	public File getOutputDir() {
		return this.outputDir;
	}

	/**
	 * Sets this builder's output directory.
	 *
	 * @param 		outputDir	the new output directory
	 */
	public void setOutputDir(File outputDir) {
		if (outputDir == null) {
			throw new NullPointerException();
		}
		this.outputDir = outputDir;
	}

	/**
	 * Returns this builder's configuration source directories.
	 *
	 * @return		the config's source dirs
	 */
	public File getSourceDir() {
		return this.sourceDir;
	}

	/**
	 * Sets the proprocess job's source directory.
	 *
	 * @param 		sourceDir	the source directory to preprocess
	 */
	public void setSourceDir(File sourceDir) {
		if (sourceDir == null) {
			throw new NullPointerException();
		} else {
			this.sourceDir = sourceDir;
		}
	}

	/**
	 * Set builder aware of other sources (to be used by the ExternalMessagesExtension).
	 *
	 * @param 		multipleSources		<code>true</code> if there are other sources, <code>false</code> otherwise
	 */
	public void setMultipleSources(boolean multipleSources) {
		this.multipleSources = multipleSources;
	}

	/**
	 * Returns whether or not the configuration that setup this builder has multiple sources.
	 *
	 * @return		<code>true</code> if there are other sources, <code>false</code> otherwise
	 */
	public boolean hasMultipleSources() {
		return multipleSources;
	}

	/**
	 * Performs the build.
	 */
	public boolean build() {
		//create output dir even if no file is gonna be included in preprocess
		getOutputDir().mkdirs();
		if (validateOptions()) {
			computeBuildFiles();
			notifyBuildBegin();

			PreprocessorFactory factory = newPreprocessorFactory();
			boolean force = isForced(this.options);

			//Ignore folders that do not exist (warning thrown in computeBuildFiles()
			if (sourceDir != null) {
				File metadataDir = new File(outputDir.getParentFile(), ""jppmd"");
				String[] buildFiles = buildFilesBySourceDir.get(sourceDir);
				getLogger().log(""\nPreprocessing "" + sourceDir.getAbsolutePath(), 1);
				builtFileCount = 0;

				for (String buildFile : buildFiles) {
					File sourceFile = new File(sourceDir, buildFile);
					File outputFile = new File(outputDir, buildFile);
					File metadataFile = new File(metadataDir, buildFile + "".jppmd"");

					notifyBuildFileBegin(sourceFile, outputFile, buildFile);

					try (OutputStream metadataOutput = new PhantomOutputStream(metadataFile);
						 OutputStream output = new PhantomOutputStream(outputFile, force)) {

						// configure the preprocessor and let extensions do the same
						JavaPreprocessor jpp;

						if (enabledMetadata) {
							jpp = factory.newPreprocessor(metadataOutput, sourceFile, output, outputFile);
						} else {
							jpp = factory.newPreprocessor(sourceFile, output);
						}

						Calendar cal = new GregorianCalendar();
						if (!updateAllCopyrights) {
							cal.setTime(new Date(sourceFile.lastModified()));
						}
						jpp.setCopyrightYear(cal.get(Calendar.YEAR));
						jpp.addValidFlags(registry.getValidFlags());
						/*[PR 120411] Use a javadoc tag instead of TestBootpath preprocessor tag*/
						jpp.setTestBootPath(isTestsBootPath);
						notifyConfigurePreprocessor(jpp);

						// preprocess
						boolean included = false;
						try {
							included = jpp.preprocess();
							if (included) {
								builtFileCount++;
							}
							handlePreprocessorWarnings(jpp, sourceFile);
						} catch (Throwable t) {
							handlePreprocessorException(t, sourceFile);
						}

						if (!included && outputFile.exists()) {
							outputFile.delete();
						}

						if (!included && metadataFile.exists()) {
							metadataFile.delete();
						}
					} catch (Throwable t) {
						getLogger().log(""Exception occured in file "" + sourceFile.getAbsolutePath() + "", preprocess failed."", 3, t);
						handleBuildException(t);
					} finally {
						notifyBuildFileEnd(sourceFile, outputFile, buildFile);
					}
				}

				logger.log(builtFileCount + "" of "" + buildFileCount + "" file(s) included in preprocess"", 1);

				/*[PR 118220] Incremental builder is not called when file is deleted in base library*/
				List<String> deleteFiles = deleteFilesBySourceDir.get(sourceDir);
				if (deleteFiles != null && deleteFiles.size() != 0) {
					int deletedFilesCount = 0;
					for (String file : deleteFiles) {
						File deleteFile = new File(outputDir, file);
						if (deleteFile.exists()) {
							deletedFilesCount++;
							deleteFile.delete();
						}
					}
					getLogger().log(deletedFilesCount + "" of "" + deleteFileCount
							+ "" file(s) deleted in preprocess from "" + outputDir.getAbsolutePath(), 1);
				}
			}
			/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */
			List<String> buildResources = buildResourcesBySourceDir.get(sourceDir);
			if (buildResources != null && buildResources.size() != 0) {
				int copiedResourcesCount = 0;
				int deletedResorucesCount = 0;
				String outputpath;
				if (isTestsBootPath) {
					outputpath = configObject.getBootTestsOutputPath();
				} else {
					outputpath = configObject.getTestsOutputPath();
				}
				for (String file : buildResources) {
					File resource_out = new File(outputpath, file);
					File resource_src = new File(sourceDir, file);
					if (resource_src.exists()) {
						copyResource(resource_src, resource_out);
						copiedResourcesCount++;
					} else {
						resource_out.delete();
						deletedResorucesCount++;
					}
				}

				getLogger().log(""Total Build Resource Count : "" + buildResourcesCount, 1);
				getLogger().log(""  - "" + copiedResourcesCount + "" resource"" + (copiedResourcesCount > 1 ? ""s are "" : "" is "") + ""copied to "" + outputpath, 1);
				getLogger().log(""  - "" + deletedResorucesCount + "" resource"" + (deletedResorucesCount > 1 ? ""s are "" : "" is "") + ""deleted from "" + outputpath, 1);
			}

			notifyBuildEnd();
		}

		if (logger.getErrorCount() == 0) {
			if (verdict) {
				getLogger().log(""PREPROCESS WAS SUCCESSFUL"", 1);
			}
			return true;
		} else {
			if (verdict) {
				getLogger().log(""PREPROCESS WAS NOT SUCCESSFUL"", 1);
			}
			return false;
		}
	}

	/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */
	public static void copyResource(File source, File destination) {
		destination.delete();

		try {
			SimpleCopy.copyFile(source, destination);
		} catch (IOException e) {
			System.err.println(""ERROR - Could not copy the file to destination"");
			System.err.println(""   Source: "" + source.toString());
			System.err.println(""   Destination: "" + destination.toString());
			e.printStackTrace();
		}
	}

	/**
	 * Validates the build options.
	 */
	private boolean validateOptions() {
		boolean isValid = true;

		if (configObject == null) {
			configObject = registry.getConfiguration(options.getProperty(""config""));
		}
		this.options.putAll(configObject.getOptions());

		// check for the verdict option
		if (options.containsKey(""verdict"")) {
			this.verdict = true;
		}

		if (options.containsKey(""includeifunsure"")) {
			setIncludeIfUnsure(true);
		}
		if (options.containsKey(""nowarnincludeif"")) {
			setNoWarnIncludeIf(true);
		}

		if (options.containsKey(""nowarninvalidflags"")) {
			this.noWarnInvalidFlags = true;
		}

		if (options.containsKey(""updateallcopyrights"")) {
			this.updateAllCopyrights = true;
		}

		// call the method for all the extensions
		String extensionName = """";
		try {
			for (BuilderExtension extension : extensions) {
				extensionName = extension.getName();
				extension.validateOptions(this.options);
			}
		} catch (BuilderConfigurationException e) {
			logger.log(""A configuration exception occured"", Logger.SEVERITY_FATAL, e);
			isValid = false;
		} catch (Exception e) {
			StringBuffer buffer = new StringBuffer(""An exception occured while invoking validateOptions() for the extension \"""");
			buffer.append(extensionName);
			buffer.append(""\"""");
			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e);
		}
		return isValid;
	}

	/**
	 * Notifies the extensions that the build is beginning.
	 */
	private void notifyBuildBegin() {
		// call the method for all the extensions
		String extensionName = """";
		try {
			for (BuilderExtension extension : extensions) {
				extensionName = extension.getName();
				logger.setMessageSource(extensionName);
				extension.notifyBuildBegin();
				logger.setMessageSource(null);
			}
		} catch (Exception e) {
			StringBuffer buffer = new StringBuffer(""An exception occured while invoking notifyBuildBegin() for the extension \"""");
			buffer.append(extensionName);
			buffer.append(""\"""");
			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e);
		}
	}

	/**
	 * Notifies the extensions that the build is ending.
	 */
	private void notifyBuildEnd() {
		// call the method for all the extensions
		String extensionName = """";
		try {
			for (BuilderExtension extension : extensions) {
				extensionName = extension.getName();
				logger.setMessageSource(extensionName);
				extension.notifyBuildEnd();
				logger.setMessageSource(null);
			}
		} catch (Exception e) {
			StringBuffer buffer = new StringBuffer(""An exception occured while invoking notifyBuildEnd() for the extension \"""");
			buffer.append(extensionName);
			buffer.append(""\"""");
			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e);
		}
	}

	/**
	 * Notifies the extensions that the build is beginning on the specified
	 * file.
	 */
	private void notifyBuildFileBegin(File sourceFile, File outputFile, String relativePath) {
		// call the method for all the extensions
		String extensionName = """";
		try {
			for (BuilderExtension extension : extensions) {
				extensionName = extension.getName();
				logger.setMessageSource(extensionName);
				extension.notifyBuildFileBegin(sourceFile, outputFile, relativePath);
				logger.setMessageSource(null);
			}
		} catch (Exception e) {
			StringBuffer buffer = new StringBuffer(""An exception occured while invoking notifyBuildFileBegin() for the extension \"""");
			buffer.append(extensionName);
			buffer.append(""\"""");
			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e);
		}
	}

	/**
	 * Notifies the extensions that the build is ending on the specified file.
	 */
	private void notifyBuildFileEnd(File sourceFile, File outputFile, String relativePath) {
		// call the method for all the extensions
		String extensionName = """";
		try {
			for (BuilderExtension extension : extensions) {
				extensionName = extension.getName();
				logger.setMessageSource(extensionName);
				extension.notifyBuildFileEnd(sourceFile, outputFile, relativePath);
				logger.setMessageSource(null);
			}
		} catch (Exception e) {
			StringBuffer buffer = new StringBuffer(""An exception occured while invoking notifyBuildFileEnd() for the extension \"""");
			buffer.append(extensionName);
			buffer.append(""\"""");
			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e);
		}
	}

	/**
	 * Notifies the extensions that they should configure the preprocessor.
	 */
	private void notifyConfigurePreprocessor(JavaPreprocessor preprocessor) {
		preprocessor.setIncludeIfUnsure(this.includeIfUnsure);
		preprocessor.setNoWarnIncludeIf(this.noWarnIncludeIf);

		// call the method for all the extensions
		String extensionName = """";
		try {
			for (BuilderExtension extension : extensions) {
				extensionName = extension.getName();
				logger.setMessageSource(extensionName);
				extension.notifyConfigurePreprocessor(preprocessor);
				logger.setMessageSource(null);
			}
		} catch (Exception e) {
			StringBuffer buffer = new StringBuffer(""An exception occured while invoking notifyConfigurePreprocessor() for the extension \"""");
			buffer.append(extensionName);
			buffer.append(""\"""");
			logger.log(buffer.toString(), Logger.SEVERITY_ERROR, e);
		}
	}

	/**
	 * Handles exceptions thrown while building.
	 */
	private void handleBuildException(Throwable t) {
		if (t instanceof Error) {
			logger.log(""An error occured while building"", Logger.SEVERITY_FATAL, t);
			throw (Error) t;
		} else {
			logger.log(""An exception occured while building"", Logger.SEVERITY_ERROR, t);
		}
	}

	/**
	 * Handles exceptions thrown by the preprocessor.
	 */
	private void handlePreprocessorException(Throwable t, File sourceFile) {
		if (t instanceof Error) {
			logger.log(""An error occured while invoking the preprocessor"", ""preprocessor"", Logger.SEVERITY_FATAL, sourceFile, t);
			throw (Error) t;
		} else {
			logger.log(""An exception occured while invoking the preprocessor"", ""preprocessor"", Logger.SEVERITY_ERROR, sourceFile, t);
		}
	}

	/**
	 * Handles warnings generated by the preprocessor.
	 */
	private void handlePreprocessorWarnings(JavaPreprocessor jpp, File sourceFile) {
		if (jpp.hasWarnings()) {
			for (PreprocessorWarning warning : jpp.getWarnings()) {
				int severity = warning.shouldFail() ? Logger.SEVERITY_ERROR : Logger.SEVERITY_WARNING;
				/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/
				if (warning.getMessage().startsWith(""No INCLUDE-IF"") && sourceFile.getAbsolutePath().endsWith("".java"") && !includeIfUnsure && !isTestsBootPath) {
					severity = Logger.SEVERITY_ERROR;
				}

				if (warning.getMessage().startsWith(""Ignoring copyright"")) {
					severity = Logger.SEVERITY_INFO;
				}

				logger.log(warning.getMessage(), ""preprocessor"", severity, sourceFile, warning.getLine(), warning.getCharstart(), warning.getCharend());
			}
		}

		if (!noWarnInvalidFlags) {
			for (PreprocessorWarning warning : jpp.getInvalidFlags()) {
				logger.log(warning.getMessage(), ""preprocessor"", Logger.SEVERITY_ERROR, sourceFile, warning.getLine(), warning.getCharstart(), warning.getCharend());
			}
		}
	}

	/**
	 * Determines whether the specified source file should be built.
	 */
	private boolean shouldBuild(File sourceFile, File outputFile, String relativePath) {
		// call the method for all the extensions
		for (BuilderExtension extension : extensions) {
			logger.setMessageSource(extension.getName());
			boolean shouldBuild = extension.shouldBuild(sourceFile, outputFile, relativePath);
			logger.setMessageSource(null);
			if (!shouldBuild) {
				return false;
			}
		}

		return true;
	}

	/*[PR 118220] Incremental builder is not called when file is deleted in base library*/
	/**
	 * Returns the deleted Files
	 */
	/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */
	private List<String> getDeletedFiles(File sourceDir) {
		// call the method for all the extensions
		for (BuilderExtension extension : extensions) {
			logger.setMessageSource(extension.getName());
			List<String> elements = extension.getDeleteFiles(sourceDir);
			logger.setMessageSource(null);
			if (elements != null) {
				return elements;
			}
		}

		return null;
	}

	/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */
	private List<String> getBuildResources(File sourceDir) {
		// call the method for all the extensions
		for (BuilderExtension extension : extensions) {
			logger.setMessageSource(extension.getName());
			List<String> elements = extension.getBuildResources(sourceDir);
			logger.setMessageSource(null);
			if (elements != null) {
				return elements;
			}
		}
		return null;
	}

	/**
	 * Creates a new PreprocessorFactory object.
	 */
	private PreprocessorFactory newPreprocessorFactory() {
		PreprocessorFactory factory = new PreprocessorFactory();
		/*[PR 117967] idea 491: Automatically create the jars required for test bootpath*/
		factory.setFlags(this.configObject.getFlagsAsArray());
		factory.setRequiredIncludeFlags(this.configObject.getRequiredIncludeFlagSet());
		return factory;
	}

	/**
	 * Recursively searches the given root directory to find all files. The file
	 * paths are returned, relative to the root directory.
	 */
	private List<String> getFiles(File rootDirectory) {
		List<String> fileList = new ArrayList<>();
		File[] files = rootDirectory.listFiles();

		if (files == null) {
			StringBuffer msg = new StringBuffer(""Error reading the source directory \"""");
			msg.append(rootDirectory.getAbsolutePath());
			msg.append(""\"" - No Files copied"");
			getLogger().log(msg.toString(), 2);
			verdict = false;
		} else {
			getFiles(files, """", fileList);
		}

		return fileList;
	}

	/**
	 * This is a helper function to getFiles(File);
	 */
	private static void getFiles(File[] files, String relativePath, List<String> fileList) {
		for (File file : files) {
			if (file.isFile()) {
				fileList.add(relativePath + file.getName());
			} else {
				String childRelativePath = relativePath + file.getName() + File.separator;
				getFiles(file.listFiles(), childRelativePath, fileList);
			}
		}
	}

	private void computeBuildFiles() {
		if (sourceDir.exists()) {
			List<String> allFiles = getFiles(sourceDir);
			List<String> buildFiles = new ArrayList<>(allFiles.size());
			for (int j = 0; j < allFiles.size(); j++) {
				String currentFile = allFiles.get(j).toString();
				if (shouldBuild(sourceDir, outputDir, currentFile)) {
					buildFiles.add(currentFile);
				}
			}

			String[] buildFilesArray = buildFiles.toArray(new String[buildFiles.size()]);
			buildFilesBySourceDir.put(sourceDir, buildFilesArray);
			buildFileCount += buildFilesArray.length;
			/*[PR 118220] Incremental builder is not called when file is deleted in base library*/
			/*[PR 119753] classes.txt and AutoRuns are not updated when new test class is added */
			List<String> deleteFiles = getDeletedFiles(sourceDir);
			if (deleteFiles != null && deleteFiles.size() != 0) {
				deleteFileCount = deleteFiles.size();
				deleteFilesBySourceDir.put(sourceDir, deleteFiles);
			}

			List<String> buildResources = getBuildResources(sourceDir);
			if (buildResources != null && buildResources.size() != 0) {
				buildResourcesCount = buildResources.size();
				buildResourcesBySourceDir.put(sourceDir, buildResources);
			}
		} else {
			logger.log(""Error: Source directory does not exist: "" + sourceDir.getAbsolutePath(), Logger.SEVERITY_ERROR, new NullPointerException());
			sourceDir = null;
		}
	}

	/**
	 * Returns the number of files preprocessed.
	 *
	 * @return		the number of files preprocessed
	 */
	public int getBuildFileCount() {
		return buildFileCount;
	}

}
",blob
1018,"public class GwtDeviceServiceImpl extends KapuaRemoteServiceServlet implements GwtDeviceService {

    private static final long serialVersionUID = -1391026997499175151L;

    private static final KapuaLocator LOCATOR = KapuaLocator.getInstance();
    private static final AuthorizationService AUTHORIZATION_SERVICE = LOCATOR.getService(AuthorizationService.class);
    private static final PermissionFactory PERMISSION_FACTORY = LOCATOR.getFactory(PermissionFactory.class);
    private boolean isSameId;

    @Override
    public GwtDevice findDevice(String scopeIdString, String deviceIdString)
            throws GwtKapuaException {
        GwtDevice gwtDevice = null;
        try {
            KapuaId scopeId = KapuaEid.parseCompactId(scopeIdString);
            KapuaId deviceId = KapuaEid.parseCompactId(deviceIdString);

            KapuaLocator locator = KapuaLocator.getInstance();
            DeviceRegistryService deviceRegistryService = locator.getService(DeviceRegistryService.class);
            Device device = deviceRegistryService.find(scopeId, deviceId);

            gwtDevice = KapuaGwtDeviceModelConverter.convertDevice(device);
        } catch (Throwable t) {
            KapuaExceptionHandler.handle(t);
        }
        return gwtDevice;
    }

    @Override
    public ListLoadResult<GwtGroupedNVPair> findDeviceProfile(String scopeIdString, String deviceIdString)
            throws GwtKapuaException {
        List<GwtGroupedNVPair> pairs = new ArrayList<GwtGroupedNVPair>();
        KapuaLocator locator = KapuaLocator.getInstance();

        DeviceRegistryService deviceRegistryService = locator.getService(DeviceRegistryService.class);
        DeviceEventService deviceEventService = locator.getService(DeviceEventService.class);
        final DeviceConnectionService deviceConnectionService = locator.getService(DeviceConnectionService.class);
        GroupService groupService = locator.getService(GroupService.class);
        final UserService userService = locator.getService(UserService.class);

        try {

            final KapuaId scopeId = KapuaEid.parseCompactId(scopeIdString);
            KapuaId deviceId = KapuaEid.parseCompactId(deviceIdString);
            final Device device = deviceRegistryService.find(scopeId, deviceId);

            if (device != null) {
                pairs.add(new GwtGroupedNVPair(""devInfo"", ""devStatus"", device.getStatus().toString()));

                final DeviceConnection deviceConnection;
                if (device.getConnectionId() != null) {
                    if (device.getConnection() != null) {
                        deviceConnection = device.getConnection();
                    } else {
                        deviceConnection = KapuaSecurityUtils.doPrivileged(new Callable<DeviceConnection>() {

                            @Override
                            public DeviceConnection call() throws Exception {
                                return deviceConnectionService.find(device.getScopeId(), device.getConnectionId());
                            }
                        });
                    }
                } else {
                    deviceConnection = null;
                }
                if (deviceConnection != null) {
                    User lastConnectedUser = KapuaSecurityUtils.doPrivileged(new Callable<User>() {

                        @Override
                        public User call() throws Exception {
                            return userService.find(scopeId, deviceConnection.getUserId());
                        }
                    });
                    User reservedUser = null;
                    if (deviceConnection.getReservedUserId() != null) {
                        reservedUser = KapuaSecurityUtils.doPrivileged(new Callable<User>() {

                            @Override
                            public User call() throws Exception {
                                return userService.find(scopeId, deviceConnection.getReservedUserId());
                            }
                        });
                    }

                    pairs.add(new GwtGroupedNVPair(""connInfo"", ""connConnectionStatus"", deviceConnection.getStatus().toString()));
                    pairs.add(new GwtGroupedNVPair(""connInfo"", ""connClientId"", device.getClientId()));
                    pairs.add(new GwtGroupedNVPair(""connInfo"", ""connUserName"", lastConnectedUser != null ? lastConnectedUser.getName() : null));
                    if (AUTHORIZATION_SERVICE.isPermitted(PERMISSION_FACTORY.newPermission(new UserDomain(), Actions.read, scopeId))) {
                        pairs.add(new GwtGroupedNVPair(""connInfo"", ""connReservedUserId"", reservedUser != null ? reservedUser.getName() : null));
                    }
                    pairs.add(new GwtGroupedNVPair(""connInfo"", ""connUserCouplingMode"", GwtConnectionUserCouplingMode.valueOf(deviceConnection.getUserCouplingMode().name()).getLabel()));
                    pairs.add(new GwtGroupedNVPair(""connInfo"", ""connClientIp"", deviceConnection.getClientIp()));
                    pairs.add(new GwtGroupedNVPair(""netInfo"", ""netConnIface"", device.getConnectionInterface()));
                    pairs.add(new GwtGroupedNVPair(""netInfo"", ""netConnIp"", deviceConnection.getClientIp()));
                    pairs.add(new GwtGroupedNVPair(""netInfo"", ""netConnIfaceIp"", device.getConnectionIp()));
                    pairs.add(new GwtGroupedNVPair(""devInfo"", ""devConnectionStatus"", deviceConnection.getStatus().toString()));

                } else {
                    pairs.add(new GwtGroupedNVPair(""connInfo"", ""connConnectionStatus"", DeviceConnectionStatus.DISCONNECTED.toString()));
                    pairs.add(new GwtGroupedNVPair(""connInfo"", ""connClientId"", null));
                    pairs.add(new GwtGroupedNVPair(""connInfo"", ""connUserName"", null));
                    if (AUTHORIZATION_SERVICE.isPermitted(PERMISSION_FACTORY.newPermission(new UserDomain(), Actions.read, scopeId))) {
                        pairs.add(new GwtGroupedNVPair(""connInfo"", ""connReservedUserId"", null));
                    }
                    pairs.add(new GwtGroupedNVPair(""connInfo"", ""connUserCouplingMode"", null));
                    pairs.add(new GwtGroupedNVPair(""connInfo"", ""connClientIp"", null));
                    pairs.add(new GwtGroupedNVPair(""netInfo"", ""netConnIface"", null));
                    pairs.add(new GwtGroupedNVPair(""netInfo"", ""netConnIp"", null));
                    pairs.add(new GwtGroupedNVPair(""netInfo"", ""netConnIfaceIp"", null));
                    pairs.add(new GwtGroupedNVPair(""devInfo"", ""devConnectionStatus"", DeviceConnectionStatus.DISCONNECTED.toString()));
                }

                pairs.add(new GwtGroupedNVPair(""devInfo"", ""devClientId"", device.getClientId()));
                pairs.add(new GwtGroupedNVPair(""devInfo"", ""devDisplayName"", device.getDisplayName()));

                if (AUTHORIZATION_SERVICE.isPermitted(PERMISSION_FACTORY.newPermission(new GroupDomain(), Actions.read, device.getScopeId()))) {
                    if (device.getGroupId() != null) {

                        Group group = groupService.find(scopeId, device.getGroupId());
                        if (group != null) {
                            pairs.add(new GwtGroupedNVPair(""devInfo"", ""devGroupName"", group.getName()));
                        }
                    } else {
                        pairs.add(new GwtGroupedNVPair(""devInfo"", ""devGroupName"", null));
                    }
                }

                if (AUTHORIZATION_SERVICE.isPermitted(PERMISSION_FACTORY.newPermission(DeviceDomains.DEVICE_EVENT_DOMAIN, Actions.read, device.getScopeId()))) {
                    if (device.getLastEventId() != null) {
                        DeviceEvent lastEvent = deviceEventService.find(scopeId, device.getLastEventId());

                        if (lastEvent != null) {
                            pairs.add(new GwtGroupedNVPair(""devInfo"", ""devLastEventType"", lastEvent.getResource()));
                            pairs.add(new GwtGroupedNVPair(""devInfo"", ""devLastEventOn"", lastEvent.getReceivedOn()));
                        } else {
                            pairs.add(new GwtGroupedNVPair(""devInfo"", ""devLastEventType"", null));
                            pairs.add(new GwtGroupedNVPair(""devInfo"", ""devLastEventOn"", null));
                        }
                    } else {
                        if (deviceConnection != null) {
                            pairs.add(new GwtGroupedNVPair(""devInfo"", ""devLastEventType"", deviceConnection.getStatus().name()));
                            pairs.add(new GwtGroupedNVPair(""devInfo"", ""devLastEventOn"", deviceConnection.getModifiedOn()));
                        } else {
                            pairs.add(new GwtGroupedNVPair(""devInfo"", ""devLastEventType"", null));
                            pairs.add(new GwtGroupedNVPair(""devInfo"", ""devLastEventOn"", null));
                        }
                    }
                }

                pairs.add(new GwtGroupedNVPair(""devInfo"", ""devApps"", device.getApplicationIdentifiers()));
                pairs.add(new GwtGroupedNVPair(""devInfo"", ""devAccEnc"", device.getAcceptEncoding()));

                pairs.add(new GwtGroupedNVPair(""devAttributesInfo"", ""devCustomAttribute1"", device.getCustomAttribute1()));
                pairs.add(new GwtGroupedNVPair(""devAttributesInfo"", ""devCustomAttribute2"", device.getCustomAttribute2()));
                pairs.add(new GwtGroupedNVPair(""devAttributesInfo"", ""devCustomAttribute3"", device.getCustomAttribute3()));
                pairs.add(new GwtGroupedNVPair(""devAttributesInfo"", ""devCustomAttribute4"", device.getCustomAttribute4()));
                pairs.add(new GwtGroupedNVPair(""devAttributesInfo"", ""devCustomAttribute5"", device.getCustomAttribute5()));

                pairs.add(new GwtGroupedNVPair(""devHw"", ""devModelId"", device.getModelId()));
                pairs.add(new GwtGroupedNVPair(""devHw"", ""devModelName"", device.getModelName()));
                pairs.add(new GwtGroupedNVPair(""devHw"", ""devSerialNumber"", device.getSerialNumber()));

                pairs.add(new GwtGroupedNVPair(""devSw"", ""devFirmwareVersion"", device.getFirmwareVersion()));
                pairs.add(new GwtGroupedNVPair(""devSw"", ""devBiosVersion"", device.getBiosVersion()));
                pairs.add(new GwtGroupedNVPair(""devSw"", ""devOsVersion"", device.getOsVersion()));

                pairs.add(new GwtGroupedNVPair(""devJava"", ""devJvmVersion"", device.getJvmVersion()));

                // GPS infos retrieval
                if (AUTHORIZATION_SERVICE.isPermitted(PERMISSION_FACTORY.newPermission(DeviceDomains.DEVICE_EVENT_DOMAIN, Actions.read, device.getScopeId()))) {
                    DeviceEventFactory deviceEventFactory = locator.getFactory(DeviceEventFactory.class);
                    DeviceEventQuery eventQuery = deviceEventFactory
                            .newQuery(device.getScopeId());
                    eventQuery.setLimit(1);
                    eventQuery.setSortCriteria(new FieldSortCriteria(DeviceEventAttributes.RECEIVED_ON, SortOrder.DESCENDING));

                    AndPredicateImpl andPredicate = new AndPredicateImpl();
                    andPredicate.and(new AttributePredicateImpl<KapuaId>(DeviceEventAttributes.DEVICE_ID, device.getId()));
                    andPredicate.and(new AttributePredicateImpl<String>(DeviceEventAttributes.RESOURCE, ""BIRTH""));

                    eventQuery.setPredicate(andPredicate);

                    KapuaListResult<DeviceEvent> events = deviceEventService.query(eventQuery);
                    DeviceEvent lastEvent = events.getFirstItem();
                    if (lastEvent != null) {
                        KapuaPosition eventPosition = lastEvent.getPosition();
                        if (eventPosition != null) {
                            pairs.add(new GwtGroupedNVPair(""gpsInfo"", ""gpsLat"", String.valueOf(eventPosition.getLatitude())));
                            pairs.add(new GwtGroupedNVPair(""gpsInfo"", ""gpsLong"", String.valueOf(eventPosition.getLongitude())));
                        }
                    } else {
                        pairs.add(new GwtGroupedNVPair(""gpsInfo"", ""gpsLat"", null));
                        pairs.add(new GwtGroupedNVPair(""gpsInfo"", ""gpsLong"", null));
                    }
                }

                pairs.add(new GwtGroupedNVPair(""modemInfo"", ""modemImei"", device.getImei()));
                pairs.add(new GwtGroupedNVPair(""modemInfo"", ""modemImsi"", device.getImsi()));
                pairs.add(new GwtGroupedNVPair(""modemInfo"", ""modemIccid"", device.getIccid()));
            }
        } catch (Throwable t) {
            KapuaExceptionHandler.handle(t);
        }
        return new BaseListLoadResult<GwtGroupedNVPair>(pairs);
    }

    @Override
    public PagingLoadResult<GwtDevice> query(PagingLoadConfig loadConfig, GwtDeviceQuery gwtDeviceQuery)
            throws GwtKapuaException {
        KapuaLocator locator = KapuaLocator.getInstance();
        DeviceRegistryService deviceRegistryService = locator.getService(DeviceRegistryService.class);

        List<GwtDevice> gwtDevices = new ArrayList<GwtDevice>();
        BasePagingLoadResult<GwtDevice> gwtResults;
        int totalResult = 0;
        try {
            DeviceQuery deviceQuery = GwtKapuaDeviceModelConverter.convertDeviceQuery(loadConfig, gwtDeviceQuery);
            deviceQuery.addFetchAttributes(DeviceAttributes.CONNECTION);
            deviceQuery.addFetchAttributes(DeviceAttributes.LAST_EVENT);

            KapuaListResult<Device> devices = deviceRegistryService.query(deviceQuery);
            totalResult = (int) deviceRegistryService.count(deviceQuery);
            for (Device d : devices.getItems()) {
                GwtDevice gwtDevice = KapuaGwtDeviceModelConverter.convertDevice(d);

                // Connection info

                gwtDevice.setConnectionIp(d.getConnectionIp());
                gwtDevice.setConnectionInterface(d.getConnectionInterface());

                DeviceConnection deviceConnection = d.getConnection();
                if (deviceConnection != null) {
                    gwtDevice.setClientIp(deviceConnection.getClientIp());
                    gwtDevice.setGwtDeviceConnectionStatus(deviceConnection.getStatus().name());
                    gwtDevice.setLastEventOn(deviceConnection.getModifiedOn());
                    gwtDevice.setLastEventType(deviceConnection.getStatus().name());
                } else {
                    gwtDevice.setGwtDeviceConnectionStatus(GwtDeviceConnectionStatus.UNKNOWN.name());
                }

                if (d.getLastEvent() != null) {
                    DeviceEvent lastEvent = d.getLastEvent();

                    gwtDevice.setLastEventType(lastEvent.getResource());
                    gwtDevice.setLastEventOn(lastEvent.getReceivedOn());
                }

                gwtDevices.add(gwtDevice);
            }

        } catch (Throwable t) {
            KapuaExceptionHandler.handle(t);
        }

        gwtResults = new BasePagingLoadResult<GwtDevice>(gwtDevices);
        gwtResults.setOffset(loadConfig != null ? loadConfig.getOffset() : 0);
        gwtResults.setTotalLength(totalResult);

        return gwtResults;
    }

    @Override
    public List<GwtDevice> query(GwtDeviceQuery gwtDeviceQuery) throws GwtKapuaException {
        return query(null, gwtDeviceQuery).getData();
    }

    @Override
    public GwtDevice createDevice(GwtXSRFToken xsrfToken, GwtDeviceCreator gwtDeviceCreator)
            throws GwtKapuaException {
        //
        // Checking validity of the given XSRF Token
        checkXSRFToken(xsrfToken);

        KapuaLocator locator = KapuaLocator.getInstance();
        DeviceRegistryService deviceRegistryService = locator.getService(DeviceRegistryService.class);
        DeviceFactory deviceFactory = locator.getFactory(DeviceFactory.class);
        GwtDevice gwtDevice = null;

        try {
            KapuaId scopeId = KapuaEid.parseCompactId(gwtDeviceCreator.getScopeId());

            DeviceCreator deviceCreator = deviceFactory.newCreator(scopeId, gwtDeviceCreator.getClientId());
            deviceCreator.setDisplayName(gwtDeviceCreator.getDisplayName());
            deviceCreator.setGroupId(GwtKapuaCommonsModelConverter.convertKapuaId(gwtDeviceCreator.getGroupId()));
            deviceCreator.setStatus((DeviceStatus.valueOf(gwtDeviceCreator.getDeviceStatus())));

            // FIXME One day it will be specified from the form. In the meantime, defaults to LOOSE
            // deviceCreator.setCredentialsMode(DeviceCredentialsMode.LOOSE);

            deviceCreator.setCustomAttribute1(gwtDeviceCreator.getCustomAttribute1());
            deviceCreator.setCustomAttribute2(gwtDeviceCreator.getCustomAttribute2());
            deviceCreator.setCustomAttribute3(gwtDeviceCreator.getCustomAttribute3());
            deviceCreator.setCustomAttribute4(gwtDeviceCreator.getCustomAttribute4());
            deviceCreator.setCustomAttribute5(gwtDeviceCreator.getCustomAttribute5());

            Device device = deviceRegistryService.create(deviceCreator);

            gwtDevice = KapuaGwtDeviceModelConverter.convertDevice(device);
        } catch (Throwable t) {
            KapuaExceptionHandler.handle(t);
        }

        return gwtDevice;
    }

    @Override
    public GwtDevice updateAttributes(GwtXSRFToken xsrfToken, GwtDevice gwtDevice)
            throws GwtKapuaException {
        //
        // Checking validity of the given XSRF Token
        checkXSRFToken(xsrfToken);

        KapuaLocator locator = KapuaLocator.getInstance();
        DeviceRegistryService deviceRegistryService = locator.getService(DeviceRegistryService.class);
        Device device = null;
        GwtDevice gwtDeviceUpdated = null;

        try {
            //
            // Find original device
            KapuaId scopeId = KapuaEid.parseCompactId(gwtDevice.getScopeId());
            KapuaId deviceId = KapuaEid.parseCompactId(gwtDevice.getId());
            device = deviceRegistryService.find(scopeId, deviceId);

            //
            // Updated values
            // Gerenal info
            device.setDisplayName(gwtDevice.getUnescapedDisplayName());
            device.setStatus(DeviceStatus.valueOf(gwtDevice.getGwtDeviceStatus()));
            device.setGroupId(GwtKapuaCommonsModelConverter.convertKapuaId(gwtDevice.getGroupId()));

            // Security Stuff
            // device.setCredentialsMode(DeviceCredentialsMode.valueOf(gwtDevice.getCredentialsTight()));
            // KapuaId deviceUserId = KapuaEid.parseCompactId(gwtDevice.getDeviceUserId());
            // device.setPreferredUserId(deviceUserId);

            // Custom attributes
            device.setCustomAttribute1(gwtDevice.getUnescapedCustomAttribute1());
            device.setCustomAttribute2(gwtDevice.getUnescapedCustomAttribute2());
            device.setCustomAttribute3(gwtDevice.getUnescapedCustomAttribute3());
            device.setCustomAttribute4(gwtDevice.getUnescapedCustomAttribute4());
            device.setCustomAttribute5(gwtDevice.getUnescapedCustomAttribute5());

            device.setOptlock(gwtDevice.getOptlock());

            // Do the update
            device = deviceRegistryService.update(device);

            // Convert to gwt object
            gwtDeviceUpdated = KapuaGwtDeviceModelConverter.convertDevice(device);

        } catch (Throwable t) {
            KapuaExceptionHandler.handle(t);
        }
        return gwtDeviceUpdated;
    }

    @Override
    public void deleteDevice(GwtXSRFToken xsrfToken, String scopeIdString, String clientId)
            throws GwtKapuaException {
        //
        // Checking validity of the given XSRF Token
        checkXSRFToken(xsrfToken);

        try {
            KapuaId scopeId = KapuaEid.parseCompactId(scopeIdString);

            KapuaLocator locator = KapuaLocator.getInstance();
            DeviceRegistryService drs = locator.getService(DeviceRegistryService.class);
            Device d = drs.findByClientId(scopeId, clientId);
            drs.delete(d.getScopeId(), d.getId());
        } catch (Throwable t) {
            KapuaExceptionHandler.handle(t);
        }
    }

    @Override
    public void addDeviceTag(GwtXSRFToken xsrfToken, String scopeIdString, String deviceIdString, String tagIdString) throws GwtKapuaException {
        //
        // Checking validity of the given XSRF Token
        checkXSRFToken(xsrfToken);

        try {
            KapuaId scopeId = KapuaEid.parseCompactId(scopeIdString);
            KapuaId deviceId = KapuaEid.parseCompactId(deviceIdString);
            KapuaId tagId = KapuaEid.parseCompactId(tagIdString);

            KapuaLocator locator = KapuaLocator.getInstance();
            DeviceRegistryService drs = locator.getService(DeviceRegistryService.class);
            TagService tagService = locator.getService(TagService.class);
            Device device = drs.find(scopeId, deviceId);

            Set<KapuaId> tagIds = device.getTagIds();
            if (tagIds.contains(tagId)) {
                Tag tag = tagService.find(scopeId, tagId);
                isSameId = true;
                if (tag != null) {
                    throw new KapuaDuplicateNameException(tag.getName());
                }
            }
            tagIds.add(tagId);
            device.setTagIds(tagIds);

            drs.update(device);

        } catch (Throwable t) {
            KapuaExceptionHandler.handle(t);
        }
    }

    @Override
    public void deleteDeviceTag(GwtXSRFToken xsrfToken, String scopeIdString, String deviceIdString, String tagIdString) throws GwtKapuaException {
        //
        // Checking validity of the given XSRF Token
        checkXSRFToken(xsrfToken);

        try {
            KapuaId scopeId = KapuaEid.parseCompactId(scopeIdString);
            KapuaId deviceId = KapuaEid.parseCompactId(deviceIdString);
            KapuaId tagId = KapuaEid.parseCompactId(tagIdString);

            KapuaLocator locator = KapuaLocator.getInstance();
            DeviceRegistryService drs = locator.getService(DeviceRegistryService.class);

            Device device = drs.find(scopeId, deviceId);

            Set<KapuaId> tagIds = device.getTagIds();
            tagIds.remove(tagId);
            device.setTagIds(tagIds);

            drs.update(device);
        } catch (Throwable t) {
            KapuaExceptionHandler.handle(t);
        }
    }

    @Override
    public PagingLoadResult<GwtDeviceEvent> findDeviceEvents(PagingLoadConfig loadConfig,
            GwtDevice gwtDevice,
            Date startDate,
            Date endDate)
            throws GwtKapuaException {
        ArrayList<GwtDeviceEvent> gwtDeviceEvents = new ArrayList<GwtDeviceEvent>();
        BasePagingLoadResult<GwtDeviceEvent> gwtResults = null;

        KapuaLocator locator = KapuaLocator.getInstance();
        DeviceEventService des = locator.getService(DeviceEventService.class);
        DeviceEventFactory deviceEventFactory = locator.getFactory(DeviceEventFactory.class);

        try {

            // prepare the query
            BasePagingLoadConfig bplc = (BasePagingLoadConfig) loadConfig;
            DeviceEventQuery query = deviceEventFactory.newQuery(KapuaEid.parseCompactId(gwtDevice.getScopeId()));

            AndPredicate andPredicate = new AndPredicateImpl();

            andPredicate.and(new AttributePredicateImpl<KapuaId>(DeviceEventAttributes.DEVICE_ID, KapuaEid.parseCompactId(gwtDevice.getId())));
            andPredicate.and(new AttributePredicateImpl<Date>(DeviceEventAttributes.RECEIVED_ON, startDate, Operator.GREATER_THAN));
            andPredicate.and(new AttributePredicateImpl<Date>(DeviceEventAttributes.RECEIVED_ON, endDate, Operator.LESS_THAN));

            query.setPredicate(andPredicate);
            query.setSortCriteria(new FieldSortCriteria(DeviceEventAttributes.RECEIVED_ON, SortOrder.DESCENDING));
            query.setOffset(bplc.getOffset());
            query.setLimit(bplc.getLimit());

            // query execute
            KapuaListResult<DeviceEvent> deviceEvents = des.query(query);

            // prepare results
            for (DeviceEvent deviceEvent : deviceEvents.getItems()) {
                gwtDeviceEvents.add(KapuaGwtDeviceModelConverter.convertDeviceEvent(deviceEvent));
            }
            gwtResults = new BasePagingLoadResult<GwtDeviceEvent>(gwtDeviceEvents);
            gwtResults.setOffset(loadConfig.getOffset());
            gwtResults.setTotalLength((int) des.count(query));

        } catch (Throwable t) {
            KapuaExceptionHandler.handle(t);
        }
        return gwtResults;
    }

    @Override
    public String getTileEndpoint() throws GwtKapuaException {
        return ConsoleSetting.getInstance().getString(ConsoleSettingKeys.DEVICE_MAP_TILE_URI);
    }

    @Override
    public boolean isMapEnabled() {
        return ConsoleSetting.getInstance().getBoolean(ConsoleSettingKeys.DEVICE_MAP_ENABLED);
    }

}
",blob
1415,"public class AssemblerConfig {

	// Private Member Variables ------------------------------------------------

	/** The portlet app descriptor, which is usually WEB-INF/portlet.xml. */
    private File portletDescriptor;

    /** The webapp descriptor to assemble, which is usually WEB-INF/web.xml. */
    private File webappDescriptor;

    /** The assemble destination, which points to the assembled WAR file. */
    private File destination;

    /** The class of the servlet that will handle portlet requests */
    private String dispatchServletClass;

    /** The source archive to assemble */
    private File source;
    
    /** Assembler sink buffer size.  Defaults to 4096 bytes. */
    private int assemblerSinkBuflen = 1024 * 4; // 4kb

    // Public Methods ----------------------------------------------------------

    public File getPortletDescriptor() {
        return portletDescriptor;
    }

    public void setPortletDescriptor(File portletDescriptor) {
        this.portletDescriptor = portletDescriptor;
    }

    public File getWebappDescriptor() {
        return webappDescriptor;
    }

    public void setWebappDescriptor(File webappDescriptor) {
        this.webappDescriptor = webappDescriptor;
    }

    public File getDestination() {
        return destination;
    }

    public void setDestination(File destination) {
        this.destination = destination;
    }

    public String getDispatchServletClass() {
        return dispatchServletClass;
    }

    public void setDispatchServletClass(String dispatchServletClass) {
        this.dispatchServletClass = dispatchServletClass;
    }

    /**
     * @deprecated use <code>setSource(File)</code> instead.
     */
    public void setWarSource(File source) {
        this.source = source;
    }
    
    public void setSource(File source) {
        this.source = source;
    }
    
    /**
     * @deprecated use <code>getSource()</code> instead.
     */
    public File getWarSource() {
        return source;
    }
    
    public File getSource() {
        return source;
    }
    
    public int getAssemblerSinkBuflen() {
        return assemblerSinkBuflen;
    }
    
    public void setAssemblerSinkBuflen(int buflen) {
        this.assemblerSinkBuflen = buflen;
    }
}
",data class
286,"        private void write(NIOConnection c) {
            try {
                c.writeByQueue();
            } catch (Throwable e) {
                c.error(ErrorCode.ERR_WRITE_BY_QUEUE, e);
            }
        }
",feature envy
420,"    public static String shortenDbName(String dbName, int desiredLength) {
        StringBuilder dbBuf = new StringBuilder(dbName);
        if (dbBuf.length() > desiredLength) {
            // remove one vowel at a time, starting at beginning
            for (int i = dbBuf.length() - 1; i > 0; i--) {
                // don't remove vowels that are at the beginning of the string (taken care of by the i > 0) or right after an underscore
                if (dbBuf.charAt(i - 1) == '_') {
                    continue;
                }

                char curChar = dbBuf.charAt(i);
                if (vowelBag.indexOf(curChar) > 0) {
                    dbBuf.deleteCharAt(i);
                }
            }
        }

        // remove all double underscores
        while (dbBuf.indexOf(""__"") > 0) {
            dbBuf.deleteCharAt(dbBuf.indexOf(""__""));
        }

        while (dbBuf.length() > desiredLength) {
            boolean removedChars = false;

            int usIndex = dbBuf.lastIndexOf(""_"");
            while (usIndex > 0 && dbBuf.length() > desiredLength) {
                // if this is the first word in the group, don't pull letters off unless it is 4 letters or more
                int prevUsIndex = dbBuf.lastIndexOf(""_"", usIndex - 1);
                if (prevUsIndex < 0 && usIndex < 4) {
                    break;
                }

                // don't remove characters to reduce the size two less than three characters between underscores
                if (prevUsIndex >= 0 && (usIndex - prevUsIndex) <= 4) {
                    usIndex = prevUsIndex;
                    continue;
                }

                // delete the second to last character instead of the last, better chance of being unique
                dbBuf.deleteCharAt(usIndex - 2);
                removedChars = true;
                if (usIndex > 2) {
                    usIndex = dbBuf.lastIndexOf(""_"", usIndex - 2);
                } else {
                    break;
                }
            }

            // now delete the char at the end of the string if necessary
            if (dbBuf.length() > desiredLength) {
                int removeIndex = dbBuf.length() - 1;
                int prevRemoveIndex = dbBuf.lastIndexOf(""_"", removeIndex - 1);
                // don't remove characters to reduce the size two less than two characters between underscores
                if (prevRemoveIndex < 0 || (removeIndex - prevRemoveIndex) >= 3) {
                    // delete the second to last character instead of the last, better chance of being unique
                    dbBuf.deleteCharAt(removeIndex - 1);
                    removedChars = true;
                }
            }

            // remove all double underscores
            while (dbBuf.indexOf(""__"") > 0) {
                dbBuf.deleteCharAt(dbBuf.indexOf(""__""));
                removedChars = true;
            }

            // if we didn't remove anything break out to avoid an infinite loop
            if (!removedChars) {
                break;
            }
        }

        // remove all double underscores
        while (dbBuf.indexOf(""__"") > 0) {
            dbBuf.deleteCharAt(dbBuf.indexOf(""__""));
        }

        while (dbBuf.length() > desiredLength) {
            // still not short enough, get more aggressive
            // don't remove the first segment, just remove the second over and over until we are short enough
            int firstUs = dbBuf.indexOf(""_"");
            if (firstUs > 0) {
                int nextUs = dbBuf.indexOf(""_"", firstUs + 1);
                if (nextUs > 0) {
                    //Debug.logInfo(""couldn't shorten enough normally, removing second segment from "" + dbBuf, module);
                    dbBuf.delete(firstUs, nextUs);
                }
            }
        }

        //Debug.logInfo(""Shortened "" + dbName + "" to "" + dbBuf.toString(), module);
        return dbBuf.toString();
    }
",long method
1128,"    @XmlRootElement(name = ""header"")
    @XmlAccessorType(XmlAccessType.FIELD)
    public static class Header {

        @XmlAttribute
        private String key;

        @XmlAttribute
        private String type;

        @XmlValue
        private String value;

        public String getKey() {
            return key;
        }

        public void setKey(String key) {
            this.key = key;
        }

        public String getType() {
            return type;
        }

        public void setType(String type) {
            this.type = type;
        }

        public String getValue() {
            return value;
        }

        public void setValue(String value) {
            this.value = value;
        }
    }
",data class
241,"	public static Control createCustomAreaWithLink(final Composite parent, final Dialog dialog, final Binary binary) {
		final String binaryLabel = binary.getLabel();
		final String prefix = ""The requested operation cannot be performed due to invalid '"" + binaryLabel
				+ ""' settings. Check your '"" + binaryLabel
				+ ""' configuration and preferences under the corresponding "";
		final String link = ""preference page"";
		final String suffix = ""."";
		final String text = prefix + link + suffix;

		final Composite control = new Composite(parent, NONE);
		control.setLayout(GridLayoutFactory.fillDefaults().create());
		final GridData gridData = GridDataFactory.fillDefaults().align(LEFT, TOP).grab(true, true).create();
		control.setLayoutData(gridData);

		final StyleRange style = new StyleRange();
		style.underline = true;
		style.underlineStyle = UNDERLINE_LINK;

		final StyledText styledText = new StyledText(control, MULTI | READ_ONLY | WRAP);
		styledText.setWordWrap(true);
		styledText.setJustify(true);
		styledText.setText(text);
		final GridData textGridData = GridDataFactory.fillDefaults().align(FILL, FILL).grab(true, true).create();
		textGridData.widthHint = TEXT_WIDTH_HINT;
		textGridData.heightHint = TEXT_HEIGHT_HINT;
		styledText.setLayoutData(textGridData);

		styledText.setEditable(false);
		styledText.setBackground(UIUtils.getSystemColor(COLOR_WIDGET_BACKGROUND));
		final int[] ranges = { text.indexOf(link), link.length() };
		final StyleRange[] styles = { style };
		styledText.setStyleRanges(ranges, styles);

		styledText.addMouseListener(new MouseAdapter() {

			@Override
			public void mouseDown(final MouseEvent event) {
				try {
					final int offset = styledText.getOffsetAtPoint(new Point(event.x, event.y));
					final StyleRange actualStyle = offset >= 0 ? styledText.getStyleRangeAtOffset(offset) : null;
					if (null != actualStyle && actualStyle.underline
							&& UNDERLINE_LINK == actualStyle.underlineStyle) {

						dialog.close();
						final PreferenceDialog preferenceDialog = createPreferenceDialogOn(
								UIUtils.getShell(),
								BinariesPreferencePage.ID,
								FILTER_IDS,
								null);

						if (null != preferenceDialog) {
							preferenceDialog.open();
						}

					}
				} catch (final IllegalArgumentException e) {
					// We are not over the actual text.
				}
			}

		});

		return control;
	}
",feature envy
1486,"  public static int reconfigureNetworking()
  {
    // This uses values from the property settings
    if (Sage.getBoolean(NET_CONFIG_WIRED, true))
    {
      // Bring down the wireless interface if it's there
      bringDownWireless();

      setupNetworking(Sage.get(""linux/wired_network_port"", ""eth0""));
    }
    else
    {
      // Bring down the wired interface if it's there
      if (Sage.getBoolean(""linux/disable_wired_when_wireless_is_enabled"", false))
        bringDownWired();

      // Be sure the wired interface is loaded (it may need to be before it is configured)
      IOUtils.exec2(""ifconfig "" + Sage.get(""linux/wireless_network_port"", ""eth1"") + "" up"");

      // Setup the wireless networking properties before we try to connect to the network or it won't work
      IOUtils.exec2(""iwconfig "" + Sage.get(""linux/wireless_network_port"", ""eth1"") + "" essid "" + Sage.get(NET_CONFIG_SSID, ""any""));

      String crypto = Sage.get(NET_CONFIG_ENCRYPTION, ""WPA"");
      if (""None"".equals(crypto))
      {
        IOUtils.exec2(""iwconfig "" + Sage.get(""linux/wireless_network_port"", ""eth1"") + "" key off"");
      }
      else
      {
        // Check if the key is all hex
        String key = Sage.get(NET_CONFIG_ENCRYPTION_KEY, """");
        boolean hexKey = true;
        for (int i = 0; i < key.length(); i++)
        {
          if (Character.digit(key.charAt(i), 16) < 0)
          {
            hexKey = false;
            break;
          }
        }
        if (""WEP"".equals(crypto))
        {
          IOUtils.exec2(""iwconfig "" + Sage.get(""linux/wireless_network_port"", ""eth1"") + "" key on"");
          if (hexKey)
            IOUtils.exec2(""iwconfig "" + Sage.get(""linux/wireless_network_port"", ""eth1"") + "" key "" + Sage.get(NET_CONFIG_ENCRYPTION_KEY, """"));
          else
            IOUtils.exec2(""iwconfig "" + Sage.get(""linux/wireless_network_port"", ""eth1"") + "" key s:"" + Sage.get(NET_CONFIG_ENCRYPTION_KEY, """"));
        }
        else // WPA
        {
          // NOT FINISHED YET, we'll need to setup a configuration file for wpa_supplicant and then run it
        }
      }

      setupNetworking(Sage.get(""linux/wireless_network_port"", ""eth1""));
    }
    return 0;
  }
",long method
417,"public class PageExtractor
{
    private PDDocument sourceDocument;
    
    // first page to extract is page 1 (by default)
    private int startPage = 1;
    
    private int endPage = 0;
    
    /** 
     * Creates a new instance of PageExtractor
     * @param sourceDocument The document to split.
     */
    public PageExtractor(PDDocument sourceDocument)
    {
        this.sourceDocument = sourceDocument;
        endPage = sourceDocument.getNumberOfPages();
    }
    
    /** 
     * Creates a new instance of PageExtractor
     * @param sourceDocument The document to split.
     * @param startPage The first page you want extracted (inclusive)
     * @param endPage The last page you want extracted (inclusive)
     */
    public PageExtractor(PDDocument sourceDocument, int startPage, int endPage)
    {
        this(sourceDocument);
        this.startPage = startPage;
        this.endPage = endPage;
    }
    
    /**
     * This will take a document and extract the desired pages into a new 
     * document.  Both startPage and endPage are included in the extracted 
     * document.  If the endPage is greater than the number of pages in the 
     * source document, it will go to the end of the document.  If startPage is
     * less than 1, it'll start with page 1.  If startPage is greater than 
     * endPage or greater than the number of pages in the source document, a 
     * blank document will be returned.
     * 
     * @return The extracted document
     * @throws IOException If there is an IOError
     */
    public PDDocument extract() throws IOException
    {
        PDDocument extractedDocument = new PDDocument();
        extractedDocument.setDocumentInformation(sourceDocument.getDocumentInformation());
        extractedDocument.getDocumentCatalog().setViewerPreferences(
                sourceDocument.getDocumentCatalog().getViewerPreferences());
        
        for (int i = startPage; i <= endPage; i++)
        {
            PDPage page = sourceDocument.getPage(i - 1);
            PDPage imported = extractedDocument.importPage(page);
            imported.setCropBox(page.getCropBox());
            imported.setMediaBox(page.getMediaBox());
            imported.setResources(page.getResources());
            imported.setRotation(page.getRotation());
        }
            
        return extractedDocument;
    }

    /**
     * Gets the first page number to be extracted.
     * @return the first page number which should be extracted
     */
    public int getStartPage()
    {
        return startPage;
    }

    /**
     * Sets the first page number to be extracted.
     * @param startPage the first page number which should be extracted
     */
    public void setStartPage(int startPage)
    {
        this.startPage = startPage;
    }

    /**
     * Gets the last page number (inclusive) to be extracted.
     * @return the last page number which should be extracted
     */
    public int getEndPage()
    {
        return endPage;
    }

    /**
     * Sets the last page number to be extracted.
     * @param endPage the last page number which should be extracted
     */
    public void setEndPage(int endPage)
    {
        this.endPage = endPage;
    }
}
",data class
912,"			public Builder mergeFrom(com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws java.io.IOException {
				com.google.protobuf.UnknownFieldSet.Builder unknownFields = com.google.protobuf.UnknownFieldSet.newBuilder(this.getUnknownFields());
				while (true) {
					int tag = 0;
					try {
						tag = input.readTag();
					} catch (Exception e) {
						// do nothing
					}
					switch (tag) {
						case 0 :
							this.setUnknownFields(unknownFields.build());
							onChanged();
							return this;
						default : {
							if (!parseUnknownField(input, unknownFields, extensionRegistry, tag)) {
								this.setUnknownFields(unknownFields.build());
								onChanged();
								return this;
							}
							break;
						}
						case 10 : {
							bitField0_ |= 0x00000001;
							message_ = input.readBytes();
							break;
						}
						case 16 : {
							int rawValue = input.readEnum();
							org.eclipse.orion.server.cf.loggregator.LoggregatorMessage.Message.MessageType value = org.eclipse.orion.server.cf.loggregator.LoggregatorMessage.Message.MessageType.valueOf(rawValue);
							if (value == null) {
								unknownFields.mergeVarintField(2, rawValue);
							} else {
								bitField0_ |= 0x00000002;
								messageType_ = value;
							}
							break;
						}
						case 24 : {
							bitField0_ |= 0x00000004;
							timestamp_ = input.readSInt64();
							break;
						}
						case 34 : {
							bitField0_ |= 0x00000008;
							appId_ = input.readBytes();
							break;
						}
						case 50 : {
							bitField0_ |= 0x00000010;
							sourceId_ = input.readBytes();
							break;
						}
						case 58 : {
							ensureDrainUrlsIsMutable();
							drainUrls_.add(input.readBytes());
							break;
						}
						case 66 : {
							bitField0_ |= 0x00000040;
							sourceName_ = input.readBytes();
							break;
						}
					}
				}
			}
",long method
104,"@APICommand(name = RevokeCertificateCmd.APINAME,
        description = ""Revokes certificate using configured CA plugin"",
        responseObject = SuccessResponse.class,
        requestHasSensitiveInfo = true,
        responseHasSensitiveInfo = false,
        since = ""4.11.0"",
        authorized = {RoleType.Admin})
public class RevokeCertificateCmd extends BaseAsyncCmd {

    public static final String APINAME = ""revokeCertificate"";

    @Inject
    private CAManager caManager;

    /////////////////////////////////////////////////////
    //////////////// API parameters /////////////////////
    /////////////////////////////////////////////////////

    @Parameter(name = ApiConstants.SERIAL, type = BaseCmd.CommandType.STRING, required = true, description = ""The certificate serial number, as a hex value"")
    private String serial;

    @Parameter(name = ApiConstants.CN, type = BaseCmd.CommandType.STRING, description = ""The certificate CN"")
    private String cn;

    @Parameter(name = ApiConstants.PROVIDER, type = BaseCmd.CommandType.STRING, description = ""Name of the CA service provider, otherwise the default configured provider plugin will be used"")
    private String provider;

    /////////////////////////////////////////////////////
    /////////////////// Accessors ///////////////////////
    /////////////////////////////////////////////////////

    public BigInteger getSerialBigInteger() {
        if (Strings.isNullOrEmpty(serial)) {
            throw new ServerApiException(ApiErrorCode.PARAM_ERROR, ""Certificate serial cannot be empty"");
        }
        return new BigInteger(serial, 16);
    }

    public String getCn() {
        return cn;
    }

    public String getProvider() {
        return provider;
    }

    /////////////////////////////////////////////////////
    /////////////// API Implementation///////////////////
    /////////////////////////////////////////////////////

    @Override
    public void execute() {
        boolean result = caManager.revokeCertificate(getSerialBigInteger(), getCn(), getProvider());
        SuccessResponse response = new SuccessResponse(getCommandName());
        response.setSuccess(result);
        setResponseObject(response);
    }

    @Override
    public String getCommandName() {
        return APINAME.toLowerCase() + BaseCmd.RESPONSE_SUFFIX;
    }

    @Override
    public long getEntityOwnerId() {
        return CallContext.current().getCallingAccount().getId();
    }

    @Override
    public String getEventType() {
        return EventTypes.EVENT_CA_CERTIFICATE_REVOKE;
    }

    @Override
    public String getEventDescription() {
        return ""revoking certificate with serial id="" + serial + "", cn="" + cn;
    }
}
",data class
811,"public class Ipam {
  private String driver;
  private List<IpamConfig> config;
  private Map<String, String> options;

  public String getDriver() {
    return driver;
  }

  public void setDriver(String driver) {
    this.driver = driver;
  }

  public Ipam withDriver(String driver) {
    this.driver = driver;
    return this;
  }

  public List<IpamConfig> getConfig() {
    return config;
  }

  public void setConfig(List<IpamConfig> config) {
    this.config = config;
  }

  public Ipam withConfig(List<IpamConfig> config) {
    this.config = config;
    return this;
  }

  public Map<String, String> getOptions() {
    return options;
  }

  public void setOptions(Map<String, String> options) {
    this.options = options;
  }

  public Ipam withOptions(Map<String, String> options) {
    this.options = options;
    return this;
  }

  @Override
  public boolean equals(Object obj) {
    if (this == obj) {
      return true;
    }
    if (!(obj instanceof Ipam)) {
      return false;
    }
    final Ipam that = (Ipam) obj;
    return Objects.equals(driver, that.driver)
        && getConfig().equals(that.getConfig())
        && getOptions().equals(that.getOptions());
  }

  @Override
  public int hashCode() {
    int hash = 7;
    hash = 31 * hash + Objects.hashCode(driver);
    hash = 31 * hash + getConfig().hashCode();
    hash = 31 * hash + getOptions().hashCode();
    return hash;
  }

  @Override
  public String toString() {
    return ""Ipam{""
        + ""driver='""
        + driver
        + '\''
        + "", config=""
        + config
        + "", options=""
        + options
        + '}';
  }
}
",data class
717,"@XmlAccessorType(XmlAccessType.FIELD)
@XmlType(name = ""faces-config-propertyType"", propOrder = {
    ""descriptions"",
    ""displayNames"",
    ""icon"",
    ""propertyName"",
    ""propertyClass"",
    ""defaultValue"",
    ""suggestedValue"",
    ""propertyExtension""
})
public class FacesProperty {

    @XmlTransient
    protected TextMap description = new TextMap();
    @XmlTransient
    protected TextMap displayName = new TextMap();
    @XmlElement(name = ""icon"", required = true)
    protected LocalCollection<Icon> icon = new LocalCollection<Icon>();
    @XmlElement(name = ""property-name"", required = true)
    protected java.lang.String propertyName;
    @XmlElement(name = ""property-class"", required = true)
    protected java.lang.String propertyClass;
    @XmlElement(name = ""default-value"")
    protected java.lang.String defaultValue;
    @XmlElement(name = ""suggested-value"")
    protected java.lang.String suggestedValue;
    @XmlElement(name = ""property-extension"")
    protected List<FacesPropertyExtension> propertyExtension;
    @XmlAttribute
    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)
    @XmlID
    @XmlSchemaType(name = ""ID"")
    protected java.lang.String id;

    @XmlElement(name = ""description"", required = true)
    public Text[] getDescriptions() {
        return description.toArray();
    }

    public void setDescriptions(Text[] text) {
        description.set(text);
    }

    public String getDescription() {
        return description.get();
    }

    @XmlElement(name = ""display-name"", required = true)
    public Text[] getDisplayNames() {
        return displayName.toArray();
    }

    public void setDisplayNames(Text[] text) {
        displayName.set(text);
    }

    public String getDisplayName() {
        return displayName.get();
    }

    public Collection<Icon> getIcons() {
        if (icon == null) {
            icon = new LocalCollection<Icon>();
        }
        return icon;
    }

    public Map<String,Icon> getIconMap() {
        if (icon == null) {
            icon = new LocalCollection<Icon>();
        }
        return icon.toMap();
    }

    public Icon getIcon() {
        return icon.getLocal();
    }

    /**
     * Gets the value of the propertyName property.
     * 
     * @return
     *     possible object is
     *     {@link java.lang.String }
     *     
     */
    public java.lang.String getPropertyName() {
        return propertyName;
    }

    /**
     * Sets the value of the propertyName property.
     * 
     * @param value
     *     allowed object is
     *     {@link java.lang.String }
     *     
     */
    public void setPropertyName(java.lang.String value) {
        this.propertyName = value;
    }

    /**
     * Gets the value of the propertyClass property.
     * 
     * @return
     *     possible object is
     *     {@link java.lang.String }
     *     
     */
    public java.lang.String getPropertyClass() {
        return propertyClass;
    }

    /**
     * Sets the value of the propertyClass property.
     * 
     * @param value
     *     allowed object is
     *     {@link java.lang.String }
     *     
     */
    public void setPropertyClass(java.lang.String value) {
        this.propertyClass = value;
    }

    /**
     * Gets the value of the defaultValue property.
     * 
     * @return
     *     possible object is
     *     {@link java.lang.String }
     *     
     */
    public java.lang.String getDefaultValue() {
        return defaultValue;
    }

    /**
     * Sets the value of the defaultValue property.
     * 
     * @param value
     *     allowed object is
     *     {@link java.lang.String }
     *     
     */
    public void setDefaultValue(java.lang.String value) {
        this.defaultValue = value;
    }

    /**
     * Gets the value of the suggestedValue property.
     * 
     * @return
     *     possible object is
     *     {@link java.lang.String }
     *     
     */
    public java.lang.String getSuggestedValue() {
        return suggestedValue;
    }

    /**
     * Sets the value of the suggestedValue property.
     * 
     * @param value
     *     allowed object is
     *     {@link java.lang.String }
     *     
     */
    public void setSuggestedValue(java.lang.String value) {
        this.suggestedValue = value;
    }

    /**
     * Gets the value of the propertyExtension property.
     * 
     * <p>
     * This accessor method returns a reference to the live list,
     * not a snapshot. Therefore any modification you make to the
     * returned list will be present inside the JAXB object.
     * This is why there is not a <CODE>set</CODE> method for the propertyExtension property.
     * 
     * <p>
     * For example, to add a new item, do as follows:
     * <pre>
     *    getPropertyExtension().add(newItem);
     * </pre>
     * 
     * 
     * <p>
     * Objects of the following type(s) are allowed in the list
     * {@link FacesPropertyExtension }
     * 
     * 
     */
    public List<FacesPropertyExtension> getPropertyExtension() {
        if (propertyExtension == null) {
            propertyExtension = new ArrayList<FacesPropertyExtension>();
        }
        return this.propertyExtension;
    }

    /**
     * Gets the value of the id property.
     * 
     * @return
     *     possible object is
     *     {@link java.lang.String }
     *     
     */
    public java.lang.String getId() {
        return id;
    }

    /**
     * Sets the value of the id property.
     * 
     * @param value
     *     allowed object is
     *     {@link java.lang.String }
     *     
     */
    public void setId(java.lang.String value) {
        this.id = value;
    }

}
",data class
329,"public class LiteralKey {

    private Object value;

    private String type;

    private String lang;

    public LiteralKey(Object value, String type, String lang) {
        this.value = value;
        this.type = type != null ? type.intern() : null;
        this.lang = lang != null ? lang.intern() : null;
    }

    public String getLang() {
        return lang;
    }

    public String getType() {
        return type;
    }

    public Object getValue() {
        return value;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        LiteralKey that = (LiteralKey) o;

        if (lang != null ? !lang.equals(that.lang) : that.lang != null) return false;
        if (type != null ? !type.equals(that.type) : that.type != null) return false;
        return value.equals(that.value);

    }

    @Override
    public int hashCode() {
        int result = value.hashCode();
        result = 31 * result + (type != null ? type.hashCode() : 0);
        result = 31 * result + (lang != null ? lang.hashCode() : 0);
        return result;
    }
}
",data class
649,"public interface MetricsIndexerSource extends BaseSource {
  // Metrics2 and JMX constants
  String METRICS_NAME = ""PhoenixIndexer"";
  String METRICS_CONTEXT = ""phoenix"";
  String METRICS_DESCRIPTION = ""Metrics about the Phoenix Indexer"";
  String METRICS_JMX_CONTEXT = ""RegionServer,sub="" + METRICS_NAME;

  String INDEX_PREPARE_TIME = ""indexPrepareTime"";
  String INDEX_PREPARE_TIME_DESC = ""Histogram for the time in milliseconds for preparing an index write"";
  String SLOW_INDEX_PREPARE = ""slowIndexPrepareCalls"";
  String SLOW_INDEX_PREPARE_DESC = ""The number of index preparations slower than the configured threshold"";

  String INDEX_WRITE_TIME = ""indexWriteTime"";
  String INDEX_WRITE_TIME_DESC = ""Histogram for the time in milliseconds for writing an index update"";
  String SLOW_INDEX_WRITE = ""slowIndexWriteCalls"";
  String SLOW_INDEX_WRITE_DESC = ""The number of index writes slower than the configured threshold"";

  String DUPLICATE_KEY_TIME = ""duplicateKeyCheckTime"";
  String DUPLICATE_KEY_TIME_DESC = ""Histogram for the time in milliseconds to handle ON DUPLICATE keywords"";
  String SLOW_DUPLICATE_KEY = ""slowDuplicateKeyCheckCalls"";
  String SLOW_DUPLICATE_KEY_DESC = ""The number of on duplicate key checks slower than the configured threshold"";

  String PRE_WAL_RESTORE_TIME = ""preWALRestoreTime"";
  String PRE_WAL_RESTORE_TIME_DESC = ""Histogram for the time in milliseconds for Indexer's preWALRestore"";
  String SLOW_PRE_WAL_RESTORE = ""slowPreWALRestoreCalls"";
  String SLOW_PRE_WAL_RESTORE_DESC = ""The number of preWALRestore calls slower than the configured threshold"";

  String POST_PUT_TIME = ""postPutTime"";
  String POST_PUT_TIME_DESC = ""Histogram for the time in milliseconds for Indexer's postPut"";
  String SLOW_POST_PUT = ""slowPostPutCalls"";
  String SLOW_POST_PUT_DESC = ""The number of postPut calls slower than the configured threshold"";

  String POST_DELETE_TIME = ""postDeleteTime"";
  String POST_DELETE_TIME_DESC = ""Histogram for the time in milliseconds for Indexer's postDelete"";
  String SLOW_POST_DELETE = ""slowPostDeleteCalls"";
  String SLOW_POST_DELETE_DESC = ""The number of postDelete calls slower than the configured threshold"";

  String POST_OPEN_TIME = ""postOpenTime"";
  String POST_OPEN_TIME_DESC = ""Histogram for the time in milliseconds for Indexer's postOpen"";
  String SLOW_POST_OPEN = ""slowPostOpenCalls"";
  String SLOW_POST_OPEN_DESC = ""The number of postOpen calls slower than the configured threshold"";

  /**
   * Updates the index preparation time histogram (preBatchMutate).
   *
   * @param t time taken in milliseconds
   */
  void updateIndexPrepareTime(long t);

  /**
   * Increments the number of slow calls prepare an index write.
   */
  void incrementNumSlowIndexPrepareCalls();

  /**
   * Updates the index write time histogram (postBatchMutate).
   *
   * @param t time taken in milliseconds
   */
  void updateIndexWriteTime(long t);

  /**
   * Increments the number of slow calls to write to the index.
   */
  void incrementNumSlowIndexWriteCalls();

  /**
   * Updates the preWALRestore time histogram.
   *
   * @param t time taken in milliseconds
   */
  void updatePreWALRestoreTime(long t);

  /**
   * Increments the number of slow preWALRestore calls.
   */
  void incrementNumSlowPreWALRestoreCalls();

  /**
   * Updates the postPut time histogram.
   *
   * @param t time taken in milliseconds
   */
  void updatePostPutTime(long t);

  /**
   * Increments the number of slow postPut calls.
   */
  void incrementNumSlowPostPutCalls();

  /**
   * Updates the postDelete time histogram.
   *
   * @param t time taken in milliseconds
   */
  void updatePostDeleteTime(long t);

  /**
   * Increments the number of slow postDelete calls.
   */
  void incrementNumSlowPostDeleteCalls();

  /**
   * Updates the postOpen time histogram.
   *
   * @param t time taken in milliseconds
   */
  void updatePostOpenTime(long t);

  /**
   * Increments the number of slow postOpen calls.
   */
  void incrementNumSlowPostOpenCalls();

  /**
   * Updates the preIncrementAfterRowLock time histogram.
   *
   * @param t time taken in milliseconds
   */
  void updateDuplicateKeyCheckTime(long t);

  /**
   * Increments the number of slow preIncrementAfteRowLock calls.
   */
  void incrementSlowDuplicateKeyCheckCalls();
}
",data class
1095,"    @Override
    public void main(List<JCCompilationUnit> trees) {
        // complete the javac AST with a completed ceylon model
        timer.startTask(""prepareForTypeChecking"");
        prepareForTypeChecking(trees);
        timer.endTask();
        List<JCCompilationUnit> javaTrees = List.nil();
        List<JCCompilationUnit> ceylonTrees = List.nil();
        // split them in two sets: java and ceylon
        for(JCCompilationUnit tree : trees){
            if(tree instanceof CeylonCompilationUnit)
                ceylonTrees = ceylonTrees.prepend(tree);
            else
                javaTrees = javaTrees.prepend(tree);
        }
        timer.startTask(""Enter on Java trees"");
        boolean needsModelReset = isBootstrap;
        // enter java trees first to set up their ClassSymbol objects for ceylon trees to use during type-checking
        if(!javaTrees.isEmpty()){
            setupImportedPackagesForJavaTrees(javaTrees);
            hasJavaAndCeylonSources = true;
            needsModelReset = true;
        }
        // this is false if we're in an APT round where we did not generate the trees
        if(!compiler.isAddModuleTrees()){
            setupImportedPackagesForJavaTrees(ceylonTrees);
        }
        if(isBootstrap || hasJavaAndCeylonSources){
            super.main(trees);
        }
        // now we can type-check the Ceylon code
        List<JCCompilationUnit> packageInfo = completeCeylonTrees(trees);
        trees = trees.prependList(packageInfo);
        ceylonTrees = ceylonTrees.prependList(packageInfo);
        
        if(compiler.isHadRunTwiceException()){
            needsModelReset = true;
        }
        if(needsModelReset){
            // bootstrapping the language module is a bit more complex
            resetAndRunEnterAgain(trees);
        }else{
            timer.startTask(""Enter on Ceylon trees"");
            // and complete their new trees
            try {
                sourceLanguage.push(Language.CEYLON);
                super.main(ceylonTrees);
            } finally {
                sourceLanguage.pop();
            }
            timer.endTask();
        }
    }
",long method
618,"    private JPEGImageMetadataFormat() {
        super(JPEG.nativeImageMetadataFormatName,
              CHILD_POLICY_ALL);

        addElement(""JPEGvariety"",
                   JPEG.nativeImageMetadataFormatName,
                   CHILD_POLICY_CHOICE);

        addElement(""markerSequence"",
                   JPEG.nativeImageMetadataFormatName,
                   CHILD_POLICY_SEQUENCE);

        addElement(""app0JFIF"", ""JPEGvariety"", CHILD_POLICY_SOME);

        addStreamElements(""markerSequence"");

        addElement(""app14Adobe"", ""markerSequence"", CHILD_POLICY_EMPTY);

        addElement(""sof"", ""markerSequence"", 1, 4);

        addElement(""sos"", ""markerSequence"", 1, 4);

        addElement(""JFXX"", ""app0JFIF"", 1, Integer.MAX_VALUE);

        addElement(""app0JFXX"", ""JFXX"", CHILD_POLICY_CHOICE);

        addElement(""app2ICC"", ""app0JFIF"", CHILD_POLICY_EMPTY);

        addAttribute(""app0JFIF"",
                     ""majorVersion"",
                     DATATYPE_INTEGER,
                     false,
                     ""1"",
                     ""0"", ""255"",
                     true, true);
        addAttribute(""app0JFIF"",
                     ""minorVersion"",
                     DATATYPE_INTEGER,
                     false,
                     ""2"",
                     ""0"", ""255"",
                     true, true);
        List<String> resUnits = new ArrayList<>();
        resUnits.add(""0"");
        resUnits.add(""1"");
        resUnits.add(""2"");
        addAttribute(""app0JFIF"",
                     ""resUnits"",
                     DATATYPE_INTEGER,
                     false,
                     ""0"",
                     resUnits);
        addAttribute(""app0JFIF"",
                     ""Xdensity"",
                     DATATYPE_INTEGER,
                     false,
                     ""1"",
                     ""1"", ""65535"",
                     true, true);
        addAttribute(""app0JFIF"",
                     ""Ydensity"",
                     DATATYPE_INTEGER,
                     false,
                     ""1"",
                     ""1"", ""65535"",
                     true, true);
        addAttribute(""app0JFIF"",
                     ""thumbWidth"",
                     DATATYPE_INTEGER,
                     false,
                     ""0"",
                     ""0"", ""255"",
                     true, true);
        addAttribute(""app0JFIF"",
                     ""thumbHeight"",
                     DATATYPE_INTEGER,
                     false,
                     ""0"",
                     ""0"", ""255"",
                     true, true);

        addElement(""JFIFthumbJPEG"", ""app0JFXX"", CHILD_POLICY_SOME);
        addElement(""JFIFthumbPalette"", ""app0JFXX"", CHILD_POLICY_EMPTY);
        addElement(""JFIFthumbRGB"", ""app0JFXX"", CHILD_POLICY_EMPTY);

        List<String> codes = new ArrayList<>();
        codes.add(""16""); // Hex 10
        codes.add(""17""); // Hex 11
        codes.add(""19""); // Hex 13
        addAttribute(""app0JFXX"",
                     ""extensionCode"",
                     DATATYPE_INTEGER,
                     false,
                     null,
                     codes);

        addChildElement(""markerSequence"", ""JFIFthumbJPEG"");

        addAttribute(""JFIFthumbPalette"",
                     ""thumbWidth"",
                     DATATYPE_INTEGER,
                     false,
                     null,
                     ""0"", ""255"",
                     true, true);
        addAttribute(""JFIFthumbPalette"",
                     ""thumbHeight"",
                     DATATYPE_INTEGER,
                     false,
                     null,
                     ""0"", ""255"",
                     true, true);

        addAttribute(""JFIFthumbRGB"",
                     ""thumbWidth"",
                     DATATYPE_INTEGER,
                     false,
                     null,
                     ""0"", ""255"",
                     true, true);
        addAttribute(""JFIFthumbRGB"",
                     ""thumbHeight"",
                     DATATYPE_INTEGER,
                     false,
                     null,
                     ""0"", ""255"",
                     true, true);

        addObjectValue(""app2ICC"", ICC_Profile.class, false, null);

        addAttribute(""app14Adobe"",
                     ""version"",
                     DATATYPE_INTEGER,
                     false,
                     ""100"",
                     ""100"", ""255"",
                     true, true);
        addAttribute(""app14Adobe"",
                     ""flags0"",
                     DATATYPE_INTEGER,
                     false,
                     ""0"",
                     ""0"", ""65535"",
                     true, true);
        addAttribute(""app14Adobe"",
                     ""flags1"",
                     DATATYPE_INTEGER,
                     false,
                     ""0"",
                     ""0"", ""65535"",
                     true, true);

        List<String> transforms = new ArrayList<>();
        transforms.add(""0"");
        transforms.add(""1"");
        transforms.add(""2"");
        addAttribute(""app14Adobe"",
                     ""transform"",
                     DATATYPE_INTEGER,
                     true,
                     null,
                     transforms);

        addElement(""componentSpec"", ""sof"", CHILD_POLICY_EMPTY);

        List<String> procs = new ArrayList<>();
        procs.add(""0"");
        procs.add(""1"");
        procs.add(""2"");
        addAttribute(""sof"",
                     ""process"",
                     DATATYPE_INTEGER,
                     false,
                     null,
                     procs);
        addAttribute(""sof"",
                     ""samplePrecision"",
                     DATATYPE_INTEGER,
                     false,
                     ""8"");
        addAttribute(""sof"",
                     ""numLines"",
                     DATATYPE_INTEGER,
                     false,
                     null,
                     ""0"", ""65535"",
                     true, true);
        addAttribute(""sof"",
                     ""samplesPerLine"",
                     DATATYPE_INTEGER,
                     false,
                     null,
                     ""0"", ""65535"",
                     true, true);
        List<String> comps = new ArrayList<>();
        comps.add(""1"");
        comps.add(""2"");
        comps.add(""3"");
        comps.add(""4"");
        addAttribute(""sof"",
                     ""numFrameComponents"",
                     DATATYPE_INTEGER,
                     false,
                     null,
                     comps);

        addAttribute(""componentSpec"",
                     ""componentId"",
                     DATATYPE_INTEGER,
                     true,
                     null,
                     ""0"", ""255"",
                     true, true);
        addAttribute(""componentSpec"",
                     ""HsamplingFactor"",
                     DATATYPE_INTEGER,
                     true,
                     null,
                     ""1"", ""255"",
                     true, true);
        addAttribute(""componentSpec"",
                     ""VsamplingFactor"",
                     DATATYPE_INTEGER,
                     true,
                     null,
                     ""1"", ""255"",
                     true, true);
        List<String> tabids = new ArrayList<>();
        tabids.add(""0"");
        tabids.add(""1"");
        tabids.add(""2"");
        tabids.add(""3"");
        addAttribute(""componentSpec"",
                     ""QtableSelector"",
                     DATATYPE_INTEGER,
                     true,
                     null,
                     tabids);

        addElement(""scanComponentSpec"", ""sos"", CHILD_POLICY_EMPTY);

        addAttribute(""sos"",
                     ""numScanComponents"",
                     DATATYPE_INTEGER,
                     true,
                     null,
                     comps);
        addAttribute(""sos"",
                     ""startSpectralSelection"",
                      DATATYPE_INTEGER,
                     false,
                     ""0"",
                     ""0"", ""63"",
                     true, true);
        addAttribute(""sos"",
                     ""endSpectralSelection"",
                      DATATYPE_INTEGER,
                     false,
                     ""63"",
                     ""0"", ""63"",
                     true, true);
        addAttribute(""sos"",
                     ""approxHigh"",
                      DATATYPE_INTEGER,
                     false,
                     ""0"",
                     ""0"", ""15"",
                     true, true);
        addAttribute(""sos"",
                     ""approxLow"",
                      DATATYPE_INTEGER,
                     false,
                     ""0"",
                     ""0"", ""15"",
                     true, true);

        addAttribute(""scanComponentSpec"",
                     ""componentSelector"",
                     DATATYPE_INTEGER,
                     true,
                     null,
                     ""0"", ""255"",
                     true, true);
        addAttribute(""scanComponentSpec"",
                     ""dcHuffTable"",
                     DATATYPE_INTEGER,
                     true,
                     null,
                     tabids);
        addAttribute(""scanComponentSpec"",
                     ""acHuffTable"",
                     DATATYPE_INTEGER,
                     true,
                     null,
                     tabids);
    }
",long method
482,"public final class TemplateConfiguration extends Configurable implements ParserConfiguration {

    private boolean parentConfigurationSet;
    private Integer tagSyntax;
    private Integer interpolationSyntax;
    private Integer namingConvention;
    private Boolean whitespaceStripping;
    private Boolean strictSyntaxMode;
    private Integer autoEscapingPolicy;
    private Boolean recognizeStandardFileExtensions;
    private OutputFormat outputFormat;
    private String encoding;
    private Integer tabSize;

    /**
     * Creates a new instance. The parent will be {@link Configuration#getDefaultConfiguration()} initially, but it will
     * be changed to the real parent {@link Configuration} when this object is added to the {@link Configuration}. (It's
     * not allowed to add the same instance to multiple {@link Configuration}-s).
     */
    public TemplateConfiguration() {
        super(Configuration.getDefaultConfiguration());
    }

    /**
     * Same as {@link #setParentConfiguration(Configuration)}.
     */
    @Override
    void setParent(Configurable cfg) {
        NullArgumentException.check(""cfg"", cfg);
        if (!(cfg instanceof Configuration)) {
            throw new IllegalArgumentException(""The parent of a TemplateConfiguration can only be a Configuration"");
        }
        
        if (parentConfigurationSet) {
            if (getParent() != cfg) {
                throw new IllegalStateException(
                        ""This TemplateConfiguration is already associated with a different Configuration instance."");
            }
            return;
        }
        
        if (((Configuration) cfg).getIncompatibleImprovements().intValue() < _TemplateAPI.VERSION_INT_2_3_22
                && hasAnyConfigurableSet()) {
            throw new IllegalStateException(
                    ""This TemplateConfiguration can't be associated to a Configuration that has ""
                    + ""incompatibleImprovements less than 2.3.22, because it changes non-parser settings."");
        }
        
        super.setParent(cfg);
        parentConfigurationSet = true;
    }

    /**
     * Associates this instance with a {@link Configuration}; usually you don't call this, as it's called internally
     * when this instance is added to a {@link Configuration}. This method can be called only once (except with the same
     * {@link Configuration} parameter again, as that changes nothing anyway).
     * 
     * @throws IllegalArgumentException
     *             if the argument is {@code null} or not a {@link Configuration}
     * @throws IllegalStateException
     *             if this object is already associated to a different {@link Configuration} object,
     *             or if the {@code Configuration} has {@code #getIncompatibleImprovements()} less than 2.3.22 and
     *             this object tries to change any non-parser settings  
     */
    public void setParentConfiguration(Configuration cfg) {
        setParent(cfg);
    }

    /**
     * Returns the parent {@link Configuration}, or {@code null} if none was associated yet.
     */
    public Configuration getParentConfiguration() {
        return parentConfigurationSet ? (Configuration) getParent() : null;
    }

    private Configuration getNonNullParentConfiguration() {
        checkParentConfigurationSet();
        return (Configuration) getParent();
    }
    
    /**
     * Set all settings in this {@link TemplateConfiguration} that were set in the parameter
     * {@link TemplateConfiguration}, possibly overwriting the earlier value in this object. (A setting is said to be
     * set in a {@link TemplateConfiguration} if it was explicitly set via a setter method, as opposed to be inherited.)
     */
    public void merge(TemplateConfiguration tc) {
        if (tc.isAPIBuiltinEnabledSet()) {
            setAPIBuiltinEnabled(tc.isAPIBuiltinEnabled());
        }
        if (tc.isArithmeticEngineSet()) {
            setArithmeticEngine(tc.getArithmeticEngine());
        }
        if (tc.isAutoEscapingPolicySet()) {
            setAutoEscapingPolicy(tc.getAutoEscapingPolicy());
        }
        if (tc.isAutoFlushSet()) {
            setAutoFlush(tc.getAutoFlush());
        }
        if (tc.isBooleanFormatSet()) {
            setBooleanFormat(tc.getBooleanFormat());
        }
        if (tc.isClassicCompatibleSet()) {
            setClassicCompatibleAsInt(tc.getClassicCompatibleAsInt());
        }
        if (tc.isCustomDateFormatsSet()) {
            setCustomDateFormats(mergeMaps(getCustomDateFormats(), tc.getCustomDateFormats(), false));
        }
        if (tc.isCustomNumberFormatsSet()) {
            setCustomNumberFormats(mergeMaps(getCustomNumberFormats(), tc.getCustomNumberFormats(), false));
        }
        if (tc.isDateFormatSet()) {
            setDateFormat(tc.getDateFormat());
        }
        if (tc.isDateTimeFormatSet()) {
            setDateTimeFormat(tc.getDateTimeFormat());
        }
        if (tc.isEncodingSet()) {
            setEncoding(tc.getEncoding());
        }
        if (tc.isLocaleSet()) {
            setLocale(tc.getLocale());
        }
        if (tc.isLogTemplateExceptionsSet()) {
            setLogTemplateExceptions(tc.getLogTemplateExceptions());
        }
        if (tc.isWrapUncheckedExceptionsSet()) {
            setWrapUncheckedExceptions(tc.getWrapUncheckedExceptions());
        }
        if (tc.isNamingConventionSet()) {
            setNamingConvention(tc.getNamingConvention());
        }
        if (tc.isNewBuiltinClassResolverSet()) {
            setNewBuiltinClassResolver(tc.getNewBuiltinClassResolver());
        }
        if (tc.isTruncateBuiltinAlgorithmSet()) {
            setTruncateBuiltinAlgorithm(tc.getTruncateBuiltinAlgorithm());
        }
        if (tc.isNumberFormatSet()) {
            setNumberFormat(tc.getNumberFormat());
        }
        if (tc.isObjectWrapperSet()) {
            setObjectWrapper(tc.getObjectWrapper());
        }
        if (tc.isOutputEncodingSet()) {
            setOutputEncoding(tc.getOutputEncoding());
        }
        if (tc.isOutputFormatSet()) {
            setOutputFormat(tc.getOutputFormat());
        }
        if (tc.isRecognizeStandardFileExtensionsSet()) {
            setRecognizeStandardFileExtensions(tc.getRecognizeStandardFileExtensions());
        }
        if (tc.isShowErrorTipsSet()) {
            setShowErrorTips(tc.getShowErrorTips());
        }
        if (tc.isSQLDateAndTimeTimeZoneSet()) {
            setSQLDateAndTimeTimeZone(tc.getSQLDateAndTimeTimeZone());
        }
        if (tc.isStrictSyntaxModeSet()) {
            setStrictSyntaxMode(tc.getStrictSyntaxMode());
        }
        if (tc.isTagSyntaxSet()) {
            setTagSyntax(tc.getTagSyntax());
        }
        if (tc.isInterpolationSyntaxSet()) {
            setInterpolationSyntax(tc.getInterpolationSyntax());
        }
        if (tc.isTemplateExceptionHandlerSet()) {
            setTemplateExceptionHandler(tc.getTemplateExceptionHandler());
        }
        if (tc.isAttemptExceptionReporterSet()) {
            setAttemptExceptionReporter(tc.getAttemptExceptionReporter());
        }
        if (tc.isTimeFormatSet()) {
            setTimeFormat(tc.getTimeFormat());
        }
        if (tc.isTimeZoneSet()) {
            setTimeZone(tc.getTimeZone());
        }
        if (tc.isURLEscapingCharsetSet()) {
            setURLEscapingCharset(tc.getURLEscapingCharset());
        }
        if (tc.isWhitespaceStrippingSet()) {
            setWhitespaceStripping(tc.getWhitespaceStripping());
        }
        if (tc.isTabSizeSet()) {
            setTabSize(tc.getTabSize());
        }
        if (tc.isLazyImportsSet()) {
            setLazyImports(tc.getLazyImports());
        }
        if (tc.isLazyAutoImportsSet()) {
            setLazyAutoImports(tc.getLazyAutoImports());
        }
        if (tc.isAutoImportsSet()) {
            setAutoImports(mergeMaps(getAutoImportsWithoutFallback(), tc.getAutoImportsWithoutFallback(), true));
        }
        if (tc.isAutoIncludesSet()) {
            setAutoIncludes(mergeLists(getAutoIncludesWithoutFallback(), tc.getAutoIncludesWithoutFallback()));
        }
        
        tc.copyDirectCustomAttributes(this, true);
    }

    /**
     * Sets those settings of the {@link Template} which aren't yet set in the {@link Template} and are set in this
     * {@link TemplateConfiguration}, leaves the other settings as is. A setting is said to be set in a
     * {@link TemplateConfiguration} or {@link Template} if it was explicitly set via a setter method on that object, as
     * opposed to be inherited from the {@link Configuration}.
     * 
     * <p>
     * Note that this method doesn't deal with settings that influence the parser, as those are already baked in at this
     * point via the {@link ParserConfiguration}. 
     * 
     * <p>
     * Note that the {@code encoding} setting of the {@link Template} counts as unset if it's {@code null},
     * even if {@code null} was set via {@link Template#setEncoding(String)}.
     *
     * @throws IllegalStateException
     *             If the parent configuration wasn't yet set.
     */
    public void apply(Template template) {
        Configuration cfg = getNonNullParentConfiguration();
        if (template.getConfiguration() != cfg) {
            // This is actually not a problem right now, but for future BC we enforce this.
            throw new IllegalArgumentException(
                    ""The argument Template doesn't belong to the same Configuration as the TemplateConfiguration"");
        }

        if (isAPIBuiltinEnabledSet() && !template.isAPIBuiltinEnabledSet()) {
            template.setAPIBuiltinEnabled(isAPIBuiltinEnabled());
        }
        if (isArithmeticEngineSet() && !template.isArithmeticEngineSet()) {
            template.setArithmeticEngine(getArithmeticEngine());
        }
        if (isAutoFlushSet() && !template.isAutoFlushSet()) {
            template.setAutoFlush(getAutoFlush());
        }
        if (isBooleanFormatSet() && !template.isBooleanFormatSet()) {
            template.setBooleanFormat(getBooleanFormat());
        }
        if (isClassicCompatibleSet() && !template.isClassicCompatibleSet()) {
            template.setClassicCompatibleAsInt(getClassicCompatibleAsInt());
        }
        if (isCustomDateFormatsSet()) {
            template.setCustomDateFormats(
                    mergeMaps(getCustomDateFormats(), template.getCustomDateFormatsWithoutFallback(), false));
        }
        if (isCustomNumberFormatsSet()) {
            template.setCustomNumberFormats(
                    mergeMaps(getCustomNumberFormats(), template.getCustomNumberFormatsWithoutFallback(), false));
        }
        if (isDateFormatSet() && !template.isDateFormatSet()) {
            template.setDateFormat(getDateFormat());
        }
        if (isDateTimeFormatSet() && !template.isDateTimeFormatSet()) {
            template.setDateTimeFormat(getDateTimeFormat());
        }
        if (isEncodingSet() && template.getEncoding() == null) {
            template.setEncoding(getEncoding());
        }
        if (isLocaleSet() && !template.isLocaleSet()) {
            template.setLocale(getLocale());
        }
        if (isLogTemplateExceptionsSet() && !template.isLogTemplateExceptionsSet()) {
            template.setLogTemplateExceptions(getLogTemplateExceptions());
        }
        if (isWrapUncheckedExceptionsSet() && !template.isWrapUncheckedExceptionsSet()) {
            template.setWrapUncheckedExceptions(getWrapUncheckedExceptions());
        }
        if (isNewBuiltinClassResolverSet() && !template.isNewBuiltinClassResolverSet()) {
            template.setNewBuiltinClassResolver(getNewBuiltinClassResolver());
        }
        if (isTruncateBuiltinAlgorithmSet() && !template.isTruncateBuiltinAlgorithmSet()) {
            template.setTruncateBuiltinAlgorithm(getTruncateBuiltinAlgorithm());
        }
        if (isNumberFormatSet() && !template.isNumberFormatSet()) {
            template.setNumberFormat(getNumberFormat());
        }
        if (isObjectWrapperSet() && !template.isObjectWrapperSet()) {
            template.setObjectWrapper(getObjectWrapper());
        }
        if (isOutputEncodingSet() && !template.isOutputEncodingSet()) {
            template.setOutputEncoding(getOutputEncoding());
        }
        if (isShowErrorTipsSet() && !template.isShowErrorTipsSet()) {
            template.setShowErrorTips(getShowErrorTips());
        }
        if (isSQLDateAndTimeTimeZoneSet() && !template.isSQLDateAndTimeTimeZoneSet()) {
            template.setSQLDateAndTimeTimeZone(getSQLDateAndTimeTimeZone());
        }
        if (isTemplateExceptionHandlerSet() && !template.isTemplateExceptionHandlerSet()) {
            template.setTemplateExceptionHandler(getTemplateExceptionHandler());
        }
        if (isAttemptExceptionReporterSet() && !template.isAttemptExceptionReporterSet()) {
            template.setAttemptExceptionReporter(getAttemptExceptionReporter());
        }
        if (isTimeFormatSet() && !template.isTimeFormatSet()) {
            template.setTimeFormat(getTimeFormat());
        }
        if (isTimeZoneSet() && !template.isTimeZoneSet()) {
            template.setTimeZone(getTimeZone());
        }
        if (isURLEscapingCharsetSet() && !template.isURLEscapingCharsetSet()) {
            template.setURLEscapingCharset(getURLEscapingCharset());
        }
        if (isLazyImportsSet() && !template.isLazyImportsSet()) {
            template.setLazyImports(getLazyImports());
        }
        if (isLazyAutoImportsSet() && !template.isLazyAutoImportsSet()) {
            template.setLazyAutoImports(getLazyAutoImports());
        }
        if (isAutoImportsSet()) {
            // Regarding the order of the maps in the merge:
            // - Existing template-level imports have precedence over those coming from the TC (just as with the others
            //   apply()-ed settings), thus for clashing import prefixes they must win.
            // - Template-level imports count as more specific, and so come after the more generic ones from TC.
            template.setAutoImports(mergeMaps(getAutoImports(), template.getAutoImportsWithoutFallback(), true));
        }
        if (isAutoIncludesSet()) {
            template.setAutoIncludes(mergeLists(getAutoIncludes(), template.getAutoIncludesWithoutFallback()));
        }
        
        copyDirectCustomAttributes(template, false);
    }

    /**
     * See {@link Configuration#setTagSyntax(int)}.
     */
    public void setTagSyntax(int tagSyntax) {
        _TemplateAPI.valideTagSyntaxValue(tagSyntax);
        this.tagSyntax = Integer.valueOf(tagSyntax);
    }

    /**
     * The getter pair of {@link #setTagSyntax(int)}.
     */
    public int getTagSyntax() {
        return tagSyntax != null ? tagSyntax.intValue() : getNonNullParentConfiguration().getTagSyntax();
    }

    /**
     * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.
     */
    public boolean isTagSyntaxSet() {
        return tagSyntax != null;
    }

    /**
     * See {@link Configuration#setInterpolationSyntax(int)}.
     */
    public void setInterpolationSyntax(int interpolationSyntax) {
        _TemplateAPI.valideInterpolationSyntaxValue(interpolationSyntax);
        this.interpolationSyntax = Integer.valueOf(interpolationSyntax);
    }
    
    /**
     * The getter pair of {@link #setInterpolationSyntax(int)}.
     */
    public int getInterpolationSyntax() {
        return interpolationSyntax != null ? interpolationSyntax.intValue()
                : getNonNullParentConfiguration().getInterpolationSyntax();
    }

    /**
     * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.
     */
    public boolean isInterpolationSyntaxSet() {
        return interpolationSyntax != null;
    }
    
    /**
     * See {@link Configuration#setNamingConvention(int)}.
     */
    public void setNamingConvention(int namingConvention) {
        _TemplateAPI.validateNamingConventionValue(namingConvention);
        this.namingConvention = Integer.valueOf(namingConvention);
    }

    /**
     * The getter pair of {@link #setNamingConvention(int)}.
     */
    public int getNamingConvention() {
        return namingConvention != null ? namingConvention.intValue()
                : getNonNullParentConfiguration().getNamingConvention();
    }

    /**
     * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.
     */
    public boolean isNamingConventionSet() {
        return namingConvention != null;
    }

    /**
     * See {@link Configuration#setWhitespaceStripping(boolean)}.
     */
    public void setWhitespaceStripping(boolean whitespaceStripping) {
        this.whitespaceStripping = Boolean.valueOf(whitespaceStripping);
    }

    /**
     * The getter pair of {@link #getWhitespaceStripping()}.
     */
    public boolean getWhitespaceStripping() {
        return whitespaceStripping != null ? whitespaceStripping.booleanValue()
                : getNonNullParentConfiguration().getWhitespaceStripping();
    }

    /**
     * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.
     */
    public boolean isWhitespaceStrippingSet() {
        return whitespaceStripping != null;
    }

    /**
     * Sets the output format of the template; see {@link Configuration#setAutoEscapingPolicy(int)} for more.
     */
    public void setAutoEscapingPolicy(int autoEscapingPolicy) {
        _TemplateAPI.validateAutoEscapingPolicyValue(autoEscapingPolicy);
        this.autoEscapingPolicy = Integer.valueOf(autoEscapingPolicy);
    }

    /**
     * The getter pair of {@link #setAutoEscapingPolicy(int)}.
     */
    public int getAutoEscapingPolicy() {
        return autoEscapingPolicy != null ? autoEscapingPolicy.intValue()
                : getNonNullParentConfiguration().getAutoEscapingPolicy();
    }

    /**
     * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.
     */
    public boolean isAutoEscapingPolicySet() {
        return autoEscapingPolicy != null;
    }

    /**
     * Sets the output format of the template; see {@link Configuration#setOutputFormat(OutputFormat)} for more.
     */
    public void setOutputFormat(OutputFormat outputFormat) {
        NullArgumentException.check(""outputFormat"", outputFormat);
        this.outputFormat = outputFormat;
    }

    /**
     * The getter pair of {@link #setOutputFormat(OutputFormat)}.
     */
    public OutputFormat getOutputFormat() {
        return outputFormat != null ? outputFormat : getNonNullParentConfiguration().getOutputFormat();
    }

    /**
     * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.
     */
    public boolean isOutputFormatSet() {
        return outputFormat != null;
    }
    
    /**
     * See {@link Configuration#setRecognizeStandardFileExtensions(boolean)}. 
     */
    public void setRecognizeStandardFileExtensions(boolean recognizeStandardFileExtensions) {
        this.recognizeStandardFileExtensions = Boolean.valueOf(recognizeStandardFileExtensions);
    }

    /**
     * Getter pair of {@link #setRecognizeStandardFileExtensions(boolean)}.
     */
    public boolean getRecognizeStandardFileExtensions() {
        return recognizeStandardFileExtensions != null ? recognizeStandardFileExtensions.booleanValue()
                : getNonNullParentConfiguration().getRecognizeStandardFileExtensions();
    }
    
    /**
     * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.
     */
    public boolean isRecognizeStandardFileExtensionsSet() {
        return recognizeStandardFileExtensions != null;
    }
    
    /**
     * See {@link Configuration#setStrictSyntaxMode(boolean)}.
     */
    public void setStrictSyntaxMode(boolean strictSyntaxMode) {
        this.strictSyntaxMode = Boolean.valueOf(strictSyntaxMode);
    }

    /**
     * The getter pair of {@link #setStrictSyntaxMode(boolean)}.
     */
    public boolean getStrictSyntaxMode() {
        return strictSyntaxMode != null ? strictSyntaxMode.booleanValue()
                : getNonNullParentConfiguration().getStrictSyntaxMode();
    }
    
    /**
     * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.
     */
    public boolean isStrictSyntaxModeSet() {
        return strictSyntaxMode != null;
    }

    @Override
    public void setStrictBeanModels(boolean strict) {
        throw new UnsupportedOperationException(
                ""Setting strictBeanModels on "" + TemplateConfiguration.class.getSimpleName() + "" level isn't supported."");
    }

    public String getEncoding() {
        return encoding != null ? encoding : getNonNullParentConfiguration().getDefaultEncoding();
    }

    /**
     * When the standard template loading/caching mechanism is used, this forces the charset used for reading the
     * template ""file"", overriding everything but the encoding coming from the {@code #ftl} header. This setting
     * overrides the locale-specific encodings set via {@link Configuration#setEncoding(java.util.Locale, String)}. It
     * also overrides the {@code encoding} parameter of {@link Configuration#getTemplate(String, String)} (and of its
     * overloads) and the {@code encoding} parameter of the {@code #include} directive. This works like that because
     * specifying the encoding where you are requesting the template is error prone and deprecated.
     * 
     * <p>
     * If you are developing your own template loading/caching mechanism instead of the standard one, note that the
     * above behavior is not guaranteed by this class alone; you have to ensure it. Also, read the note on
     * {@code encoding} in the documentation of {@link #apply(Template)}.
     */
    public void setEncoding(String encoding) {
        NullArgumentException.check(""encoding"", encoding);
        this.encoding = encoding;
    }

    public boolean isEncodingSet() {
        return encoding != null;
    }
    
    /**
     * See {@link Configuration#setTabSize(int)}. 
     * 
     * @since 2.3.25
     */
    public void setTabSize(int tabSize) {
        this.tabSize = Integer.valueOf(tabSize);
    }

    /**
     * Getter pair of {@link #setTabSize(int)}.
     * 
     * @since 2.3.25
     */
    public int getTabSize() {
        return tabSize != null ? tabSize.intValue()
                : getNonNullParentConfiguration().getTabSize();
    }
    
    /**
     * Tells if this setting is set directly in this object or its value is coming from the {@link #getParent() parent}.
     * 
     * @since 2.3.25
     */
    public boolean isTabSizeSet() {
        return tabSize != null;
    }
    
    /**
     * Returns {@link Configuration#getIncompatibleImprovements()} from the parent {@link Configuration}. This mostly
     * just exist to satisfy the {@link ParserConfiguration} interface.
     * 
     * @throws IllegalStateException
     *             If the parent configuration wasn't yet set.
     */
    public Version getIncompatibleImprovements() {
        return getNonNullParentConfiguration().getIncompatibleImprovements();
    }

    private void checkParentConfigurationSet() {
        if (!parentConfigurationSet) {
            throw new IllegalStateException(""The TemplateConfiguration wasn't associated with a Configuration yet."");
        }
    }

    private boolean hasAnyConfigurableSet() {
        return
                isAPIBuiltinEnabledSet()
                || isArithmeticEngineSet()
                || isAutoFlushSet()
                || isAutoImportsSet()
                || isAutoIncludesSet()
                || isBooleanFormatSet()
                || isClassicCompatibleSet()
                || isCustomDateFormatsSet()
                || isCustomNumberFormatsSet()
                || isDateFormatSet()
                || isDateTimeFormatSet()
                || isLazyImportsSet()
                || isLazyAutoImportsSet()
                || isLocaleSet()
                || isLogTemplateExceptionsSet()
                || isWrapUncheckedExceptionsSet()
                || isNewBuiltinClassResolverSet()
                || isTruncateBuiltinAlgorithmSet()
                || isNumberFormatSet()
                || isObjectWrapperSet()
                || isOutputEncodingSet()
                || isShowErrorTipsSet()
                || isSQLDateAndTimeTimeZoneSet()
                || isTemplateExceptionHandlerSet()
                || isAttemptExceptionReporterSet()
                || isTimeFormatSet()
                || isTimeZoneSet()
                || isURLEscapingCharsetSet();
    }
    
    private Map mergeMaps(Map m1, Map m2, boolean overwriteUpdatesOrder) {
        if (m1 == null) return m2;
        if (m2 == null) return m1;
        if (m1.isEmpty()) return m2;
        if (m2.isEmpty()) return m1;
        
        LinkedHashMap mergedM = new LinkedHashMap((m1.size() + m2.size()) * 4 / 3 + 1, 0.75f);
        mergedM.putAll(m1);
        for (Object m2Key : m2.keySet()) {
            mergedM.remove(m2Key); // So that duplicate keys are moved after m1 keys
        }
        mergedM.putAll(m2);
        return mergedM;
    }

    private List<String> mergeLists(List<String> list1, List<String> list2) {
        if (list1 == null) return list2;
        if (list2 == null) return list1;
        if (list1.isEmpty()) return list2;
        if (list2.isEmpty()) return list1;
        
        ArrayList<String> mergedList = new ArrayList<String>(list1.size() + list2.size());
        mergedList.addAll(list1);
        mergedList.addAll(list2);
        return mergedList;
    }
    
}
",data class
752,"    @Override
    public void endAccess() {
        super.endAccess() ;
        if(manager instanceof ClusterManagerBase) {
            ((ClusterManagerBase)manager).registerSessionAtReplicationValve(this);
        }
    }
",feature envy
881,"    public static final class SecretKeyEntry implements Entry {

        private final SecretKey sKey;

        /**
         * Constructs a <code>SecretKeyEntry</code> with a
         * <code>SecretKey</code>.
         *
         * @param secretKey the <code>SecretKey</code>
         *
         * @exception NullPointerException if <code>secretKey</code>
         *      is <code>null</code>
         */
        public SecretKeyEntry(SecretKey secretKey) {
            if (secretKey == null) {
                throw new NullPointerException(""invalid null input"");
            }
            this.sKey = secretKey;
        }

        /**
         * Gets the <code>SecretKey</code> from this entry.
         *
         * @return the <code>SecretKey</code> from this entry
         */
        public SecretKey getSecretKey() {
            return sKey;
        }

        /**
         * Returns a string representation of this SecretKeyEntry.
         * @return a string representation of this SecretKeyEntry.
         */
        public String toString() {
            return ""Secret key entry with algorithm "" + sKey.getAlgorithm();
        }
    }
",data class
1247,"  @Override
  public boolean incrementToken() throws IOException {
    for(;;) {

      if (!remainingTokens.isEmpty()) {
        // clearAttributes();  // not currently necessary
        restoreState(remainingTokens.removeFirst());
        return true;
      }

      if (!input.incrementToken()) return false;

      int len = termAtt.length();
      if (len==0) return true; // pass through zero length terms
      
      int firstAlternativeIncrement = inject ? 0 : posAtt.getPositionIncrement();

      String v = termAtt.toString();
      String primaryPhoneticValue = encoder.doubleMetaphone(v);
      String alternatePhoneticValue = encoder.doubleMetaphone(v, true);

      // a flag to lazily save state if needed... this avoids a save/restore when only
      // one token will be generated.
      boolean saveState=inject;

      if (primaryPhoneticValue!=null && primaryPhoneticValue.length() > 0 && !primaryPhoneticValue.equals(v)) {
        if (saveState) {
          remainingTokens.addLast(captureState());
        }
        posAtt.setPositionIncrement( firstAlternativeIncrement );
        firstAlternativeIncrement = 0;
        termAtt.setEmpty().append(primaryPhoneticValue);
        saveState = true;
      }

      if (alternatePhoneticValue!=null && alternatePhoneticValue.length() > 0
              && !alternatePhoneticValue.equals(primaryPhoneticValue)
              && !primaryPhoneticValue.equals(v)) {
        if (saveState) {
          remainingTokens.addLast(captureState());
          saveState = false;
        }
        posAtt.setPositionIncrement( firstAlternativeIncrement );
        termAtt.setEmpty().append(alternatePhoneticValue);
        saveState = true;
      }

      // Just one token to return, so no need to capture/restore
      // any state, simply return it.
      if (remainingTokens.isEmpty()) {
        return true;
      }

      if (saveState) {
        remainingTokens.addLast(captureState());
      }
    }
  }
",long method
73,"	public BindStatus(RequestContext requestContext, String path, boolean htmlEscape) throws IllegalStateException {
		this.requestContext = requestContext;
		this.path = path;
		this.htmlEscape = htmlEscape;

		// determine name of the object and property
		String beanName;
		int dotPos = path.indexOf('.');
		if (dotPos == -1) {
			// property not set, only the object itself
			beanName = path;
			this.expression = null;
		}
		else {
			beanName = path.substring(0, dotPos);
			this.expression = path.substring(dotPos + 1);
		}

		this.errors = requestContext.getErrors(beanName, false);

		if (this.errors != null) {
			// Usual case: A BindingResult is available as request attribute.
			// Can determine error codes and messages for the given expression.
			// Can use a custom PropertyEditor, as registered by a form controller.
			if (this.expression != null) {
				if (""*"".equals(this.expression)) {
					this.objectErrors = this.errors.getAllErrors();
				}
				else if (this.expression.endsWith(""*"")) {
					this.objectErrors = this.errors.getFieldErrors(this.expression);
				}
				else {
					this.objectErrors = this.errors.getFieldErrors(this.expression);
					this.value = this.errors.getFieldValue(this.expression);
					this.valueType = this.errors.getFieldType(this.expression);
					if (this.errors instanceof BindingResult) {
						this.bindingResult = (BindingResult) this.errors;
						this.actualValue = this.bindingResult.getRawFieldValue(this.expression);
						this.editor = this.bindingResult.findEditor(this.expression, null);
					}
					else {
						this.actualValue = this.value;
					}
				}
			}
			else {
				this.objectErrors = this.errors.getGlobalErrors();
			}
			this.errorCodes = initErrorCodes(this.objectErrors);
		}

		else {
			// No BindingResult available as request attribute:
			// Probably forwarded directly to a form view.
			// Let's do the best we can: extract a plain target if appropriate.
			Object target = requestContext.getModelObject(beanName);
			if (target == null) {
				throw new IllegalStateException(""Neither BindingResult nor plain target object for bean name '"" +
						beanName + ""' available as request attribute"");
			}
			if (this.expression != null && !""*"".equals(this.expression) && !this.expression.endsWith(""*"")) {
				BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(target);
				this.value = bw.getPropertyValue(this.expression);
				this.valueType = bw.getPropertyType(this.expression);
				this.actualValue = this.value;
			}
			this.errorCodes = new String[0];
			this.errorMessages = new String[0];
		}

		if (htmlEscape && this.value instanceof String) {
			this.value = HtmlUtils.htmlEscape((String) this.value);
		}
	}
",long method
277,"public class ExprList implements Iterable<Expr>
{
    private final List<Expr> expressions ;
    /** Create a copy which does not share the list of expressions with the original */ 
    public static ExprList copy(ExprList other) { return new ExprList(other) ; }
    
    /** Create an ExprList that contains the expressions */
    public static ExprList create(Collection<Expr> exprs) {
        ExprList exprList = new ExprList() ;
        exprs.forEach(exprList::add) ;
        return exprList ; 
    } 
    
    /** Empty, immutable ExprList */
    public static final ExprList emptyList = new ExprList(Collections.emptyList()) ;
    
    public ExprList() { expressions = new ArrayList<>() ; }
    
    private ExprList(ExprList other) {
        this() ;
        expressions.addAll(other.expressions) ;
    }

    public ExprList(Expr expr) {
        this() ;
        expressions.add(expr) ;
    }

    public ExprList(List<Expr> x)   { expressions = x ; }

    public boolean isSatisfied(Binding binding, ExecutionContext execCxt) {
        for (Expr expr : expressions) {
            if ( !expr.isSatisfied(binding, execCxt) )
                return false ;
        }
        return true ;
    }
    
    public Expr get(int idx)                            { return expressions.get(idx) ; }
    public int size()                                   { return expressions.size() ; }
    public boolean isEmpty()                            { return expressions.isEmpty() ; }
    public ExprList subList(int fromIdx, int toIdx)     { return new ExprList(expressions.subList(fromIdx, toIdx)) ; }
    public ExprList tail(int fromIdx)                   { return subList(fromIdx, expressions.size()) ; }
    
    public Set<Var> getVarsMentioned() {
        Set<Var> x = new HashSet<>() ;
        varsMentioned(x) ;
        return x ;
    }

    /** @deprecated Use {@link ExprVars#varsMentioned(Collection, ExprList)} */
    @Deprecated
    public void varsMentioned(Collection<Var> acc) {
        for (Expr expr : expressions)
            ExprVars.varsMentioned(acc, expr);
    }
    
    /**
     * Rewrite, applying a node{@literal ->}node transformation
     */
    public ExprList applyNodeTransform(NodeTransform transform) {
        ExprList x = new ExprList() ;
        for ( Expr e : expressions)
            x.add(e.applyNodeTransform(transform));
        return x ; 
    }

    public ExprList copySubstitute(Binding binding) {
        ExprList x = new ExprList() ;
        for (Expr expr : expressions ) {
            expr = expr.copySubstitute(binding) ;
            x.add(expr) ;
        }
        return x ;
    }

    public void addAll(ExprList exprs)      { expressions.addAll(exprs.getList()) ; }
    public void add(Expr expr)              { expressions.add(expr) ; }
    public List<Expr> getList()             { return Collections.unmodifiableList(expressions) ; }
    /** Use only while building ExprList */
    public List<Expr> getListRaw()          { return expressions ; }
    @Override
    public Iterator<Expr> iterator()        { return expressions.iterator() ; }
    
    public void prepareExprs(Context context) {
        ExprBuild build = new ExprBuild(context) ;
        // Give each expression the chance to set up (bind functions)
        for (Expr expr : expressions)
            Walker.walk(expr, build) ;
    }
    
    @Override
    public String toString()
    { return expressions.toString() ; }
    
    @Override
    public int hashCode() { return expressions.hashCode() ; }

    public boolean equals(ExprList other, boolean bySyntax) {
        if ( this == other ) return true ;
        if (expressions.size() != other.expressions.size()) return false;
        
        for ( int i = 0 ; i < expressions.size() ; i++ ) {
            Expr e1 = expressions.get(i) ;
            Expr e2 = other.expressions.get(i) ;
            if ( ! e1.equals(e2, bySyntax) ) 
                return false ;
        }
        return true ;
    }
    
    @Override
    public boolean equals(Object other) {
        if ( this == other ) return true ;
        if ( ! ( other instanceof ExprList ) ) return false ;
        ExprList exprs = (ExprList)other ;
        //return expressions.equals(exprs.expressions) ;
        return equals((ExprList)other, false) ;
    }

    public static ExprList splitConjunction(ExprList exprList1) {
        ExprList exprList2 = new ExprList() ;
        for (Expr expr : exprList1)
            split(exprList2, expr) ;
        return exprList2 ;
    }

    private static ExprList splitConjunction(Expr expr) {
        ExprList exprList = new ExprList() ;
        split(exprList, expr) ;
        return exprList ;
    }

    private static void split(ExprList exprList, Expr expr) {
        // Explode &&-chain to exprlist.
        while (expr instanceof E_LogicalAnd) {
            E_LogicalAnd x = (E_LogicalAnd)expr ;
            Expr left = x.getArg1() ;
            Expr right = x.getArg2() ;
            split(exprList, left) ;
            expr = right ;
        }
        // Drop through and add remaining
        exprList.add(expr) ;
    }
}
",blob
458,"	private static void countCompiledInstructions(ProgramBlock pb, ExplainCounts counts, boolean MR, boolean CP, boolean SP) 
	{
		if (pb instanceof WhileProgramBlock)
		{
			WhileProgramBlock tmp = (WhileProgramBlock)pb;
			countCompiledInstructions(tmp.getPredicate(), counts, MR, CP, SP);
			for (ProgramBlock pb2 : tmp.getChildBlocks())
				countCompiledInstructions(pb2, counts, MR, CP, SP);
		}
		else if (pb instanceof IfProgramBlock)
		{
			IfProgramBlock tmp = (IfProgramBlock)pb;	
			countCompiledInstructions(tmp.getPredicate(), counts, MR, CP, SP);
			for( ProgramBlock pb2 : tmp.getChildBlocksIfBody() )
				countCompiledInstructions(pb2, counts, MR, CP, SP);
			for( ProgramBlock pb2 : tmp.getChildBlocksElseBody() )
				countCompiledInstructions(pb2, counts, MR, CP, SP);
		}
		else if (pb instanceof ForProgramBlock) //includes ParFORProgramBlock
		{ 
			ForProgramBlock tmp = (ForProgramBlock)pb;	
			countCompiledInstructions(tmp.getFromInstructions(), counts, MR, CP, SP);
			countCompiledInstructions(tmp.getToInstructions(), counts, MR, CP, SP);
			countCompiledInstructions(tmp.getIncrementInstructions(), counts, MR, CP, SP);
			for( ProgramBlock pb2 : tmp.getChildBlocks() )
				countCompiledInstructions(pb2, counts, MR, CP, SP);
			//additional parfor jobs counted during runtime
		}		
		else if (  pb instanceof FunctionProgramBlock ) //includes ExternalFunctionProgramBlock and ExternalFunctionProgramBlockCP
		{
			FunctionProgramBlock fpb = (FunctionProgramBlock)pb;
			for( ProgramBlock pb2 : fpb.getChildBlocks() )
				countCompiledInstructions(pb2, counts, MR, CP, SP);
		}
		else 
		{
			countCompiledInstructions(pb.getInstructions(), counts, MR, CP, SP);
		}
	}
",long method
769,"  @Override
  public ExitCode runWithoutHelp(CommandRunnerParams params) throws Exception {
    ProjectFilesystem projectFilesystem = params.getCell().getFilesystem();
    try (ProjectBuildFileParser parser =
        new DefaultProjectBuildFileParserFactory(
                new DefaultTypeCoercerFactory(),
                params.getConsole(),
                new ParserPythonInterpreterProvider(
                    params.getCell().getBuckConfig(), params.getExecutableFinder()),
                params.getKnownRuleTypesProvider(),
                params.getManifestServiceSupplier(),
                params.getFileHashCache())
            .createBuildFileParser(
                params.getBuckEventBus(), params.getCell(), params.getWatchman())) {
      /*
       * The super console does a bunch of rewriting over the top of the console such that
       * simultaneously writing to stdout and stderr in an interactive session is problematic.
       * (Overwritten characters, lines never showing up, etc). As such, writing to stdout directly
       * stops superconsole rendering (no errors appear). Because of all of this, we need to
       * just buffer the output and print it to stdout at the end fo the run. The downside
       * is that we have to buffer all of the output in memory, and it could potentially be large,
       * however, we'll just have to accept that tradeoff for now to get both error messages
       * from the parser, and the final output
       */

      try (ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
          PrintStream out = new PrintStream(new BufferedOutputStream(byteOut))) {
        for (String pathToBuildFile : getArguments()) {
          // Print a comment with the path to the build file.
          out.printf(""# %s\n\n"", pathToBuildFile);

          // Resolve the path specified by the user.
          Path path = Paths.get(pathToBuildFile);
          if (!path.isAbsolute()) {
            Path root = projectFilesystem.getRootPath();
            path = root.resolve(path);
          }

          // Parse the rules from the build file.
          ImmutableMap<String, Map<String, Object>> rawRules =
              parser.getBuildFileManifest(path).getTargets();

          // Format and print the rules from the raw data, filtered by type.
          ImmutableSet<String> types = getTypes();
          Predicate<String> includeType = type -> types.isEmpty() || types.contains(type);
          printRulesToStdout(out, rawRules, includeType);
        }

        // Make sure we tell the event listener to flush, otherwise there is a race condition where
        // the event listener might not have flushed, we dirty the stream, and then it will not
        // render the last frame (see {@link SuperConsoleEventListener})
        params.getBuckEventBus().post(new FlushConsoleEvent());
        out.close();
        params.getConsole().getStdOut().write(byteOut.toByteArray());
      }
    }

    return ExitCode.SUCCESS;
  }
",long method
1367,,data class
151,"final class Prefixes {
    /**
     * The SI “deca” prefix. This is the only SI prefix encoded on two letters instead than one.
     * It can be represented by the CJK compatibility character “㍲”, but use of those characters
     * is generally not recommended outside of Chinese, Japanese or Korean texts.
     */
    private static final String DECA = ""da"";

    /**
     * The SI prefixes in increasing order. The only two-letters prefix – “da” – is encoded using the JCK compatibility
     * character “㍲”. The Greek letter μ is repeated twice: the U+00B5 character for micro sign (this is the character
     * that Apache SIS uses in unit symbols) and the U+03BC character for the Greek small letter “mu” (the later is the
     * character that appears when decomposing JCK compatibility characters with {@link java.text.Normalizer}).
     * Both characters have same appearance but different values.
     *
     * <p>For each prefix at index <var>i</var>, the multiplication factor is given by 10 raised to power {@code POWERS[i]}.</p>
     */
    private static final char[] PREFIXES = {'E','G','M','P','T','Y','Z','a','c','d','f','h','k','m','n','p','y','z','µ','μ','㍲'};
    private static final byte[] POWERS   = {18,  9,  6, 15, 12, 24, 21,-18, -2, -1,-15,  2,  3, -3, -9,-12,-24,-21, -6, -6,  1};

    /**
     * The SI prefixes from smallest to largest. Power of tens go from -24 to +24 inclusive with a step of 3,
     * except for the addition of -2, -1, +1, +2 and the omission of 0.
     *
     * @see #symbol(double, int)
     */
    private static final char[] ENUM = {'y','z','a','f','p','n','µ','m','c','d','㍲','h','k','M','G','T','P','E','Z','Y'};

    /**
     * The maximal power of 1000 for the prefixes in the {@link #ENUM} array. Note that 1000⁸ = 1E+24.
     */
    static final int MAX_POWER = 8;

    /**
     * The converters for SI prefixes, created when first needed.
     *
     * @see #converter(char)
     */
    private static final LinearConverter[] CONVERTERS = new LinearConverter[POWERS.length];

    /**
     * Do not allow instantiation of this class.
     */
    private Prefixes() {
    }

    /**
     * Returns the converter for the given SI prefix, or {@code null} if none.
     * Those converters are created when first needed and cached for reuse.
     */
    static LinearConverter converter(final char prefix) {
        final int i = Arrays.binarySearch(PREFIXES, prefix);
        if (i < 0) {
            return null;
        }
        synchronized (CONVERTERS) {
            LinearConverter c = CONVERTERS[i];
            if (c == null) {
                final int p = POWERS[i];
                final double numerator, denominator;
                if (p >= 0) {
                    numerator = MathFunctions.pow10(p);
                    denominator = 1;
                } else {
                    numerator = 1;
                    denominator = MathFunctions.pow10(-p);
                }
                c = LinearConverter.scale(numerator, denominator);
                CONVERTERS[i] = c;
            }
            return c;
        }
    }

    /**
     * Returns the SI prefix symbol for the given scale factor, or 0 if none.
     *
     * @param  scale  the scale factor.
     * @param  power  the unit power. For example if we are scaling m², then this is 2.
     * @return the prefix, or 0 if none.
     */
    static char symbol(double scale, final int power) {
        switch (power) {
            case 0:  return 0;
            case 1:  break;
            case 2:  scale = Math.sqrt(scale); break;
            case 3:  scale = Math.cbrt(scale); break;
            default: scale = Math.pow(scale, 1.0/power);
        }
        final int n = Numerics.toExp10(Math.getExponent(scale)) + 1;
        if (AbstractConverter.epsilonEquals(MathFunctions.pow10(n), scale)) {
            int i = Math.abs(n);
            switch (i) {
                case 0:  return 0;
                case 1:  // Fallthrough
                case 2:  break;
                default: {
                    if (i > (MAX_POWER*3) || (i % 3) != 0) {
                        return 0;
                    }
                    i = i/3 + 2;
                    break;
                }
            }
            return ENUM[n >= 0 ? (MAX_POWER+1) + i : (MAX_POWER+2) - i];
        }
        return 0;
    }

    /**
     * Returns the concatenation of the given prefix with the given unit symbol.
     */
    static String concat(final char prefix, final String unit) {
        return (prefix == '㍲') ? DECA + unit : prefix + unit;
    }

    /**
     * Returns the unit for the given symbol, taking the SI prefix in account. The given string is usually a single symbol
     * like ""km"", but may be an expression like ""m³"" or ""m/s"" if the given symbol is explicitly registered as an item that
     * {@link Units#get(String)} recognizes. This method does not perform any arithmetic operation on {@code Unit},
     * except a check for the exponent.
     *
     * @param  uom  a symbol compliant with the rules documented in {@link AbstractUnit#symbol}.
     * @return the unit for the given symbol, or {@code null} if no unit is found.
     */
    static Unit<?> getUnit(final String uom) {
        Unit<?> unit = Units.get(uom);
        if (unit == null && uom.length() >= 2) {
            int s = 1;
            char prefix = uom.charAt(0);
            if (prefix == 'd' && uom.charAt(1) == 'a') {
                prefix = '㍲';      // Converse of above 'concat(char, String)' method.
                s = 2;              // Skip ""da"", which we represent by '㍲'.
            }
            unit = Units.get(uom.substring(s));
            if (AbstractUnit.isPrefixable(unit)) {
                LinearConverter c = Prefixes.converter(prefix);
                if (c != null) {
                    String symbol = unit.getSymbol();
                    final int power = ConventionalUnit.power(symbol);
                    if (power != 0) {
                        if (power != 1) {
                            c = LinearConverter.pow(c, power, false);
                        }
                        symbol = Prefixes.concat(prefix, symbol);
                        return new ConventionalUnit<>((AbstractUnit<?>) unit, c, symbol.intern(), (byte) 0, (short) 0);
                    }
                }
            }
            unit = null;
        }
        return unit;
    }

    /**
     * If the given system unit should be replaced by pseudo-unit for the purpose of formatting,
     * returns that pseudo-unit. Otherwise returns {@code null}. This method is for handling the
     * Special case of {@link Units#KILOGRAM}, to be replaced by {@link Units#GRAM} so a prefix
     * can be computed. The kilogram may appear in an expression like ""kg/m"", which we want to
     * replace by ""g/m"". We do that by dividing the unit by 1000 (the converter for ""milli"" prefix).
     */
    @SuppressWarnings(""unchecked"")
    static <Q extends Quantity<Q>> ConventionalUnit<Q> pseudoSystemUnit(final SystemUnit<Q> unit) {
        if ((unit.scope & ~UnitRegistry.SI) == 0 && unit.dimension.numeratorIs('M')) {
            if (unit == Units.KILOGRAM) {
                return (ConventionalUnit<Q>) Units.GRAM;            // Optimization for a common case.
            } else {
                String symbol = unit.getSymbol();
                if (symbol != null && symbol.length() >= 3 && symbol.startsWith(""kg"")
                        && !AbstractUnit.isSymbolChar(symbol.codePointAt(2)))
                {
                    symbol = symbol.substring(1);
                    UnitConverter c = converter('m');
                    return new ConventionalUnit<>(unit, c, symbol, UnitRegistry.PREFIXABLE, (short) 0).unique(symbol);
                }
            }
        }
        return null;
    }
}
",blob
305,"@InterfaceAudience.Private
@InterfaceStability.Unstable
public class JobStatusChangedEvent implements HistoryEvent {
  private JobStatusChanged datum = new JobStatusChanged();

  /**
   * Create an event to record the change in the Job Status
   * @param id Job ID
   * @param jobStatus The new job status
   */
  public JobStatusChangedEvent(JobID id, String jobStatus) {
    datum.jobid = new Utf8(id.toString());
    datum.jobStatus = new Utf8(jobStatus);
  }

  JobStatusChangedEvent() {}

  public Object getDatum() { return datum; }
  public void setDatum(Object datum) {
    this.datum = (JobStatusChanged)datum;
  }

  /** Get the Job Id */
  public JobID getJobId() { return JobID.forName(datum.jobid.toString()); }
  /** Get the event status */
  public String getStatus() { return datum.jobStatus.toString(); }
  /** Get the event type */
  public EventType getEventType() {
    return EventType.JOB_STATUS_CHANGED;
  }

}
",data class
245,"    private synchronized Map getResourceBundleEntries(final Bundle bundle)
    {
        String file = (String) bundle.getHeaders().get(Constants.BUNDLE_LOCALIZATION);
        if (file == null)
        {
            file = Constants.BUNDLE_LOCALIZATION_DEFAULT_BASENAME;
        }

        // remove leading slash
        if (file.startsWith(""/"")) //$NON-NLS-1$
        {
            file = file.substring(1);
        }

        // split path and base name
        int slash = file.lastIndexOf('/');
        String fileName = file.substring(slash + 1);
        String path = (slash <= 0) ? ""/"" : file.substring(0, slash); //$NON-NLS-1$

        HashMap resourceBundleEntries = new HashMap();

        Enumeration locales = bundle.findEntries(path, fileName + ""*.properties"", false); //$NON-NLS-1$
        if (locales != null)
        {
            while (locales.hasMoreElements())
            {
                URL entry = (URL) locales.nextElement();

                // calculate the key
                String entryPath = entry.getPath();
                final int start = entryPath.lastIndexOf('/') + 1 + fileName.length(); // path,
                                                                                      // slash
                                                                                      // and
                                                                                      // base
                                                                                      // name
                final int end = entryPath.length() - 11; // .properties suffix
                entryPath = entryPath.substring(start, end);

                // the default language is ""name.properties"" thus the entry
                // path is empty and must default to ""_""+DEFAULT_LOCALE
                if (entryPath.length() == 0)
                {
                    entryPath = ""_"" + DEFAULT_LOCALE; //$NON-NLS-1$
                }

                // only add this entry, if the ""language"" is not provided
                // by the main bundle or an earlier bound fragment
                if (!resourceBundleEntries.containsKey(entryPath))
                {
                    resourceBundleEntries.put(entryPath, entry);
                }
            }
        }

        return resourceBundleEntries;
    }
",long method
1096,"  @Override
  public final Element getDocumentElement()
  {
                int dochandle=dtm.getDocument();
                int elementhandle=DTM.NULL;
                for(int kidhandle=dtm.getFirstChild(dochandle);
                                kidhandle!=DTM.NULL;
                                kidhandle=dtm.getNextSibling(kidhandle))
                {
                        switch(dtm.getNodeType(kidhandle))
                        {
                        case Node.ELEMENT_NODE:
                                if(elementhandle!=DTM.NULL)
                                {
                                        elementhandle=DTM.NULL; // More than one; ill-formed.
                                        kidhandle=dtm.getLastChild(dochandle); // End loop
                                }
                                else
                                        elementhandle=kidhandle;
                                break;

                        // These are harmless; document is still wellformed
                        case Node.COMMENT_NODE:
                        case Node.PROCESSING_INSTRUCTION_NODE:
                        case Node.DOCUMENT_TYPE_NODE:
                                break;

                        default:
                                elementhandle=DTM.NULL; // ill-formed
                                kidhandle=dtm.getLastChild(dochandle); // End loop
                                break;
                        }
                }
                if(elementhandle==DTM.NULL)
                        throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
                else
                        return (Element)(dtm.getNode(elementhandle));
  }
",long method
177,"public class HistoryClientService extends AbstractService {

  private static final Log LOG = LogFactory.getLog(HistoryClientService.class);

  private HSClientProtocol protocolHandler;
  private Server server;
  private WebApp webApp;
  private InetSocketAddress bindAddress;
  private HistoryContext history;
  private JHSDelegationTokenSecretManager jhsDTSecretManager;
  
  public HistoryClientService(HistoryContext history,
      JHSDelegationTokenSecretManager jhsDTSecretManager) {
    super(""HistoryClientService"");
    this.history = history;
    this.protocolHandler = new HSClientProtocolHandler();
    this.jhsDTSecretManager = jhsDTSecretManager;
  }

  protected void serviceStart() throws Exception {
    Configuration conf = getConfig();
    YarnRPC rpc = YarnRPC.create(conf);
    initializeWebApp(conf);
    InetSocketAddress address = conf.getSocketAddr(
        JHAdminConfig.MR_HISTORY_BIND_HOST,
        JHAdminConfig.MR_HISTORY_ADDRESS,
        JHAdminConfig.DEFAULT_MR_HISTORY_ADDRESS,
        JHAdminConfig.DEFAULT_MR_HISTORY_PORT);

    server =
        rpc.getServer(HSClientProtocol.class, protocolHandler, address,
            conf, jhsDTSecretManager,
            conf.getInt(JHAdminConfig.MR_HISTORY_CLIENT_THREAD_COUNT,
                JHAdminConfig.DEFAULT_MR_HISTORY_CLIENT_THREAD_COUNT));

    // Enable service authorization?
    if (conf.getBoolean(
        CommonConfigurationKeysPublic.HADOOP_SECURITY_AUTHORIZATION,
        false)) {
      server.refreshServiceAcl(conf, new ClientHSPolicyProvider());
    }
    
    server.start();
    this.bindAddress = conf.updateConnectAddr(JHAdminConfig.MR_HISTORY_BIND_HOST,
                                              JHAdminConfig.MR_HISTORY_ADDRESS,
                                              JHAdminConfig.DEFAULT_MR_HISTORY_ADDRESS,
                                              server.getListenerAddress());
    LOG.info(""Instantiated HistoryClientService at "" + this.bindAddress);

    super.serviceStart();
  }

  @VisibleForTesting
  protected void initializeWebApp(Configuration conf) {
    webApp = new HsWebApp(history);
    InetSocketAddress bindAddress = MRWebAppUtil.getJHSWebBindAddress(conf);
    // NOTE: there should be a .at(InetSocketAddress)
    WebApps
        .$for(""jobhistory"", HistoryClientService.class, this, ""ws"")
        .with(conf)
        .withHttpSpnegoKeytabKey(
            JHAdminConfig.MR_WEBAPP_SPNEGO_KEYTAB_FILE_KEY)
        .withHttpSpnegoPrincipalKey(
            JHAdminConfig.MR_WEBAPP_SPNEGO_USER_NAME_KEY)
        .at(NetUtils.getHostPortString(bindAddress)).start(webApp);
    
    String connectHost = MRWebAppUtil.getJHSWebappURLWithoutScheme(conf).split("":"")[0];
    MRWebAppUtil.setJHSWebappURLWithoutScheme(conf,
        connectHost + "":"" + webApp.getListenerAddress().getPort());
  }

  @Override
  protected void serviceStop() throws Exception {
    if (server != null) {
      server.stop();
    }
    if (webApp != null) {
      webApp.stop();
    }
    super.serviceStop();
  }

  @Private
  public MRClientProtocol getClientHandler() {
    return this.protocolHandler;
  }

  @Private
  public InetSocketAddress getBindAddress() {
    return this.bindAddress;
  }

  private class HSClientProtocolHandler implements HSClientProtocol {

    private RecordFactory recordFactory = RecordFactoryProvider.getRecordFactory(null);

    public InetSocketAddress getConnectAddress() {
      return getBindAddress();
    }
    
    private Job verifyAndGetJob(final JobId jobID) throws IOException {
      UserGroupInformation loginUgi = null;
      Job job = null;
      try {
        loginUgi = UserGroupInformation.getLoginUser();
        job = loginUgi.doAs(new PrivilegedExceptionAction<Job>() {

          @Override
          public Job run() throws Exception {
            Job job = history.getJob(jobID);
            return job;
          }
        });
      } catch (InterruptedException e) {
        throw new IOException(e);
      }
      if (job != null) {
        JobACL operation = JobACL.VIEW_JOB;
        checkAccess(job, operation);
      }
      return job;
    }

    @Override
    public GetCountersResponse getCounters(GetCountersRequest request)
        throws IOException {
      JobId jobId = request.getJobId();
      Job job = verifyAndGetJob(jobId);
      GetCountersResponse response = recordFactory.newRecordInstance(GetCountersResponse.class);
      response.setCounters(TypeConverter.toYarn(job.getAllCounters()));
      return response;
    }

    @Override
    public GetJobReportResponse getJobReport(GetJobReportRequest request)
        throws IOException {
      JobId jobId = request.getJobId();
      Job job = verifyAndGetJob(jobId);
      GetJobReportResponse response = recordFactory.newRecordInstance(GetJobReportResponse.class);
      if (job != null) {
        response.setJobReport(job.getReport());
      }
      else {
        response.setJobReport(null);
      }
      return response;
    }

    @Override
    public GetTaskAttemptReportResponse getTaskAttemptReport(
        GetTaskAttemptReportRequest request) throws IOException {
      TaskAttemptId taskAttemptId = request.getTaskAttemptId();
      Job job = verifyAndGetJob(taskAttemptId.getTaskId().getJobId());
      GetTaskAttemptReportResponse response = recordFactory.newRecordInstance(GetTaskAttemptReportResponse.class);
      response.setTaskAttemptReport(job.getTask(taskAttemptId.getTaskId()).getAttempt(taskAttemptId).getReport());
      return response;
    }

    @Override
    public GetTaskReportResponse getTaskReport(GetTaskReportRequest request)
        throws IOException {
      TaskId taskId = request.getTaskId();
      Job job = verifyAndGetJob(taskId.getJobId());
      GetTaskReportResponse response = recordFactory.newRecordInstance(GetTaskReportResponse.class);
      response.setTaskReport(job.getTask(taskId).getReport());
      return response;
    }

    @Override
    public GetTaskAttemptCompletionEventsResponse
        getTaskAttemptCompletionEvents(
            GetTaskAttemptCompletionEventsRequest request) throws IOException {
      JobId jobId = request.getJobId();
      int fromEventId = request.getFromEventId();
      int maxEvents = request.getMaxEvents();

      Job job = verifyAndGetJob(jobId);
      GetTaskAttemptCompletionEventsResponse response = recordFactory.newRecordInstance(GetTaskAttemptCompletionEventsResponse.class);
      response.addAllCompletionEvents(Arrays.asList(job.getTaskAttemptCompletionEvents(fromEventId, maxEvents)));
      return response;
    }

    @Override
    public KillJobResponse killJob(KillJobRequest request) throws IOException {
      throw new IOException(""Invalid operation on completed job"");
    }

    @Override
    public KillTaskResponse killTask(KillTaskRequest request)
        throws IOException {
      throw new IOException(""Invalid operation on completed job"");
    }

    @Override
    public KillTaskAttemptResponse killTaskAttempt(
        KillTaskAttemptRequest request) throws IOException {
      throw new IOException(""Invalid operation on completed job"");
    }

    @Override
    public GetDiagnosticsResponse getDiagnostics(GetDiagnosticsRequest request)
        throws IOException {
      TaskAttemptId taskAttemptId = request.getTaskAttemptId();

      Job job = verifyAndGetJob(taskAttemptId.getTaskId().getJobId());

      GetDiagnosticsResponse response = recordFactory.newRecordInstance(GetDiagnosticsResponse.class);
      response.addAllDiagnostics(job.getTask(taskAttemptId.getTaskId()).getAttempt(taskAttemptId).getDiagnostics());
      return response;
    }

    @Override
    public FailTaskAttemptResponse failTaskAttempt(
        FailTaskAttemptRequest request) throws IOException {
      throw new IOException(""Invalid operation on completed job"");
    }

    @Override
    public GetTaskReportsResponse getTaskReports(GetTaskReportsRequest request)
        throws IOException {
      JobId jobId = request.getJobId();
      TaskType taskType = request.getTaskType();

      GetTaskReportsResponse response = recordFactory.newRecordInstance(GetTaskReportsResponse.class);
      Job job = verifyAndGetJob(jobId);
      Collection<Task> tasks = job.getTasks(taskType).values();
      for (Task task : tasks) {
        response.addTaskReport(task.getReport());
      }
      return response;
    }
    
    @Override
    public GetDelegationTokenResponse getDelegationToken(
        GetDelegationTokenRequest request) throws IOException {

      UserGroupInformation ugi = UserGroupInformation.getCurrentUser();

      // Verify that the connection is kerberos authenticated
        if (!isAllowedDelegationTokenOp()) {
          throw new IOException(
              ""Delegation Token can be issued only with kerberos authentication"");
        }

      GetDelegationTokenResponse response = recordFactory.newRecordInstance(
          GetDelegationTokenResponse.class);

      String user = ugi.getUserName();
      Text owner = new Text(user);
      Text realUser = null;
      if (ugi.getRealUser() != null) {
        realUser = new Text(ugi.getRealUser().getUserName());
      }
      MRDelegationTokenIdentifier tokenIdentifier =
          new MRDelegationTokenIdentifier(owner, new Text(
            request.getRenewer()), realUser);
      Token<MRDelegationTokenIdentifier> realJHSToken =
          new Token<MRDelegationTokenIdentifier>(tokenIdentifier,
              jhsDTSecretManager);
      org.apache.hadoop.yarn.api.records.Token mrDToken =
          org.apache.hadoop.yarn.api.records.Token.newInstance(
            realJHSToken.getIdentifier(), realJHSToken.getKind().toString(),
            realJHSToken.getPassword(), realJHSToken.getService().toString());
      response.setDelegationToken(mrDToken);
      return response;
    }

    @Override
    public RenewDelegationTokenResponse renewDelegationToken(
        RenewDelegationTokenRequest request) throws IOException {
        if (!isAllowedDelegationTokenOp()) {
          throw new IOException(
              ""Delegation Token can be renewed only with kerberos authentication"");
        }

        org.apache.hadoop.yarn.api.records.Token protoToken = request.getDelegationToken();
        Token<MRDelegationTokenIdentifier> token =
            new Token<MRDelegationTokenIdentifier>(
                protoToken.getIdentifier().array(), protoToken.getPassword()
                    .array(), new Text(protoToken.getKind()), new Text(
                    protoToken.getService()));

        String user = UserGroupInformation.getCurrentUser().getShortUserName();
        long nextExpTime = jhsDTSecretManager.renewToken(token, user);
        RenewDelegationTokenResponse renewResponse = Records
            .newRecord(RenewDelegationTokenResponse.class);
        renewResponse.setNextExpirationTime(nextExpTime);
        return renewResponse;
    }

    @Override
    public CancelDelegationTokenResponse cancelDelegationToken(
        CancelDelegationTokenRequest request) throws IOException {
        if (!isAllowedDelegationTokenOp()) {
          throw new IOException(
              ""Delegation Token can be cancelled only with kerberos authentication"");
        }

        org.apache.hadoop.yarn.api.records.Token protoToken = request.getDelegationToken();
        Token<MRDelegationTokenIdentifier> token =
            new Token<MRDelegationTokenIdentifier>(
                protoToken.getIdentifier().array(), protoToken.getPassword()
                    .array(), new Text(protoToken.getKind()), new Text(
                    protoToken.getService()));

        String user = UserGroupInformation.getCurrentUser().getUserName();
        jhsDTSecretManager.cancelToken(token, user);
        return Records.newRecord(CancelDelegationTokenResponse.class);
    }

    private void checkAccess(Job job, JobACL jobOperation)
        throws IOException {

      UserGroupInformation callerUGI;
      callerUGI = UserGroupInformation.getCurrentUser();

      if (!job.checkAccess(callerUGI, jobOperation)) {
        throw new IOException(new AccessControlException(""User ""
            + callerUGI.getShortUserName() + "" cannot perform operation ""
            + jobOperation.name() + "" on "" + job.getID()));
      }
    }

    private boolean isAllowedDelegationTokenOp() throws IOException {
      if (UserGroupInformation.isSecurityEnabled()) {
        return EnumSet.of(AuthenticationMethod.KERBEROS,
                          AuthenticationMethod.KERBEROS_SSL,
                          AuthenticationMethod.CERTIFICATE)
            .contains(UserGroupInformation.getCurrentUser()
                    .getRealAuthenticationMethod());
      } else {
        return true;
      }
    }

  }
}
",blob
666,"public class LaunchRequest {
	private String jobName;

	String jobParameters;

	public String getJobName() {
		return jobName;
	}

	public void setJobName(String jobName) {
		this.jobName = jobName;
	}

	public String getJobParameters() {
		return jobParameters;
	}

	public void setJobParameters(String jobParameters) {
		this.jobParameters = jobParameters;
	}

}
",data class
984,"    public static String getOatFileInstructionSet(File oatFile) throws Throwable {
        ShareElfFile elfFile = null;
        String result = """";
        try {
            elfFile = new ShareElfFile(oatFile);
            final ShareElfFile.SectionHeader roDataHdr = elfFile.getSectionHeaderByName("".rodata"");
            if (roDataHdr == null) {
                throw new IOException(""Unable to find .rodata section."");
            }

            final FileChannel channel = elfFile.getChannel();
            channel.position(roDataHdr.shOffset);

            final byte[] oatMagicAndVersion = new byte[8];
            ShareElfFile.readUntilLimit(channel, ByteBuffer.wrap(oatMagicAndVersion), ""Failed to read oat magic and version."");

            if (oatMagicAndVersion[0] != 'o'
                    || oatMagicAndVersion[1] != 'a'
                    || oatMagicAndVersion[2] != 't'
                    || oatMagicAndVersion[3] != '\n') {
                throw new IOException(
                        String.format(""Bad oat magic: %x %x %x %x"",
                                oatMagicAndVersion[0],
                                oatMagicAndVersion[1],
                                oatMagicAndVersion[2],
                                oatMagicAndVersion[3])
                );
            }

            final int versionOffsetFromOatBegin = 4;
            final int versionBytes = 3;

            final String oatVersion = new String(oatMagicAndVersion,
                    versionOffsetFromOatBegin, versionBytes, Charset.forName(""ASCII""));
            try {
                Integer.parseInt(oatVersion);
            } catch (NumberFormatException e) {
                throw new IOException(""Bad oat version: "" + oatVersion);
            }

            ByteBuffer buffer = ByteBuffer.allocate(128);
            buffer.order(elfFile.getDataOrder());
            // TODO This is a risk point, since each oat version may use a different offset.
            // So far it's ok. Perhaps we should use oatVersionNum to judge the right offset in
            // the future.
            final int isaNumOffsetFromOatBegin = 12;
            channel.position(roDataHdr.shOffset + isaNumOffsetFromOatBegin);
            buffer.limit(4);
            ShareElfFile.readUntilLimit(channel, buffer, ""Failed to read isa num."");

            int isaNum = buffer.getInt();
            if (isaNum < 0 || isaNum >= InstructionSet.values().length) {
                throw new IOException(""Bad isa num: "" + isaNum);
            }

            switch (InstructionSet.values()[isaNum]) {
                case kArm:
                case kThumb2:
                    result = ""arm"";
                    break;
                case kArm64:
                    result = ""arm64"";
                    break;
                case kX86:
                    result = ""x86"";
                    break;
                case kX86_64:
                    result = ""x86_64"";
                    break;
                case kMips:
                    result = ""mips"";
                    break;
                case kMips64:
                    result = ""mips64"";
                    break;
                case kNone:
                    result = ""none"";
                    break;
                default:
                    throw new IOException(""Should not reach here."");
            }
        } finally {
            if (elfFile != null) {
                try {
                    elfFile.close();
                } catch (Exception ignored) {
                    // Ignored.
                }
            }
        }
        return result;
    }
",long method
429,"@InterfaceAudience.Private
@Metrics(context=""metricssystem"")
public class MetricsSystemImpl extends MetricsSystem implements MetricsSource {

  static final Log LOG = LogFactory.getLog(MetricsSystemImpl.class);
  static final String MS_NAME = ""MetricsSystem"";
  static final String MS_STATS_NAME = MS_NAME +"",sub=Stats"";
  static final String MS_STATS_DESC = ""Metrics system metrics"";
  static final String MS_CONTROL_NAME = MS_NAME +"",sub=Control"";
  static final String MS_INIT_MODE_KEY = ""hadoop.metrics.init.mode"";

  enum InitMode { NORMAL, STANDBY }

  private final Map<String, MetricsSourceAdapter> sources;
  private final Map<String, MetricsSource> allSources;
  private final Map<String, MetricsSinkAdapter> sinks;
  private final Map<String, MetricsSink> allSinks;
  private final List<Callback> callbacks;
  private final MetricsCollectorImpl collector;
  private final MetricsRegistry registry = new MetricsRegistry(MS_NAME);
  @Metric({""Snapshot"", ""Snapshot stats""}) MutableStat snapshotStat;
  @Metric({""Publish"", ""Publishing stats""}) MutableStat publishStat;
  @Metric(""Dropped updates by all sinks"") MutableCounterLong droppedPubAll;

  private final List<MetricsTag> injectedTags;

  // Things that are changed by init()/start()/stop()
  private String prefix;
  private MetricsFilter sourceFilter;
  private MetricsConfig config;
  private Map<String, MetricsConfig> sourceConfigs, sinkConfigs;
  private boolean monitoring = false;
  private Timer timer;
  private int period; // seconds
  private long logicalTime; // number of timer invocations * period
  private ObjectName mbeanName;
  private boolean publishSelfMetrics = true;
  private MetricsSourceAdapter sysSource;
  private int refCount = 0; // for mini cluster mode

  /**
   * Construct the metrics system
   * @param prefix  for the system
   */
  public MetricsSystemImpl(String prefix) {
    this.prefix = prefix;
    allSources = Maps.newHashMap();
    sources = Maps.newLinkedHashMap();
    allSinks = Maps.newHashMap();
    sinks = Maps.newLinkedHashMap();
    sourceConfigs = Maps.newHashMap();
    sinkConfigs = Maps.newHashMap();
    callbacks = Lists.newArrayList();
    injectedTags = Lists.newArrayList();
    collector = new MetricsCollectorImpl();
    if (prefix != null) {
      // prefix could be null for default ctor, which requires init later
      initSystemMBean();
    }
  }

  /**
   * Construct the system but not initializing (read config etc.) it.
   */
  public MetricsSystemImpl() {
    this(null);
  }

  /**
   * Initialized the metrics system with a prefix.
   * @param prefix  the system will look for configs with the prefix
   * @return the metrics system object itself
   */
  @Override
  public synchronized MetricsSystem init(String prefix) {
    if (monitoring && !DefaultMetricsSystem.inMiniClusterMode()) {
      LOG.warn(this.prefix +"" metrics system already initialized!"");
      return this;
    }
    this.prefix = checkNotNull(prefix, ""prefix"");
    ++refCount;
    if (monitoring) {
      // in mini cluster mode
      LOG.info(this.prefix +"" metrics system started (again)"");
      return this;
    }
    switch (initMode()) {
      case NORMAL:
        try { start(); }
        catch (MetricsConfigException e) {
          // Configuration errors (e.g., typos) should not be fatal.
          // We can always start the metrics system later via JMX.
          LOG.warn(""Metrics system not started: ""+ e.getMessage());
          LOG.debug(""Stacktrace: "", e);
        }
        break;
      case STANDBY:
        LOG.info(prefix +"" metrics system started in standby mode"");
    }
    initSystemMBean();
    return this;
  }

  @Override
  public synchronized void start() {
    checkNotNull(prefix, ""prefix"");
    if (monitoring) {
      LOG.warn(prefix +"" metrics system already started!"",
               new MetricsException(""Illegal start""));
      return;
    }
    for (Callback cb : callbacks) cb.preStart();
    configure(prefix);
    startTimer();
    monitoring = true;
    LOG.info(prefix +"" metrics system started"");
    for (Callback cb : callbacks) cb.postStart();
  }

  @Override
  public synchronized void stop() {
    if (!monitoring && !DefaultMetricsSystem.inMiniClusterMode()) {
      LOG.warn(prefix +"" metrics system not yet started!"",
               new MetricsException(""Illegal stop""));
      return;
    }
    if (!monitoring) {
      // in mini cluster mode
      LOG.info(prefix +"" metrics system stopped (again)"");
      return;
    }
    for (Callback cb : callbacks) cb.preStop();
    LOG.info(""Stopping ""+ prefix +"" metrics system..."");
    stopTimer();
    stopSources();
    stopSinks();
    clearConfigs();
    monitoring = false;
    LOG.info(prefix +"" metrics system stopped."");
    for (Callback cb : callbacks) cb.postStop();
  }

  @Override public synchronized <T>
  T register(String name, String desc, T source) {
    MetricsSourceBuilder sb = MetricsAnnotations.newSourceBuilder(source);
    final MetricsSource s = sb.build();
    MetricsInfo si = sb.info();
    String name2 = name == null ? si.name() : name;
    final String finalDesc = desc == null ? si.description() : desc;
    final String finalName = // be friendly to non-metrics tests
        DefaultMetricsSystem.sourceName(name2, !monitoring);
    allSources.put(finalName, s);
    LOG.debug(finalName +"", ""+ finalDesc);
    if (monitoring) {
      registerSource(finalName, finalDesc, s);
    }
    // We want to re-register the source to pick up new config when the
    // metrics system restarts.
    register(new AbstractCallback() {
      @Override public void postStart() {
        registerSource(finalName, finalDesc, s);
      }
    });
    return source;
  }

  @Override public synchronized
  void unregisterSource(String name) {
    if (sources.containsKey(name)) {
      sources.get(name).stop();
      sources.remove(name);
    }
    if (allSources.containsKey(name)) {
      allSources.remove(name);
    }
  }

  synchronized
  void registerSource(String name, String desc, MetricsSource source) {
    checkNotNull(config, ""config"");
    MetricsConfig conf = sourceConfigs.get(name);
    MetricsSourceAdapter sa = new MetricsSourceAdapter(prefix, name, desc,
        source, injectedTags, period, conf != null ? conf
            : config.subset(SOURCE_KEY));
    sources.put(name, sa);
    sa.start();
    LOG.debug(""Registered source ""+ name);
  }

  @Override public synchronized <T extends MetricsSink>
  T register(final String name, final String description, final T sink) {
    LOG.debug(name +"", ""+ description);
    if (allSinks.containsKey(name)) {
      LOG.warn(""Sink ""+ name +"" already exists!"");
      return sink;
    }
    allSinks.put(name, sink);
    if (config != null) {
      registerSink(name, description, sink);
    }
    // We want to re-register the sink to pick up new config
    // when the metrics system restarts.
    register(new AbstractCallback() {
      @Override public void postStart() {
        register(name, description, sink);
      }
    });
    return sink;
  }

  synchronized void registerSink(String name, String desc, MetricsSink sink) {
    checkNotNull(config, ""config"");
    MetricsConfig conf = sinkConfigs.get(name);
    MetricsSinkAdapter sa = conf != null
        ? newSink(name, desc, sink, conf)
        : newSink(name, desc, sink, config.subset(SINK_KEY));
    sinks.put(name, sa);
    sa.start();
    LOG.info(""Registered sink ""+ name);
  }

  @Override
  public synchronized void register(final Callback callback) {
    callbacks.add((Callback) Proxy.newProxyInstance(
        callback.getClass().getClassLoader(), new Class<?>[] { Callback.class },
        new InvocationHandler() {
          @Override
          public Object invoke(Object proxy, Method method, Object[] args)
              throws Throwable {
            try {
              return method.invoke(callback, args);
            } catch (Exception e) {
              // These are not considered fatal.
              LOG.warn(""Caught exception in callback ""+ method.getName(), e);
            }
            return null;
          }
        }));
  }

  @Override
  public synchronized void startMetricsMBeans() {
    for (MetricsSourceAdapter sa : sources.values()) {
      sa.startMBeans();
    }
  }

  @Override
  public synchronized void stopMetricsMBeans() {
    for (MetricsSourceAdapter sa : sources.values()) {
      sa.stopMBeans();
    }
  }

  @Override
  public synchronized String currentConfig() {
    PropertiesConfiguration saver = new PropertiesConfiguration();
    StringWriter writer = new StringWriter();
    saver.copy(config);
    try { saver.save(writer); }
    catch (Exception e) {
      throw new MetricsConfigException(""Error stringify config"", e);
    }
    return writer.toString();
  }

  private synchronized void startTimer() {
    if (timer != null) {
      LOG.warn(prefix +"" metrics system timer already started!"");
      return;
    }
    logicalTime = 0;
    long millis = period * 1000;
    timer = new Timer(""Timer for '""+ prefix +""' metrics system"", true);
    timer.scheduleAtFixedRate(new TimerTask() {
          @Override
          public void run() {
            try {
              onTimerEvent();
            } catch (Exception e) {
              LOG.warn(e);
            }
          }
        }, millis, millis);
    LOG.info(""Scheduled snapshot period at ""+ period +"" second(s)."");
  }

  synchronized void onTimerEvent() {
    logicalTime += period;
    if (sinks.size() > 0) {
      publishMetrics(sampleMetrics(), false);
    }
  }
  
  /**
   * Requests an immediate publish of all metrics from sources to sinks.
   */
  @Override
  public void publishMetricsNow() {
    if (sinks.size() > 0) {
      publishMetrics(sampleMetrics(), true);
    }    
  }

  /**
   * Sample all the sources for a snapshot of metrics/tags
   * @return  the metrics buffer containing the snapshot
   */
  synchronized MetricsBuffer sampleMetrics() {
    collector.clear();
    MetricsBufferBuilder bufferBuilder = new MetricsBufferBuilder();

    for (Entry<String, MetricsSourceAdapter> entry : sources.entrySet()) {
      if (sourceFilter == null || sourceFilter.accepts(entry.getKey())) {
        snapshotMetrics(entry.getValue(), bufferBuilder);
      }
    }
    if (publishSelfMetrics) {
      snapshotMetrics(sysSource, bufferBuilder);
    }
    MetricsBuffer buffer = bufferBuilder.get();
    return buffer;
  }

  private void snapshotMetrics(MetricsSourceAdapter sa,
                               MetricsBufferBuilder bufferBuilder) {
    long startTime = Time.now();
    bufferBuilder.add(sa.name(), sa.getMetrics(collector, true));
    collector.clear();
    snapshotStat.add(Time.now() - startTime);
    LOG.debug(""Snapshotted source ""+ sa.name());
  }

  /**
   * Publish a metrics snapshot to all the sinks
   * @param buffer  the metrics snapshot to publish
   * @param immediate  indicates that we should publish metrics immediately
   *                   instead of using a separate thread.
   */
  synchronized void publishMetrics(MetricsBuffer buffer, boolean immediate) {
    int dropped = 0;
    for (MetricsSinkAdapter sa : sinks.values()) {
      long startTime = Time.now();
      boolean result;
      if (immediate) {
        result = sa.putMetricsImmediate(buffer); 
      } else {
        result = sa.putMetrics(buffer, logicalTime);
      }
      dropped += result ? 0 : 1;
      publishStat.add(Time.now() - startTime);
    }
    droppedPubAll.incr(dropped);
  }

  private synchronized void stopTimer() {
    if (timer == null) {
      LOG.warn(prefix +"" metrics system timer already stopped!"");
      return;
    }
    timer.cancel();
    timer = null;
  }

  private synchronized void stopSources() {
    for (Entry<String, MetricsSourceAdapter> entry : sources.entrySet()) {
      MetricsSourceAdapter sa = entry.getValue();
      LOG.debug(""Stopping metrics source ""+ entry.getKey() +
          "": class="" + sa.source().getClass());
      sa.stop();
    }
    sysSource.stop();
    sources.clear();
  }

  private synchronized void stopSinks() {
    for (Entry<String, MetricsSinkAdapter> entry : sinks.entrySet()) {
      MetricsSinkAdapter sa = entry.getValue();
      LOG.debug(""Stopping metrics sink ""+ entry.getKey() +
          "": class="" + sa.sink().getClass());
      sa.stop();
    }
    sinks.clear();
  }

  private synchronized void configure(String prefix) {
    config = MetricsConfig.create(prefix);
    configureSinks();
    configureSources();
    configureSystem();
  }

  private synchronized void configureSystem() {
    injectedTags.add(Interns.tag(MsInfo.Hostname, getHostname()));
  }

  private synchronized void configureSinks() {
    sinkConfigs = config.getInstanceConfigs(SINK_KEY);
    int confPeriod = 0;
    for (Entry<String, MetricsConfig> entry : sinkConfigs.entrySet()) {
      MetricsConfig conf = entry.getValue();
      int sinkPeriod = conf.getInt(PERIOD_KEY, PERIOD_DEFAULT);
      confPeriod = confPeriod == 0 ? sinkPeriod
                                   : ArithmeticUtils.gcd(confPeriod, sinkPeriod);
      String clsName = conf.getClassName("""");
      if (clsName == null) continue;  // sink can be registered later on
      String sinkName = entry.getKey();
      try {
        MetricsSinkAdapter sa = newSink(sinkName,
            conf.getString(DESC_KEY, sinkName), conf);
        sa.start();
        sinks.put(sinkName, sa);
      } catch (Exception e) {
        LOG.warn(""Error creating sink '""+ sinkName +""'"", e);
      }
    }
    period = confPeriod > 0 ? confPeriod
                            : config.getInt(PERIOD_KEY, PERIOD_DEFAULT);
  }

  static MetricsSinkAdapter newSink(String name, String desc, MetricsSink sink,
                                    MetricsConfig conf) {
    return new MetricsSinkAdapter(name, desc, sink, conf.getString(CONTEXT_KEY),
        conf.getFilter(SOURCE_FILTER_KEY),
        conf.getFilter(RECORD_FILTER_KEY),
        conf.getFilter(METRIC_FILTER_KEY),
        conf.getInt(PERIOD_KEY, PERIOD_DEFAULT),
        conf.getInt(QUEUE_CAPACITY_KEY, QUEUE_CAPACITY_DEFAULT),
        conf.getInt(RETRY_DELAY_KEY, RETRY_DELAY_DEFAULT),
        conf.getFloat(RETRY_BACKOFF_KEY, RETRY_BACKOFF_DEFAULT),
        conf.getInt(RETRY_COUNT_KEY, RETRY_COUNT_DEFAULT));
  }

  static MetricsSinkAdapter newSink(String name, String desc,
                                    MetricsConfig conf) {
    return newSink(name, desc, (MetricsSink) conf.getPlugin(""""), conf);
  }

  private void configureSources() {
    sourceFilter = config.getFilter(PREFIX_DEFAULT + SOURCE_FILTER_KEY);
    sourceConfigs = config.getInstanceConfigs(SOURCE_KEY);
    registerSystemSource();
  }

  private void clearConfigs() {
    sinkConfigs.clear();
    sourceConfigs.clear();
    injectedTags.clear();
    config = null;
  }

  static String getHostname() {
    try {
      return InetAddress.getLocalHost().getHostName();
    } catch (Exception e) {
      LOG.error(""Error getting localhost name. Using 'localhost'..."", e);
    }
    return ""localhost"";
  }

  private void registerSystemSource() {
    MetricsConfig sysConf = sourceConfigs.get(MS_NAME);
    sysSource = new MetricsSourceAdapter(prefix, MS_STATS_NAME, MS_STATS_DESC,
        MetricsAnnotations.makeSource(this), injectedTags, period,
        sysConf == null ? config.subset(SOURCE_KEY) : sysConf);
    sysSource.start();
  }

  @Override
  public synchronized void getMetrics(MetricsCollector builder, boolean all) {
    MetricsRecordBuilder rb = builder.addRecord(MS_NAME)
        .addGauge(MsInfo.NumActiveSources, sources.size())
        .addGauge(MsInfo.NumAllSources, allSources.size())
        .addGauge(MsInfo.NumActiveSinks, sinks.size())
        .addGauge(MsInfo.NumAllSinks, allSinks.size());

    for (MetricsSinkAdapter sa : sinks.values()) {
      sa.snapshot(rb, all);
    }
    registry.snapshot(rb, all);
  }

  private void initSystemMBean() {
    checkNotNull(prefix, ""prefix should not be null here!"");
    if (mbeanName == null) {
      mbeanName = MBeans.register(prefix, MS_CONTROL_NAME, this);
    }
  }

  @Override
  public synchronized boolean shutdown() {
    LOG.debug(""refCount=""+ refCount);
    if (refCount <= 0) {
      LOG.debug(""Redundant shutdown"", new Throwable());
      return true; // already shutdown
    }
    if (--refCount > 0) return false;
    if (monitoring) {
      try { stop(); }
      catch (Exception e) {
        LOG.warn(""Error stopping the metrics system"", e);
      }
    }
    allSources.clear();
    allSinks.clear();
    callbacks.clear();
    if (mbeanName != null) {
      MBeans.unregister(mbeanName);
      mbeanName = null;
    }
    LOG.info(prefix +"" metrics system shutdown complete."");
    return true;
  }

  @Override
  public MetricsSource getSource(String name) {
    return allSources.get(name);
  }

  @VisibleForTesting
  MetricsSourceAdapter getSourceAdapter(String name) {
    return sources.get(name);
  }

  private InitMode initMode() {
    LOG.debug(""from system property: ""+ System.getProperty(MS_INIT_MODE_KEY));
    LOG.debug(""from environment variable: ""+ System.getenv(MS_INIT_MODE_KEY));
    String m = System.getProperty(MS_INIT_MODE_KEY);
    String m2 = m == null ? System.getenv(MS_INIT_MODE_KEY) : m;
    return InitMode.valueOf((m2 == null ? InitMode.NORMAL.name() : m2)
                            .toUpperCase(Locale.US));
  }
}
",blob
1032,"    @Override
    public java.util.concurrent.Future<UpdateStackResponse> updateStack(
            final UpdateStackRequest request,
            final com.oracle.bmc.responses.AsyncHandler<UpdateStackRequest, UpdateStackResponse>
                    handler) {
        LOG.trace(""Called async updateStack"");
        final UpdateStackRequest interceptedRequest =
                UpdateStackConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                UpdateStackConverter.fromRequest(client, interceptedRequest);
        final com.google.common.base.Function<javax.ws.rs.core.Response, UpdateStackResponse>
                transformer = UpdateStackConverter.fromResponse();

        com.oracle.bmc.responses.AsyncHandler<UpdateStackRequest, UpdateStackResponse>
                handlerToUse = handler;
        if (handler != null
                && this.authenticationDetailsProvider
                        instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            handlerToUse =
                    new com.oracle.bmc.util.internal.RefreshAuthTokenWrappingAsyncHandler<
                            UpdateStackRequest, UpdateStackResponse>(
                            (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                                    this.authenticationDetailsProvider,
                            handler) {
                        @Override
                        public void retryCall() {
                            final com.oracle.bmc.util.internal.Consumer<javax.ws.rs.core.Response>
                                    onSuccess =
                                            new com.oracle.bmc.http.internal.SuccessConsumer<>(
                                                    this, transformer, interceptedRequest);
                            final com.oracle.bmc.util.internal.Consumer<Throwable> onError =
                                    new com.oracle.bmc.http.internal.ErrorConsumer<>(
                                            this, interceptedRequest);
                            client.put(
                                    ib,
                                    interceptedRequest.getUpdateStackDetails(),
                                    interceptedRequest,
                                    onSuccess,
                                    onError);
                        }
                    };
        }

        final com.oracle.bmc.util.internal.Consumer<javax.ws.rs.core.Response> onSuccess =
                (handler == null)
                        ? null
                        : new com.oracle.bmc.http.internal.SuccessConsumer<>(
                                handlerToUse, transformer, interceptedRequest);
        final com.oracle.bmc.util.internal.Consumer<Throwable> onError =
                (handler == null)
                        ? null
                        : new com.oracle.bmc.http.internal.ErrorConsumer<>(
                                handlerToUse, interceptedRequest);

        java.util.concurrent.Future<javax.ws.rs.core.Response> responseFuture =
                client.put(
                        ib,
                        interceptedRequest.getUpdateStackDetails(),
                        interceptedRequest,
                        onSuccess,
                        onError);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenTransformingFuture<
                    javax.ws.rs.core.Response, UpdateStackResponse>(
                    responseFuture,
                    transformer,
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    new com.google.common.base.Supplier<
                            java.util.concurrent.Future<javax.ws.rs.core.Response>>() {
                        @Override
                        public java.util.concurrent.Future<javax.ws.rs.core.Response> get() {
                            return client.put(
                                    ib,
                                    interceptedRequest.getUpdateStackDetails(),
                                    interceptedRequest,
                                    onSuccess,
                                    onError);
                        }
                    });
        } else {
            return new com.oracle.bmc.util.internal.TransformingFuture<>(
                    responseFuture, transformer);
        }
    }
",long method
328,"public class OperatorWrapper {
  @SuppressWarnings(""unused"")
  private static final org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger(OperatorWrapper.class);

  private static final DecimalFormat DECIMAL_FORMATTER = new DecimalFormat(""#.##"");
  private static final String UNKNOWN_OPERATOR = ""UNKNOWN_OPERATOR"";
  //Negative valued constant used for denoting invalid index to indicate absence of metric
  private static final int NO_SPILL_METRIC_INDEX = Integer.MIN_VALUE;
  private final int major;
  private final List<ImmutablePair<ImmutablePair<OperatorProfile, Integer>, String>> opsAndHosts; // [(operatorProfile --> minorFragment number,host), ...]
  private final OperatorProfile firstProfile;
  private final CoreOperatorType operatorType;
  private final String operatorName;
  private final int size;
  private final int timeSkewMin;
  private final double timeSkewRatio;
  private final int scanWaitMin;
  private final double waitSkewRatio;

  public OperatorWrapper(int major, List<ImmutablePair<ImmutablePair<OperatorProfile, Integer>, String>> opsAndHostsList, Map<String, String> phyOperMap, DrillConfig config) {
    //Threshold to track if the slowest operator ran relatively slow
    timeSkewMin = config.getInt(ExecConstants.PROFILE_WARNING_TIME_SKEW_MIN);
    timeSkewRatio = config.getDouble(ExecConstants.PROFILE_WARNING_TIME_SKEW_RATIO_PROCESS);
    //Threshold to track if the slowest SCAN operator spent more time in wait than processing
    scanWaitMin = config.getInt(ExecConstants.PROFILE_WARNING_SCAN_WAIT_MIN);
    waitSkewRatio = config.getDouble(ExecConstants.PROFILE_WARNING_TIME_SKEW_RATIO_WAIT);

    Preconditions.checkArgument(opsAndHostsList.size() > 0);
    this.major = major;
    firstProfile = opsAndHostsList.get(0).getLeft().getLeft();
    operatorType = CoreOperatorType.valueOf(firstProfile.getOperatorType());
    //Update Name from Physical Map
    String path = new OperatorPathBuilder().setMajor(major).setOperator(firstProfile).build();
    //Use Plan Extracted Operator Names if available
    String extractedOpName = phyOperMap.get(path);
    String inferredOpName = operatorType == null ? UNKNOWN_OPERATOR : operatorType.toString();
    //Revert to inferred names for exceptional cases
    // 1. Extracted 'FLATTEN' operator is NULL
    // 2. Extracted 'SCAN' could be a PARQUET_ROW_GROUP_SCAN, or KAFKA_SUB_SCAN, or etc.
    // 3. Extracted 'UNION_EXCHANGE' could be a SINGLE_SENDER or UNORDERED_RECEIVER
    if (extractedOpName == null || inferredOpName.contains(extractedOpName) || extractedOpName.endsWith(""_EXCHANGE"")) {
      operatorName =  inferredOpName;
    } else {
      operatorName =  extractedOpName;
    }
    this.opsAndHosts = opsAndHostsList;
    size = opsAndHostsList.size();
  }

  public String getDisplayName() {
    final String path = new OperatorPathBuilder().setMajor(major).setOperator(firstProfile).build();
    return String.format(""%s - %s"", path, operatorName);
  }

  public String getId() {
    return String.format(""operator-%d-%d"", major, opsAndHosts.get(0).getLeft().getLeft().getOperatorId());
  }

  public static final String [] OPERATOR_COLUMNS = {
      OperatorTblTxt.MINOR_FRAGMENT, OperatorTblTxt.HOSTNAME, OperatorTblTxt.SETUP_TIME, OperatorTblTxt.PROCESS_TIME, OperatorTblTxt.WAIT_TIME,
      OperatorTblTxt.MAX_BATCHES, OperatorTblTxt.MAX_RECORDS, OperatorTblTxt.PEAK_MEMORY
  };

  public static final String [] OPERATOR_COLUMNS_TOOLTIP = {
      OperatorTblTooltip.MINOR_FRAGMENT, OperatorTblTooltip.HOSTNAME, OperatorTblTooltip.SETUP_TIME, OperatorTblTooltip.PROCESS_TIME, OperatorTblTooltip.WAIT_TIME,
      OperatorTblTooltip.MAX_BATCHES, OperatorTblTooltip.MAX_RECORDS, OperatorTblTooltip.PEAK_MEMORY
  };

  public String getContent() {
    TableBuilder builder = new TableBuilder(OPERATOR_COLUMNS, OPERATOR_COLUMNS_TOOLTIP, true);

    Map<String, String> attributeMap = new HashMap<>(); //Reusing for different fragments
    for (ImmutablePair<ImmutablePair<OperatorProfile, Integer>, String> ip : opsAndHosts) {
      int minor = ip.getLeft().getRight();
      OperatorProfile op = ip.getLeft().getLeft();

      attributeMap.put(HtmlAttribute.DATA_ORDER, String.valueOf(minor)); //Overwrite values from previous fragments
      String path = new OperatorPathBuilder().setMajor(major).setMinor(minor).setOperator(op).build();
      builder.appendCell(path, attributeMap);
      builder.appendCell(ip.getRight());
      builder.appendNanos(op.getSetupNanos());
      builder.appendNanos(op.getProcessNanos());
      builder.appendNanos(op.getWaitNanos());

      long maxBatches = Long.MIN_VALUE;
      long maxRecords = Long.MIN_VALUE;
      for (StreamProfile sp : op.getInputProfileList()) {
        maxBatches = Math.max(sp.getBatches(), maxBatches);
        maxRecords = Math.max(sp.getRecords(), maxRecords);
      }

      builder.appendFormattedInteger(maxBatches);
      builder.appendFormattedInteger(maxRecords);
      builder.appendBytes(op.getPeakLocalMemoryAllocated());
    }
    return builder.build();
  }

  public static final String[] OPERATORS_OVERVIEW_COLUMNS = {
      OverviewTblTxt.OPERATOR_ID, OverviewTblTxt.TYPE_OF_OPERATOR,
      OverviewTblTxt.AVG_SETUP_TIME, OverviewTblTxt.MAX_SETUP_TIME,
      OverviewTblTxt.AVG_PROCESS_TIME, OverviewTblTxt.MAX_PROCESS_TIME,
      OverviewTblTxt.MIN_WAIT_TIME, OverviewTblTxt.AVG_WAIT_TIME, OverviewTblTxt.MAX_WAIT_TIME,
      OverviewTblTxt.PERCENT_FRAGMENT_TIME, OverviewTblTxt.PERCENT_QUERY_TIME, OverviewTblTxt.ROWS,
      OverviewTblTxt.AVG_PEAK_MEMORY, OverviewTblTxt.MAX_PEAK_MEMORY
  };

  public static final String[] OPERATORS_OVERVIEW_COLUMNS_TOOLTIP = {
      OverviewTblTooltip.OPERATOR_ID, OverviewTblTooltip.TYPE_OF_OPERATOR,
      OverviewTblTooltip.AVG_SETUP_TIME, OverviewTblTooltip.MAX_SETUP_TIME,
      OverviewTblTooltip.AVG_PROCESS_TIME, OverviewTblTooltip.MAX_PROCESS_TIME,
      OverviewTblTooltip.MIN_WAIT_TIME, OverviewTblTooltip.AVG_WAIT_TIME, OverviewTblTooltip.MAX_WAIT_TIME,
      OverviewTblTooltip.PERCENT_FRAGMENT_TIME, OverviewTblTooltip.PERCENT_QUERY_TIME, OverviewTblTooltip.ROWS,
      OverviewTblTooltip.AVG_PEAK_MEMORY, OverviewTblTooltip.MAX_PEAK_MEMORY
  };

  //Palette to help shade operators sharing a common major fragment
  private static final String[] OPERATOR_OVERVIEW_BGCOLOR_PALETTE = {""#ffffff"",""#f2f2f2""};

  public void addSummary(TableBuilder tb, Map<String, Long> majorFragmentBusyTally, long majorFragmentBusyTallyTotal) {
    //Select background color from palette
    String opTblBgColor = OPERATOR_OVERVIEW_BGCOLOR_PALETTE[major%OPERATOR_OVERVIEW_BGCOLOR_PALETTE.length];
    String path = new OperatorPathBuilder().setMajor(major).setOperator(firstProfile).build();
    tb.appendCell(path, opTblBgColor, null);
    tb.appendCell(operatorName);

    //Check if spill information is available
    int spillCycleMetricIndex = getSpillCycleMetricIndex(operatorType);
    boolean isSpillableOp = (spillCycleMetricIndex != NO_SPILL_METRIC_INDEX);
    boolean hasSpilledToDisk = false;
    boolean isScanOp = operatorName.endsWith(""SCAN"");

    //Get MajorFragment Busy+Wait Time Tally
    long majorBusyNanos = majorFragmentBusyTally.get(new OperatorPathBuilder().setMajor(major).build());

    double setupSum = 0.0;
    double processSum = 0.0;
    double waitSum = 0.0;
    double memSum = 0.0;
    double spillCycleSum = 0.0;
    long spillCycleMax = 0L;
    long recordSum = 0L;

    //Construct list for sorting purposes (using legacy Comparators)
    final List<ImmutablePair<OperatorProfile, Integer>> opList = new ArrayList<>();

    for (ImmutablePair<ImmutablePair<OperatorProfile, Integer>,String> ip : opsAndHosts) {
      OperatorProfile profile = ip.getLeft().getLeft();
      setupSum += profile.getSetupNanos();
      processSum += profile.getProcessNanos();
      waitSum += profile.getWaitNanos();
      memSum += profile.getPeakLocalMemoryAllocated();
      for (final StreamProfile sp : profile.getInputProfileList()) {
        recordSum += sp.getRecords();
      }
      opList.add(ip.getLeft());

      //Capture Spill Info
      //Check to ensure index < #metrics (old profiles have less metrics); else reset isSpillableOp
      if (isSpillableOp) {
        //NOTE: We get non-zero value for non-existent metrics, so we can't use getMetric(index)
        //profile.getMetric(spillCycleMetricIndex).getLongValue();
        //Forced to iterate list
        for (MetricValue metricVal : profile.getMetricList()) {
          if (metricVal.getMetricId() == spillCycleMetricIndex) {
            long spillCycles = metricVal.getLongValue();
            spillCycleMax = Math.max(spillCycles, spillCycleMax);
            spillCycleSum += spillCycles;
            hasSpilledToDisk = (spillCycleSum > 0.0);
          }
        }
      }
    }

    final ImmutablePair<OperatorProfile, Integer> longSetup = Collections.max(opList, Comparators.setupTime);
    tb.appendNanos(Math.round(setupSum / size));
    tb.appendNanos(longSetup.getLeft().getSetupNanos());

    Map<String, String> timeSkewMap = null;
    final ImmutablePair<OperatorProfile, Integer> longProcess = Collections.max(opList, Comparators.processTime);
    //Calculating average processing time
    long avgProcTime = Math.round(processSum / size);
    tb.appendNanos(avgProcTime);
    long maxProcTime = longProcess.getLeft().getProcessNanos();
    //Calculating skew of longest processing fragment w.r.t. average
    double maxSkew = (avgProcTime > 0) ? maxProcTime/Double.valueOf(avgProcTime) : 0.0d;
    //Marking skew if both thresholds are crossed
    if (avgProcTime > TimeUnit.SECONDS.toNanos(timeSkewMin) && maxSkew > timeSkewRatio ) {
      timeSkewMap = new HashMap<>();
      timeSkewMap.put(HtmlAttribute.CLASS, HtmlAttribute.CLASS_VALUE_TIME_SKEW_TAG);
      timeSkewMap.put(HtmlAttribute.TITLE,  ""One fragment took "" + DECIMAL_FORMATTER.format(maxSkew) + "" longer than average"");
      timeSkewMap.put(HtmlAttribute.STYLE, HtmlAttribute.STYLE_VALUE_CURSOR_HELP);
    }
    tb.appendNanos(maxProcTime, timeSkewMap);

    final ImmutablePair<OperatorProfile, Integer> shortWait = Collections.min(opList, Comparators.waitTime);
    final ImmutablePair<OperatorProfile, Integer> longWait = Collections.max(opList, Comparators.waitTime);
    tb.appendNanos(shortWait.getLeft().getWaitNanos());
    //Calculating average wait time for fragment
    long avgWaitTime = Math.round(waitSum / size);

    //Slow Scan Warning
    Map<String, String> slowScanMap = null;
    //Marking slow scan if threshold is crossed and wait was longer than processing
    if (isScanOp && (avgWaitTime > TimeUnit.SECONDS.toNanos(scanWaitMin)) && (avgWaitTime > avgProcTime)) {
      slowScanMap = new HashMap<>();
      slowScanMap.put(HtmlAttribute.CLASS, HtmlAttribute.CLASS_VALUE_SCAN_WAIT_TAG);
      slowScanMap.put(HtmlAttribute.TITLE, ""Avg Wait Time &gt; Avg Processing Time"");
      slowScanMap.put(HtmlAttribute.STYLE, HtmlAttribute.STYLE_VALUE_CURSOR_HELP);
    }
    tb.appendNanos(avgWaitTime, slowScanMap);

    long maxWaitTime = longWait.getLeft().getWaitNanos();
    //Skewed Wait Warning
    timeSkewMap = null; //Resetting
    //Calculating skew of longest waiting fragment w.r.t. average
    maxSkew = (avgWaitTime > 0) ? maxWaitTime/Double.valueOf(avgWaitTime) : 0.0d;
    //Marking skew if both thresholds are crossed
    if (avgWaitTime > TimeUnit.SECONDS.toNanos(timeSkewMin) && maxSkew > waitSkewRatio) {
      timeSkewMap = new HashMap<>();
      timeSkewMap.put(HtmlAttribute.CLASS, HtmlAttribute.CLASS_VALUE_TIME_SKEW_TAG);
      timeSkewMap.put(HtmlAttribute.TITLE, ""One fragment waited "" + DECIMAL_FORMATTER.format(maxSkew) + "" longer than average"");
      timeSkewMap.put(HtmlAttribute.STYLE, HtmlAttribute.STYLE_VALUE_CURSOR_HELP);
    }
    tb.appendNanos(maxWaitTime, timeSkewMap);

    tb.appendPercent(processSum / majorBusyNanos);
    tb.appendPercent(processSum / majorFragmentBusyTallyTotal);

    tb.appendFormattedInteger(recordSum);

    final ImmutablePair<OperatorProfile, Integer> peakMem = Collections.max(opList, Comparators.operatorPeakMemory);

    //Inject spill-to-disk attributes
    Map<String, String> avgSpillMap = null;
    Map<String, String> maxSpillMap = null;
    if (hasSpilledToDisk) {
      avgSpillMap = new HashMap<>();
      //Average SpillCycle
      double avgSpillCycle = spillCycleSum/size;
      avgSpillMap.put(HtmlAttribute.TITLE, DECIMAL_FORMATTER.format(avgSpillCycle) + "" spills on average"");
      avgSpillMap.put(HtmlAttribute.STYLE, HtmlAttribute.STYLE_VALUE_CURSOR_HELP);
      avgSpillMap.put(HtmlAttribute.CLASS, HtmlAttribute.CLASS_VALUE_SPILL_TAG); //JScript will inject Icon
      avgSpillMap.put(HtmlAttribute.SPILLS, DECIMAL_FORMATTER.format(avgSpillCycle)); //JScript will inject Count
      maxSpillMap = new HashMap<>();
      maxSpillMap.put(HtmlAttribute.TITLE, ""Most # spills: "" + spillCycleMax);
      maxSpillMap.put(HtmlAttribute.STYLE, HtmlAttribute.STYLE_VALUE_CURSOR_HELP);
      maxSpillMap.put(HtmlAttribute.CLASS, HtmlAttribute.CLASS_VALUE_SPILL_TAG); //JScript will inject Icon
      maxSpillMap.put(HtmlAttribute.SPILLS, String.valueOf(spillCycleMax)); //JScript will inject Count
    }

    tb.appendBytes(Math.round(memSum / size), avgSpillMap);
    tb.appendBytes(peakMem.getLeft().getPeakLocalMemoryAllocated(), maxSpillMap);
  }

  /**
   * Returns index of Spill Count/Cycle metric
   * @param operatorType
   * @return index of spill metric
   */
  private int getSpillCycleMetricIndex(CoreOperatorType operatorType) {
    // TODO: DRILL-6642, replace null values for ProtocolMessageEnum with UNRECOGNIZED NullValue to avoid null checks
    if (operatorType == null) {
      return NO_SPILL_METRIC_INDEX;
    }
    String metricName;

    switch (operatorType) {
    case EXTERNAL_SORT:
      metricName = ""SPILL_COUNT"";
      break;
    case HASH_AGGREGATE:
    case HASH_JOIN:
      metricName = ""SPILL_CYCLE"";
      break;
    default:
      return NO_SPILL_METRIC_INDEX;
    }

    int metricIndex = 0; //Default
    String[] metricNames = OperatorMetricRegistry.getMetricNames(operatorType.getNumber());
    for (String name : metricNames) {
      if (name.equalsIgnoreCase(metricName)) {
        return metricIndex;
      }
      metricIndex++;
    }
    //Backward compatibility with rendering older profiles. Ideally we should never touch this if an expected metric is not there
    return NO_SPILL_METRIC_INDEX;
  }

  public String getMetricsTable() {
    if (operatorType == null) {
      return """";
    }
    final String[] metricNames = OperatorMetricRegistry.getMetricNames(operatorType.getNumber());
    if (metricNames == null) {
      return """";
    }

    final String[] metricsTableColumnNames = new String[metricNames.length + 1];
    metricsTableColumnNames[0] = ""Minor Fragment"";
    int i = 1;
    for (final String metricName : metricNames) {
      metricsTableColumnNames[i++] = metricName;
    }
    final TableBuilder builder = new TableBuilder(metricsTableColumnNames, null);

    for (final ImmutablePair<ImmutablePair<OperatorProfile, Integer>,String> ip : opsAndHosts) {
      final OperatorProfile op = ip.getLeft().getLeft();

      builder.appendCell(
          new OperatorPathBuilder()
          .setMajor(major)
          .setMinor(ip.getLeft().getRight())
          .setOperator(op)
          .build());

      final Number[] values = new Number[metricNames.length];
      //Track new/Unknown Metrics
      final Set<Integer> unknownMetrics = new TreeSet<>();
      for (final MetricValue metric : op.getMetricList()) {
        if (metric.getMetricId() < metricNames.length) {
          if (metric.hasLongValue()) {
            values[metric.getMetricId()] = metric.getLongValue();
          } else if (metric.hasDoubleValue()) {
            values[metric.getMetricId()] = metric.getDoubleValue();
          }
        } else {
          //Tracking unknown metric IDs
          unknownMetrics.add(metric.getMetricId());
        }
      }
      for (final Number value : values) {
        if (value != null) {
          builder.appendFormattedNumber(value);
        } else {
          builder.appendCell("""");
        }
      }
    }
    return builder.build();
  }

  private class OperatorTblTxt {
    static final String MINOR_FRAGMENT = ""Minor Fragment"";
    static final String HOSTNAME = ""Hostname"";
    static final String SETUP_TIME = ""Setup Time"";
    static final String PROCESS_TIME = ""Process Time"";
    static final String WAIT_TIME = ""Wait Time"";
    static final String MAX_BATCHES = ""Max Batches"";
    static final String MAX_RECORDS = ""Max Records"";
    static final String PEAK_MEMORY = ""Peak Memory"";
  }

  private class OperatorTblTooltip {
    static final String MINOR_FRAGMENT = ""Operator's Minor Fragment"";
    static final String HOSTNAME = ""Host on which the minor fragment ran"";
    static final String SETUP_TIME = ""Setup Time for the minor fragment's operator"";
    static final String PROCESS_TIME = ""Process Time for the minor fragment's operator"";
    static final String WAIT_TIME = ""Wait Time for the minor fragment's operator"";
    static final String MAX_BATCHES = ""Max Batches processed by the minor fragment's operator"";
    static final String MAX_RECORDS = ""Max Records processed by the minor fragment's operator"";
    static final String PEAK_MEMORY = ""Peak Memory usage by the minor fragment's operator"";
  }

  private class OverviewTblTxt {
    static final String OPERATOR_ID = ""Operator ID"";
    static final String TYPE_OF_OPERATOR = ""Type"";
    static final String AVG_SETUP_TIME = ""Avg Setup Time"";
    static final String MAX_SETUP_TIME = ""Max Setup Time"";
    static final String AVG_PROCESS_TIME = ""Avg Process Time"";
    static final String MAX_PROCESS_TIME = ""Max Process Time"";
    static final String MIN_WAIT_TIME = ""Min Wait Time"";
    static final String AVG_WAIT_TIME = ""Avg Wait Time"";
    static final String MAX_WAIT_TIME = ""Max Wait Time"";
    static final String PERCENT_FRAGMENT_TIME = ""% Fragment Time"";
    static final String PERCENT_QUERY_TIME = ""% Query Time"";
    static final String ROWS = ""Rows"";
    static final String AVG_PEAK_MEMORY = ""Avg Peak Memory"";
    static final String MAX_PEAK_MEMORY = ""Max Peak Memory"";
  }

  private class OverviewTblTooltip {
    static final String OPERATOR_ID = ""Operator ID"";
    static final String TYPE_OF_OPERATOR = ""Operator Type"";
    static final String AVG_SETUP_TIME = ""Average time in setting up fragments"";
    static final String MAX_SETUP_TIME = ""Longest time a fragment took in setup"";
    static final String AVG_PROCESS_TIME = ""Average process time for a fragment"";
    static final String MAX_PROCESS_TIME = ""Longest process time of any fragment"";
    static final String MIN_WAIT_TIME = ""Shortest time a fragment spent in waiting"";
    static final String AVG_WAIT_TIME = ""Average wait time for a fragment"";
    static final String MAX_WAIT_TIME = ""Longest time a fragment spent in waiting"";
    static final String PERCENT_FRAGMENT_TIME = ""Percentage of the total fragment time that was spent on the operator"";
    static final String PERCENT_QUERY_TIME = ""Percentage of the total query time that was spent on the operator"";
    static final String ROWS = ""Rows emitted by scans, or consumed by other operators"";
    static final String AVG_PEAK_MEMORY  =  ""Average memory consumption by a fragment"";
    static final String MAX_PEAK_MEMORY  =  ""Highest memory consumption by a fragment"";
  }
}
",blob
1464,"public class Signal {
  public enum Type { LEAVE_LOOP, LEAVE_ROUTINE, LEAVE_PROGRAM, SQLEXCEPTION, NOTFOUND, UNSUPPORTED_OPERATION, USERDEFINED };
  Type type;
  String value = """";
  Exception exception = null;
  
  Signal(Type type, String value) {
    this.type = type;
    this.value = value;
    this.exception = null;
  }
  
  Signal(Type type, String value, Exception exception) {
    this.type = type;
    this.value = value;
    this.exception = exception;
  }
  
  /**
   * Get the signal value (message text)
   */
  public String getValue() {
    return value;
  }
}
",data class
339,"  private static Optional<Schema> removeUncomparableFieldsFromRecord(Schema record, Set<Schema> processed) {
    Preconditions.checkArgument(record.getType() == Schema.Type.RECORD);

    if (processed.contains(record)) {
      return Optional.absent();
    }
    processed.add(record);

    List<Field> fields = Lists.newArrayList();
    for (Field field : record.getFields()) {
      Optional<Schema> newFieldSchema = removeUncomparableFields(field.schema(), processed);
      if (newFieldSchema.isPresent()) {
        fields.add(new Field(field.name(), newFieldSchema.get(), field.doc(), field.defaultValue()));
      }
    }

    Schema newSchema = Schema.createRecord(record.getName(), record.getDoc(), record.getNamespace(), false);
    newSchema.setFields(fields);
    return Optional.of(newSchema);
  }
",feature envy
284,"public class FieldAttributeModel {

  /** Typescript value of the type of the field */
  private final String typeName;

  /** For Map, List object, need to initialize field first. Like new Field<>() */
  private boolean needInitialize;

  /** Name of the field */
  private String fieldName;

  /** Java Type of the object (used internally) */
  private Type type;

  /** This field type is a List of objects ? */
  private boolean isList;

  /** This field type is a simple primitive */
  private boolean isPrimitive;

  /** This field type is a map */
  private boolean isMap;

  /** This list type is in fact a list of DTOs */
  private boolean isListOfDto;

  /** This map type is a map of DTOs */
  private boolean isMapOfDto;

  /**
   * The type is a DTO or a list of DTO and then this value is the name of the DTO implementation
   */
  private String dtoImpl;

  /** type is a DTO object. */
  private boolean isDto;

  /** type is a Enum object. */
  private boolean isEnum;

  /** Map key type */
  private String mapKeyType;

  /** Map value type */
  private String mapValueType;

  /** Dto type for d.ts */
  private String dtsType;

  /** Dto class where this field declared */
  private Class declarationClass;

  /**
   * Build a new field model based on the name and Java type
   *
   * @param fieldName the name of the field
   * @param type the Java raw type that will allow further analyzes
   * @param declarationClass
   */
  public FieldAttributeModel(String fieldName, Type type, Class declarationClass) {
    this.fieldName = fieldName;
    this.type = type;
    this.typeName = convertType(type);
    this.dtsType = convertTypeForDTS(declarationClass, type);
    this.declarationClass = declarationClass;

    if (typeName.startsWith(""Array<"") || typeName.startsWith(""Map<"")) {
      this.needInitialize = true;
    }

    if (this.type instanceof ParameterizedType) {
      ParameterizedType parameterizedType = (ParameterizedType) this.type;
      Type rawType = parameterizedType.getRawType();
      analyzeParametrizedType(parameterizedType, rawType);
    } else if (Primitives.isPrimitive(this.type)
        || Primitives.isWrapperType(this.type)
        || String.class.equals(this.type)) {
      this.isPrimitive = true;
    } else if (this.type instanceof Class && ((Class) this.type).isAnnotationPresent(DTO.class)) {
      this.isDto = true;
      dtoImpl = this.type.getTypeName() + ""Impl"";
    } else if (this.type instanceof Class && ((Class) this.type).isEnum()) {
      this.isEnum = true;
    }
  }

  /**
   * Analyze a complex parametrized type attribute (which can be a list or map for example)
   *
   * @param parameterizedType
   * @param rawType
   */
  protected void analyzeParametrizedType(ParameterizedType parameterizedType, Type rawType) {
    if (List.class.equals(rawType)) {
      this.isList = true;
      if (parameterizedType.getActualTypeArguments()[0] instanceof Class
          && ((Class) parameterizedType.getActualTypeArguments()[0])
              .isAnnotationPresent(DTO.class)) {
        isListOfDto = true;
        dtoImpl = convertType(parameterizedType.getActualTypeArguments()[0]) + ""Impl"";
      }
    } else if (Map.class.equals(rawType)) {
      isMap = true;
      mapKeyType =
          convertTypeForDTS(declarationClass, parameterizedType.getActualTypeArguments()[0]);
      if (parameterizedType.getActualTypeArguments()[1] instanceof Class
          && ((Class) parameterizedType.getActualTypeArguments()[1])
              .isAnnotationPresent(DTO.class)) {

        isMapOfDto = true;
        dtoImpl = convertType(parameterizedType.getActualTypeArguments()[1]) + ""Impl"";
      }

      mapValueType =
          convertTypeForDTS(declarationClass, parameterizedType.getActualTypeArguments()[1]);
    }
  }

  public String getTypeName() {
    return typeName;
  }

  public String getFieldName() {
    return fieldName;
  }

  public Type getType() {
    return type;
  }

  public boolean isList() {
    return isList;
  }

  public boolean isPrimitive() {
    return isPrimitive;
  }

  public boolean isMap() {
    return isMap;
  }

  public boolean isListOfDto() {
    return isListOfDto;
  }

  public boolean isMapOfDto() {
    return isMapOfDto;
  }

  public String getDtoImpl() {
    return dtoImpl;
  }

  public boolean isDto() {
    return isDto;
  }

  public boolean isNeedInitialize() {
    return needInitialize;
  }

  public boolean isEnum() {
    return isEnum;
  }

  public String getName() {
    return this.fieldName;
  }

  public String getSimpleType() {
    return this.typeName;
  }

  public String getMapKeyType() {
    return mapKeyType;
  }

  public String getMapValueType() {
    return mapValueType;
  }

  public String getDtsType() {
    return dtsType;
  }
}
",data class
1151,"@XmlRootElement(name = ""realm"")
@XmlType
public class RealmTO implements EntityTO, TemplatableTO {

    private static final long serialVersionUID = 516330662956254391L;

    private String key;

    private String name;

    private String parent;

    private String fullPath;

    private String accountPolicy;

    private String passwordPolicy;

    private final List<String> actions = new ArrayList<>();

    @XmlJavaTypeAdapter(XmlGenericMapAdapter.class)
    private final Map<String, AnyTO> templates = new HashMap<>();

    private final Set<String> resources = new HashSet<>();

    @Override
    public String getKey() {
        return key;
    }

    @Override
    public void setKey(final String key) {
        this.key = key;
    }

    public String getName() {
        return name;
    }

    public void setName(final String name) {
        this.name = name;
    }

    public String getParent() {
        return parent;
    }

    public void setParent(final String parent) {
        this.parent = parent;
    }

    public String getFullPath() {
        return fullPath;
    }

    @PathParam(""fullPath"")
    public void setFullPath(final String fullPath) {
        this.fullPath = fullPath;
    }

    public String getAccountPolicy() {
        return accountPolicy;
    }

    public void setAccountPolicy(final String accountPolicy) {
        this.accountPolicy = accountPolicy;
    }

    public String getPasswordPolicy() {
        return passwordPolicy;
    }

    public void setPasswordPolicy(final String passwordPolicy) {
        this.passwordPolicy = passwordPolicy;
    }

    @XmlElementWrapper(name = ""actions"")
    @XmlElement(name = ""action"")
    @JsonProperty(""actions"")
    public List<String> getActions() {
        return actions;
    }

    @JsonProperty
    @Override
    public Map<String, AnyTO> getTemplates() {
        return templates;
    }

    @XmlElementWrapper(name = ""resources"")
    @XmlElement(name = ""resource"")
    @JsonProperty(""resources"")
    public Set<String> getResources() {
        return resources;
    }

}
",data class
491,"@Component(service = RuleRegistry.class, immediate = true, property = { ""rule.reinitialization.delay:Long=500"" })
public class RuleRegistryImpl extends AbstractRegistry<Rule, String, RuleProvider>
        implements RuleRegistry, RegistryChangeListener<RuleTemplate> {

    /**
     * Default value of delay between rule's re-initialization tries.
     */
    private static final long DEFAULT_REINITIALIZATION_DELAY = 500;

    /**
     * Delay between rule's re-initialization tries.
     */
    private static final String CONFIG_PROPERTY_REINITIALIZATION_DELAY = ""rule.reinitialization.delay"";

    private static final String SOURCE = RuleRegistryImpl.class.getSimpleName();

    private final Logger logger = LoggerFactory.getLogger(RuleRegistryImpl.class.getName());

    /**
     * Delay between rule's re-initialization tries.
     */
    private long scheduleReinitializationDelay;
    private ModuleTypeRegistry moduleTypeRegistry;
    private RuleTemplateRegistry templateRegistry;

    /**
     * {@link Map} of template UIDs to rules where these templates participated.
     */
    private final Map<String, Set<String>> mapTemplateToRules = new HashMap<String, Set<String>>();

    /**
     * Constructor that is responsible to invoke the super constructor with appropriate providerClazz
     * {@link RuleProvider} - the class of the providers that should be tracked automatically after activation.
     */
    public RuleRegistryImpl() {
        super(RuleProvider.class);
    }

    /**
     * Activates this component. Called from DS.
     *
     * @param componentContext this component context.
     */
    @Activate
    protected void activate(BundleContext bundleContext, Map<String, Object> properties) throws Exception {
        modified(properties);
        super.activate(bundleContext);
    }

    /**
     * This method is responsible for updating the value of delay between rule's re-initialization tries.
     *
     * @param config a {@link Map} containing the new value of delay.
     */
    @Modified
    protected void modified(Map<String, Object> config) {
        Object value = config == null ? null : config.get(CONFIG_PROPERTY_REINITIALIZATION_DELAY);
        this.scheduleReinitializationDelay = (value != null && value instanceof Number) ? (((Number) value).longValue())
                : DEFAULT_REINITIALIZATION_DELAY;
        if (value != null && !(value instanceof Number)) {
            logger.warn(""Invalid configuration value: {}. It MUST be Number."", value);
        }
    }

    @Override
    @Deactivate
    protected void deactivate() {
        super.deactivate();
    }

    @Reference(cardinality = ReferenceCardinality.OPTIONAL, policy = ReferencePolicy.DYNAMIC)
    @Override
    protected void setEventPublisher(EventPublisher eventPublisher) {
        super.setEventPublisher(eventPublisher);
    }

    @Override
    protected void unsetEventPublisher(EventPublisher eventPublisher) {
        super.unsetEventPublisher(eventPublisher);
    }

    @Reference(cardinality = ReferenceCardinality.OPTIONAL, policy = ReferencePolicy.DYNAMIC, name = ""ManagedRuleProvider"")
    protected void setManagedProvider(ManagedRuleProvider managedProvider) {
        super.setManagedProvider(managedProvider);
    }

    protected void unsetManagedProvider(ManagedRuleProvider managedProvider) {
        super.unsetManagedProvider(managedProvider);
    }

    /**
     * Bind the {@link ModuleTypeRegistry} service - called from DS.
     *
     * @param moduleTypeRegistry a {@link ModuleTypeRegistry} service.
     */
    @Reference(cardinality = ReferenceCardinality.MANDATORY, policy = ReferencePolicy.STATIC)
    protected void setModuleTypeRegistry(ModuleTypeRegistry moduleTypeRegistry) {
        this.moduleTypeRegistry = moduleTypeRegistry;
    }

    /**
     * Unbind the {@link ModuleTypeRegistry} service - called from DS.
     *
     * @param moduleTypeRegistry a {@link ModuleTypeRegistry} service.
     */
    protected void unsetModuleTypeRegistry(ModuleTypeRegistry moduleTypeRegistry) {
        this.moduleTypeRegistry = null;
    }

    /**
     * Bind the {@link RuleTemplateRegistry} service - called from DS.
     *
     * @param templateRegistry a {@link RuleTemplateRegistry} service.
     */
    @Reference(cardinality = ReferenceCardinality.MANDATORY, policy = ReferencePolicy.STATIC)
    protected void setTemplateRegistry(TemplateRegistry<RuleTemplate> templateRegistry) {
        if (templateRegistry instanceof RuleTemplateRegistry) {
            this.templateRegistry = (RuleTemplateRegistry) templateRegistry;
            templateRegistry.addRegistryChangeListener(this);
        }
    }

    /**
     * Unbind the {@link RuleTemplateRegistry} service - called from DS.
     *
     * @param templateRegistry a {@link RuleTemplateRegistry} service.
     */
    protected void unsetTemplateRegistry(TemplateRegistry<RuleTemplate> templateRegistry) {
        if (templateRegistry instanceof RuleTemplateRegistry) {
            this.templateRegistry = null;
            templateRegistry.removeRegistryChangeListener(this);
        }
    }

    /**
     * This method is used to register a {@link Rule} into the {@link RuleEngineImpl}. First the {@link Rule} become
     * {@link RuleStatus#UNINITIALIZED}.
     * Then verification procedure will be done and the Rule become {@link RuleStatus#IDLE}.
     * If the verification fails, the Rule will stay {@link RuleStatus#UNINITIALIZED}.
     *
     * @param rule a {@link Rule} instance which have to be added into the {@link RuleEngineImpl}.
     * @return a copy of the added {@link Rule}
     * @throws RuntimeException
     *                                  when passed module has a required configuration property and it is not specified
     *                                  in rule definition
     *                                  nor
     *                                  in the module's module type definition.
     * @throws IllegalArgumentException
     *                                  when a module id contains dot or when the rule with the same UID already exists.
     */
    @Override
    public Rule add(Rule rule) {
        super.add(rule);
        Rule ruleCopy = get(rule.getUID());
        if (ruleCopy == null) {
            throw new IllegalStateException();
        }
        return ruleCopy;
    }

    @Override
    protected void notifyListenersAboutAddedElement(Rule element) {
        postRuleAddedEvent(element);
        postRuleStatusInfoEvent(element.getUID(), new RuleStatusInfo(RuleStatus.UNINITIALIZED));
        super.notifyListenersAboutAddedElement(element);
    }

    @Override
    protected void notifyListenersAboutUpdatedElement(Rule oldElement, Rule element) {
        postRuleUpdatedEvent(element, oldElement);
        super.notifyListenersAboutUpdatedElement(oldElement, element);
    }

    /**
     * @see RuleRegistryImpl#postEvent(org.eclipse.smarthome.core.events.Event)
     */
    protected void postRuleAddedEvent(Rule rule) {
        postEvent(RuleEventFactory.createRuleAddedEvent(rule, SOURCE));
    }

    /**
     * @see RuleRegistryImpl#postEvent(org.eclipse.smarthome.core.events.Event)
     */
    protected void postRuleRemovedEvent(Rule rule) {
        postEvent(RuleEventFactory.createRuleRemovedEvent(rule, SOURCE));
    }

    /**
     * @see RuleRegistryImpl#postEvent(org.eclipse.smarthome.core.events.Event)
     */
    protected void postRuleUpdatedEvent(Rule rule, Rule oldRule) {
        postEvent(RuleEventFactory.createRuleUpdatedEvent(rule, oldRule, SOURCE));
    }

    /**
     * This method can be used in order to post events through the Eclipse SmartHome events bus. A common
     * use case is to notify event subscribers about the {@link Rule}'s status change.
     *
     * @param ruleUID    the UID of the {@link Rule}, whose status is changed.
     * @param statusInfo the new {@link Rule}s status.
     */
    protected void postRuleStatusInfoEvent(String ruleUID, RuleStatusInfo statusInfo) {
        postEvent(RuleEventFactory.createRuleStatusInfoEvent(statusInfo, ruleUID, SOURCE));
    }

    @Override
    protected void onRemoveElement(Rule rule) {
        String uid = rule.getUID();
        String templateUID = rule.getTemplateUID();
        if (templateUID != null) {
            updateRuleTemplateMapping(templateUID, uid, true);
        }
    }

    @Override
    protected void notifyListenersAboutRemovedElement(Rule element) {
        super.notifyListenersAboutRemovedElement(element);
        postRuleRemovedEvent(element);
    }

    @Override
    public Collection<Rule> getByTag(String tag) {
        Collection<Rule> result = new LinkedList<Rule>();
        if (tag == null) {
            forEach(result::add);
        } else {
            forEach(rule -> {
                if (rule.getTags().contains(tag)) {
                    result.add(rule);
                }
            });
        }
        return result;
    }

    @Override
    public Collection<Rule> getByTags(String... tags) {
        Set<String> tagSet = tags != null ? new HashSet<String>(Arrays.asList(tags)) : null;
        Collection<Rule> result = new LinkedList<Rule>();
        if (tagSet == null || tagSet.isEmpty()) {
            forEach(result::add);
        } else {
            forEach(rule -> {
                if (rule.getTags().containsAll(tagSet)) {
                    result.add(rule);
                }
            });
        }
        return result;
    }

    /**
     * The method checks if the rule has to be resolved by template or not. If the rule does not contain tempateUID it
     * returns same rule, otherwise it tries to resolve the rule created from template. If the template is available
     * the method creates a new rule based on triggers, conditions and actions from template. If the template is not
     * available returns the same rule.
     *
     * @param rule a rule defined by template.
     * @return the resolved rule(containing modules defined by the template) or not resolved rule, if the template is
     *         missing.
     */
    private Rule resolveRuleByTemplate(Rule rule) {
        String templateUID = rule.getTemplateUID();
        if (templateUID == null) {
            return rule;
        }
        RuleTemplate template = templateRegistry.get(templateUID);
        String uid = rule.getUID();
        if (template == null) {
            updateRuleTemplateMapping(templateUID, uid, false);
            logger.debug(""Rule template {} does not exist."", templateUID);
            return rule;
        } else {
            RuleImpl resolvedRule = (RuleImpl) RuleBuilder
                    .create(template, rule.getUID(), rule.getName(), rule.getConfiguration(), rule.getVisibility())
                    .build();
            resolveConfigurations(resolvedRule);
            updateRuleTemplateMapping(templateUID, uid, true);
            return resolvedRule;
        }
    }

    /**
     * Updates the content of the {@link Map} that maps the template to rules, using it to complete their definitions.
     *
     * @param templateUID the {@link RuleTemplate}'s UID specifying the template.
     * @param ruleUID     the {@link Rule}'s UID specifying a rule created by the specified template.
     * @param resolved    specifies if the {@link Map} should be updated by adding or removing the specified rule
     *                    accordingly if the rule is resolved or not.
     */
    private void updateRuleTemplateMapping(String templateUID, String ruleUID, boolean resolved) {
        synchronized (this) {
            Set<String> ruleUIDs = mapTemplateToRules.get(templateUID);
            if (ruleUIDs == null) {
                ruleUIDs = new HashSet<String>();
                mapTemplateToRules.put(templateUID, ruleUIDs);
            }
            if (resolved) {
                ruleUIDs.remove(ruleUID);
            } else {
                ruleUIDs.add(ruleUID);
            }
        }
    }

    @Override
    protected void addProvider(Provider<Rule> provider) {
        super.addProvider(provider);
        forEach(provider, rule -> {
            try {
                Rule resolvedRule = resolveRuleByTemplate(rule);
                if (rule != resolvedRule && provider instanceof ManagedRuleProvider) {
                    update(resolvedRule);
                }
            } catch (IllegalArgumentException e) {
                logger.error(""Added rule '{}' is invalid"", rule.getUID(), e);
            }
        });
    }

    @Override
    public void added(Provider<Rule> provider, Rule element) {
        String ruleUID = element.getUID();
        Rule resolvedRule = element;
        try {
            resolvedRule = resolveRuleByTemplate(element);
        } catch (IllegalArgumentException e) {
            logger.debug(""Added rule '{}' is invalid"", ruleUID, e);
        }
        super.added(provider, element);
        if (element != resolvedRule) {
            if (provider instanceof ManagedRuleProvider) {
                update(resolvedRule);
            } else {
                super.updated(provider, element, resolvedRule);
            }
        }
    }

    @Override
    public void updated(Provider<Rule> provider, Rule oldElement, Rule element) {
        String uid = element.getUID();
        if (oldElement != null && uid.equals(oldElement.getUID())) {
            Rule resolvedRule = element;
            try {
                resolvedRule = resolveRuleByTemplate(element);
            } catch (IllegalArgumentException e) {
                logger.error(""The rule '{}' is not updated, the new version is invalid"", uid, e);
            }
            if (element != resolvedRule && provider instanceof ManagedRuleProvider) {
                update(resolvedRule);
            } else {
                super.updated(provider, oldElement, resolvedRule);
            }
        } else {
            throw new IllegalArgumentException(
                    String.format(""The rule '%s' is not updated, not matching with any existing rule"", uid));
        }
    }

    @Override
    protected void onAddElement(Rule element) throws IllegalArgumentException {
        String uid = element.getUID();
        try {
            resolveConfigurations(element);
        } catch (IllegalArgumentException e) {
            logger.debug(""Added rule '{}' is invalid"", uid, e);
        }
    }

    @Override
    protected void onUpdateElement(Rule oldElement, Rule element) throws IllegalArgumentException {
        String uid = element.getUID();
        try {
            resolveConfigurations(element);
        } catch (IllegalArgumentException e) {
            logger.debug(""The new version of updated rule '{}' is invalid"", uid, e);
        }
    }

    /**
     * This method serves to resolve and normalize the {@link Rule}s configuration values and its module configurations.
     *
     * @param rule the {@link Rule}, whose configuration values and module configuration values should be resolved and
     *             normalized.
     */
    private void resolveConfigurations(Rule rule) {
        List<ConfigDescriptionParameter> configDescriptions = rule.getConfigurationDescriptions();
        Configuration configuration = rule.getConfiguration();
        ConfigurationNormalizer.normalizeConfiguration(configuration,
                ConfigurationNormalizer.getConfigDescriptionMap(configDescriptions));
        Map<String, Object> configurationProperties = configuration.getProperties();
        if (rule.getTemplateUID() == null) {
            String uid = rule.getUID();
            try {
                validateConfiguration(configDescriptions, new HashMap<>(configurationProperties));
                resolveModuleConfigReferences(rule.getModules(), configurationProperties);
                ConfigurationNormalizer.normalizeModuleConfigurations(rule.getModules(), moduleTypeRegistry);
            } catch (IllegalArgumentException e) {
                throw new IllegalArgumentException(String.format(""The rule '%s' has incorrect configurations"", uid), e);
            }
        }
    }

    /**
     * This method serves to validate the {@link Rule}s configuration values.
     *
     * @param rule the {@link Rule}, whose configuration values should be validated.
     */
    private void validateConfiguration(List<ConfigDescriptionParameter> configDescriptions,
            Map<String, Object> configurations) {
        if (configurations == null || configurations.isEmpty()) {
            if (isOptionalConfig(configDescriptions)) {
                return;
            } else {
                StringBuffer statusDescription = new StringBuffer();
                String msg = "" '%s';"";
                for (ConfigDescriptionParameter configParameter : configDescriptions) {
                    if (configParameter.isRequired()) {
                        String name = configParameter.getName();
                        statusDescription.append(String.format(msg, name));
                    }
                }
                throw new IllegalArgumentException(
                        ""Missing required configuration properties: "" + statusDescription.toString());
            }
        } else {
            for (ConfigDescriptionParameter configParameter : configDescriptions) {
                String configParameterName = configParameter.getName();
                processValue(configurations.remove(configParameterName), configParameter);
            }
            if (!configurations.isEmpty()) {
                StringBuffer statusDescription = new StringBuffer();
                String msg = "" '%s';"";
                for (String name : configurations.keySet()) {
                    statusDescription.append(String.format(msg, name));
                }
                throw new IllegalArgumentException(""Extra configuration properties: "" + statusDescription.toString());
            }
        }
    }

    /**
     * Utility method for {@link Rule}s configuration validation.
     *
     * @param configDescriptions the meta-data for {@link Rule}s configuration, used for validation.
     * @return {@code true} if all configuration properties are optional or {@code false} if there is at least one
     *         required property.
     */
    private boolean isOptionalConfig(List<ConfigDescriptionParameter> configDescriptions) {
        if (configDescriptions != null && !configDescriptions.isEmpty()) {
            boolean required = false;
            Iterator<ConfigDescriptionParameter> i = configDescriptions.iterator();
            while (i.hasNext()) {
                ConfigDescriptionParameter param = i.next();
                required = required || param.isRequired();
            }
            return !required;
        }
        return true;
    }

    /**
     * Utility method for {@link Rule}s configuration validation. Validates the value of a configuration property.
     *
     * @param configValue     the value for {@link Rule}s configuration property, that should be validated.
     * @param configParameter the meta-data for {@link Rule}s configuration value, used for validation.
     */
    private void processValue(Object configValue, ConfigDescriptionParameter configParameter) {
        if (configValue != null) {
            Type type = configParameter.getType();
            if (configParameter.isMultiple()) {
                if (configValue instanceof List) {
                    @SuppressWarnings(""rawtypes"")
                    List lConfigValues = (List) configValue;
                    for (Object value : lConfigValues) {
                        if (!checkType(type, value)) {
                            throw new IllegalArgumentException(""Unexpected value for configuration property \""""
                                    + configParameter.getName() + ""\"". Expected type: "" + type);
                        }
                    }
                } else {
                    throw new IllegalArgumentException(
                            ""Unexpected value for configuration property \"""" + configParameter.getName()
                                    + ""\"". Expected is Array with type for elements : "" + type.toString() + ""!"");
                }
            } else if (!checkType(type, configValue)) {
                throw new IllegalArgumentException(""Unexpected value for configuration property \""""
                        + configParameter.getName() + ""\"". Expected is "" + type.toString() + ""!"");
            }
        } else if (configParameter.isRequired()) {
            throw new IllegalArgumentException(
                    ""Required configuration property missing: \"""" + configParameter.getName() + ""\""!"");
        }
    }

    /**
     * Avoid code duplication in {@link #processValue(Object, ConfigDescriptionParameter)} method.
     *
     * @param type        the {@link Type} of a parameter that should be checked.
     * @param configValue the value of a parameter that should be checked.
     * @return <code>true</code> if the type and value matching or <code>false</code> in the opposite.
     */
    private boolean checkType(Type type, Object configValue) {
        switch (type) {
            case TEXT:
                return configValue instanceof String;
            case BOOLEAN:
                return configValue instanceof Boolean;
            case INTEGER:
                return configValue instanceof BigDecimal || configValue instanceof Integer
                        || configValue instanceof Double && ((Double) configValue).intValue() == (Double) configValue;
            case DECIMAL:
                return configValue instanceof BigDecimal || configValue instanceof Double;
        }
        return false;
    }

    /**
     * This method serves to replace module configuration references with the {@link Rule}s configuration values.
     *
     * @param modules           the {@link Rule}'s modules, whose configuration values should be resolved.
     * @param ruleConfiguration the {@link Rule}'s configuration values that should be resolve module configuration
     *                          values.
     */
    private void resolveModuleConfigReferences(List<? extends Module> modules, Map<String, ?> ruleConfiguration) {
        if (modules != null) {
            StringBuffer statusDescription = new StringBuffer();
            for (Module module : modules) {
                try {
                    ReferenceResolver.updateConfiguration(module.getConfiguration(), ruleConfiguration, logger);
                } catch (IllegalArgumentException e) {
                    statusDescription.append("" in module["" + module.getId() + ""]: "" + e.getLocalizedMessage() + "";"");
                }
            }
            String statusDescriptionStr = statusDescription.toString();
            if (!statusDescriptionStr.isEmpty()) {
                throw new IllegalArgumentException(String.format(""Incorrect configurations: %s"", statusDescriptionStr));
            }
        }
    }

    @Override
    public void added(RuleTemplate element) {
        String templateUID = element.getUID();
        Set<String> rules = new HashSet<String>();
        synchronized (this) {
            Set<String> rulesForResolving = mapTemplateToRules.get(templateUID);
            if (rulesForResolving != null) {
                rules.addAll(rulesForResolving);
            }
        }
        for (String rUID : rules) {
            try {
                Rule unresolvedRule = get(rUID);
                Rule resolvedRule = resolveRuleByTemplate(unresolvedRule);
                Provider<Rule> provider = getProvider(rUID);
                if (provider instanceof ManagedRuleProvider) {
                    update(resolvedRule);
                } else {
                    updated(provider, unresolvedRule, unresolvedRule);
                }
            } catch (IllegalArgumentException e) {
                logger.error(""Resolving the rule '{}' by template '{}' failed"", rUID, templateUID, e);
            }
        }
    }

    @Override
    public void removed(RuleTemplate element) {
        // Do nothing - resolved rules are independent from templates
    }

    @Override
    public void updated(RuleTemplate oldElement, RuleTemplate element) {
        // Do nothing - resolved rules are independent from templates
    }

    /**
     * Getter for {@link #scheduleReinitializationDelay} used by {@link RuleEngineImpl} to schedule rule's
     * re-initialization
     * tries.
     *
     * @return the {@link #scheduleReinitializationDelay}.
     */
    long getScheduleReinitializationDelay() {
        return scheduleReinitializationDelay;
    }

}
",blob
1229,"public interface MetricsIndexerSource extends BaseSource {
  // Metrics2 and JMX constants
  String METRICS_NAME = ""PhoenixIndexer"";
  String METRICS_CONTEXT = ""phoenix"";
  String METRICS_DESCRIPTION = ""Metrics about the Phoenix Indexer"";
  String METRICS_JMX_CONTEXT = ""RegionServer,sub="" + METRICS_NAME;

  String INDEX_PREPARE_TIME = ""indexPrepareTime"";
  String INDEX_PREPARE_TIME_DESC = ""Histogram for the time in milliseconds for preparing an index write"";
  String SLOW_INDEX_PREPARE = ""slowIndexPrepareCalls"";
  String SLOW_INDEX_PREPARE_DESC = ""The number of index preparations slower than the configured threshold"";

  String INDEX_WRITE_TIME = ""indexWriteTime"";
  String INDEX_WRITE_TIME_DESC = ""Histogram for the time in milliseconds for writing an index update"";
  String SLOW_INDEX_WRITE = ""slowIndexWriteCalls"";
  String SLOW_INDEX_WRITE_DESC = ""The number of index writes slower than the configured threshold"";

  String DUPLICATE_KEY_TIME = ""duplicateKeyCheckTime"";
  String DUPLICATE_KEY_TIME_DESC = ""Histogram for the time in milliseconds to handle ON DUPLICATE keywords"";
  String SLOW_DUPLICATE_KEY = ""slowDuplicateKeyCheckCalls"";
  String SLOW_DUPLICATE_KEY_DESC = ""The number of on duplicate key checks slower than the configured threshold"";

  String PRE_WAL_RESTORE_TIME = ""preWALRestoreTime"";
  String PRE_WAL_RESTORE_TIME_DESC = ""Histogram for the time in milliseconds for Indexer's preWALRestore"";
  String SLOW_PRE_WAL_RESTORE = ""slowPreWALRestoreCalls"";
  String SLOW_PRE_WAL_RESTORE_DESC = ""The number of preWALRestore calls slower than the configured threshold"";

  String POST_PUT_TIME = ""postPutTime"";
  String POST_PUT_TIME_DESC = ""Histogram for the time in milliseconds for Indexer's postPut"";
  String SLOW_POST_PUT = ""slowPostPutCalls"";
  String SLOW_POST_PUT_DESC = ""The number of postPut calls slower than the configured threshold"";

  String POST_DELETE_TIME = ""postDeleteTime"";
  String POST_DELETE_TIME_DESC = ""Histogram for the time in milliseconds for Indexer's postDelete"";
  String SLOW_POST_DELETE = ""slowPostDeleteCalls"";
  String SLOW_POST_DELETE_DESC = ""The number of postDelete calls slower than the configured threshold"";

  String POST_OPEN_TIME = ""postOpenTime"";
  String POST_OPEN_TIME_DESC = ""Histogram for the time in milliseconds for Indexer's postOpen"";
  String SLOW_POST_OPEN = ""slowPostOpenCalls"";
  String SLOW_POST_OPEN_DESC = ""The number of postOpen calls slower than the configured threshold"";

  /**
   * Updates the index preparation time histogram (preBatchMutate).
   *
   * @param t time taken in milliseconds
   */
  void updateIndexPrepareTime(long t);

  /**
   * Increments the number of slow calls prepare an index write.
   */
  void incrementNumSlowIndexPrepareCalls();

  /**
   * Updates the index write time histogram (postBatchMutate).
   *
   * @param t time taken in milliseconds
   */
  void updateIndexWriteTime(long t);

  /**
   * Increments the number of slow calls to write to the index.
   */
  void incrementNumSlowIndexWriteCalls();

  /**
   * Updates the preWALRestore time histogram.
   *
   * @param t time taken in milliseconds
   */
  void updatePreWALRestoreTime(long t);

  /**
   * Increments the number of slow preWALRestore calls.
   */
  void incrementNumSlowPreWALRestoreCalls();

  /**
   * Updates the postPut time histogram.
   *
   * @param t time taken in milliseconds
   */
  void updatePostPutTime(long t);

  /**
   * Increments the number of slow postPut calls.
   */
  void incrementNumSlowPostPutCalls();

  /**
   * Updates the postDelete time histogram.
   *
   * @param t time taken in milliseconds
   */
  void updatePostDeleteTime(long t);

  /**
   * Increments the number of slow postDelete calls.
   */
  void incrementNumSlowPostDeleteCalls();

  /**
   * Updates the postOpen time histogram.
   *
   * @param t time taken in milliseconds
   */
  void updatePostOpenTime(long t);

  /**
   * Increments the number of slow postOpen calls.
   */
  void incrementNumSlowPostOpenCalls();

  /**
   * Updates the preIncrementAfterRowLock time histogram.
   *
   * @param t time taken in milliseconds
   */
  void updateDuplicateKeyCheckTime(long t);

  /**
   * Increments the number of slow preIncrementAfteRowLock calls.
   */
  void incrementSlowDuplicateKeyCheckCalls();
}
",data class
656,"public class ConstraintBasePanel extends FormComponentPanel
{
    /** Default serialVersionUID */
    private static final long serialVersionUID = 1L;
    private static final String CLS_NM = ConstraintPanel.class.getName();
    private static final Logger log = Logger.getLogger( CLS_NM );

    protected static final String TIMEOUT = ""timeout"";
    protected static final String SUNDAY = ""sunday"";
    protected static final String MONDAY = ""monday"";
    protected static final String TUESDAY = ""tuesday"";
    protected static final String WEDNESDAY = ""wednesday"";
    protected static final String THURSDAY = ""thursday"";
    protected static final String FRIDAY = ""friday"";
    protected static final String SATURDAY = ""saturday"";

    protected static final String BEGIN_TIME = ""beginTime"";
    protected static final String END_TIME = ""endTime"";
    protected static final String BEGIN_DATE = ""beginDate"";
    protected static final String END_DATE = ""endDate"";
    protected static final String BEGIN_LOCK_DATE = ""beginLockDate"";
    protected static final String END_LOCK_DATE = ""endLockDate"";

    protected static final String DAY1 = ""1"";
    protected static final String DAY2 = ""2"";
    protected static final String DAY3 = ""3"";
    protected static final String DAY4 = ""4"";
    protected static final String DAY5 = ""5"";
    protected static final String DAY6 = ""6"";
    protected static final String DAY7 = ""7"";
    // These are used by this panel component's PropertyModel objects:

    protected Date beginTime;
    protected Date beginDate;
    protected Date endTime;
    protected Date endDate;
    protected Date beginLockDate;
    protected Date endLockDate;

    // These are the actual Wicket JQuery controls to process the input:
    protected TimePicker beginTimeTP;
    protected TimePicker endTimeTP;
    protected DatePicker beginDateDP;
    protected DatePicker endDateDP;
    protected DatePicker beginLockDateDP;
    protected DatePicker endLockDateDP;

    // The Wicket checkBoxes are used for constructing a {@link us.uts.fortress.rbac.User#dayMask} entity attribute into model model:
    protected CheckBox sundayCB;
    protected CheckBox mondayCB;
    protected CheckBox tuesdayCB;
    protected CheckBox wednesdayCB;
    protected CheckBox thursdayCB;
    protected CheckBox fridayCB;
    protected CheckBox saturdayCB;

    // These are used by CheckBox control to store the dayMask fields until mapped to {@link us.uts.fortress.rbac.User#dayMask} into model object:
    protected Boolean sunday = false;
    protected Boolean monday = false;
    protected Boolean tuesday = false;
    protected Boolean wednesday = false;
    protected Boolean thursday = false;
    protected Boolean friday = false;
    protected Boolean saturday = false;


    public ConstraintBasePanel( String id, final IModel constraint )
    {
        super( id, constraint );
        final Spinner<Integer> timeout = new Spinner<>( TIMEOUT );
        timeout.setRequired( false );
        add( timeout );

        // Add the dayMask's day of week CheckBoxes:
        sundayCB = new CheckBox( SUNDAY, new PropertyModel<Boolean>( this, SUNDAY ) )
        {
            /** Default serialVersionUID */
            private static final long serialVersionUID = 1L;


            @Override
            protected void onBeforeRender()
            {
                if ( this.getParent().getDefaultModelObject() != null )
                {
                    super.onBeforeRender();
                    Constraint constraint = ( Constraint ) this.getParent().getDefaultModelObject();
                    setSunday( isDayOfWeek( constraint, DAY1 ) );
                }
            }
        };
        add( sundayCB );
        mondayCB = new CheckBox( ""monday"", new PropertyModel<Boolean>( this, MONDAY ) )
        {
            /** Default serialVersionUID */
            private static final long serialVersionUID = 1L;


            @Override
            protected void onBeforeRender()
            {
                if ( this.getParent().getDefaultModelObject() != null )
                {
                    super.onBeforeRender();
                    Constraint constraint = ( Constraint ) this.getParent().getDefaultModelObject();
                    setMonday( isDayOfWeek( constraint, DAY2 ) );
                }
            }
        };
        add( mondayCB );
        tuesdayCB = new CheckBox( TUESDAY, new PropertyModel<Boolean>( this, TUESDAY ) )
        {
            /** Default serialVersionUID */
            private static final long serialVersionUID = 1L;


            @Override
            protected void onBeforeRender()
            {
                if ( this.getParent().getDefaultModelObject() != null )
                {
                    super.onBeforeRender();
                    Constraint constraint = ( Constraint ) this.getParent().getDefaultModelObject();
                    setTuesday( isDayOfWeek( constraint, DAY3 ) );
                }
            }
        };
        add( tuesdayCB );
        wednesdayCB = new CheckBox( WEDNESDAY, new PropertyModel<Boolean>( this, WEDNESDAY ) )
        {
            /** Default serialVersionUID */
            private static final long serialVersionUID = 1L;


            @Override
            protected void onBeforeRender()
            {
                if ( this.getParent().getDefaultModelObject() != null )
                {
                    super.onBeforeRender();
                    Constraint constraint = ( Constraint ) this.getParent().getDefaultModelObject();
                    setWednesday( isDayOfWeek( constraint, DAY4 ) );
                }
            }
        };
        add( wednesdayCB );
        thursdayCB = new CheckBox( THURSDAY, new PropertyModel<Boolean>( this, THURSDAY ) )
        {
            /** Default serialVersionUID */
            private static final long serialVersionUID = 1L;


            @Override
            protected void onBeforeRender()
            {
                if ( this.getParent().getDefaultModelObject() != null )
                {
                    super.onBeforeRender();
                    Constraint constraint = ( Constraint ) this.getParent().getDefaultModelObject();
                    setThursday( isDayOfWeek( constraint, DAY5 ) );
                }
            }
        };
        add( thursdayCB );
        fridayCB = new CheckBox( FRIDAY, new PropertyModel<Boolean>( this, FRIDAY ) )
        {
            /** Default serialVersionUID */
            private static final long serialVersionUID = 1L;


            @Override
            protected void onBeforeRender()
            {
                if ( this.getParent().getDefaultModelObject() != null )
                {
                    super.onBeforeRender();
                    Constraint constraint = ( Constraint ) this.getParent().getDefaultModelObject();
                    setFriday( isDayOfWeek( constraint, DAY6 ) );
                }
            }
        };
        add( fridayCB );
        saturdayCB = new CheckBox( SATURDAY, new PropertyModel<Boolean>( this, SATURDAY ) )
        {
            /** Default serialVersionUID */
            private static final long serialVersionUID = 1L;


            @Override
            protected void onBeforeRender()
            {
                if ( this.getParent().getDefaultModelObject() != null )
                {
                    super.onBeforeRender();
                    Constraint constraint = ( Constraint ) this.getParent().getDefaultModelObject();
                    setSaturday( isDayOfWeek( constraint, DAY7 ) );
                }
            }
        };
        add( saturdayCB );
    }


    /**
     * This method is used to convert from the panel component model to the domain model:
     */
    @Override
    public void convertInput()
    {
        Constraint constraint = ( Constraint ) getDefaultModelObject();
        if ( constraint != null )
        {
            constraint.setBeginTime( convertTime( beginTimeTP ) );
            constraint.setEndTime( convertTime( endTimeTP ) );
            constraint.setBeginDate( convertDate( beginDateDP ) );
            constraint.setEndDate( convertDate( endDateDP ) );
            constraint.setBeginLockDate( convertDate( beginLockDateDP ) );
            constraint.setEndLockDate( convertDate( endLockDateDP ) );

            setSunday( sundayCB.getConvertedInput() );
            setMonday( mondayCB.getConvertedInput() );
            setTuesday( tuesdayCB.getConvertedInput() );
            setWednesday( wednesdayCB.getConvertedInput() );
            setThursday( thursdayCB.getConvertedInput() );
            setFriday( fridayCB.getConvertedInput() );
            setSaturday( saturdayCB.getConvertedInput() );

            String szDayMask = """";
            if ( sunday )
                szDayMask += DAY1;
            if ( monday )
                szDayMask += DAY2;
            if ( tuesday )
                szDayMask += DAY3;
            if ( wednesday )
                szDayMask += DAY4;
            if ( thursday )
                szDayMask += DAY5;
            if ( friday )
                szDayMask += DAY6;
            if ( saturday )
                szDayMask += DAY7;

            constraint.setDayMask( szDayMask );
            setConvertedInput( constraint );
        }
        else
        {
            log.warn( ""constraint was null"" );
        }
    }


    protected boolean isDayOfWeek( Constraint constraint, String szDay )
    {
        boolean isSet = false;
        if ( constraint != null && constraint.getDayMask() != null
            && ( constraint.getDayMask().contains( szDay ) || constraint.getDayMask().equals( ""all"" ) ) )
        {
            isSet = true;
        }
        return isSet;
    }


    protected String convertTime( TimePicker time )
    {
        String szTime = null;
        if ( time != null )
        {
            Date localDate = time.getConvertedInput();
            if ( localDate != null )
            {
                Calendar calendar = Calendar.getInstance();
                calendar.setTime( localDate );
                log.debug( ""localDate="" + localDate.toString() );
                if ( calendar.get( Calendar.HOUR_OF_DAY ) < 10 )
                    szTime = ""0"" + calendar.get( Calendar.HOUR_OF_DAY );
                else
                    szTime = """" + calendar.get( Calendar.HOUR_OF_DAY );
                if ( calendar.get( Calendar.MINUTE ) < 10 )
                    szTime += ""0"" + calendar.get( Calendar.MINUTE );
                else
                    szTime += """" + calendar.get( Calendar.MINUTE );
            }
        }
        return szTime;
    }


    protected String convertDate( DatePicker date )
    {
        String szDate = null;
        if ( date != null )
        {
            Date localDate = date.getConvertedInput();
            if ( localDate != null )
            {
                Calendar calendar = Calendar.getInstance();
                calendar.setTime( localDate );
                log.debug( ""localDate="" + localDate.toString() );
                szDate = """" + calendar.get( Calendar.YEAR );

                if ( ( calendar.get( Calendar.MONTH ) + 1 ) < 10 )
                    szDate += ""0"" + ( calendar.get( Calendar.MONTH ) + 1 );
                else
                    szDate += """" + ( calendar.get( Calendar.MONTH ) + 1 );
                if ( calendar.get( Calendar.DAY_OF_MONTH ) < 10 )
                    szDate += ""0"" + calendar.get( Calendar.DAY_OF_MONTH );
                else
                    szDate += """" + calendar.get( Calendar.DAY_OF_MONTH );
            }
        }
        return szDate;
    }


    protected Date renderTime( Date date, String szTime )
    {
        if ( szTime != null )
        {
            Calendar calendar = Calendar.getInstance();
            try
            {
                int hours = Integer.valueOf( szTime.substring( 0, 2 ) );
                int minutes = Integer.valueOf( szTime.substring( 2, 4 ) );
                // zero hours convert to 24 for calendar:
                if(hours == 0)
                {
                    hours = 24;
                }
                calendar.set( 0, 0, 0, hours, minutes );
                date = calendar.getTime();
            }
            catch ( StringIndexOutOfBoundsException e )
            {
                String warning = CLS_NM + "".renderTime bad time: "" + szTime;
                log.warn( warning );
                //warn(warning);
            }
        }
        else
        {
            date = null;
        }
        return date;
    }


    protected Date renderDate( Date date, String szDate )
    {
        if ( szDate != null && !szDate.equalsIgnoreCase( ""none"" ) )
        {
            Calendar calendar = Calendar.getInstance();
            try
            {
                int years = Integer.valueOf( szDate.substring( 0, 4 ) );
                int months = Integer.valueOf( szDate.substring( 4, 6 ) );
                // Convert months because the Calendar uses 0 - 11:
                months = months - 1;
                int days = Integer.valueOf( szDate.substring( 6, 8 ) );
                calendar.set( years, months, days, 0, 0 );
                date = calendar.getTime();
            }
            catch ( StringIndexOutOfBoundsException e )
            {
                String warning = CLS_NM + "".renderDate bad date: "" + szDate;
                log.warn( warning );
                //warn(warning);
            }
        }
        else
        {
            date = null;
        }
        return date;
    }


    protected Boolean getSunday()
    {
        return sunday;
    }


    protected void setSunday( Boolean sunday )
    {
        this.sunday = sunday;
    }


    protected Boolean getMonday()
    {
        return monday;
    }


    protected void setMonday( Boolean monday )
    {
        this.monday = monday;
    }


    protected Boolean getTuesday()
    {
        return tuesday;
    }


    protected void setTuesday( Boolean tuesday )
    {
        this.tuesday = tuesday;
    }


    protected Boolean getWednesday()
    {
        return wednesday;
    }


    protected void setWednesday( Boolean wednesday )
    {
        this.wednesday = wednesday;
    }


    protected Boolean getThursday()
    {
        return thursday;
    }


    protected void setThursday( Boolean thursday )
    {
        this.thursday = thursday;
    }


    protected Boolean getFriday()
    {
        return friday;
    }


    protected void setFriday( Boolean friday )
    {
        this.friday = friday;
    }


    protected Boolean getSaturday()
    {
        return saturday;
    }


    protected void setSaturday( Boolean saturday )
    {
        this.saturday = saturday;
    }
}
",data class
1242,"        Type asTuple() {
            final Type result;
            if (types.size() == 0) {
                result = unit.getEmptyType();
            } else {
                final Type sequentialType;
                if (variadic) {
                    Part part = new Part(""Sequence"", Collections.singletonList(getLast()));
                    sequentialType = loadType(""ceylon.language"", 
                            atLeastOne ? ""ceylon.language.Sequence"" : ""ceylon.language.Sequential"", 
                                    part, null);
                } else {
                    sequentialType = unit.getEmptyType();
                }
                
                if (variadic && types.size() == 1) {
                    result = sequentialType;
                } else {
                    Part part = new Part();
                    // if we're variadic we put the element type there because we skip it below
                    // if we're not variadic we are not going to skip it so let's not union it with itself
                    Type union = variadic ? getLast() : null;
                    Type tupleType = sequentialType;
                    // A,B= 
                    // union = null
                    // tupleType = []
                    // t = B
                    // union = B
                    // tupleType = [B]
                    // tupleType = [B]|[]
                    // t = A
                    // union = A|B
                    // tupleType = [A,[B]|[]]

                    // A=,B= 
                    // union = null
                    // tupleType = []
                    // t = B
                    // union = B
                    // tupleType = [B]
                    // tupleType = [B]|[]
                    // t = A
                    // union = A|B
                    // tupleType = [A,[B]|[]]
                    // tupleType = [A,[B]|[]]|[]

                    // A=,B* 
                    // union = B
                    // tupleType = [B*]
                    // t = A
                    // union = A|B
                    // tupleType = [A,[B*]]
                    // tupleType = [A,[B*]]|[]

                    int makeDefaulted = defaulted;
                    for (int ii  = types.size()-(variadic? 2 : 1); ii >= 0; ii--) {
                        Type t = types.get(ii);
                        // FIXME: subtyping in the type parser may cause issues
                        if(union != null) // any second element (variadic or not)
                            union = ModelUtil.unionType(union, t, unit);
                        else
                            union = t; // any first element
                        part.parameters = Arrays.asList(union, t, tupleType);
                        part.name = ""Tuple"";
                        tupleType = loadType(""ceylon.language"", ""ceylon.language.Tuple"", part, null);
                        if(makeDefaulted > 0){
                            makeDefaulted--;
                            tupleType = union(Arrays.asList(unit.getEmptyType(), tupleType), unit);
                        }
                    }
                    result = tupleType;
                }
            }
            return result;
        }
",long method
333,"public interface IAopReferenceModel {
	
	void start();

	void shutdown();

	void removeProject(IJavaProject project);

	void addProject(IJavaProject project, IAopProject aopProject);

	void fireModelChanged();

	List<IAopReference> getAdviceDefinition(IJavaElement je);

	List<IAopReference> getAllReferences();
	
	List<IAopReference> getAllReferencesForResource(IResource resource);

	IAopProject getProject(IJavaProject project);
	
	Collection<IAopProject> getProjects();

	boolean isAdvice(IJavaElement je);

	boolean isAdvised(IJavaElement je);
	
	boolean isAdvised(IBean bean);

	void registerAopModelChangedListener(IAopModelChangedListener listener);

	void unregisterAopModelChangedListener(IAopModelChangedListener listener);
	
	void clearProjects();

}
",data class
1256,"public class _BuildWebServiceSoap_UpdateBuildDefinitions
    implements ElementSerializable
{
    // No attributes    

    // Elements
    protected _BuildDefinition[] updates;

    public _BuildWebServiceSoap_UpdateBuildDefinitions()
    {
        super();
    }

    public _BuildWebServiceSoap_UpdateBuildDefinitions(final _BuildDefinition[] updates)
    {
        // TODO : Call super() instead of setting all fields directly?
        setUpdates(updates);
    }

    public _BuildDefinition[] getUpdates()
    {
        return this.updates;
    }

    public void setUpdates(_BuildDefinition[] value)
    {
        this.updates = value;
    }

    public void writeAsElement(
        final XMLStreamWriter writer,
        final String name)
        throws XMLStreamException
    {
        writer.writeStartElement(name);

        // Elements
        if (this.updates != null)
        {
            /*
             * The element type is an array.
             */
            writer.writeStartElement(""updates"");

            for (int iterator0 = 0; iterator0 < this.updates.length; iterator0++)
            {
                this.updates[iterator0].writeAsElement(
                    writer,
                    ""BuildDefinition"");
            }

            writer.writeEndElement();
        }

        writer.writeEndElement();
    }
}
",blob
1188,"public class SageRuntimeException extends RuntimeException implements SageExceptable
{
  protected final int kind;


  public SageRuntimeException()
  {
    kind = UNKNOWN;
  }

  public SageRuntimeException(String message, int kind)
  {
    super(message);

    this.kind = kind;
  }

  public SageRuntimeException(Throwable cause, int kind)
  {
    super(cause);

    this.kind = kind;
  }

  public SageRuntimeException(String message, Throwable cause, int kind)
  {
    super(message, cause);

    this.kind = kind;
  }

  public int getKind()
  {
    return (kind);
  }

  public boolean isKind(int kind)
  {
    return ((this.kind & kind) != 0);
  }

  public String getMessage()
  {
    return (""kind="" + kind + ""; "" + super.getMessage());
  }
}
",data class
1120,"public class Socket {

    /* Standard socket defines */
    public static final int SOCK_STREAM = 0;
    public static final int SOCK_DGRAM  = 1;
    /*
     * apr_sockopt Socket option definitions
     */
    public static final int APR_SO_LINGER       = 1;    /** Linger */
    public static final int APR_SO_KEEPALIVE    = 2;    /** Keepalive */
    public static final int APR_SO_DEBUG        = 4;    /** Debug */
    public static final int APR_SO_NONBLOCK     = 8;    /** Non-blocking IO */
    public static final int APR_SO_REUSEADDR    = 16;   /** Reuse addresses */
    public static final int APR_SO_SNDBUF       = 64;   /** Send buffer */
    public static final int APR_SO_RCVBUF       = 128;  /** Receive buffer */
    public static final int APR_SO_DISCONNECTED = 256;  /** Disconnected */
    /** For SCTP sockets, this is mapped to STCP_NODELAY internally. */
    public static final int APR_TCP_NODELAY     = 512;
    public static final int APR_TCP_NOPUSH      = 1024; /** No push */
    /** This flag is ONLY set internally when we set APR_TCP_NOPUSH with
     * APR_TCP_NODELAY set to tell us that APR_TCP_NODELAY should be turned on
     * again when NOPUSH is turned off
     */
    public static final int APR_RESET_NODELAY   = 2048;
    /** Set on non-blocking sockets (timeout != 0) on which the
     * previous read() did not fill a buffer completely.  the next
     * apr_socket_recv()  will first call select()/poll() rather than
     * going straight into read().  (Can also be set by an application to
     * force a select()/poll() call before the next read, in cases where
     * the app expects that an immediate read would fail.)
     */
    public static final int APR_INCOMPLETE_READ = 4096;
    /** like APR_INCOMPLETE_READ, but for write
     */
    public static final int APR_INCOMPLETE_WRITE = 8192;
    /** Don't accept IPv4 connections on an IPv6 listening socket.
     */
    public static final int APR_IPV6_V6ONLY      = 16384;
    /** Delay accepting of new connections until data is available.
     */
    public static final int APR_TCP_DEFER_ACCEPT = 32768;

    /** Define what type of socket shutdown should occur.
     * apr_shutdown_how_e enum
     */
    public static final int APR_SHUTDOWN_READ      = 0; /** no longer allow read request */
    public static final int APR_SHUTDOWN_WRITE     = 1; /** no longer allow write requests */
    public static final int APR_SHUTDOWN_READWRITE = 2; /** no longer allow read or write requests */

    public static final int APR_IPV4_ADDR_OK = 0x01;
    public static final int APR_IPV6_ADDR_OK = 0x02;

    public static final int APR_UNSPEC = 0;
    public static final int APR_INET   = 1;
    public static final int APR_INET6  = 2;

    public static final int APR_PROTO_TCP  =   6; /** TCP  */
    public static final int APR_PROTO_UDP  =  17; /** UDP  */
    public static final int APR_PROTO_SCTP = 132; /** SCTP */

    /**
     * Enum to tell us if we're interested in remote or local socket
     * apr_interface_e
     */
    public static final int APR_LOCAL  = 0;
    public static final int APR_REMOTE = 1;

    /* Socket.get types */
    public static final int SOCKET_GET_POOL = 0;
    public static final int SOCKET_GET_IMPL = 1;
    public static final int SOCKET_GET_APRS = 2;
    public static final int SOCKET_GET_TYPE = 3;

    /**
     * Create a socket.
     * @param family The address family of the socket (e.g., APR_INET).
     * @param type The type of the socket (e.g., SOCK_STREAM).
     * @param protocol The protocol of the socket (e.g., APR_PROTO_TCP).
     * @param cont The parent pool to use
     * @return The new socket that has been set up.
     * @throws Exception Error creating socket
     */
    public static native long create(int family, int type,
                                     int protocol, long cont)
        throws Exception;


    /**
     * Shutdown either reading, writing, or both sides of a socket.
     * <br>
     * This does not actually close the socket descriptor, it just
     *      controls which calls are still valid on the socket.
     * @param thesocket The socket to close
     * @param how How to shutdown the socket.  One of:
     * <PRE>
     * APR_SHUTDOWN_READ         no longer allow read requests
     * APR_SHUTDOWN_WRITE        no longer allow write requests
     * APR_SHUTDOWN_READWRITE    no longer allow read or write requests
     * </PRE>
     * @return the operation status
     */
    public static native int shutdown(long thesocket, int how);

    /**
     * Close a socket.
     * @param thesocket The socket to close
     * @return the operation status
     */
    public static native int close(long thesocket);

    /**
     * Destroy a pool associated with socket
     * @param thesocket The destroy
     */
    public static native void destroy(long thesocket);

    /**
     * Bind the socket to its associated port
     * @param sock The socket to bind
     * @param sa The socket address to bind to
     * This may be where we will find out if there is any other process
     *      using the selected port.
     * @return the operation status
     */
    public static native int bind(long sock, long sa);

    /**
     * Listen to a bound socket for connections.
     * @param sock The socket to listen on
     * @param backlog The number of outstanding connections allowed in the sockets
     *                listen queue.  If this value is less than zero, the listen
     *                queue size is set to zero.
     * @return the operation status
     */
    public static native int listen(long sock, int backlog);

    /**
     * Accept a new connection request
     * @param sock The socket we are listening on.
     * @param pool The pool for the new socket.
     * @return  A copy of the socket that is connected to the socket that
     *          made the connection request.  This is the socket which should
     *          be used for all future communication.
     * @throws Exception Socket accept error
     */
    public static native long acceptx(long sock, long pool)
        throws Exception;

    /**
     * Accept a new connection request
     * @param sock The socket we are listening on.
     * @return  A copy of the socket that is connected to the socket that
     *          made the connection request.  This is the socket which should
     *          be used for all future communication.
     * @throws Exception Socket accept error
     */
    public static native long accept(long sock)
        throws Exception;

    /**
     * Set an OS level accept filter.
     * @param sock The socket to put the accept filter on.
     * @param name The accept filter
     * @param args Any extra args to the accept filter.  Passing NULL here removes
     *             the accept filter.
     * @return the operation status
     */
    public static native int acceptfilter(long sock, String name, String args);

    /**
     * Query the specified socket if at the OOB/Urgent data mark
     * @param sock The socket to query
     * @return <code>true</code> if socket is at the OOB/urgent mark,
     *         otherwise <code>false</code>.
     */
    public static native boolean atmark(long sock);

    /**
     * Issue a connection request to a socket either on the same machine
     * or a different one.
     * @param sock The socket we wish to use for our side of the connection
     * @param sa The address of the machine we wish to connect to.
     * @return the operation status
     */
    public static native int connect(long sock, long sa);

    /**
     * Send data over a network.
     * <PRE>
     * This functions acts like a blocking write by default.  To change
     * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK
     * socket option.
     *
     * It is possible for both bytes to be sent and an error to be returned.
     *
     * APR_EINTR is never returned.
     * </PRE>
     * @param sock The socket to send the data over.
     * @param buf The buffer which contains the data to be sent.
     * @param offset Offset in the byte buffer.
     * @param len The number of bytes to write; (-1) for full array.
     * @return The number of bytes sent
     */
    public static native int send(long sock, byte[] buf, int offset, int len);

    /**
     * Send data over a network.
     * <PRE>
     * This functions acts like a blocking write by default.  To change
     * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK
     * socket option.
     *
     * It is possible for both bytes to be sent and an error to be returned.
     *
     * APR_EINTR is never returned.
     * </PRE>
     * @param sock The socket to send the data over.
     * @param buf The Byte buffer which contains the data to be sent.
     * @param offset The offset within the buffer array of the first buffer from
     *               which bytes are to be retrieved; must be non-negative
     *               and no larger than buf.length
     * @param len The maximum number of buffers to be accessed; must be non-negative
     *            and no larger than buf.length - offset
     * @return The number of bytes sent
     */
    public static native int sendb(long sock, ByteBuffer buf,
                                   int offset, int len);

    /**
     * Send data over a network without retry
     * <PRE>
     * This functions acts like a blocking write by default.  To change
     * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK
     * socket option.
     *
     * It is possible for both bytes to be sent and an error to be returned.
     *
     * </PRE>
     * @param sock The socket to send the data over.
     * @param buf The Byte buffer which contains the data to be sent.
     * @param offset The offset within the buffer array of the first buffer from
     *               which bytes are to be retrieved; must be non-negative
     *               and no larger than buf.length
     * @param len The maximum number of buffers to be accessed; must be non-negative
     *            and no larger than buf.length - offset
     * @return The number of bytes sent
     */
    public static native int sendib(long sock, ByteBuffer buf,
                                    int offset, int len);

    /**
     * Send data over a network using internally set ByteBuffer
     * @param sock The socket to send the data over.
     * @param offset The offset within the buffer array of the first buffer from
     *               which bytes are to be retrieved; must be non-negative
     *               and no larger than buf.length
     * @param len The maximum number of buffers to be accessed; must be non-negative
     *            and no larger than buf.length - offset
     * @return The number of bytes sent
     */
    public static native int sendbb(long sock,
                                   int offset, int len);

    /**
     * Send data over a network using internally set ByteBuffer
     * without internal retry.
     * @param sock The socket to send the data over.
     * @param offset The offset within the buffer array of the first buffer from
     *               which bytes are to be retrieved; must be non-negative
     *               and no larger than buf.length
     * @param len The maximum number of buffers to be accessed; must be non-negative
     *            and no larger than buf.length - offset
     * @return The number of bytes sent
     */
    public static native int sendibb(long sock,
                                     int offset, int len);

    /**
     * Send multiple packets of data over a network.
     * <PRE>
     * This functions acts like a blocking write by default.  To change
     * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK
     * socket option.
     * The number of bytes actually sent is stored in argument 3.
     *
     * It is possible for both bytes to be sent and an error to be returned.
     *
     * APR_EINTR is never returned.
     * </PRE>
     * @param sock The socket to send the data over.
     * @param vec The array from which to get the data to send.
     * @return The number of bytes sent
     */
    public static native int sendv(long sock, byte[][] vec);

    /**
     * @param sock The socket to send from
     * @param where The apr_sockaddr_t describing where to send the data
     * @param flags The flags to use
     * @param buf  The data to send
     * @param offset Offset in the byte buffer.
     * @param len  The length of the data to send
     * @return The number of bytes sent
     */
    public static native int sendto(long sock, long where, int flags,
                                    byte[] buf, int offset, int len);

    /**
     * Read data from a network.
     *
     * <PRE>
     * This functions acts like a blocking read by default.  To change
     * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK
     * socket option.
     * The number of bytes actually received is stored in argument 3.
     *
     * It is possible for both bytes to be received and an APR_EOF or
     * other error to be returned.
     *
     * APR_EINTR is never returned.
     * </PRE>
     * @param sock The socket to read the data from.
     * @param buf The buffer to store the data in.
     * @param offset Offset in the byte buffer.
     * @param nbytes The number of bytes to read (-1) for full array.
     * @return the number of bytes received.
     */
    public static native int recv(long sock, byte[] buf, int offset, int nbytes);

    /**
     * Read data from a network with timeout.
     *
     * <PRE>
     * This functions acts like a blocking read by default.  To change
     * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK
     * socket option.
     * The number of bytes actually received is stored in argument 3.
     *
     * It is possible for both bytes to be received and an APR_EOF or
     * other error to be returned.
     *
     * APR_EINTR is never returned.
     * </PRE>
     * @param sock The socket to read the data from.
     * @param buf The buffer to store the data in.
     * @param offset Offset in the byte buffer.
     * @param nbytes The number of bytes to read (-1) for full array.
     * @param timeout The socket timeout in microseconds.
     * @return the number of bytes received.
     */
    public static native int recvt(long sock, byte[] buf, int offset,
                                   int nbytes, long timeout);

    /**
     * Read data from a network.
     *
     * <PRE>
     * This functions acts like a blocking read by default.  To change
     * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK
     * socket option.
     * The number of bytes actually received is stored in argument 3.
     *
     * It is possible for both bytes to be received and an APR_EOF or
     * other error to be returned.
     *
     * APR_EINTR is never returned.
     * </PRE>
     * @param sock The socket to read the data from.
     * @param buf The buffer to store the data in.
     * @param offset Offset in the byte buffer.
     * @param nbytes The number of bytes to read (-1) for full array.
     * @return If &ge; 0, the return value is the number of bytes read. Note a
     *         non-blocking read with no data current available will return
     *         {@link Status#EAGAIN} and EOF will return {@link Status#APR_EOF}.
     */
    public static native int recvb(long sock, ByteBuffer buf,
                                   int offset, int nbytes);

    /**
     * Read data from a network using internally set ByteBuffer.
     *
     * @param sock The socket to read the data from.
     * @param offset Offset in the byte buffer.
     * @param nbytes The number of bytes to read (-1) for full array.
     * @return If &gt; 0, the return value is the number of bytes read. If == 0,
     *         the return value indicates EOF and if &lt; 0 the return value is the
     *         error code. Note a non-blocking read with no data current
     *         available will return {@link Status#EAGAIN} not zero.
     */
    public static native int recvbb(long sock,
                                    int offset, int nbytes);
    /**
     * Read data from a network with timeout.
     *
     * <PRE>
     * This functions acts like a blocking read by default.  To change
     * this behavior, use apr_socket_timeout_set() or the APR_SO_NONBLOCK
     * socket option.
     * The number of bytes actually received is stored in argument 3.
     *
     * It is possible for both bytes to be received and an APR_EOF or
     * other error to be returned.
     *
     * APR_EINTR is never returned.
     * </PRE>
     * @param sock The socket to read the data from.
     * @param buf The buffer to store the data in.
     * @param offset Offset in the byte buffer.
     * @param nbytes The number of bytes to read (-1) for full array.
     * @param timeout The socket timeout in microseconds.
     * @return the number of bytes received.
     */
    public static native int recvbt(long sock, ByteBuffer buf,
                                    int offset, int nbytes, long timeout);
    /**
     * Read data from a network with timeout using internally set ByteBuffer
     * @param sock The socket to read the data from.
     * @param offset Offset in the byte buffer.
     * @param nbytes The number of bytes to read (-1) for full array.
     * @param timeout The socket timeout in microseconds.
     * @return the number of bytes received.
     */
    public static native int recvbbt(long sock,
                                     int offset, int nbytes, long timeout);

    /**
     * @param from The apr_sockaddr_t to fill in the recipient info
     * @param sock The socket to use
     * @param flags The flags to use
     * @param buf  The buffer to use
     * @param offset Offset in the byte buffer.
     * @param nbytes The number of bytes to read (-1) for full array.
     * @return the number of bytes received.
     */
    public static native int recvfrom(long from, long sock, int flags,
                                      byte[] buf, int offset, int nbytes);

    /**
     * Setup socket options for the specified socket
     * @param sock The socket to set up.
     * @param opt The option we would like to configure.  One of:
     * <PRE>
     * APR_SO_DEBUG      --  turn on debugging information
     * APR_SO_KEEPALIVE  --  keep connections active
     * APR_SO_LINGER     --  lingers on close if data is present
     * APR_SO_NONBLOCK   --  Turns blocking on/off for socket
     *                       When this option is enabled, use
     *                       the APR_STATUS_IS_EAGAIN() macro to
     *                       see if a send or receive function
     *                       could not transfer data without
     *                       blocking.
     * APR_SO_REUSEADDR  --  The rules used in validating addresses
     *                       supplied to bind should allow reuse
     *                       of local addresses.
     * APR_SO_SNDBUF     --  Set the SendBufferSize
     * APR_SO_RCVBUF     --  Set the ReceiveBufferSize
     * </PRE>
     * @param on Value for the option.
     * @return the operation status
     */
    public static native int optSet(long sock, int opt, int on);

    /**
     * Query socket options for the specified socket
     * @param sock The socket to query
     * @param opt The option we would like to query.  One of:
     * <PRE>
     * APR_SO_DEBUG      --  turn on debugging information
     * APR_SO_KEEPALIVE  --  keep connections active
     * APR_SO_LINGER     --  lingers on close if data is present
     * APR_SO_NONBLOCK   --  Turns blocking on/off for socket
     * APR_SO_REUSEADDR  --  The rules used in validating addresses
     *                       supplied to bind should allow reuse
     *                       of local addresses.
     * APR_SO_SNDBUF     --  Set the SendBufferSize
     * APR_SO_RCVBUF     --  Set the ReceiveBufferSize
     * APR_SO_DISCONNECTED -- Query the disconnected state of the socket.
     *                       (Currently only used on Windows)
     * </PRE>
     * @return Socket option returned on the call.
     * @throws Exception An error occurred
     */
    public static native int optGet(long sock, int opt)
        throws Exception;

    /**
     * Setup socket timeout for the specified socket
     * @param sock The socket to set up.
     * @param t Value for the timeout in microseconds.
     * <PRE>
     * t &gt; 0  -- read and write calls return APR_TIMEUP if specified time
     *           elapses with no data read or written
     * t == 0 -- read and write calls never block
     * t &lt; 0  -- read and write calls block
     * </PRE>
     * @return the operation status
     */
    public static native int timeoutSet(long sock, long t);

    /**
     * Query socket timeout for the specified socket
     * @param sock The socket to query
     * @return Socket timeout returned from the query.
     * @throws Exception An error occurred
     */
    public static native long timeoutGet(long sock)
        throws Exception;

    /**
     * Send a file from an open file descriptor to a socket, along with
     * optional headers and trailers.
     * <br>
     * This functions acts like a blocking write by default.  To change
     *         this behavior, use apr_socket_timeout_set() or the
     *         APR_SO_NONBLOCK socket option.
     * The number of bytes actually sent is stored in the len parameter.
     * The offset parameter is passed by reference for no reason; its
     * value will never be modified by the apr_socket_sendfile() function.
     * @param sock The socket to which we're writing
     * @param file The open file from which to read
     * @param headers Array containing the headers to send
     * @param trailers Array containing the trailers to send
     * @param offset Offset into the file where we should begin writing
     * @param len Number of bytes to send from the file
     * @param flags APR flags that are mapped to OS specific flags
     * @return Number of bytes actually sent, including headers,
     *         file, and trailers
     */
    public static native long sendfile(long sock, long file, byte [][] headers,
                                       byte[][] trailers, long offset,
                                       long len, int flags);

    /**
     * Send a file without header and trailer arrays.
     * @param sock The socket to which we're writing
     * @param file The open file from which to read
     * @param offset Offset into the file where we should begin writing
     * @param len Number of bytes to send from the file
     * @param flags APR flags that are mapped to OS specific flags
     * @return Number of bytes actually sent
     */
    public static native long sendfilen(long sock, long file, long offset,
                                        long len, int flags);

    /**
     * Create a child pool from associated socket pool.
     * @param thesocket The socket to use
     * @return a pointer to the pool
     * @throws Exception An error occurred
     */
    public static native long pool(long thesocket)
        throws Exception;

    /**
     * Private method for getting the socket struct members
     * @param socket The socket to use
     * @param what Struct member to obtain
     * <PRE>
     * SOCKET_GET_POOL  - The socket pool
     * SOCKET_GET_IMPL  - The socket implementation object
     * SOCKET_GET_APRS  - APR socket
     * SOCKET_GET_TYPE  - Socket type
     * </PRE>
     * @return The structure member address
     */
    private static native long get(long socket, int what);

    /**
     * Set internal send ByteBuffer.
     * This function will preset internal Java ByteBuffer for
     * consecutive sendbb calls.
     * @param sock The socket to use
     * @param buf The ByteBuffer
     */
    public static native void setsbb(long sock, ByteBuffer buf);

    /**
     * Set internal receive ByteBuffer.
     * This function will preset internal Java ByteBuffer for
     * consecutive revcvbb/recvbbt calls.
     * @param sock The socket to use
     * @param buf The ByteBuffer
     */
    public static native void setrbb(long sock, ByteBuffer buf);

    /**
     * Set the data associated with the current socket.
     * @param sock The currently open socket.
     * @param data The user data to associate with the socket.
     * @param key The key to associate with the data.
     * @return the operation status
     */
      public static native int dataSet(long sock, String key, Object data);

    /**
     * Return the data associated with the current socket
     * @param sock The currently open socket.
     * @param key The key to associate with the user data.
     * @return Data or null in case of error.
     */
     public static native Object dataGet(long sock, String key);

}
",blob
754,"  private XMLEvent expectTag(String expected, boolean allowEnd)
      throws IOException {
    XMLEvent ev = null;
    while (true) {
      try {
        ev = events.nextEvent();
      } catch (XMLStreamException e) {
        throw new IOException(""Expecting "" + expected +
            "", but got XMLStreamException"", e);
      }
      switch (ev.getEventType()) {
      case XMLEvent.ATTRIBUTE:
        throw new IOException(""Got unexpected attribute: "" + ev);
      case XMLEvent.CHARACTERS:
        if (!ev.asCharacters().isWhiteSpace()) {
          throw new IOException(""Got unxpected characters while "" +
              ""looking for "" + expected + "": "" +
              ev.asCharacters().getData());
        }
        break;
      case XMLEvent.END_ELEMENT:
        if (!allowEnd) {
          throw new IOException(""Got unexpected end event "" +
              ""while looking for "" + expected);
        }
        return ev;
      case XMLEvent.START_ELEMENT:
        if (!expected.startsWith(""["")) {
          if (!ev.asStartElement().getName().getLocalPart().
                equals(expected)) {
            throw new IOException(""Failed to find <"" + expected + "">; "" +
                ""got "" + ev.asStartElement().getName().getLocalPart() +
                "" instead."");
          }
        }
        return ev;
      default:
        // Ignore other event types like comment, etc.
        if (LOG.isTraceEnabled()) {
          LOG.trace(""Skipping XMLEvent of type "" +
              ev.getEventType() + ""("" +  ev + "")"");
        }
        break;
      }
    }
  }
",long method
187,"  public List<String> getTraceback() {
    return traceback;
  }
",feature envy
419,"public class BooleanQuantizer extends StatelessQuantizer { 

  public final float read(ByteBuffer stream, int position) { 
    return 1.0f; 
  } 

  public final void write(ByteBuffer stream, float value) {} 

  @Override 
  public String getKey() { 
    return ""boolean""; 
  } 

  public final int size() { 
    return 0; 
  } 
}
",data class
46,"public class XPathConstants {

    /**
     * <p>Private constructor to prevent instantiation.</p>
     */
    private XPathConstants() { }

    /**
     * <p>The XPath 1.0 number data type.</p>
     *
     * <p>Maps to Java {@link Double}.</p>
     */
    public static final QName NUMBER = new QName(""http://www.w3.org/1999/XSL/Transform"", ""NUMBER"");

    /**
     * <p>The XPath 1.0 string data type.</p>
     *
     * <p>Maps to Java {@link String}.</p>
     */
    public static final QName STRING = new QName(""http://www.w3.org/1999/XSL/Transform"", ""STRING"");

    /**
     * <p>The XPath 1.0 boolean data type.</p>
     *
     * <p>Maps to Java {@link Boolean}.</p>
     */
    public static final QName BOOLEAN = new QName(""http://www.w3.org/1999/XSL/Transform"", ""BOOLEAN"");

    /**
     * <p>The XPath 1.0 NodeSet data type.</p>
     *
     * <p>Maps to Java {@link org.w3c.dom.NodeList}.</p>
     */
    public static final QName NODESET = new QName(""http://www.w3.org/1999/XSL/Transform"", ""NODESET"");

    /**
     * <p>The XPath 1.0 NodeSet data type.
     *
     * <p>Maps to Java {@link org.w3c.dom.Node}.</p>
     */
    public static final QName NODE = new QName(""http://www.w3.org/1999/XSL/Transform"", ""NODE"");

    /**
     * <p>The URI for the DOM object model, ""http://java.sun.com/jaxp/xpath/dom"".</p>
     */
    public static final String DOM_OBJECT_MODEL = ""http://java.sun.com/jaxp/xpath/dom"";
}
",data class
996,"    public JsonGenerator(LogIterator iter) {
	servers = new HashSet<Integer>();

	Pattern stateChangeP = Pattern.compile(""- (LOOKING|FOLLOWING|LEADING)"");
	Pattern newElectionP = Pattern.compile(""New election. My id =  (\\d+), Proposed zxid = (\\d+)"");
	Pattern receivedProposalP = Pattern.compile(""Notification: (\\d+) \\(n.leader\\), (\\d+) \\(n.zxid\\), (\\d+) \\(n.round\\), .+ \\(n.state\\), (\\d+) \\(n.sid\\), .+ \\(my state\\)"");
	Pattern exceptionP = Pattern.compile(""xception"");
	
	root = new JSONObject();
	Matcher m = null;
	JSONArray events = new JSONArray();
	root.put(""events"", events);
	
	long starttime = Long.MAX_VALUE;
	long endtime = 0;

	int leader = 0;
	long curEpoch = 0;
	boolean newEpoch = false;

	while (iter.hasNext()) {
	    LogEntry ent = iter.next();
	    
	    if (ent.getTimestamp() < starttime) {
		starttime = ent.getTimestamp();
	    }
	    if (ent.getTimestamp() > endtime) {
		endtime = ent.getTimestamp();
	    }
	    
	    if (ent.getType() == LogEntry.Type.TXN) {
		events.add(txnEntry((TransactionEntry)ent));
	    } else {
		Log4JEntry e = (Log4JEntry)ent;
		servers.add(e.getNode());
		
		if ((m = stateChangeP.matcher(e.getEntry())).find()) {
		    JSONObject stateChange = new JSONObject();
		    stateChange.put(""type"", ""stateChange"");
		    stateChange.put(""time"", e.getTimestamp());
		    stateChange.put(""server"", e.getNode());
		    stateChange.put(""state"", m.group(1));
		    events.add(stateChange);
		    
		    if (m.group(1).equals(""LEADING"")) {
			leader = e.getNode();
		    }
		} else if ((m = newElectionP.matcher(e.getEntry())).find()) {
		    Iterator<Integer> iterator = servers.iterator();
		    long zxid = Long.valueOf(m.group(2));
		    int count = (int)zxid;// & 0xFFFFFFFFL;
		    int epoch = (int)Long.rotateRight(zxid, 32);// >> 32;
		    
		    if (leader != 0 && epoch > curEpoch) {
			JSONObject stateChange = new JSONObject();
			stateChange.put(""type"", ""stateChange"");
			stateChange.put(""time"", e.getTimestamp());
			stateChange.put(""server"", leader);
			stateChange.put(""state"", ""INIT"");
			events.add(stateChange);
			leader = 0;
		    }
		    
		    while (iterator.hasNext()) {
			int dst = iterator.next();
			if (dst != e.getNode()) {
			    JSONObject msg = new JSONObject();
			    msg.put(""type"", ""postmessage"");
			    msg.put(""src"", e.getNode());
			    msg.put(""dst"", dst);
			    msg.put(""time"", e.getTimestamp());
			    msg.put(""zxid"", m.group(2));
			    msg.put(""count"", count);
			    msg.put(""epoch"", epoch);
			    
			    events.add(msg);
			}
		    }
		} else if ((m = receivedProposalP.matcher(e.getEntry())).find()) {
		    // Pattern.compile(""Notification: \\d+, (\\d+), (\\d+), \\d+, [^,]*, [^,]*, (\\d+)"");//, LOOKING, LOOKING, 2
		    int src = Integer.valueOf(m.group(4));
		    long zxid = Long.valueOf(m.group(2));
		    int dst = e.getNode();
		    long epoch2 = Long.valueOf(m.group(3));
		    
		    int count = (int)zxid;// & 0xFFFFFFFFL;
		    int epoch = (int)Long.rotateRight(zxid, 32);// >> 32;
		    
		    if (leader != 0 && epoch > curEpoch) {
			JSONObject stateChange = new JSONObject();
			stateChange.put(""type"", ""stateChange"");
			stateChange.put(""time"", e.getTimestamp());
			stateChange.put(""server"", leader);
			stateChange.put(""state"", ""INIT"");
			events.add(stateChange);
			leader = 0;
		    }
		    
		    if (src != dst) {
			JSONObject msg = new JSONObject();
			msg.put(""type"", ""delivermessage"");
			msg.put(""src"", src);
			msg.put(""dst"", dst);
			msg.put(""time"", e.getTimestamp());
			msg.put(""zxid"", zxid);
			msg.put(""epoch"", epoch);
			msg.put(""count"", count);
			msg.put(""epoch2"", epoch2);
			
			events.add(msg);
		    }
		} else if ((m = exceptionP.matcher(e.getEntry())).find()) {
		    JSONObject ex = new JSONObject();
		    ex.put(""type"", ""exception"");
		    ex.put(""server"", e.getNode());
		    ex.put(""time"", e.getTimestamp());
		    ex.put(""text"", e.getEntry());
		    events.add(ex);
		} 
	    }
	    JSONObject ex = new JSONObject();
	    ex.put(""type"", ""text"");
	    ex.put(""time"", ent.getTimestamp());
	    String txt = ent.toString();
	    ex.put(""text"", txt);
	    events.add(ex);
	}
	//	System.out.println(""pending messages: ""+pendingMessages.size());
	root.put(""starttime"", starttime);
	root.put(""endtime"", endtime);

	JSONArray serversarray = new JSONArray();
	root.put(""servers"", serversarray);
	
	Iterator<Integer> iterator = servers.iterator();
	while (iterator.hasNext()) {
	    serversarray.add(iterator.next());
	}
    }
",long method
214,"	private static class GrailsContentProposal implements IContentProposal, Comparable<GrailsContentProposal> {

		private String fLabel;

		private String fContent;

		private String fDescription;

		private Image fImage;

		public GrailsContentProposal(String label, String content, String description, Image image) {
			fLabel = label;
			fContent = content;
			fDescription = description;
			fImage = image;
		}

		public String getContent() {
			return fContent;
		}

		public int getCursorPosition() {
			if (fContent != null) {
				return fContent.length();
			}
			return 0;
		}

		public String getDescription() {
			return fDescription;
		}

		public String getLabel() {
			return fLabel;
		}

		@SuppressWarnings(""unused"")
		public Image getImage() {
			return fImage;
		}

		public String toString() {
			return fLabel;
		}

		public int compareTo(GrailsContentProposal o) {
			return this.fContent.compareTo(o.fContent);
		}
	}
",data class
1419,"@Entity
public class Customer1149 {

	@Id @GeneratedValue(strategy = GenerationType.AUTO) private long id;
	private String firstName;
	private String lastName;

	protected Customer1149() {}

	public Customer1149(String firstName, String lastName) {
		this.firstName = firstName;
		this.lastName = lastName;
	}

	@Override
	public String toString() {
		return String.format(""Customer1149[id=%d, firstName='%s', lastName='%s']"", id, firstName, lastName);
	}

}
",data class
1091,"    @Override
    public short syncAll(short syncMode) {
        short syncState = SYNC_STATE_IN_SYNC;

        /* vnc classes need to be synchronized with cloudstack */
        s_logger.debug(""syncing cloudstack db with vnc"");
        try {
            for (Class<?> cls : _vncClasses) {

                /* lock the sync mode*/
                _lockSyncMode.lock();
                _rwMode = syncMode == DBSyncGeneric.SYNC_MODE_UPDATE;
                _dbSync.setSyncMode(syncMode);

                if (_dbSync.getSyncMode() == DBSyncGeneric.SYNC_MODE_CHECK) {
                    s_logger.debug(""sync check start: "" + DBSyncGeneric.getClassName(cls));
                } else {
                    s_logger.debug(""sync start: "" + DBSyncGeneric.getClassName(cls));
                }

                if (_dbSync.sync(cls) == false) {
                    if (_dbSync.getSyncMode() == DBSyncGeneric.SYNC_MODE_CHECK) {
                        s_logger.info(""out of sync detected: "" + DBSyncGeneric.getClassName(cls));
                    } else {
                        s_logger.info(""out of sync detected and re-synced: "" + DBSyncGeneric.getClassName(cls));
                    }
                    syncState = SYNC_STATE_OUT_OF_SYNC;
                }
                if (_dbSync.getSyncMode() == DBSyncGeneric.SYNC_MODE_CHECK) {
                    s_logger.debug(""sync check finish: "" + DBSyncGeneric.getClassName(cls));
                } else {
                    s_logger.debug(""sync finish: "" + DBSyncGeneric.getClassName(cls));
                }
                /* unlock the sync mode */
                _lockSyncMode.unlock();
            }
        } catch (Exception ex) {
            s_logger.warn(""DB Synchronization"", ex);
            syncState = SYNC_STATE_UNKNOWN;
            if (_lockSyncMode.isLocked()) {
                _lockSyncMode.unlock();
            }
        }

        return syncState;
    }
",long method
705,"    private class ClientSelectDeleteMutationPlan implements MutationPlan {
        private final StatementContext context;
        private final TableRef targetTableRef;
        private final QueryPlan dataPlan;
        private final QueryPlan bestPlan;
        private final boolean hasPreOrPostProcessing;
        private final DeletingParallelIteratorFactory parallelIteratorFactory;
        private final List<TableRef> otherTableRefs;
        private final TableRef projectedTableRef;
        private final int maxSize;
        private final int maxSizeBytes;
        private final PhoenixConnection connection;

        public ClientSelectDeleteMutationPlan(TableRef targetTableRef, QueryPlan dataPlan, QueryPlan bestPlan,
                                              boolean hasPreOrPostProcessing,
                                              DeletingParallelIteratorFactory parallelIteratorFactory,
                                              List<TableRef> otherTableRefs, TableRef projectedTableRef, int maxSize,
                                              int maxSizeBytes, PhoenixConnection connection) {
            this.context = bestPlan.getContext();
            this.targetTableRef = targetTableRef;
            this.dataPlan = dataPlan;
            this.bestPlan = bestPlan;
            this.hasPreOrPostProcessing = hasPreOrPostProcessing;
            this.parallelIteratorFactory = parallelIteratorFactory;
            this.otherTableRefs = otherTableRefs;
            this.projectedTableRef = projectedTableRef;
            this.maxSize = maxSize;
            this.maxSizeBytes = maxSizeBytes;
            this.connection = connection;
        }

        @Override
        public ParameterMetaData getParameterMetaData() {
            return context.getBindManager().getParameterMetaData();
        }

        @Override
        public StatementContext getContext() {
            return context;
        }

        @Override
        public TableRef getTargetRef() {
            return targetTableRef;
        }

        @Override
        public Set<TableRef> getSourceRefs() {
            return dataPlan.getSourceRefs();
        }

        @Override
        public Operation getOperation() {
          return operation;
        }

        @Override
        public MutationState execute() throws SQLException {
            ResultIterator iterator = bestPlan.iterator();
            try {
                // If we're not doing any pre or post processing, we can produce the delete mutations directly
                // in the parallel threads executed for the scan
                if (!hasPreOrPostProcessing) {
                    Tuple tuple;
                    long totalRowCount = 0;
                    if (parallelIteratorFactory != null) {
                        parallelIteratorFactory.setQueryPlan(bestPlan);
                        parallelIteratorFactory.setOtherTableRefs(otherTableRefs);
                        parallelIteratorFactory.setProjectedTableRef(projectedTableRef);
                    }
                    while ((tuple=iterator.next()) != null) {// Runs query
                        Cell kv = tuple.getValue(0);
                        totalRowCount += PLong.INSTANCE.getCodec().decodeLong(kv.getValueArray(), kv.getValueOffset(), SortOrder.getDefault());
                    }
                    // Return total number of rows that have been deleted from the table. In the case of auto commit being off
                    // the mutations will all be in the mutation state of the current connection. We need to divide by the
                    // total number of tables we updated as otherwise the client will get an inflated result.
                    int totalTablesUpdateClientSide = 1; // data table is always updated
                    PTable bestTable = bestPlan.getTableRef().getTable();
                    // global immutable tables are also updated client side (but don't double count the data table)
                    if (bestPlan != dataPlan && isMaintainedOnClient(bestTable)) {
                        totalTablesUpdateClientSide++;
                    }
                    for (TableRef otherTableRef : otherTableRefs) {
                        PTable otherTable = otherTableRef.getTable();
                        // Don't double count the data table here (which morphs when it becomes a projected table, hence this check)
                        if (projectedTableRef != otherTableRef && isMaintainedOnClient(otherTable)) {
                            totalTablesUpdateClientSide++;
                        }
                    }
                    MutationState state = new MutationState(maxSize, maxSizeBytes, connection, totalRowCount/totalTablesUpdateClientSide);

                    // set the read metrics accumulated in the parent context so that it can be published when the mutations are committed.
                    state.setReadMetricQueue(context.getReadMetricsQueue());

                    return state;
                } else {
                    // Otherwise, we have to execute the query and produce the delete mutations in the single thread
                    // producing the query results.
                    return deleteRows(context, iterator, bestPlan, projectedTableRef, otherTableRefs);
                }
            } finally {
                iterator.close();
            }
        }

        @Override
        public ExplainPlan getExplainPlan() throws SQLException {
            List<String> queryPlanSteps =  bestPlan.getExplainPlan().getPlanSteps();
            List<String> planSteps = Lists.newArrayListWithExpectedSize(queryPlanSteps.size()+1);
            planSteps.add(""DELETE ROWS"");
            planSteps.addAll(queryPlanSteps);
            return new ExplainPlan(planSteps);
        }

        @Override
        public Long getEstimatedRowsToScan() throws SQLException {
            return bestPlan.getEstimatedRowsToScan();
        }

        @Override
        public Long getEstimatedBytesToScan() throws SQLException {
            return bestPlan.getEstimatedBytesToScan();
        }

        @Override
        public Long getEstimateInfoTimestamp() throws SQLException {
            return bestPlan.getEstimateInfoTimestamp();
        }

        @Override
        public QueryPlan getQueryPlan() {
            return bestPlan;
        }
    }
",blob
325,"@Singleton
public class StandardComponentInitializer {

  public static final String NAVIGATE_TO_FILE = ""navigateToFile"";
  public static final String FULL_TEXT_SEARCH = ""fullTextSearch"";
  public static final String PREVIEW_IMAGE = ""previewImage"";
  public static final String FIND_ACTION = ""findAction"";
  public static final String FORMAT = ""format"";
  public static final String SAVE = ""save"";
  public static final String COPY = ""copy"";
  public static final String CUT = ""cut"";
  public static final String PASTE = ""paste"";
  public static final String UNDO = ""undo"";
  public static final String REDO = ""redo"";
  public static final String SWITCH_LEFT_TAB = ""switchLeftTab"";
  public static final String SWITCH_RIGHT_TAB = ""switchRightTab"";
  public static final String OPEN_RECENT_FILES = ""openRecentFiles"";
  public static final String DELETE_ITEM = ""deleteItem"";
  public static final String NEW_FILE = ""newFile"";
  public static final String CREATE_PROJECT = ""createProject"";
  public static final String IMPORT_PROJECT = ""importProject"";
  public static final String CLOSE_ACTIVE_EDITOR = ""closeActiveEditor"";
  public static final String SIGNATURE_HELP = ""signatureHelp"";
  public static final String SOFT_WRAP = ""softWrap"";
  public static final String RENAME = ""renameResource"";
  public static final String SHOW_REFERENCE = ""showReference"";
  public static final String SHOW_COMMANDS_PALETTE = ""showCommandsPalette"";
  public static final String NEW_TERMINAL = ""newTerminal"";
  public static final String OPEN_IN_TERMINAL = ""openInTerminal"";
  public static final String PROJECT_EXPLORER_DISPLAYING_MODE = ""projectExplorerDisplayingMode"";
  public static final String COMMAND_EXPLORER_DISPLAYING_MODE = ""commandExplorerDisplayingMode"";
  public static final String FIND_RESULT_DISPLAYING_MODE = ""findResultDisplayingMode"";
  public static final String EVENT_LOGS_DISPLAYING_MODE = ""eventLogsDisplayingMode"";
  public static final String EDITOR_DISPLAYING_MODE = ""editorDisplayingMode"";
  public static final String TERMINAL_DISPLAYING_MODE = ""terminalDisplayingMode"";
  public static final String REVEAL_RESOURCE = ""revealResourceInProjectTree"";
  public static final String COLLAPSE_ALL = ""collapseAll"";

  public interface ParserResource extends ClientBundle {
    @Source(""org/eclipse/che/ide/blank.svg"")
    SVGResource samplesCategoryBlank();
  }

  @Inject private EditorRegistry editorRegistry;

  @Inject private FileTypeRegistry fileTypeRegistry;

  @Inject private Resources resources;

  @Inject private KeyBindingAgent keyBinding;

  @Inject private ActionManager actionManager;

  @Inject private SaveAction saveAction;

  @Inject private SaveAllAction saveAllAction;

  @Inject private ShowPreferencesAction showPreferencesAction;

  @Inject private PreviewImageAction previewImageAction;

  @Inject private FindActionAction findActionAction;

  @Inject private NavigateToFileAction navigateToFileAction;

  @Inject @MainToolbar private ToolbarPresenter toolbarPresenter;

  @Inject private CutResourceAction cutResourceAction;

  @Inject private CopyResourceAction copyResourceAction;

  @Inject private PasteResourceAction pasteResourceAction;

  @Inject private DeleteResourceAction deleteResourceAction;

  @Inject private RenameItemAction renameItemAction;

  @Inject private SplitVerticallyAction splitVerticallyAction;

  @Inject private SplitHorizontallyAction splitHorizontallyAction;

  @Inject private CloseAction closeAction;

  @Inject private CloseAllAction closeAllAction;

  @Inject private CloseOtherAction closeOtherAction;

  @Inject private CloseAllExceptPinnedAction closeAllExceptPinnedAction;

  @Inject private ReopenClosedFileAction reopenClosedFileAction;

  @Inject private PinEditorTabAction pinEditorTabAction;

  @Inject private GoIntoAction goIntoAction;

  @Inject private EditFileAction editFileAction;

  @Inject private OpenFileAction openFileAction;

  @Inject private ShowHiddenFilesAction showHiddenFilesAction;

  @Inject private FormatterAction formatterAction;

  @Inject private UndoAction undoAction;

  @Inject private RedoAction redoAction;

  @Inject private UploadFileAction uploadFileAction;

  @Inject private UploadFolderAction uploadFolderAction;

  @Inject private DownloadProjectAction downloadProjectAction;

  @Inject private DownloadWsAction downloadWsAction;

  @Inject private DownloadResourceAction downloadResourceAction;

  @Inject private ImportProjectAction importProjectAction;

  @Inject private CreateProjectAction createProjectAction;

  @Inject private ConvertFolderToProjectAction convertFolderToProjectAction;

  @Inject private FullTextSearchAction fullTextSearchAction;

  @Inject private NewFolderAction newFolderAction;

  @Inject private NewFileAction newFileAction;

  @Inject private NewXmlFileAction newXmlFileAction;

  @Inject private ImageViewerProvider imageViewerProvider;

  @Inject private ProjectConfigurationAction projectConfigurationAction;

  @Inject private ExpandEditorAction expandEditorAction;

  @Inject private CompleteAction completeAction;

  @Inject private SwitchPreviousEditorAction switchPreviousEditorAction;

  @Inject private SwitchNextEditorAction switchNextEditorAction;

  @Inject private HotKeysListAction hotKeysListAction;

  @Inject private OpenRecentFilesAction openRecentFilesAction;

  @Inject private ClearRecentListAction clearRecentFilesAction;

  @Inject private CloseActiveEditorAction closeActiveEditorAction;

  @Inject private MessageLoaderResources messageLoaderResources;

  @Inject private EditorResources editorResources;

  @Inject private PopupResources popupResources;

  @Inject private ShowReferenceAction showReferenceAction;

  @Inject private RevealResourceAction revealResourceAction;

  @Inject private RefreshPathAction refreshPathAction;

  @Inject private LinkWithEditorAction linkWithEditorAction;

  @Inject private ShowToolbarAction showToolbarAction;

  @Inject private SignatureHelpAction signatureHelpAction;

  @Inject private MaximizePartAction maximizePartAction;

  @Inject private HidePartAction hidePartAction;

  @Inject private RestorePartAction restorePartAction;

  @Inject private ShowCommandsPaletteAction showCommandsPaletteAction;

  @Inject private SoftWrapAction softWrapAction;

  @Inject private StartWorkspaceAction startWorkspaceAction;

  @Inject private StopWorkspaceAction stopWorkspaceAction;

  @Inject private ShowWorkspaceStatusAction showWorkspaceStatusAction;

  @Inject private ShowRuntimeInfoAction showRuntimeInfoAction;

  @Inject private RunCommandAction runCommandAction;

  @Inject private NewTerminalAction newTerminalAction;

  @Inject private ReRunProcessAction reRunProcessAction;

  @Inject private StopProcessAction stopProcessAction;

  @Inject private CloseConsoleAction closeConsoleAction;

  @Inject private DisplayMachineOutputAction displayMachineOutputAction;

  @Inject private PreviewSSHAction previewSSHAction;

  @Inject private ShowConsoleTreeAction showConsoleTreeAction;

  @Inject private AddToFileWatcherExcludesAction addToFileWatcherExcludesAction;

  @Inject private RemoveFromFileWatcherExcludesAction removeFromFileWatcherExcludesAction;

  @Inject private DevModeSetUpAction devModeSetUpAction;

  @Inject private DevModeOffAction devModeOffAction;

  @Inject private CollapseAllAction collapseAllAction;

  @Inject private PerspectiveManager perspectiveManager;

  @Inject private CommandsExplorerDisplayingModeAction commandsExplorerDisplayingModeAction;

  @Inject private ProjectExplorerDisplayingModeAction projectExplorerDisplayingModeAction;

  @Inject private EventLogsDisplayingModeAction eventLogsDisplayingModeAction;

  @Inject private FindResultDisplayingModeAction findResultDisplayingModeAction;

  @Inject private EditorDisplayingModeAction editorDisplayingModeAction;

  @Inject private TerminalDisplayingModeAction terminalDisplayingModeAction;

  @Inject private RenameCommandAction renameCommandAction;

  @Inject private MoveCommandAction moveCommandAction;

  @Inject private OpenInTerminalAction openInTerminalAction;

  @Inject private FreeDiskSpaceStatusBarAction freeDiskSpaceStatusBarAction;

  @Inject
  @Named(""XMLFileType"")
  private FileType xmlFile;

  @Inject
  @Named(""TXTFileType"")
  private FileType txtFile;

  @Inject
  @Named(""JsonFileType"")
  private FileType jsonFile;

  @Inject
  @Named(""MDFileType"")
  private FileType mdFile;

  @Inject
  @Named(""PNGFileType"")
  private FileType pngFile;

  @Inject
  @Named(""BMPFileType"")
  private FileType bmpFile;

  @Inject
  @Named(""GIFFileType"")
  private FileType gifFile;

  @Inject
  @Named(""ICOFileType"")
  private FileType iconFile;

  @Inject
  @Named(""SVGFileType"")
  private FileType svgFile;

  @Inject
  @Named(""JPEFileType"")
  private FileType jpeFile;

  @Inject
  @Named(""JPEGFileType"")
  private FileType jpegFile;

  @Inject
  @Named(""JPGFileType"")
  private FileType jpgFile;

  @Inject private CommandEditorProvider commandEditorProvider;

  @Inject
  @Named(""CommandFileType"")
  private FileType commandFileType;

  @Inject private ProjectConfigSynchronized projectConfigSynchronized;

  @Inject private TreeResourceRevealer treeResourceRevealer; // just to work with it

  @Inject private TerminalInitializer terminalInitializer;

  /** Instantiates {@link StandardComponentInitializer} an creates standard content. */
  @Inject
  public StandardComponentInitializer(
      IconRegistry iconRegistry,
      MachineResources machineResources,
      StandardComponentInitializer.ParserResource parserResource) {
    iconRegistry.registerIcon(
        new Icon(BLANK_CATEGORY + "".samples.category.icon"", parserResource.samplesCategoryBlank()));
    iconRegistry.registerIcon(new Icon(""che.machine.icon"", machineResources.devMachine()));
    machineResources.getCss().ensureInjected();
  }

  public void initialize() {
    messageLoaderResources.Css().ensureInjected();
    editorResources.editorCss().ensureInjected();
    popupResources.popupStyle().ensureInjected();

    fileTypeRegistry.registerFileType(xmlFile);

    fileTypeRegistry.registerFileType(txtFile);

    fileTypeRegistry.registerFileType(jsonFile);

    fileTypeRegistry.registerFileType(mdFile);

    fileTypeRegistry.registerFileType(pngFile);
    editorRegistry.registerDefaultEditor(pngFile, imageViewerProvider);

    fileTypeRegistry.registerFileType(bmpFile);
    editorRegistry.registerDefaultEditor(bmpFile, imageViewerProvider);

    fileTypeRegistry.registerFileType(gifFile);
    editorRegistry.registerDefaultEditor(gifFile, imageViewerProvider);

    fileTypeRegistry.registerFileType(iconFile);
    editorRegistry.registerDefaultEditor(iconFile, imageViewerProvider);

    fileTypeRegistry.registerFileType(svgFile);
    editorRegistry.registerDefaultEditor(svgFile, imageViewerProvider);

    fileTypeRegistry.registerFileType(jpeFile);
    editorRegistry.registerDefaultEditor(jpeFile, imageViewerProvider);

    fileTypeRegistry.registerFileType(jpegFile);
    editorRegistry.registerDefaultEditor(jpegFile, imageViewerProvider);

    fileTypeRegistry.registerFileType(jpgFile);
    editorRegistry.registerDefaultEditor(jpgFile, imageViewerProvider);

    fileTypeRegistry.registerFileType(commandFileType);
    editorRegistry.registerDefaultEditor(commandFileType, commandEditorProvider);

    // Workspace (New Menu)
    DefaultActionGroup workspaceGroup =
        (DefaultActionGroup) actionManager.getAction(GROUP_WORKSPACE);

    actionManager.registerAction(IMPORT_PROJECT, importProjectAction);
    workspaceGroup.add(importProjectAction);

    actionManager.registerAction(CREATE_PROJECT, createProjectAction);
    workspaceGroup.add(createProjectAction);

    actionManager.registerAction(""downloadWsAsZipAction"", downloadWsAction);
    workspaceGroup.add(downloadWsAction);

    workspaceGroup.addSeparator();
    workspaceGroup.add(startWorkspaceAction);
    workspaceGroup.add(stopWorkspaceAction);
    workspaceGroup.add(showWorkspaceStatusAction);

    // Project (New Menu)
    DefaultActionGroup projectGroup = (DefaultActionGroup) actionManager.getAction(GROUP_PROJECT);

    DefaultActionGroup newGroup = new DefaultActionGroup(""New"", true, actionManager);
    newGroup.getTemplatePresentation().setDescription(""Create..."");
    newGroup
        .getTemplatePresentation()
        .setImageElement(new SVGImage(resources.newResource()).getElement());
    actionManager.registerAction(GROUP_FILE_NEW, newGroup);
    projectGroup.add(newGroup);

    newGroup.addSeparator();

    actionManager.registerAction(NEW_FILE, newFileAction);
    newGroup.addAction(newFileAction, Constraints.FIRST);

    actionManager.registerAction(""newFolder"", newFolderAction);
    newGroup.addAction(newFolderAction, new Constraints(AFTER, NEW_FILE));

    newGroup.addSeparator();

    actionManager.registerAction(""newXmlFile"", newXmlFileAction);
    newXmlFileAction
        .getTemplatePresentation()
        .setImageElement(new SVGImage(xmlFile.getImage()).getElement());
    newGroup.addAction(newXmlFileAction);

    actionManager.registerAction(""uploadFile"", uploadFileAction);
    projectGroup.add(uploadFileAction);

    actionManager.registerAction(""uploadFolder"", uploadFolderAction);
    projectGroup.add(uploadFolderAction);

    actionManager.registerAction(""convertFolderToProject"", convertFolderToProjectAction);
    projectGroup.add(convertFolderToProjectAction);

    actionManager.registerAction(""downloadAsZipAction"", downloadProjectAction);
    projectGroup.add(downloadProjectAction);

    actionManager.registerAction(""showHideHiddenFiles"", showHiddenFilesAction);
    projectGroup.add(showHiddenFilesAction);

    projectGroup.addSeparator();

    actionManager.registerAction(""projectConfiguration"", projectConfigurationAction);
    projectGroup.add(projectConfigurationAction);

    DefaultActionGroup saveGroup = new DefaultActionGroup(actionManager);
    actionManager.registerAction(""saveGroup"", saveGroup);
    actionManager.registerAction(SAVE, saveAction);
    saveGroup.addSeparator();
    saveGroup.add(saveAction);

    // Edit (New Menu)
    DefaultActionGroup editGroup = (DefaultActionGroup) actionManager.getAction(GROUP_EDIT);
    DefaultActionGroup recentGroup = new DefaultActionGroup(RECENT_GROUP_ID, true, actionManager);
    actionManager.registerAction(GROUP_RECENT_FILES, recentGroup);
    actionManager.registerAction(""clearRecentList"", clearRecentFilesAction);
    recentGroup.addSeparator();
    recentGroup.add(clearRecentFilesAction, LAST);
    editGroup.add(recentGroup);
    actionManager.registerAction(OPEN_RECENT_FILES, openRecentFilesAction);
    editGroup.add(openRecentFilesAction);

    actionManager.registerAction(CLOSE_ACTIVE_EDITOR, closeActiveEditorAction);
    editGroup.add(closeActiveEditorAction);

    actionManager.registerAction(FORMAT, formatterAction);
    editGroup.add(formatterAction);

    editGroup.add(saveAction);

    actionManager.registerAction(UNDO, undoAction);
    editGroup.add(undoAction);

    actionManager.registerAction(REDO, redoAction);
    editGroup.add(redoAction);

    actionManager.registerAction(SOFT_WRAP, softWrapAction);
    editGroup.add(softWrapAction);

    actionManager.registerAction(CUT, cutResourceAction);
    editGroup.add(cutResourceAction);

    actionManager.registerAction(COPY, copyResourceAction);
    editGroup.add(copyResourceAction);

    actionManager.registerAction(PASTE, pasteResourceAction);
    editGroup.add(pasteResourceAction);

    actionManager.registerAction(RENAME, renameItemAction);
    editGroup.add(renameItemAction);

    actionManager.registerAction(DELETE_ITEM, deleteResourceAction);
    editGroup.add(deleteResourceAction);

    actionManager.registerAction(FULL_TEXT_SEARCH, fullTextSearchAction);
    editGroup.add(fullTextSearchAction);

    editGroup.addSeparator();
    editGroup.add(switchPreviousEditorAction);
    editGroup.add(switchNextEditorAction);

    // Assistant (New Menu)
    DefaultActionGroup assistantGroup =
        (DefaultActionGroup) actionManager.getAction(GROUP_ASSISTANT);

    actionManager.registerAction(PREVIEW_IMAGE, previewImageAction);
    assistantGroup.add(previewImageAction);

    actionManager.registerAction(FIND_ACTION, findActionAction);
    assistantGroup.add(findActionAction);

    actionManager.registerAction(""hotKeysList"", hotKeysListAction);
    assistantGroup.add(hotKeysListAction);

    assistantGroup.addSeparator();

    // Switching of parts
    DefaultActionGroup toolWindowsGroup =
        new DefaultActionGroup(""Tool Windows"", true, actionManager);
    actionManager.registerAction(TOOL_WINDOWS_GROUP, toolWindowsGroup);

    actionManager.registerAction(
        PROJECT_EXPLORER_DISPLAYING_MODE, projectExplorerDisplayingModeAction);
    actionManager.registerAction(FIND_RESULT_DISPLAYING_MODE, findResultDisplayingModeAction);
    actionManager.registerAction(EVENT_LOGS_DISPLAYING_MODE, eventLogsDisplayingModeAction);
    actionManager.registerAction(
        COMMAND_EXPLORER_DISPLAYING_MODE, commandsExplorerDisplayingModeAction);
    actionManager.registerAction(EDITOR_DISPLAYING_MODE, editorDisplayingModeAction);
    actionManager.registerAction(TERMINAL_DISPLAYING_MODE, terminalDisplayingModeAction);
    toolWindowsGroup.add(projectExplorerDisplayingModeAction, FIRST);
    toolWindowsGroup.add(
        eventLogsDisplayingModeAction, new Constraints(AFTER, PROJECT_EXPLORER_DISPLAYING_MODE));
    toolWindowsGroup.add(
        findResultDisplayingModeAction, new Constraints(AFTER, EVENT_LOGS_DISPLAYING_MODE));
    toolWindowsGroup.add(
        commandsExplorerDisplayingModeAction, new Constraints(AFTER, FIND_RESULT_DISPLAYING_MODE));
    toolWindowsGroup.add(editorDisplayingModeAction);
    toolWindowsGroup.add(terminalDisplayingModeAction);

    assistantGroup.add(toolWindowsGroup);
    assistantGroup.addSeparator();

    actionManager.registerAction(""callCompletion"", completeAction);
    assistantGroup.add(completeAction);

    actionManager.registerAction(""downloadItemAction"", downloadResourceAction);
    actionManager.registerAction(NAVIGATE_TO_FILE, navigateToFileAction);
    assistantGroup.add(navigateToFileAction);

    assistantGroup.addSeparator();
    actionManager.registerAction(""devModeSetUpAction"", devModeSetUpAction);
    actionManager.registerAction(""devModeOffAction"", devModeOffAction);
    assistantGroup.add(devModeSetUpAction);
    assistantGroup.add(devModeOffAction);

    // Compose Profile menu
    DefaultActionGroup profileGroup = (DefaultActionGroup) actionManager.getAction(GROUP_PROFILE);
    actionManager.registerAction(""showPreferences"", showPreferencesAction);

    profileGroup.add(showPreferencesAction);

    // Compose Help menu
    DefaultActionGroup helpGroup = (DefaultActionGroup) actionManager.getAction(GROUP_HELP);
    helpGroup.addSeparator();

    // Processes panel actions
    actionManager.registerAction(""startWorkspace"", startWorkspaceAction);
    actionManager.registerAction(""stopWorkspace"", stopWorkspaceAction);
    actionManager.registerAction(""showWorkspaceStatus"", showWorkspaceStatusAction);
    actionManager.registerAction(""runCommand"", runCommandAction);
    actionManager.registerAction(""newTerminal"", newTerminalAction);

    // Compose main context menu
    DefaultActionGroup resourceOperation = new DefaultActionGroup(actionManager);
    actionManager.registerAction(""resourceOperation"", resourceOperation);
    actionManager.registerAction(""refreshPathAction"", refreshPathAction);
    actionManager.registerAction(""linkWithEditor"", linkWithEditorAction);
    actionManager.registerAction(""showToolbar"", showToolbarAction);

    resourceOperation.addSeparator();
    resourceOperation.add(previewImageAction);
    resourceOperation.add(showReferenceAction);
    resourceOperation.add(goIntoAction);
    resourceOperation.add(editFileAction);

    resourceOperation.add(saveAction);
    resourceOperation.add(cutResourceAction);
    resourceOperation.add(copyResourceAction);
    resourceOperation.add(pasteResourceAction);
    resourceOperation.add(renameItemAction);
    resourceOperation.add(deleteResourceAction);
    resourceOperation.addSeparator();
    resourceOperation.add(downloadResourceAction);
    resourceOperation.add(refreshPathAction);
    resourceOperation.add(linkWithEditorAction);
    resourceOperation.add(collapseAllAction);
    resourceOperation.addSeparator();
    resourceOperation.add(convertFolderToProjectAction);
    resourceOperation.addSeparator();
    resourceOperation.addSeparator();
    resourceOperation.add(addToFileWatcherExcludesAction);
    resourceOperation.add(removeFromFileWatcherExcludesAction);
    resourceOperation.addSeparator();

    DefaultActionGroup mainContextMenuGroup =
        (DefaultActionGroup) actionManager.getAction(GROUP_MAIN_CONTEXT_MENU);
    mainContextMenuGroup.add(newGroup, FIRST);
    mainContextMenuGroup.addSeparator();
    mainContextMenuGroup.add(resourceOperation);
    mainContextMenuGroup.add(openInTerminalAction);
    actionManager.registerAction(OPEN_IN_TERMINAL, openInTerminalAction);

    DefaultActionGroup partMenuGroup =
        (DefaultActionGroup) actionManager.getAction(GROUP_PART_MENU);
    partMenuGroup.add(maximizePartAction);
    partMenuGroup.add(hidePartAction);
    partMenuGroup.add(restorePartAction);
    partMenuGroup.add(showConsoleTreeAction);
    partMenuGroup.add(revealResourceAction);
    partMenuGroup.add(collapseAllAction);
    partMenuGroup.add(refreshPathAction);
    partMenuGroup.add(linkWithEditorAction);

    DefaultActionGroup toolbarControllerGroup =
        (DefaultActionGroup) actionManager.getAction(GROUP_TOOLBAR_CONTROLLER);
    toolbarControllerGroup.add(showToolbarAction);

    actionManager.registerAction(""expandEditor"", expandEditorAction);
    DefaultActionGroup rightMenuGroup =
        (DefaultActionGroup) actionManager.getAction(GROUP_RIGHT_MAIN_MENU);
    rightMenuGroup.add(expandEditorAction, FIRST);

    // Compose main toolbar
    DefaultActionGroup changeResourceGroup = new DefaultActionGroup(actionManager);
    actionManager.registerAction(""changeResourceGroup"", changeResourceGroup);
    actionManager.registerAction(""editFile"", editFileAction);
    actionManager.registerAction(""goInto"", goIntoAction);
    actionManager.registerAction(SHOW_REFERENCE, showReferenceAction);

    actionManager.registerAction(REVEAL_RESOURCE, revealResourceAction);
    actionManager.registerAction(COLLAPSE_ALL, collapseAllAction);

    actionManager.registerAction(""openFile"", openFileAction);
    actionManager.registerAction(SWITCH_LEFT_TAB, switchPreviousEditorAction);
    actionManager.registerAction(SWITCH_RIGHT_TAB, switchNextEditorAction);

    changeResourceGroup.add(cutResourceAction);
    changeResourceGroup.add(copyResourceAction);
    changeResourceGroup.add(pasteResourceAction);
    changeResourceGroup.add(deleteResourceAction);

    DefaultActionGroup mainToolbarGroup =
        (DefaultActionGroup) actionManager.getAction(GROUP_MAIN_TOOLBAR);
    mainToolbarGroup.add(newGroup);
    mainToolbarGroup.add(saveGroup);
    mainToolbarGroup.add(changeResourceGroup);
    toolbarPresenter.bindMainGroup(mainToolbarGroup);

    DefaultActionGroup centerToolbarGroup =
        (DefaultActionGroup) actionManager.getAction(GROUP_CENTER_TOOLBAR);
    toolbarPresenter.bindCenterGroup(centerToolbarGroup);

    DefaultActionGroup rightToolbarGroup =
        (DefaultActionGroup) actionManager.getAction(GROUP_RIGHT_TOOLBAR);
    toolbarPresenter.bindRightGroup(rightToolbarGroup);

    actionManager.registerAction(""showServers"", showRuntimeInfoAction);

    // Consoles tree context menu group
    DefaultActionGroup consolesTreeContextMenu =
        (DefaultActionGroup) actionManager.getAction(GROUP_CONSOLES_TREE_CONTEXT_MENU);
    consolesTreeContextMenu.add(showRuntimeInfoAction);
    consolesTreeContextMenu.add(newTerminalAction);
    consolesTreeContextMenu.add(reRunProcessAction);
    consolesTreeContextMenu.add(stopProcessAction);
    consolesTreeContextMenu.add(closeConsoleAction);

    actionManager.registerAction(""displayMachineOutput"", displayMachineOutputAction);
    consolesTreeContextMenu.add(displayMachineOutputAction);

    actionManager.registerAction(""previewSSH"", previewSSHAction);
    consolesTreeContextMenu.add(previewSSHAction);

    // Editor context menu group
    DefaultActionGroup editorTabContextMenu =
        (DefaultActionGroup) actionManager.getAction(GROUP_EDITOR_TAB_CONTEXT_MENU);
    editorTabContextMenu.add(closeAction);
    actionManager.registerAction(CLOSE, closeAction);
    editorTabContextMenu.add(closeAllAction);
    actionManager.registerAction(CLOSE_ALL, closeAllAction);
    editorTabContextMenu.add(closeOtherAction);
    actionManager.registerAction(CLOSE_OTHER, closeOtherAction);
    editorTabContextMenu.add(closeAllExceptPinnedAction);
    actionManager.registerAction(CLOSE_ALL_EXCEPT_PINNED, closeAllExceptPinnedAction);
    editorTabContextMenu.addSeparator();
    editorTabContextMenu.add(reopenClosedFileAction);
    actionManager.registerAction(REOPEN_CLOSED, reopenClosedFileAction);
    editorTabContextMenu.add(pinEditorTabAction);
    actionManager.registerAction(PIN_TAB, pinEditorTabAction);
    editorTabContextMenu.addSeparator();
    actionManager.registerAction(SPLIT_HORIZONTALLY, splitHorizontallyAction);
    editorTabContextMenu.add(splitHorizontallyAction);
    actionManager.registerAction(SPLIT_VERTICALLY, splitVerticallyAction);
    editorTabContextMenu.add(splitVerticallyAction);
    actionManager.registerAction(SIGNATURE_HELP, signatureHelpAction);

    actionManager.registerAction(SHOW_COMMANDS_PALETTE, showCommandsPaletteAction);
    DefaultActionGroup runGroup =
        (DefaultActionGroup) actionManager.getAction(IdeActions.GROUP_RUN);
    runGroup.add(showCommandsPaletteAction);
    runGroup.add(newTerminalAction, FIRST);
    runGroup.addSeparator();

    DefaultActionGroup editorContextMenuGroup = new DefaultActionGroup(actionManager);
    actionManager.registerAction(GROUP_EDITOR_CONTEXT_MENU, editorContextMenuGroup);

    editorContextMenuGroup.add(saveAction);
    editorContextMenuGroup.add(undoAction);
    editorContextMenuGroup.add(redoAction);
    editorContextMenuGroup.addSeparator();
    editorContextMenuGroup.add(formatterAction);
    editorContextMenuGroup.add(softWrapAction);

    editorContextMenuGroup.addSeparator();
    editorContextMenuGroup.add(fullTextSearchAction);
    editorContextMenuGroup.add(closeActiveEditorAction);

    editorContextMenuGroup.addSeparator();
    editorContextMenuGroup.add(revealResourceAction);

    DefaultActionGroup commandExplorerMenuGroup = new DefaultActionGroup(actionManager);
    actionManager.registerAction(GROUP_COMMAND_EXPLORER_CONTEXT_MENU, commandExplorerMenuGroup);

    actionManager.registerAction(""renameCommand"", renameCommandAction);
    commandExplorerMenuGroup.add(renameCommandAction);
    actionManager.registerAction(""moveCommand"", moveCommandAction);
    commandExplorerMenuGroup.add(moveCommandAction);

    DefaultActionGroup rightStatusPanelGroup =
        (DefaultActionGroup) actionManager.getAction(GROUP_RIGHT_STATUS_PANEL);
    rightStatusPanelGroup.add(freeDiskSpaceStatusBarAction);

    // Define hot-keys
    keyBinding
        .getGlobal()
        .addKey(new KeyBuilder().action().alt().charCode('n').build(), NAVIGATE_TO_FILE);
    keyBinding
        .getGlobal()
        .addKey(new KeyBuilder().action().charCode('F').build(), FULL_TEXT_SEARCH);
    keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('A').build(), FIND_ACTION);
    keyBinding.getGlobal().addKey(new KeyBuilder().alt().charCode('L').build(), FORMAT);
    keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('c').build(), COPY);
    keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('x').build(), CUT);
    keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('v').build(), PASTE);
    keyBinding.getGlobal().addKey(new KeyBuilder().shift().charCode(KeyCodeMap.F6).build(), RENAME);
    keyBinding
        .getGlobal()
        .addKey(new KeyBuilder().shift().charCode(KeyCodeMap.F7).build(), SHOW_REFERENCE);
    keyBinding
        .getGlobal()
        .addKey(new KeyBuilder().alt().charCode(KeyCodeMap.ARROW_LEFT).build(), SWITCH_LEFT_TAB);
    keyBinding
        .getGlobal()
        .addKey(new KeyBuilder().alt().charCode(KeyCodeMap.ARROW_RIGHT).build(), SWITCH_RIGHT_TAB);
    keyBinding
        .getGlobal()
        .addKey(new KeyBuilder().action().charCode('e').build(), OPEN_RECENT_FILES);
    keyBinding
        .getGlobal()
        .addKey(new KeyBuilder().charCode(KeyCodeMap.DELETE).build(), DELETE_ITEM);
    keyBinding.getGlobal().addKey(new KeyBuilder().action().alt().charCode('w').build(), SOFT_WRAP);
    keyBinding
        .getGlobal()
        .addKey(new KeyBuilder().alt().charCode(KeyCodeMap.F12).build(), NEW_TERMINAL);
    keyBinding
        .getGlobal()
        .addKey(new KeyBuilder().alt().shift().charCode(KeyCodeMap.F12).build(), OPEN_IN_TERMINAL);

    keyBinding.getGlobal().addKey(new KeyBuilder().alt().charCode('N').build(), NEW_FILE);
    keyBinding.getGlobal().addKey(new KeyBuilder().alt().charCode('x').build(), CREATE_PROJECT);
    keyBinding.getGlobal().addKey(new KeyBuilder().alt().charCode('A').build(), IMPORT_PROJECT);

    keyBinding
        .getGlobal()
        .addKey(new KeyBuilder().shift().charCode(KeyCodeMap.F10).build(), SHOW_COMMANDS_PALETTE);

    keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('s').build(), SAVE);

    keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('z').build(), UNDO);
    keyBinding.getGlobal().addKey(new KeyBuilder().action().charCode('y').build(), REDO);

    if (UserAgent.isMac()) {
      keyBinding
          .getGlobal()
          .addKey(
              new KeyBuilder().action().control().charCode('1').build(),
              PROJECT_EXPLORER_DISPLAYING_MODE);

      keyBinding
          .getGlobal()
          .addKey(
              new KeyBuilder().action().control().charCode('2').build(),
              EVENT_LOGS_DISPLAYING_MODE);

      keyBinding
          .getGlobal()
          .addKey(
              new KeyBuilder().action().control().charCode('3').build(),
              FIND_RESULT_DISPLAYING_MODE);

      keyBinding
          .getGlobal()
          .addKey(
              new KeyBuilder().action().control().charCode('4').build(),
              COMMAND_EXPLORER_DISPLAYING_MODE);

      keyBinding
          .getGlobal()
          .addKey(new KeyBuilder().action().charCode('E').build(), EDITOR_DISPLAYING_MODE);

      keyBinding
          .getGlobal()
          .addKey(new KeyBuilder().action().charCode('T').build(), TERMINAL_DISPLAYING_MODE);
    } else {
      keyBinding
          .getGlobal()
          .addKey(
              new KeyBuilder().action().alt().charCode('1').build(),
              PROJECT_EXPLORER_DISPLAYING_MODE);

      keyBinding
          .getGlobal()
          .addKey(
              new KeyBuilder().action().alt().charCode('2').build(), EVENT_LOGS_DISPLAYING_MODE);

      keyBinding
          .getGlobal()
          .addKey(
              new KeyBuilder().action().alt().charCode('3').build(), FIND_RESULT_DISPLAYING_MODE);

      keyBinding
          .getGlobal()
          .addKey(
              new KeyBuilder().action().alt().charCode('4').build(),
              COMMAND_EXPLORER_DISPLAYING_MODE);

      keyBinding
          .getGlobal()
          .addKey(new KeyBuilder().alt().charCode('E').build(), EDITOR_DISPLAYING_MODE);

      keyBinding
          .getGlobal()
          .addKey(new KeyBuilder().alt().charCode('T').build(), TERMINAL_DISPLAYING_MODE);
    }

    keyBinding
        .getGlobal()
        .addKey(new KeyBuilder().action().charCode(ARROW_DOWN).build(), REVEAL_RESOURCE);
    keyBinding
        .getGlobal()
        .addKey(new KeyBuilder().action().charCode(ARROW_UP).build(), COLLAPSE_ALL);

    if (UserAgent.isMac()) {
      keyBinding
          .getGlobal()
          .addKey(new KeyBuilder().control().charCode('w').build(), CLOSE_ACTIVE_EDITOR);
      keyBinding
          .getGlobal()
          .addKey(new KeyBuilder().control().charCode('p').build(), SIGNATURE_HELP);
    } else {
      keyBinding
          .getGlobal()
          .addKey(new KeyBuilder().alt().charCode('w').build(), CLOSE_ACTIVE_EDITOR);
      keyBinding
          .getGlobal()
          .addKey(new KeyBuilder().action().charCode('p').build(), SIGNATURE_HELP);
    }

    final Map<String, Perspective> perspectives = perspectiveManager.getPerspectives();
    if (perspectives.size()
        > 1) { // if registered perspectives will be more then 2 Main Menu -> Window
      // will appears and contains all of them as sub-menu
      final DefaultActionGroup windowMenu = new DefaultActionGroup(""Window"", true, actionManager);
      actionManager.registerAction(""Window"", windowMenu);
      final DefaultActionGroup mainMenu =
          (DefaultActionGroup) actionManager.getAction(GROUP_MAIN_MENU);
      mainMenu.add(windowMenu);
      for (Perspective perspective : perspectives.values()) {
        final BaseAction action =
            new BaseAction(perspective.getPerspectiveName()) {
              @Override
              public void actionPerformed(ActionEvent e) {
                perspectiveManager.setPerspectiveId(perspective.getPerspectiveId());
              }
            };
        actionManager.registerAction(perspective.getPerspectiveId(), action);
        windowMenu.add(action);
      }
    }
  }
}
",blob
569,"@XmlRootElement(name = ""Product"")
public class Product {
    private long id;
    private String description;

    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    public String getDescription() {
        return description;
    }

    public void setDescription(String d) {
        this.description = d;
    }
}
",data class
1213,"    public static byte[] getIP() {
        try {
            Enumeration allNetInterfaces = NetworkInterface.getNetworkInterfaces();
            InetAddress ip = null;
            byte[] internalIP = null;
            while (allNetInterfaces.hasMoreElements()) {
                NetworkInterface netInterface = (NetworkInterface) allNetInterfaces.nextElement();
                Enumeration addresses = netInterface.getInetAddresses();
                while (addresses.hasMoreElements()) {
                    ip = (InetAddress) addresses.nextElement();
                    if (ip != null && ip instanceof Inet4Address) {
                        byte[] ipByte = ip.getAddress();
                        if (ipByte.length == 4) {
                            if (ipCheck(ipByte)) {
                                if (!isInternalIP(ipByte)) {
                                    return ipByte;
                                } else if (internalIP == null) {
                                    internalIP = ipByte;
                                }
                            }
                        }
                    }
                }
            }
            if (internalIP != null) {
                return internalIP;
            } else {
                throw new RuntimeException(""Can not get local ip"");
            }
        } catch (Exception e) {
            throw new RuntimeException(""Can not get local ip"", e);
        }
    }
",long method
1481,"public class Shape {

    private String type;

    private Map<String, Member> members = Collections.emptyMap();

    private String documentation;

    private List<String> required;

    private List<String> enumValues;

    private String payload;

    private boolean flattened;

    private boolean exception;

    private boolean streaming;

    private boolean wrapper;

    private Member listMember;

    private Member mapKeyType;

    private Member mapValueType;

    @JsonProperty(value = ""error"")
    private ErrorTrait errorTrait;

    private long min;

    private long max;

    private String pattern;

    private boolean fault;

    private boolean deprecated;

    @JsonProperty(value = ""eventstream"")
    private boolean isEventStream;

    @JsonProperty(value = ""event"")
    private boolean isEvent;

    private String timestampFormat;

    private boolean sensitive;

    public boolean isFault() {
        return fault;
    }

    public void setFault(boolean fault) {
        this.fault = fault;
    }

    public String getPattern() {
        return pattern;
    }

    public void setPattern(String pattern) {
        this.pattern = pattern;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public Map<String, Member> getMembers() {
        return members;
    }

    public void setMembers(Map<String, Member> members) {
        this.members = members;
    }

    public String getDocumentation() {
        return documentation;
    }

    public void setDocumentation(String documentation) {
        this.documentation = documentation;
    }

    public List<String> getRequired() {
        return required;
    }

    public void setRequired(List<String> required) {
        this.required = required;
    }

    public List<String> getEnumValues() {
        return enumValues;
    }

    @JsonProperty(value = ""enum"")
    public void setEnumValues(List<String> enumValues) {
        this.enumValues = enumValues;
    }

    public String getPayload() {
        return payload;
    }

    public void setPayload(String payload) {
        this.payload = payload;
    }

    public boolean isFlattened() {
        return flattened;
    }

    public void setFlattened(boolean flattened) {
        this.flattened = flattened;
    }

    public boolean isException() {
        return exception;
    }

    public void setException(boolean exception) {
        this.exception = exception;
    }

    public Member getMapKeyType() {
        return mapKeyType;
    }

    @JsonProperty(value = ""key"")
    public void setMapKeyType(Member mapKeyType) {
        this.mapKeyType = mapKeyType;
    }

    public Member getMapValueType() {
        return mapValueType;
    }

    @JsonProperty(value = ""value"")
    public void setMapValueType(Member mapValueType) {
        this.mapValueType = mapValueType;
    }

    public Member getListMember() {
        return listMember;
    }

    @JsonProperty(value = ""member"")
    public void setListMember(Member listMember) {
        this.listMember = listMember;
    }

    public long getMin() {
        return min;
    }

    public void setMin(long min) {
        this.min = min;
    }

    public long getMax() {
        return max;
    }

    public void setMax(long max) {
        this.max = max;
    }

    public boolean isStreaming() {
        return streaming;
    }

    public void setStreaming(boolean streaming) {
        this.streaming = streaming;
    }

    public boolean isWrapper() {
        return wrapper;
    }

    public void setWrapper(boolean wrapper) {
        this.wrapper = wrapper;
    }

    public ErrorTrait getErrorTrait() {
        return errorTrait;
    }

    public void setErrorTrait(ErrorTrait errorTrait) {
        this.errorTrait = errorTrait;
    }

    public boolean isDeprecated() {
        return deprecated;
    }

    public void setDeprecated(boolean deprecated) {
        this.deprecated = deprecated;
    }

    public boolean isEventStream() {
        return isEventStream;
    }

    public void setIsEventStream(boolean eventStream) {
        isEventStream = eventStream;
    }

    public boolean isEvent() {
        return isEvent;
    }

    public void setIsEvent(boolean event) {
        isEvent = event;
    }

    public String getTimestampFormat() {
        return timestampFormat;
    }

    public void setTimestampFormat(String timestampFormat) {
        this.timestampFormat = timestampFormat;
    }

    public boolean isSensitive() {
        return sensitive;
    }

    public void setSensitive(boolean sensitive) {
        this.sensitive = sensitive;
    }
}
",data class
1330,"@SuppressWarnings(""deprecation"")
public class MRBaseForCommonInstructions extends MapReduceBase
{
	
	//indicate whether the matrix value in this mapper is a matrix cell or a matrix block
	protected Class<? extends MatrixValue> valueClass;
	
	//a cache to hold the intermediate results
	protected CachedValueMap cachedValues=new CachedValueMap();
	
	//distributed cache data handling
	public static boolean isJobLocal = false; //set from MapperBase
	public static HashMap<Byte, DistributedCacheInput> dcValues = new HashMap<>();
 	
	protected HashMap<Byte, MatrixCharacteristics> dimensions=new HashMap<>();
	
	//temporary variables
	protected IndexedMatrixValue tempValue=null;
	protected IndexedMatrixValue zeroInput=null;	

	@Override
	public void configure(JobConf job)
	{	
		//whether to use the cell representation or the block representation
		valueClass=MRJobConfiguration.getMatrixValueClass(job);
		//allocate space for temporary variables
		tempValue=new IndexedMatrixValue(valueClass);
		zeroInput=new IndexedMatrixValue(valueClass);
		
		//matrix characteristics inputs/outputs
		byte[] inputIX = MRJobConfiguration.getInputIndexesInMapper(job);
		for( byte ix : inputIX )
			dimensions.put(ix, MRJobConfiguration.getMatrixCharacteristicsForInput(job, ix));	
		
		byte[] mapOutputIX = MRJobConfiguration.getOutputIndexesInMapper(job);
		for(byte ix : mapOutputIX)
			dimensions.put(ix, MRJobConfiguration.getMatrixCharacteristicsForMapOutput(job, ix));
		
		byte[] outputIX = MRJobConfiguration.getResultIndexes(job);
		for( byte ix : outputIX )
			dimensions.put(ix, MRJobConfiguration.getMatrixCharacteristicsForOutput(job, ix));	
		
		//matrix characteristics intermediates
		byte[] immediateIndexes=MRJobConfiguration.getIntermediateMatrixIndexes(job);
		if(immediateIndexes!=null)
		{
			for(byte index: immediateIndexes)
				dimensions.put(index, MRJobConfiguration.getIntermediateMatrixCharactristics(job, index));			
		}
	}

	protected void collectOutput_N_Increase_Counter(MatrixIndexes indexes, MatrixValue value, 
			int i, Reporter reporter, CollectMultipleConvertedOutputs collectFinalMultipleOutputs, 
			byte[] resultDimsUnknown, long[] resultsNonZeros, long[] resultsMaxRowDims, 
			long[] resultsMaxColDims) throws IOException
	{
 		collectFinalMultipleOutputs.collectOutput(indexes, value, i, reporter);
		resultsNonZeros[i]+=value.getNonZeros();
		
		if ( resultDimsUnknown[i] == (byte) 1 ) 
		{
			// compute dimensions for the resulting matrix
			
			// find the maximum row index and column index encountered in current output block/cell 
			long maxrow = getMaxDimension(indexes, value, true);
			long maxcol = getMaxDimension(indexes, value, false);
			
			if ( maxrow > resultsMaxRowDims[i] )
				resultsMaxRowDims[i] = maxrow;
				
			if ( maxcol > resultsMaxColDims[i] )
				resultsMaxColDims[i] = maxcol;
		}
		else if(resultDimsUnknown[i] == (byte) 2)
		{
			if ( indexes.getRowIndex() > resultsMaxRowDims[i] )
				resultsMaxRowDims[i] = indexes.getRowIndex();
				
			if ( indexes.getColumnIndex() > resultsMaxColDims[i] )
				resultsMaxColDims[i] = indexes.getColumnIndex();
		}
	}

	protected void processMixedInstructions(ArrayList<MRInstruction> mixed_instructions) {
		if( mixed_instructions != null )
			for( MRInstruction ins : mixed_instructions )
				processOneInstruction(ins, valueClass, cachedValues, tempValue, zeroInput);
	}

	protected void processOneInstruction(MRInstruction ins, Class<? extends MatrixValue> valueClass,
			CachedValueMap cachedValues, IndexedMatrixValue tempValue, IndexedMatrixValue zeroInput) {
		//Timing time = new Timing(true);
		
		if ( ins instanceof AggregateBinaryInstruction ) {
			byte input = ((AggregateBinaryInstruction)ins).input1;
			MatrixCharacteristics dim=dimensions.get(input);
			if(dim==null)
				throw new DMLRuntimeException(""dimension for instruction ""+ins+""  is unset!!!"");
			ins.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dim.getRowsPerBlock(), dim.getColsPerBlock());
		}
		else if(ins instanceof ZeroOutInstruction || ins instanceof AggregateUnaryInstruction 
				|| ins instanceof RangeBasedReIndexInstruction || ins instanceof CumulativeSplitInstruction)
		{
			byte input=((UnaryMRInstructionBase) ins).input;
			MatrixCharacteristics dim=dimensions.get(input);
			if(dim==null)
				throw new DMLRuntimeException(""dimension for instruction ""+ins+""  is unset!!!"");
			if( ins instanceof CumulativeAggregateInstruction )
				((CumulativeAggregateInstruction)ins).setMatrixCharacteristics(dim);
			if( ins instanceof CumulativeSplitInstruction )
				((CumulativeSplitInstruction)ins).setMatrixCharacteristics(dim);
			ins.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dim.getRowsPerBlock(), dim.getColsPerBlock());
		}
		else if( ins instanceof ReorgInstruction )
		{
			ReorgInstruction rinst = (ReorgInstruction) ins;
			byte input = rinst.input;
			MatrixCharacteristics dim = dimensions.get(input);
			if(dim==null)
				throw new DMLRuntimeException(""dimension for instruction ""+ins+""  is unset!!!"");
			rinst.setInputMatrixCharacteristics(dim);
			rinst.setOutputEmptyBlocks(!(this instanceof MMCJMRMapper)); //MMCJMRMapper does not output empty blocks, no need to generate
			ins.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dim.getRowsPerBlock(), dim.getColsPerBlock());
		}
		else if( ins instanceof MatrixReshapeMRInstruction )
		{
			MatrixReshapeMRInstruction mrins = (MatrixReshapeMRInstruction) ins;
			byte input = mrins.input;
			byte output = mrins.output; 
			MatrixCharacteristics dimIn=dimensions.get(input);
			MatrixCharacteristics dimOut=dimensions.get(output);
			if(dimIn==null || dimOut==null)
				throw new DMLRuntimeException(""dimension for instruction ""+ins+""  is unset!!!"");
			mrins.setMatrixCharacteristics(dimIn, dimOut);
			mrins.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dimIn.getRowsPerBlock(), dimIn.getColsPerBlock());
		}
		else if(ins instanceof AppendMInstruction)
		{
			byte input=((AppendMInstruction) ins).input1;
			MatrixCharacteristics dim=dimensions.get(input);
			if(dim==null)
				throw new DMLRuntimeException(""dimension for instruction ""+ins+""  is unset!!!"");
			ins.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dim.getRowsPerBlock(), dim.getColsPerBlock());
		}
		else if(ins instanceof BinaryMInstruction || ins instanceof RemoveEmptyMRInstruction )
		{
			byte input=((BinaryMRInstructionBase) ins).input1;
			MatrixCharacteristics dim=dimensions.get(input);
			if(dim==null)
				throw new DMLRuntimeException(""dimension for instruction ""+ins+""  is unset!!!"");
			ins.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dim.getRowsPerBlock(), dim.getColsPerBlock());
		}
		else if(ins instanceof AppendGInstruction)
		{
			AppendGInstruction arinst = ((AppendGInstruction) ins);
			byte input = arinst.input1;
			MatrixCharacteristics dimIn=dimensions.get(input);
			if( dimIn==null )
				throw new DMLRuntimeException(""Dimensions for instruction ""+arinst+""  is unset!!!"");
			arinst.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dimIn.getRowsPerBlock(), dimIn.getColsPerBlock());
		}
		else if(ins instanceof UnaryMRInstructionBase)
		{
			UnaryMRInstructionBase rinst = (UnaryMRInstructionBase) ins;
			MatrixCharacteristics dimIn=dimensions.get(rinst.input);
			if( dimIn==null )
				throw new DMLRuntimeException(""Dimensions for instruction ""+rinst+""  is unset!!!"");
			rinst.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dimIn.getRowsPerBlock(), dimIn.getColsPerBlock());
		}
		else if(ins instanceof BinaryMRInstructionBase)
		{
			BinaryMRInstructionBase rinst = (BinaryMRInstructionBase) ins;
			MatrixCharacteristics dimIn=dimensions.get(rinst.input1);
			if( dimIn!=null ) //not set for all
				rinst.processInstruction(valueClass, cachedValues, tempValue, zeroInput, dimIn.getRowsPerBlock(), dimIn.getColsPerBlock());
			else
				ins.processInstruction(valueClass, cachedValues, tempValue, zeroInput, -1, -1);
		}
		else
			ins.processInstruction(valueClass, cachedValues, tempValue, zeroInput, -1, -1);
	
		//System.out.println(ins.getMRInstructionType()+"" in ""+time.stop());
	}
	
	/**
	 * Reset in-memory state from distributed cache (required only for
	 * local job runner) 
	 */
	public static void resetDistCache()
	{
		for(DistributedCacheInput dcInput : dcValues.values() ) 
			dcInput.reset();
		dcValues.clear();
	}

	protected void setupDistCacheFiles(JobConf job) 
		throws IOException 
	{
		
		if ( MRJobConfiguration.getDistCacheInputIndices(job) == null )
			return;
		
		//boolean isJobLocal = false;
		isJobLocal = InfrastructureAnalyzer.isLocalMode(job);
		
		String[] inputIndices = MRJobConfiguration.getInputPaths(job);
		String[] dcIndices = MRJobConfiguration.getDistCacheInputIndices(job).split(Instruction.INSTRUCTION_DELIM);
		Path[] dcFiles = DistributedCache.getLocalCacheFiles(job);
		PDataPartitionFormat[] inputPartitionFormats = MRJobConfiguration.getInputPartitionFormats(job);
		
		DistributedCacheInput[] dcInputs = new DistributedCacheInput[dcIndices.length];
		for(int i=0; i < dcIndices.length; i++) {
        	byte inputIndex = Byte.parseByte(dcIndices[i]);
        	
        	//load if not already present (jvm reuse)
        	if( !dcValues.containsKey(inputIndex) )
        	{
				// When the job is in local mode, files can be read from HDFS directly -- use 
				// input paths as opposed to ""local"" paths prepared by DistributedCache. 
	        	Path p = null;
				if(isJobLocal)
					p = new Path(inputIndices[ Byte.parseByte(dcIndices[i]) ]);
				else
					p = dcFiles[i];
				
				dcInputs[i] = new DistributedCacheInput(
									p, 
									MRJobConfiguration.getNumRows(job, inputIndex), //rlens[inputIndex],
									MRJobConfiguration.getNumColumns(job, inputIndex), //clens[inputIndex],
									MRJobConfiguration.getNumRowsPerBlock(job, inputIndex), //brlens[inputIndex],
									MRJobConfiguration.getNumColumnsPerBlock(job, inputIndex), //bclens[inputIndex],
									inputPartitionFormats[inputIndex]
								);
	        	dcValues.put(inputIndex, dcInputs[i]);
        	}
		}	
	}
	
	/**
	 * Returns the maximum row or column dimension of the given key and value pair. 
	 * 
	 * @param key matrix indexes
	 * @param value MatrixValue of either type MatrixCell or MatrixBlock
	 * @param row if true return row dimension, else return column dimension
	 * @return maximum row or column dimension, or 0 if MatrixValue not MatrixCell or MatrixBlock
	 */
	private static long getMaxDimension( MatrixIndexes key, MatrixValue value, boolean row ) {
		if( value instanceof MatrixCell )
			return row ? key.getRowIndex() : key.getColumnIndex();
		else if( value instanceof MatrixBlock )
			return row ? value.getNumRows() : value.getNumColumns();
		return 0;
	}
}
",blob
1035,"    public static byte[] getIP() {
        try {
            Enumeration allNetInterfaces = NetworkInterface.getNetworkInterfaces();
            InetAddress ip = null;
            byte[] internalIP = null;
            while (allNetInterfaces.hasMoreElements()) {
                NetworkInterface netInterface = (NetworkInterface) allNetInterfaces.nextElement();
                Enumeration addresses = netInterface.getInetAddresses();
                while (addresses.hasMoreElements()) {
                    ip = (InetAddress) addresses.nextElement();
                    if (ip != null && ip instanceof Inet4Address) {
                        byte[] ipByte = ip.getAddress();
                        if (ipByte.length == 4) {
                            if (ipCheck(ipByte)) {
                                if (!isInternalIP(ipByte)) {
                                    return ipByte;
                                } else if (internalIP == null) {
                                    internalIP = ipByte;
                                }
                            }
                        }
                    }
                }
            }
            if (internalIP != null) {
                return internalIP;
            } else {
                throw new RuntimeException(""Can not get local ip"");
            }
        } catch (Exception e) {
            throw new RuntimeException(""Can not get local ip"", e);
        }
    }
",long method
1083,"public class SparkCubingMerge extends AbstractApplication implements Serializable {

    protected static final Logger logger = LoggerFactory.getLogger(SparkCubingMerge.class);

    public static final Option OPTION_CUBE_NAME = OptionBuilder.withArgName(BatchConstants.ARG_CUBE_NAME).hasArg()
            .isRequired(true).withDescription(""Cube Name"").create(BatchConstants.ARG_CUBE_NAME);
    public static final Option OPTION_SEGMENT_ID = OptionBuilder.withArgName(""segment"").hasArg().isRequired(true)
            .withDescription(""Cube Segment Id"").create(""segmentId"");
    public static final Option OPTION_META_URL = OptionBuilder.withArgName(""metaUrl"").hasArg().isRequired(true)
            .withDescription(""HDFS metadata url"").create(""metaUrl"");
    public static final Option OPTION_OUTPUT_PATH = OptionBuilder.withArgName(BatchConstants.ARG_OUTPUT).hasArg()
            .isRequired(true).withDescription(""HFile output path"").create(BatchConstants.ARG_OUTPUT);
    public static final Option OPTION_INPUT_PATH = OptionBuilder.withArgName(BatchConstants.ARG_INPUT).hasArg()
            .isRequired(true).withDescription(""Cuboid files PATH"").create(BatchConstants.ARG_INPUT);

    private Options options;

    private String cubeName;
    private String metaUrl;

    public SparkCubingMerge() {
        options = new Options();
        options.addOption(OPTION_META_URL);
        options.addOption(OPTION_CUBE_NAME);
        options.addOption(OPTION_SEGMENT_ID);
        options.addOption(OPTION_INPUT_PATH);
        options.addOption(OPTION_OUTPUT_PATH);
    }

    @Override
    protected Options getOptions() {
        return options;
    }

    @Override
    protected void execute(OptionsHelper optionsHelper) throws Exception {
        this.metaUrl = optionsHelper.getOptionValue(OPTION_META_URL);
        this.cubeName = optionsHelper.getOptionValue(OPTION_CUBE_NAME);
        final String inputPath = optionsHelper.getOptionValue(OPTION_INPUT_PATH);
        final String segmentId = optionsHelper.getOptionValue(OPTION_SEGMENT_ID);
        final String outputPath = optionsHelper.getOptionValue(OPTION_OUTPUT_PATH);

        Class[] kryoClassArray = new Class[] { Class.forName(""scala.reflect.ClassTag$$anon$1"") };

        SparkConf conf = new SparkConf().setAppName(""Merge segments for cube:"" + cubeName + "", segment "" + segmentId);
        //serialization conf
        conf.set(""spark.serializer"", ""org.apache.spark.serializer.KryoSerializer"");
        conf.set(""spark.kryo.registrator"", ""org.apache.kylin.engine.spark.KylinKryoRegistrator"");
        conf.set(""spark.kryo.registrationRequired"", ""true"").registerKryoClasses(kryoClassArray);

        try (JavaSparkContext sc = new JavaSparkContext(conf)) {
            SparkUtil.modifySparkHadoopConfiguration(sc.sc()); // set dfs.replication=2 and enable compress
            KylinSparkJobListener jobListener = new KylinSparkJobListener();
            sc.sc().addSparkListener(jobListener);

            HadoopUtil.deletePath(sc.hadoopConfiguration(), new Path(outputPath));
            final SerializableConfiguration sConf = new SerializableConfiguration(sc.hadoopConfiguration());
            final KylinConfig envConfig = AbstractHadoopJob.loadKylinConfigFromHdfs(sConf, metaUrl);

            final CubeInstance cubeInstance = CubeManager.getInstance(envConfig).getCube(cubeName);
            final CubeDesc cubeDesc = CubeDescManager.getInstance(envConfig).getCubeDesc(cubeInstance.getDescName());
            final CubeSegment cubeSegment = cubeInstance.getSegmentById(segmentId);
            final CubeStatsReader cubeStatsReader = new CubeStatsReader(cubeSegment, envConfig);

            logger.info(""Input path: {}"", inputPath);
            logger.info(""Output path: {}"", outputPath);

            final Job job = Job.getInstance(sConf.get());

            SparkUtil.setHadoopConfForCuboid(job, cubeSegment, metaUrl);

            final MeasureAggregators aggregators = new MeasureAggregators(cubeDesc.getMeasures());
            final Function2 reduceFunction = new Function2<Object[], Object[], Object[]>() {
                @Override
                public Object[] call(Object[] input1, Object[] input2) throws Exception {
                    Object[] measureObjs = new Object[input1.length];
                    aggregators.aggregate(input1, input2, measureObjs);
                    return measureObjs;
                }
            };

            final PairFunction convertTextFunction = new PairFunction<Tuple2<Text, Object[]>, org.apache.hadoop.io.Text, org.apache.hadoop.io.Text>() {
                private transient volatile boolean initialized = false;
                BufferedMeasureCodec codec;

                @Override
                public Tuple2<org.apache.hadoop.io.Text, org.apache.hadoop.io.Text> call(Tuple2<Text, Object[]> tuple2)
                        throws Exception {

                    if (initialized == false) {
                        synchronized (SparkCubingMerge.class) {
                            if (initialized == false) {
                                synchronized (SparkCubingMerge.class) {
                                    if (initialized == false) {
                                        KylinConfig kylinConfig = AbstractHadoopJob.loadKylinConfigFromHdfs(sConf, metaUrl);
                                        try (KylinConfig.SetAndUnsetThreadLocalConfig autoUnset = KylinConfig
                                                .setAndUnsetThreadLocalConfig(kylinConfig)) {
                                            CubeDesc desc = CubeDescManager.getInstance(kylinConfig).getCubeDesc(cubeName);
                                            codec = new BufferedMeasureCodec(desc.getMeasures());
                                            initialized = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    ByteBuffer valueBuf = codec.encode(tuple2._2());
                    byte[] encodedBytes = new byte[valueBuf.position()];
                    System.arraycopy(valueBuf.array(), 0, encodedBytes, 0, valueBuf.position());
                    return new Tuple2<>(tuple2._1(), new org.apache.hadoop.io.Text(encodedBytes));
                }
            };

            final int totalLevels = cubeSegment.getCuboidScheduler().getBuildLevel();
            final String[] inputFolders = StringSplitter.split(inputPath, "","");
            FileSystem fs = HadoopUtil.getWorkingFileSystem();
            boolean isLegacyMode = false;
            for (String inputFolder : inputFolders) {
                Path baseCuboidPath = new Path(BatchCubingJobBuilder2.getCuboidOutputPathsByLevel(inputFolder, 0));
                if (fs.exists(baseCuboidPath) == false) {
                    // doesn't exist sub folder, that means the merged cuboid in one folder (not by layer)
                    isLegacyMode = true;
                    break;
                }
            }

            if (isLegacyMode == true) {
                // merge all layer's cuboid at once, this might be hard for Spark
                List<JavaPairRDD<Text, Object[]>> mergingSegs = Lists.newArrayListWithExpectedSize(inputFolders.length);
                for (int i = 0; i < inputFolders.length; i++) {
                    String path = inputFolders[i];
                    JavaPairRDD segRdd = SparkUtil.parseInputPath(path, fs, sc, Text.class, Text.class);
                    CubeSegment sourceSegment = findSourceSegment(path, cubeInstance);
                    // re-encode with new dictionaries
                    JavaPairRDD<Text, Object[]> newEcoddedRdd = segRdd.mapToPair(new ReEncodeCuboidFunction(cubeName,
                            sourceSegment.getUuid(), cubeSegment.getUuid(), metaUrl, sConf));
                    mergingSegs.add(newEcoddedRdd);
                }

                FileOutputFormat.setOutputPath(job, new Path(outputPath));
                sc.union(mergingSegs.toArray(new JavaPairRDD[mergingSegs.size()]))
                        .reduceByKey(reduceFunction, SparkUtil.estimateTotalPartitionNum(cubeStatsReader, envConfig))
                        .mapToPair(convertTextFunction).saveAsNewAPIHadoopDataset(job.getConfiguration());

            } else {
                // merge by layer
                for (int level = 0; level <= totalLevels; level++) {
                    List<JavaPairRDD<Text, Object[]>> mergingSegs = Lists.newArrayList();
                    for (int i = 0; i < inputFolders.length; i++) {
                        String path = inputFolders[i];
                        CubeSegment sourceSegment = findSourceSegment(path, cubeInstance);
                        final String cuboidInputPath = BatchCubingJobBuilder2.getCuboidOutputPathsByLevel(path, level);
                        JavaPairRDD<Text, Text> segRdd = sc.sequenceFile(cuboidInputPath, Text.class, Text.class);
                        // re-encode with new dictionaries
                        JavaPairRDD<Text, Object[]> newEcoddedRdd = segRdd.mapToPair(new ReEncodeCuboidFunction(cubeName,
                                sourceSegment.getUuid(), cubeSegment.getUuid(), metaUrl, sConf));
                        mergingSegs.add(newEcoddedRdd);
                    }

                    final String cuboidOutputPath = BatchCubingJobBuilder2.getCuboidOutputPathsByLevel(outputPath, level);
                    FileOutputFormat.setOutputPath(job, new Path(cuboidOutputPath));

                    sc.union(mergingSegs.toArray(new JavaPairRDD[mergingSegs.size()]))
                            .reduceByKey(reduceFunction,
                                    SparkUtil.estimateLayerPartitionNum(level, cubeStatsReader, envConfig))
                            .mapToPair(convertTextFunction).saveAsNewAPIHadoopDataset(job.getConfiguration());
                }
            }
            // output the data size to console, job engine will parse and save the metric
            // please note: this mechanism won't work when spark.submit.deployMode=cluster
            logger.info(""HDFS: Number of bytes written={}"", jobListener.metrics.getBytesWritten());
        }
    }

    static class ReEncodeCuboidFunction implements PairFunction<Tuple2<Text, Text>, Text, Object[]> {
        private transient volatile boolean initialized = false;
        private String cubeName;
        private String sourceSegmentId;
        private String mergedSegmentId;
        private String metaUrl;
        private SerializableConfiguration conf;
        private transient KylinConfig kylinConfig;
        private transient SegmentReEncoder segmentReEncoder = null;

        ReEncodeCuboidFunction(String cubeName, String sourceSegmentId, String mergedSegmentId, String metaUrl,
                               SerializableConfiguration conf) {
            this.cubeName = cubeName;
            this.sourceSegmentId = sourceSegmentId;
            this.mergedSegmentId = mergedSegmentId;
            this.metaUrl = metaUrl;
            this.conf = conf;
        }

        private void init() {
            this.kylinConfig = AbstractHadoopJob.loadKylinConfigFromHdfs(conf, metaUrl);
            final CubeInstance cube = CubeManager.getInstance(kylinConfig).getCube(cubeName);
            final CubeDesc cubeDesc = CubeDescManager.getInstance(kylinConfig).getCubeDesc(cube.getDescName());
            final CubeSegment sourceSeg = cube.getSegmentById(sourceSegmentId);
            final CubeSegment mergedSeg = cube.getSegmentById(mergedSegmentId);
            this.segmentReEncoder = new SegmentReEncoder(cubeDesc, sourceSeg, mergedSeg, kylinConfig);
        }

        @Override
        public Tuple2<Text, Object[]> call(Tuple2<Text, Text> textTextTuple2) throws Exception {
            if (initialized == false) {
                synchronized (ReEncodeCuboidFunction.class) {
                    if (initialized == false) {
                        init();
                        initialized = true;
                    }
                }
            }
            Pair<Text, Object[]> encodedPair = segmentReEncoder.reEncode2(textTextTuple2._1, textTextTuple2._2);
            return new Tuple2(encodedPair.getFirst(), encodedPair.getSecond());
        }
    }

    private CubeSegment findSourceSegment(String filePath, CubeInstance cube) {
        String jobID = JobBuilderSupport.extractJobIDFromPath(filePath);
        return CubeInstance.findSegmentWithJobId(jobID, cube);
    }

}
",blob
62,"  @Override
  public String vmExecutablePath(Vm vm) {
    File homeDir = vmHomeDir(vm);
    for (String extension : EXECUTABLE_EXTENSIONS) {
      for (String dir : EXECUTABLE_DIRS) {
        File file = new File(homeDir, dir + vm.executable() + extension);
        if (file.isFile()) {
          return file.getAbsolutePath();
        }
      }
    }
    throw new VirtualMachineException(
        String.format(
            ""VM executable %s for VM %s not found under home dir %s"",
            vm.executable(), vm, homeDir));
  }
",feature envy
1085,"public class SetOrderReferenceDetailsRequest extends DelegateRequest<SetOrderReferenceDetailsRequest> implements Serializable {

    @Override
    protected SetOrderReferenceDetailsRequest getThis() {
        return this;
    }

    //required parameters
    private String amazonOrderReferenceId;
    private String orderAmount;
    private CurrencyCode orderCurrencyCode;

    //optional parameters
    private String platformId;
    private String sellerNote;
    private String sellerOrderId;
    private String storeName;
    private String supplementaryData;
    private String customInformation;
    private Boolean requestPaymentAuthorization;

    /**
     *
     * @param amazonOrderReferenceId
     *              This value is retrieved from the Amazon Button widget
     *              after the buyer has successfully authenticated with Amazon.
     *
     * @param orderAmount
     *              Specifies the total amount of the order represented by this order reference.
     */
    public SetOrderReferenceDetailsRequest(String amazonOrderReferenceId, String orderAmount) {
        this.amazonOrderReferenceId = amazonOrderReferenceId;
        this.orderAmount = orderAmount;
    }

    /**
     * Overrides the Client's currency code with specified currency code in SetOrderReferenceDetailsRequest
     *
     * @param currencyCode
     *              A three-digit currency code, formatted based on the ISO 4217 standard.
     *
     * @return currenyCode
     */
    public SetOrderReferenceDetailsRequest setOrderCurrencyCode(CurrencyCode currencyCode) {
        this.orderCurrencyCode = currencyCode;
        return this;
    }

    /**
     * Represents the SellerId of the Solution Provider that developed the platform.
     * This value should only be provided by Solution Providers. It should not be
     * provided by merchants creating their own custom integration.
     *
     * @param platformId Represents the SellerId of the Solution Provider that developed the platform.
     *                   This value should only be provided by Solution Providers. It should
     *                   not be provided by merchants creating their own custom integration.
     *
     * @return Returns a reference to this object so that methods can be chained together.
     */
    public SetOrderReferenceDetailsRequest setPlatformId(String platformId) {
        this.platformId = platformId;
        return this;
    }

    /**
     * Represents a description of the order that is displayed in emails to the buyer.
     *
     * @param sellerNote Represents a description of the order that is displayed in emails to the buyer.
     *
     * @return Returns a reference to this object so that methods can be chained together.
     */
    public SetOrderReferenceDetailsRequest setSellerNote(String sellerNote) {
        this.sellerNote = sellerNote;
        return this;
    }

    /**
     * The merchant-specified identifier of this order. This is displayed to the
     * buyer in their emails and transaction history on the Amazon Pay website.
     *
     * @param sellerOrderId merchant-specified identifier of the order.
     *
     * @return the Seller Order ID
     */
    public SetOrderReferenceDetailsRequest setSellerOrderId(String sellerOrderId) {
        this.sellerOrderId = sellerOrderId;
        return this;
    }

    /**
     * The identifier of the store from which the order was placed. This overrides
     * the default value in Seller Central under Settings &gt; Account Settings. It is
     * displayed to the buyer in their emails and transaction history on the
     * Amazon Pay website.
     *
     * @param storeName the identifier of the store from which the order was placed.
     *
     * @return the Store Name
     */
    public SetOrderReferenceDetailsRequest setStoreName(String storeName) {
        this.storeName = storeName;
        return this;
    }

    /**
     * Set the trusted authorization supplementary data.
     * Use only as directed by Amazon Pay.
     *
     * @param supplementaryData Trusted authorization supplementary data (JSON string)
     *
     * @return Request object
     */
    public SetOrderReferenceDetailsRequest setSupplementaryData(final String supplementaryData) {
        this.supplementaryData = supplementaryData;
        return this;
    }

    /**
     * Any additional information that you want to include with this order reference.
     *
     * @param customInformation Additional information that merchant wants to pass for the order.
     *
     * @return Custom Information
     */
    public SetOrderReferenceDetailsRequest setCustomInformation(String customInformation) {
        this.customInformation = customInformation;
        return this;
    }

    /**
     *
     * @return AmazonOrderReferenceId
     */
    public String getAmazonOrderReferenceId() {
        return amazonOrderReferenceId;
    }

    /**
     *
     * @return OrderAmount
     */
    public String getOrderAmount() {
        return orderAmount;
    }

    /**
     *
     * @return OrderCurrencyCode
     */
    public CurrencyCode getOrderCurrencyCode() {
        return orderCurrencyCode;
    }

    /**
     *
     * @return PlatformId
     */
    public String getPlatformId() {
        return platformId;
    }

    /**
     *
     * @return SellerNote
     */
    public String getSellerNote() {
        return sellerNote;
    }

    /**
     *
     * @return SellerOrderId
     */
    public String getSellerOrderId() {
        return sellerOrderId;
    }

    /**
     *
     * @return StoreName
     */
    public String getStoreName() {
        return storeName;
    }

    /**
     * Returns the trusted authorization supplementary data.
     *
     * @return supplementaryData as a JSON string
     */
    public String getSupplementaryData() {
        return supplementaryData;
    }

    /**
     *
     * @return CustomInformation
     */
    public String getCustomInformation() {
        return customInformation;
    }

    /**
     *Check if payment authorization has been requested or not
     *
     * @return Value of the requestPaymentAuthorization
     */
    public Boolean getRequestPaymentAuthorization() {
        return requestPaymentAuthorization;
    }

    /**
     * Specifies if the merchants want their buyers to go through multi-factor authentication
     *
     * @param requestPaymentAuthorization flag exposed to merchants using which merchants
     *                                    can enforce their buyers to through multi-factor authentication
     *
     * @return Value of the requestPaymentAuthorization
     */
    public SetOrderReferenceDetailsRequest setRequestPaymentAuthorization(Boolean requestPaymentAuthorization) {
        this.requestPaymentAuthorization = requestPaymentAuthorization;
        return this;
    }

    /**
     * Returns a string representation of this object; useful for testing and
     * debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        return ""SetOrderReferenceDetailsRequest{""
                + ""amazonOrderReferenceId="" + amazonOrderReferenceId
                + "", orderAmount="" + orderAmount
                + "", orderCurrencyCode="" + orderCurrencyCode
                + "", platformId="" + platformId
                + "", sellerNote="" + sellerNote
                + "", sellerOrderId="" + sellerOrderId
                + "", storeName="" + storeName
                + "", supplementaryData="" + supplementaryData
                + "", customInformation="" + customInformation
                + "", mwsAuthToken="" + getMwsAuthToken() + '}';
    }

}
",data class
51,"public interface CompilationIdentifier {

    enum Verbosity {
        /**
         * Only the unique identifier of the compilation.
         */
        ID,
        /**
         * Only the name of the compilation unit.
         */
        NAME,
        /**
         * {@link #ID} + a readable description.
         */
        DETAILED
    }

    CompilationRequestIdentifier INVALID_COMPILATION_ID = new CompilationRequestIdentifier() {

        @Override
        public String toString() {
            return toString(Verbosity.DETAILED);
        }

        @Override
        public String toString(Verbosity verbosity) {
            return ""InvalidCompilationID"";
        }

        @Override
        public CompilationRequest getRequest() {
            return null;
        }

    };

    /**
     * This method is a shortcut for {@link #toString(Verbosity)} with {@link Verbosity#DETAILED}.
     */
    @Override
    String toString();

    /**
     * Creates a String representation for this compilation identifier with a given
     * {@link Verbosity}.
     */
    String toString(Verbosity verbosity);
}
",data class
526,"public class Shape {

    private String type;

    private Map<String, Member> members = Collections.emptyMap();

    private String documentation;

    private List<String> required;

    private List<String> enumValues;

    private String payload;

    private boolean flattened;

    private boolean exception;

    private boolean streaming;

    private boolean wrapper;

    private Member listMember;

    private Member mapKeyType;

    private Member mapValueType;

    @JsonProperty(value = ""error"")
    private ErrorTrait errorTrait;

    private long min;

    private long max;

    private String pattern;

    private boolean fault;

    private boolean deprecated;

    @JsonProperty(value = ""eventstream"")
    private boolean isEventStream;

    @JsonProperty(value = ""event"")
    private boolean isEvent;

    private String timestampFormat;

    private boolean sensitive;

    public boolean isFault() {
        return fault;
    }

    public void setFault(boolean fault) {
        this.fault = fault;
    }

    public String getPattern() {
        return pattern;
    }

    public void setPattern(String pattern) {
        this.pattern = pattern;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public Map<String, Member> getMembers() {
        return members;
    }

    public void setMembers(Map<String, Member> members) {
        this.members = members;
    }

    public String getDocumentation() {
        return documentation;
    }

    public void setDocumentation(String documentation) {
        this.documentation = documentation;
    }

    public List<String> getRequired() {
        return required;
    }

    public void setRequired(List<String> required) {
        this.required = required;
    }

    public List<String> getEnumValues() {
        return enumValues;
    }

    @JsonProperty(value = ""enum"")
    public void setEnumValues(List<String> enumValues) {
        this.enumValues = enumValues;
    }

    public String getPayload() {
        return payload;
    }

    public void setPayload(String payload) {
        this.payload = payload;
    }

    public boolean isFlattened() {
        return flattened;
    }

    public void setFlattened(boolean flattened) {
        this.flattened = flattened;
    }

    public boolean isException() {
        return exception;
    }

    public void setException(boolean exception) {
        this.exception = exception;
    }

    public Member getMapKeyType() {
        return mapKeyType;
    }

    @JsonProperty(value = ""key"")
    public void setMapKeyType(Member mapKeyType) {
        this.mapKeyType = mapKeyType;
    }

    public Member getMapValueType() {
        return mapValueType;
    }

    @JsonProperty(value = ""value"")
    public void setMapValueType(Member mapValueType) {
        this.mapValueType = mapValueType;
    }

    public Member getListMember() {
        return listMember;
    }

    @JsonProperty(value = ""member"")
    public void setListMember(Member listMember) {
        this.listMember = listMember;
    }

    public long getMin() {
        return min;
    }

    public void setMin(long min) {
        this.min = min;
    }

    public long getMax() {
        return max;
    }

    public void setMax(long max) {
        this.max = max;
    }

    public boolean isStreaming() {
        return streaming;
    }

    public void setStreaming(boolean streaming) {
        this.streaming = streaming;
    }

    public boolean isWrapper() {
        return wrapper;
    }

    public void setWrapper(boolean wrapper) {
        this.wrapper = wrapper;
    }

    public ErrorTrait getErrorTrait() {
        return errorTrait;
    }

    public void setErrorTrait(ErrorTrait errorTrait) {
        this.errorTrait = errorTrait;
    }

    public boolean isDeprecated() {
        return deprecated;
    }

    public void setDeprecated(boolean deprecated) {
        this.deprecated = deprecated;
    }

    public boolean isEventStream() {
        return isEventStream;
    }

    public void setIsEventStream(boolean eventStream) {
        isEventStream = eventStream;
    }

    public boolean isEvent() {
        return isEvent;
    }

    public void setIsEvent(boolean event) {
        isEvent = event;
    }

    public String getTimestampFormat() {
        return timestampFormat;
    }

    public void setTimestampFormat(String timestampFormat) {
        this.timestampFormat = timestampFormat;
    }

    public boolean isSensitive() {
        return sensitive;
    }

    public void setSensitive(boolean sensitive) {
        this.sensitive = sensitive;
    }
}
",data class
516,"        @Override
        public Validator childNodeChanged(String name, NodeState before, NodeState after) throws CommitFailedException {
            Tree beforeTree = (parentBefore == null) ? null : parentBefore.getChild(name);
            Tree afterTree = parentAfter.getChild(name);

            if (isTokenTree(beforeTree) || isTokenTree(afterTree)) {
                validateTokenTree(afterTree);
            } else if (isTokensParent(beforeTree) || isTokensParent(afterTree)) {
                validateTokensParent(afterTree);
            }

            return new VisibleValidator(new TokenValidator(beforeTree, afterTree, commitInfo), true, true);
        }
",feature envy
341,"public class BuckAddDependencyIntention extends BaseIntentionAction {
  private static Logger LOGGER = Logger.getInstance(BuckAddDependencyIntention.class);

  /**
   * Creates an {@link com.intellij.codeInsight.intention.IntentionAction} that will create an
   * dependency edge in both the Buck target graph and IntelliJ module graph from the nodes for the
   * given reference element to those of the given psiClass.
   *
   * <p>Note that this intention can fail to be created if either side of the edge cannot be
   * resolved to a buck file in a buck cell, in which case this method returns null. Also, invoking
   * this intention may fail to create edges in either the Buck target graph or the IntelliJ module
   * graph (or both).
   */
  @Nullable
  public static BuckAddDependencyIntention create(
      PsiJavaCodeReferenceElement referenceElement, PsiClass psiClass) {
    VirtualFile editSourceFile = referenceElement.getContainingFile().getVirtualFile();
    if (editSourceFile == null) {
      return null;
    }
    Project project = referenceElement.getProject();
    BuckTargetLocator buckTargetLocator = BuckTargetLocator.getInstance(project);
    VirtualFile editBuildFile =
        buckTargetLocator.findBuckFileForVirtualFile(editSourceFile).orElse(null);
    if (editBuildFile == null) {
      return null;
    }
    VirtualFile importSourceFile = psiClass.getContainingFile().getVirtualFile();
    if (importSourceFile == null) {
      return null;
    }
    VirtualFile importBuildFile =
        buckTargetLocator.findBuckFileForVirtualFile(importSourceFile).orElse(null);
    if (importBuildFile == null) {
      return null;
    }
    if (importBuildFile.equals(editBuildFile)) {
      return null;
    }
    ProjectFileIndex projectFileIndex = ProjectFileIndex.getInstance(project);
    Module editModule = projectFileIndex.getModuleForFile(editSourceFile);
    if (editModule == null) {
      return null;
    }
    Module importModule = projectFileIndex.getModuleForFile(importSourceFile);
    if (importModule == null) {
      return null;
    }
    BuckTarget editSourceTarget =
        buckTargetLocator
            .findTargetPatternForVirtualFile(editSourceFile)
            .flatMap(BuckTargetPattern::asBuckTarget)
            .orElse(null);
    if (editSourceTarget == null) {
      return null;
    }
    BuckTarget importSourceTarget =
        buckTargetLocator
            .findTargetPatternForVirtualFile(importSourceFile)
            .flatMap(BuckTargetPattern::asBuckTarget)
            .orElse(null);
    if (importSourceTarget == null) {
      return null;
    }
    return new BuckAddDependencyIntention(
        project,
        referenceElement,
        editBuildFile,
        editSourceFile,
        editSourceTarget,
        editModule,
        psiClass,
        importBuildFile,
        importSourceFile,
        importSourceTarget,
        importModule);
  }

  private Project project;

  // Fields pertaining to the element in the file being edited
  private PsiJavaCodeReferenceElement referenceElement;
  private VirtualFile editBuildFile;
  private VirtualFile editSourceFile;
  private BuckTarget editSourceTarget;
  private BuckTarget editTarget;
  private Module editModule;

  // Fields pertaining to the dependency that should be resolved/imported
  private PsiClass psiClass;
  private VirtualFile importBuildFile;
  private VirtualFile importSourceFile;
  private BuckTarget importSourceTarget;
  private BuckTarget importTarget;
  private Module importModule;

  BuckAddDependencyIntention(
      Project project,
      PsiJavaCodeReferenceElement referenceElement,
      VirtualFile editBuildFile,
      VirtualFile editSourceFile,
      BuckTarget editSourceTarget,
      Module editModule,
      PsiClass psiClass,
      VirtualFile importBuildFile,
      VirtualFile importSourceFile,
      BuckTarget importSourceTarget,
      Module importModule) {
    this.project = project;
    this.referenceElement = referenceElement;
    this.editBuildFile = editBuildFile;
    this.editSourceFile = editSourceFile;
    this.editSourceTarget = editSourceTarget;
    this.editModule = editModule;
    this.psiClass = psiClass;
    this.importBuildFile = importBuildFile;
    this.importSourceFile = importSourceFile;
    this.importSourceTarget = importSourceTarget;
    this.importModule = importModule;
    String message = ""Add BUCK dependency on owner("" + importSourceTarget + "")"";
    setText(message);
  }

  @Nls(capitalization = Capitalization.Sentence)
  @NotNull
  @Override
  public String getFamilyName() {
    return this.getClass().getSimpleName();
  }

  @Override
  public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile psiFile) {
    return true;
  }

  @Override
  public void invoke(@NotNull Project project, Editor editor, PsiFile psiFile)
      throws IncorrectOperationException {
    String msg = ""Invoked for project "" + project.getName() + "" and file "" + psiFile.getName();
    LOGGER.info(msg);
    queryBuckForTargets(editor);
  }

  /** Helper class to handle deserialization of buck query. */
  static class TargetMetadata {
    public BuckTarget target;
    public @Nullable List<BuckTarget> deps;
    public @Nullable List<BuckTargetPattern> visibility; // null means PUBLIC
    public @Nullable List<String> srcs;
    public @Nullable List<String> resources;

    static TargetMetadata from(
        BuckTargetLocator buckTargetLocator, BuckTarget target, JsonObject payload) {
      TargetMetadata targetMetadata = new TargetMetadata();
      targetMetadata.target = target;
      targetMetadata.srcs = stringListOrNull(payload.get(""srcs""));
      targetMetadata.resources = stringListOrNull(payload.get(""resources""));

      // Deps are a list of BuckTargets
      targetMetadata.deps =
          Optional.ofNullable(stringListOrNull(payload.get(""deps"")))
              .map(
                  deps ->
                      deps.stream()
                          .map(
                              s -> BuckTarget.parse(s).map(buckTargetLocator::resolve).orElse(null))
                          .collect(Collectors.toList()))
              .orElse(null);

      // Visibilility falls in one of three cases:
      //   (1) if unspecified => means visibility is limited to the current package
      //   (2) contains ""PUBLIC"" => available everywhere
      //   (3) otherwise is a list of buck target patterns where it is visible
      List<String> optionalVisibility = stringListOrNull(payload.get(""visibility""));
      if (optionalVisibility == null) {
        targetMetadata.visibility =
            Collections.singletonList(target.asPattern().asPackageMatchingPattern());
      } else if (optionalVisibility.contains(""PUBLIC"")) {
        targetMetadata.visibility = null; //
      } else {
        targetMetadata.visibility =
            optionalVisibility
                .stream()
                .map(p -> BuckTargetPattern.parse(p).map(buckTargetLocator::resolve).orElse(null))
                .collect(Collectors.toList());
      }

      return targetMetadata;
    }

    static @Nullable List<String> stringListOrNull(@Nullable JsonElement jsonElement) {
      if (jsonElement == null) {
        return null;
      }
      return new Gson().fromJson(jsonElement, new TypeToken<List<String>>() {}.getType());
    }

    boolean isVisibleTo(BuckTarget target) {
      if (visibility == null) {
        return true;
      }
      return visibility.stream().anyMatch(pattern -> pattern.matches(target));
    }

    boolean hasDependencyOn(BuckTarget target) {
      return deps.stream().anyMatch(dep -> dep.equals(target));
    }

    boolean contains(BuckTarget targetFile) {
      if (!target.asPattern().asPackageMatchingPattern().matches(targetFile)) {
        return false;
      }
      String relativeToBuildFile = targetFile.getRuleName();
      return srcs.contains(relativeToBuildFile) || resources.contains(relativeToBuildFile);
    }
  }

  /** Queries buck for targets that own the editSourceFile and the importSourceFile. */
  private void queryBuckForTargets(Editor editor) {
    BuckTargetLocator buckTargetLocator = BuckTargetLocator.getInstance(project);
    String editPath = editSourceFile.getPath();
    String importPath = importSourceFile.getPath();
    BuckJsonCommandHandler<List<TargetMetadata>> handler =
        new BuckJsonCommandHandler<>(
            project,
            BuckCommand.QUERY,
            new Callback<List<TargetMetadata>>() {
              @Override
              public List<TargetMetadata> deserialize(JsonElement jsonElement) throws IOException {
                Type type = new TypeToken<Map<String, JsonObject>>() {}.getType();
                Map<String, JsonObject> raw = new Gson().fromJson(jsonElement, type);
                List<TargetMetadata> results = new ArrayList<>();
                for (Entry<String, JsonObject> entry : raw.entrySet()) {
                  BuckTarget.parse(entry.getKey())
                      .map(buckTargetLocator::resolve)
                      .map(
                          target ->
                              TargetMetadata.from(buckTargetLocator, target, entry.getValue()))
                      .ifPresent(results::add);
                }
                return results;
              }

              @Override
              public void onSuccess(List<TargetMetadata> results, String stderr) {
                List<TargetMetadata> editTargets = new ArrayList<>();
                List<TargetMetadata> importTargets = new ArrayList<>();
                for (TargetMetadata targetMetadata : results) {
                  if (targetMetadata.contains(editSourceTarget)) {
                    editTargets.add(targetMetadata);
                  }
                  if (targetMetadata.contains(importSourceTarget)) {
                    importTargets.add(targetMetadata);
                  }
                }
                updateDependencies(editor, editTargets, importTargets);
              }

              @Override
              public void onFailure(
                  String stdout,
                  String stderr,
                  @Nullable Integer exitCode,
                  @Nullable Throwable throwable) {
                BuckNotification.getInstance(project)
                    .showWarningBalloon(
                        ""Could not determine owners for ""
                            + editSourceFile
                            + "" and/or ""
                            + importSourceFile);
                return;
              }
            });
    handler
        .command()
        .addParameters(
            ""owner(%s)"",
            editPath, importPath, ""--output-attributes=deps|srcs|visibility|resources"");
    handler.runInCurrentThreadPostEnd(() -> {});
  }

  /**
   * Implementation of {@link
   * com.intellij.notification.NotificationListener#hyperlinkUpdate(Notification, HyperlinkEvent)}.
   */
  private void hyperlinkActivated(
      @NotNull Notification notification, @NotNull HyperlinkEvent event) {
    String href = event.getDescription();
    switch (href) {
      case ""editTarget"":
        if (BuckTargetLocator.getInstance(project)
            .findElementForTarget(editTarget)
            .filter(target -> target instanceof NavigatablePsiElement)
            .map(target -> (NavigatablePsiElement) target)
            .filter(Navigatable::canNavigate)
            .map(
                e -> {
                  e.navigate(true);
                  return true;
                })
            .orElse(false)) {
          break;
        }
        // fallthrough
      case ""editBuildFile"":
        FileEditorManager.getInstance(project).openFile(editBuildFile, true);
        break;
      case ""editSourceFile"":
        FileEditorManager.getInstance(project).openFile(editSourceFile, true);
        break;
      case ""importTarget"":
        if (BuckTargetLocator.getInstance(project)
            .findElementForTarget(importTarget)
            .filter(target -> target instanceof NavigatablePsiElement)
            .map(target -> (NavigatablePsiElement) target)
            .filter(Navigatable::canNavigate)
            .map(
                e -> {
                  e.navigate(true);
                  return true;
                })
            .orElse(false)) {
          break;
        }
        // fallthrough
      case ""importBuildFile"":
        FileEditorManager.getInstance(project).openFile(importBuildFile, true);
        break;
      case ""importSourceFile"":
        FileEditorManager.getInstance(project).openFile(importSourceFile, true);
        break;
    }
  }

  private void updateDependencies(
      Editor editor, List<TargetMetadata> editTargets, List<TargetMetadata> importTargets) {
    if (editTargets.size() == 0) {
      String message =
          ""<html><b>Add dependency failed</b>: Couldn't determine a Buck owner for <a href='editSourceFile'>""
              + editSourceTarget
              + ""</a> in <a href='editBuildFile'>""
              + editBuildFile.getPath()
              + ""</a>"";
      BuckNotification.getInstance(project).showErrorBalloon(message, this::hyperlinkActivated);
      return;
    }
    if (importTargets.size() == 0) {
      String message =
          ""<html><b>Add dependency failed</b>: Couldn't determine a Buck owner for <a href='importSourceFile'>""
              + importSourceTarget
              + ""</a> in <a href='importBuildFile'>""
              + importBuildFile.getPath()
              + ""</a></html>"";
      BuckNotification.getInstance(project).showErrorBalloon(message, this::hyperlinkActivated);
      return;
    }
    TargetMetadata editTargetMetadata = editTargets.get(0);
    TargetMetadata importTargetMetadata = importTargets.get(0);
    editTarget = editTargetMetadata.target;
    importTarget = importTargetMetadata.target;

    if (!importTargetMetadata.isVisibleTo(editTarget)) {
      String message =
          ""<html><b>Add dependency failed</b>: The target <a href='importTarget'>""
              + importTarget
              + ""</a> is not visible to <a href='editTarget'>""
              + editTarget
              + ""</a></html>"";
      BuckNotification.getInstance(project).showErrorBalloon(message, this::hyperlinkActivated);
      return;
    }
    if (!editTargetMetadata.hasDependencyOn(importTarget)) {
      if (!BuckDeps.modifyTargetToAddDependency(
          editBuildFile, editTarget.toString(), importTarget.toString())) {
        String message =
            ""<html><b>Add dependency failed</b>:  Could not add modify build file for <a href='editTarget'>""
                + editTarget
                + ""</a> to add dependency on <a href='importTarget'>""
                + importTarget
                + ""</a></html>"";
        BuckNotification.getInstance(project).showErrorBalloon(message, this::hyperlinkActivated);
        return;
      }
    } else {
      String message =
          ""<html>No need to modify build file <a href='editBuildFile'>""
              + editBuildFile
              + ""</a>, already has dependency from <a href='editTarget'>""
              + editTarget
              + ""</a> to <a href='importTarget'>""
              + importTarget
              + ""</a></html>"";
      BuckNotification.getInstance(project).showInfoBalloon(message, this::hyperlinkActivated);
    }
    ModuleRootModificationUtil.updateModel(
        editModule,
        (modifiableRootModel -> {
          if (modifiableRootModel.findModuleOrderEntry(importModule) != null) {
            LOGGER.info(
                ""No need to modify module ""
                    + editModule.getName()
                    + "", already has dependency on ""
                    + importModule.getName());
          } else {
            modifiableRootModel.addModuleOrderEntry(importModule);
            LOGGER.info(
                ""Successfully added module dependency from ""
                    + editModule.getName()
                    + "" on ""
                    + importModule.getName());
          }
          new AddImportAction(project, referenceElement, editor, psiClass).execute();
        }));
  }
}
",blob
258,"public class Device {

	private String id;

	private String deviceType;

	private String name;

	private Authentication authentication;

	public String getId() {
		return id;
	}

	public void setId(String id) {
		this.id = id;
	}

	public String getDeviceType() {
		return deviceType;
	}

	public void setDeviceType(String deviceType) {
		this.deviceType = deviceType;
	}

	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public Authentication getAuthentication() {
		return authentication;
	}

	public void setAuthentication(Authentication authentication) {
		this.authentication = authentication;
	}

}
",data class
479,"public class CoapEncoder implements StatelessProtocolEncoder<CoapMessage, ByteBuffer> {

    private static final Logger LOG = LoggerFactory.getLogger(CoapEncoder.class);

    private static final int HEADER_SIZE = 4;

    /**
     * {@inheritDoc}
     */
    @Override
    public Void createEncoderState() {
        return null;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ByteBuffer encode(CoapMessage message, Void context) {

        LOG.debug(""encoding {}"", message);

        // compute size of the needed buffer
        int size = HEADER_SIZE + message.getToken().length;

        int delta = 0;
        for (CoapOption opt : message.getOptions()) {
            // compute delta encoding size
            int code = opt.getType().getCode();
            delta = code - delta;
            if (delta < 13) {
                size += 1;
            } else if (delta < 256 + 13) {
                size += 2;
            } else if (delta < 65536 + 269) {
                size += 3;
            }

            // compute option length encoding size
            int optLength = opt.getData().length;
            if (optLength < 13) {
                size += 0;
            } else if (optLength < 256 + 13) {
                size += 1;
            } else if (optLength < 65536 + 269) {
                size += 2;
            }

            // compute option data encoding size
            size += optLength;
        }

        // if we have a payload, we place the marker and the payload
        if (message.getPayload() != null && message.getPayload().length > 0) {
            // payload marker
            size += 1;
            size += message.getPayload().length;
        }

        ByteBuffer buffer = ByteBuffer.allocate(size);

        buffer.order(ByteOrder.BIG_ENDIAN);

        // encode header
        buffer.put((byte) (((message.getVersion() & 0x03) << 6) | (message.getType().getCode() & 0x03) << 4 | (message
                .getToken().length & 0x0F)));
        buffer.put((byte) message.getCode());
        buffer.putShort((short) message.getId());
        buffer.put(message.getToken());

        // encode options
        int lastOptCode = 0;

        for (CoapOption opt : message.getOptions()) {
            int optionDelta = opt.getType().getCode() - lastOptCode;
            int deltaQuartet = getQuartet(optionDelta);
            int optionLength = opt.getData().length;

            int optionQuartet = getQuartet(optionLength);

            buffer.put((byte) ((deltaQuartet << 4) | optionQuartet));

            // write extended option delta field (0 - 2 bytes)
            if (deltaQuartet == 13) {
                buffer.put((byte) (optionDelta - 13));
            } else if (deltaQuartet == 14) {
                buffer.putShort((short) (optionDelta - 269));
            }

            if (optionQuartet == 13) {
                buffer.put((byte) (optionLength - 13));
            } else if (optionQuartet == 14) {
                buffer.putShort((short) (optionLength - 269));
            }
            buffer.put(opt.getData());

            lastOptCode = opt.getType().getCode();
        }

        if (message.getPayload() != null && message.getPayload().length > 0) {
            buffer.put((byte) 0xFF);
            buffer.put(message.getPayload());
        }

        buffer.flip();
        return buffer;
    }

    private int getQuartet(int value) {
        if (value <= 12) {
            return value;
        } else if (value <= 255 + 13) {
            return 13;
        } else {
            return 14;
        }
    }
}
",blob
573,"        @Override
        public Component getNextComponent(final Container container, final Component component,
            final FocusTraversalDirection direction) {
            Utils.checkNull(container, ""container"");
            Utils.checkNull(direction, ""direction"");

            Component nextComponent = null;

            int n = container.getLength();
            if (n > 0) {
                switch (direction) {
                    case FORWARD:
                        if (component == null) {
                            // Return the first component in the sequence
                            nextComponent = container.get(0);
                        } else {
                            // Return the next component in the sequence
                            int index = container.indexOf(component);
                            if (index == -1) {
                                throw new IllegalArgumentException(""Component is not a child of the container."");
                            }

                            if (index < n - 1) {
                                nextComponent = container.get(index + 1);
                            } else {
                                if (wrap) {
                                    nextComponent = container.get(0);
                                }
                            }
                        }

                        break;

                    case BACKWARD:
                        if (component == null) {
                            // Return the last component in the sequence
                            nextComponent = container.get(n - 1);
                        } else {
                            // Return the previous component in the sequence
                            int index = container.indexOf(component);
                            if (index == -1) {
                                throw new IllegalArgumentException(""Component is not a child of the container."");
                            }

                            if (index > 0) {
                                nextComponent = container.get(index - 1);
                            } else {
                                if (wrap) {
                                    nextComponent = container.get(n - 1);
                                }
                            }
                        }

                        break;

                    default:
                        break;
                }
            }

            return nextComponent;
        }
",long method
399,"@XmlRootElement(name = ""realm"")
@XmlType
public class RealmTO implements EntityTO, TemplatableTO {

    private static final long serialVersionUID = 516330662956254391L;

    private String key;

    private String name;

    private String parent;

    private String fullPath;

    private String accountPolicy;

    private String passwordPolicy;

    private final List<String> actions = new ArrayList<>();

    @XmlJavaTypeAdapter(XmlGenericMapAdapter.class)
    private final Map<String, AnyTO> templates = new HashMap<>();

    private final Set<String> resources = new HashSet<>();

    @Override
    public String getKey() {
        return key;
    }

    @Override
    public void setKey(final String key) {
        this.key = key;
    }

    public String getName() {
        return name;
    }

    public void setName(final String name) {
        this.name = name;
    }

    public String getParent() {
        return parent;
    }

    public void setParent(final String parent) {
        this.parent = parent;
    }

    public String getFullPath() {
        return fullPath;
    }

    @PathParam(""fullPath"")
    public void setFullPath(final String fullPath) {
        this.fullPath = fullPath;
    }

    public String getAccountPolicy() {
        return accountPolicy;
    }

    public void setAccountPolicy(final String accountPolicy) {
        this.accountPolicy = accountPolicy;
    }

    public String getPasswordPolicy() {
        return passwordPolicy;
    }

    public void setPasswordPolicy(final String passwordPolicy) {
        this.passwordPolicy = passwordPolicy;
    }

    @XmlElementWrapper(name = ""actions"")
    @XmlElement(name = ""action"")
    @JsonProperty(""actions"")
    public List<String> getActions() {
        return actions;
    }

    @JsonProperty
    @Override
    public Map<String, AnyTO> getTemplates() {
        return templates;
    }

    @XmlElementWrapper(name = ""resources"")
    @XmlElement(name = ""resource"")
    @JsonProperty(""resources"")
    public Set<String> getResources() {
        return resources;
    }

}
",data class
84,"    public void read(org.apache.thrift.protocol.TProtocol iprot, FetchRuleKeyLogsRequest struct) throws org.apache.thrift.TException {
      org.apache.thrift.protocol.TField schemeField;
      iprot.readStructBegin();
      while (true)
      {
        schemeField = iprot.readFieldBegin();
        if (schemeField.type == org.apache.thrift.protocol.TType.STOP) { 
          break;
        }
        switch (schemeField.id) {
          case 1: // RULE_KEYS
            if (schemeField.type == org.apache.thrift.protocol.TType.LIST) {
              {
                org.apache.thrift.protocol.TList _list184 = iprot.readListBegin();
                struct.ruleKeys = new java.util.ArrayList<java.lang.String>(_list184.size);
                java.lang.String _elem185;
                for (int _i186 = 0; _i186 < _list184.size; ++_i186)
                {
                  _elem185 = iprot.readString();
                  struct.ruleKeys.add(_elem185);
                }
                iprot.readListEnd();
              }
              struct.setRuleKeysIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 2: // REPOSITORY
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.repository = iprot.readString();
              struct.setRepositoryIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 3: // SCHEDULE_TYPE
            if (schemeField.type == org.apache.thrift.protocol.TType.STRING) {
              struct.scheduleType = iprot.readString();
              struct.setScheduleTypeIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          case 4: // DISTRIBUTED_BUILD_MODE_ENABLED
            if (schemeField.type == org.apache.thrift.protocol.TType.BOOL) {
              struct.distributedBuildModeEnabled = iprot.readBool();
              struct.setDistributedBuildModeEnabledIsSet(true);
            } else { 
              org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
            }
            break;
          default:
            org.apache.thrift.protocol.TProtocolUtil.skip(iprot, schemeField.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      struct.validate();
    }
",long method
953,"public interface VMInstanceDao extends GenericDao<VMInstanceVO, Long>, StateDao<State, VirtualMachine.Event, VirtualMachine> {
    /**
     * What are the vms running on this host?
     * @param hostId host.
     * @return list of VMInstanceVO running on that host.
     */
    List<VMInstanceVO> listByHostId(long hostId);

    /**
     * List VMs by zone ID
     * @param zoneId
     * @return list of VMInstanceVO in the specified zone
     */
    List<VMInstanceVO> listByZoneId(long zoneId);

    /**
     * List VMs by pod ID
     * @param podId
     * @return list of VMInstanceVO in the specified pod
     */
    List<VMInstanceVO> listByPodId(long podId);

    /**
     * Lists non-expunged VMs by  templateId
     * @param templateId
     * @return list of VMInstanceVO deployed from the specified template, that are not expunged
     */
    public List<VMInstanceVO> listNonExpungedByTemplate(long templateId);


    /**
     * Lists non-expunged VMs by zone ID and templateId
     * @param zoneId
     * @return list of VMInstanceVO in the specified zone, deployed from the specified template, that are not expunged
     */
    public List<VMInstanceVO> listNonExpungedByZoneAndTemplate(long zoneId, long templateId);

    /**
     * Find vm instance with names like.
     *
     * @param name name that fits SQL like.
     * @return list of VMInstanceVO
     */
    List<VMInstanceVO> findVMInstancesLike(String name);

    List<VMInstanceVO> findVMInTransition(Date time, State... states);

    List<VMInstanceVO> listByHostAndState(long hostId, State... states);

    List<VMInstanceVO> listByTypes(VirtualMachine.Type... types);

    VMInstanceVO findByIdTypes(long id, VirtualMachine.Type... types);

    VMInstanceVO findVMByInstanceName(String name);

    VMInstanceVO findVMByHostName(String hostName);

    void updateProxyId(long id, Long proxyId, Date time);

    List<VMInstanceVO> listByHostIdTypes(long hostid, VirtualMachine.Type... types);

    List<VMInstanceVO> listUpByHostIdTypes(long hostid, VirtualMachine.Type... types);

    List<VMInstanceVO> listByZoneIdAndType(long zoneId, VirtualMachine.Type type);

    List<VMInstanceVO> listUpByHostId(Long hostId);

    List<VMInstanceVO> listByLastHostId(Long hostId);

    List<VMInstanceVO> listByTypeAndState(VirtualMachine.Type type, State state);

    List<VMInstanceVO> listByAccountId(long accountId);

    public List<Long> findIdsOfAllocatedVirtualRoutersForAccount(long accountId);

    List<VMInstanceVO> listByClusterId(long clusterId);  // this does not pull up VMs which are starting

    List<VMInstanceVO> listLHByClusterId(long clusterId);  // get all the VMs even starting one on this cluster

    List<VMInstanceVO> listVmsMigratingFromHost(Long hostId);

    public Long countActiveByHostId(long hostId);

    Pair<List<Long>, Map<Long, Double>> listClusterIdsInZoneByVmCount(long zoneId, long accountId);

    Pair<List<Long>, Map<Long, Double>> listClusterIdsInPodByVmCount(long podId, long accountId);

    Pair<List<Long>, Map<Long, Double>> listPodIdsInZoneByVmCount(long dataCenterId, long accountId);

    List<Long> listHostIdsByVmCount(long dcId, Long podId, Long clusterId, long accountId);

    Long countRunningByAccount(long accountId);

    Long countByZoneAndState(long zoneId, State state);

    List<VMInstanceVO> listNonRemovedVmsByTypeAndNetwork(long networkId, VirtualMachine.Type... types);

    /**
     * @param networkId
     * @param types
     * @return
     */
    List<String> listDistinctHostNames(long networkId, VirtualMachine.Type... types);

    List<VMInstanceVO> findByHostInStates(Long hostId, State... states);

    List<VMInstanceVO> listStartingWithNoHostId();

    boolean updatePowerState(long instanceId, long powerHostId, VirtualMachine.PowerState powerState);

    void resetVmPowerStateTracking(long instanceId);

    void resetHostPowerStateTracking(long hostId);

    HashMap<String, Long> countVgpuVMs(Long dcId, Long podId, Long clusterId);

    VMInstanceVO findVMByHostNameInZone(String hostName, long zoneId);

    boolean isPowerStateUpToDate(long instanceId);

    List<VMInstanceVO> listNonMigratingVmsByHostEqualsLastHost(long hostId);
}
",blob
141,"  public static class MetaColumn implements Named {
    public final String tableCat;
    public final String tableSchem;
    public final String tableName;
    public final String columnName;
    public final int dataType;
    public final String typeName;
    public final Integer columnSize;
    public final Integer bufferLength = null;
    public final Integer decimalDigits;
    public final Integer numPrecRadix;
    public final int nullable;
    public final String remarks = null;
    public final String columnDef = null;
    public final Integer sqlDataType = null;
    public final Integer sqlDatetimeSub = null;
    public final Integer charOctetLength;
    public final int ordinalPosition;
    @NotNull
    public final String isNullable;
    public final String scopeCatalog = null;
    public final String scopeSchema = null;
    public final String scopeTable = null;
    public final Short sourceDataType = null;
    @NotNull
    public final String isAutoincrement = """";
    @NotNull
    public final String isGeneratedcolumn = """";

    public MetaColumn(
        String tableCat,
        String tableSchem,
        String tableName,
        String columnName,
        int dataType,
        String typeName,
        Integer columnSize,
        Integer decimalDigits,
        Integer numPrecRadix,
        int nullable,
        Integer charOctetLength,
        int ordinalPosition,
        String isNullable) {
      this.tableCat = tableCat;
      this.tableSchem = tableSchem;
      this.tableName = tableName;
      this.columnName = columnName;
      this.dataType = dataType;
      this.typeName = typeName;
      this.columnSize = columnSize;
      this.decimalDigits = decimalDigits;
      this.numPrecRadix = numPrecRadix;
      this.nullable = nullable;
      this.charOctetLength = charOctetLength;
      this.ordinalPosition = ordinalPosition;
      this.isNullable = isNullable;
    }

    @Override
    public String getName() {
      return columnName;
    }
  }
",data class
979,"public class AsyncRcvdMsgCheckpointImpl<M extends Writable> implements
    BSPFaultTolerantService<M> {

  private static final Log LOG = LogFactory
      .getLog(AsyncRcvdMsgCheckpointImpl.class);

  /**
   * It is responsible to find the smallest superstep for which the
   * checkpointing is done and then restart all the peers from that superstep.
   */
  private static class CheckpointMasterService implements
      FaultTolerantMasterService {

    private Configuration conf;
    private TaskInProgress tasks[];
    private BSPJobID jobId;
    private int maxTaskAttempts;
    private int currentAttemptId;
    private MasterSyncClient masterSyncClient;
    private TaskAllocationStrategy allocationStrategy;

    /**
     * Initializes the fault tolerance service at BSPMasters
     * 
     * @param jobId The identifier of the job.
     * @param maxTaskAttempts Number of attempts allowed for recovering from
     *          failure.
     * @param tasks The list of tasks in the job.
     * @param conf The job configuration object.
     * @param masterClient The synchronization client used by BSPMaster.
     * @param allocationStrategy The task allocation strategy of the job.
     */
    public void initialize(BSPJobID jobId, int maxTaskAttempts,
        TaskInProgress[] tasks, Configuration conf,
        MasterSyncClient masterClient, TaskAllocationStrategy allocationStrategy) {
      this.tasks = tasks;
      this.jobId = jobId;
      this.conf = conf;
      this.maxTaskAttempts = maxTaskAttempts;
      this.currentAttemptId = 0;
      this.masterSyncClient = masterClient;
      this.allocationStrategy = allocationStrategy;
    }

    @Override
    public boolean isRecoveryPossible(TaskInProgress tip) {
      return currentAttemptId < maxTaskAttempts;
    }

    @Override
    public boolean isAlreadyRecovered(TaskInProgress tip) {
      return currentAttemptId < tip.getCurrentTaskAttemptId().getId();
    }

    @Override
    public void recoverTasks(JobInProgress jip,
        Map<String, GroomServerStatus> groomStatuses,
        TaskInProgress[] failedTasksInProgress,
        TaskInProgress[] allTasksInProgress,
        Map<GroomServerStatus, Integer> taskCountInGroomMap,
        Map<GroomServerStatus, List<GroomServerAction>> actionMap)
        throws IOException {

      Map<TaskID, TaskInProgress> recoverySet = new HashMap<TaskID, TaskInProgress>(
          2 * failedTasksInProgress.length);
      for (TaskInProgress failedTasksInProgres : failedTasksInProgress) {
        recoverySet.put(failedTasksInProgres.getTaskId(), failedTasksInProgres);
      }

      long lowestSuperstepNumber = Long.MAX_VALUE;

      String[] taskProgress = this.masterSyncClient.getChildKeySet(
          this.masterSyncClient.constructKey(jobId, ""checkpoint""), null);

      if (LOG.isDebugEnabled()) {
        StringBuffer list = new StringBuffer(25 * taskProgress.length);
        list.append(""got child key set"").append(taskProgress.length)
            .append(""/"").append(tasks.length).append("" "");
        for (String entry : taskProgress) {
          list.append(entry).append("","");
        }
        LOG.debug(list);
      }

      if (taskProgress.length == this.tasks.length) {
        for (String taskProgres : taskProgress) {
          ArrayWritable progressInformation = new ArrayWritable(
              LongWritable.class);
          boolean result = this.masterSyncClient.getInformation(
              this.masterSyncClient.constructKey(jobId, ""checkpoint"",
                  taskProgres), progressInformation);

          if (!result) {
            lowestSuperstepNumber = -1L;
            break;
          }

          Writable[] progressArr = progressInformation.get();
          LongWritable superstepProgress = (LongWritable) progressArr[0];

          if (superstepProgress != null) {
            if (superstepProgress.get() < lowestSuperstepNumber) {
              lowestSuperstepNumber = superstepProgress.get();
              if (LOG.isDebugEnabled()) {
                LOG.debug(""Got superstep number "" + lowestSuperstepNumber
                    + "" from "" + taskProgres);
              }
            }
          }
        }
        clearClientForSuperstep(lowestSuperstepNumber);
        restartJob(lowestSuperstepNumber, groomStatuses, recoverySet,
            allTasksInProgress, taskCountInGroomMap, actionMap);

      } else {
        restartJob(-1, groomStatuses, recoverySet, allTasksInProgress,
            taskCountInGroomMap, actionMap);
      }

      ++currentAttemptId;
    }

    private void clearClientForSuperstep(long superstep) {
      this.masterSyncClient.remove(
          masterSyncClient.constructKey(jobId, ""sync""), null);
    }

    private void populateAction(Task task, long superstep,
        GroomServerStatus groomStatus,
        Map<GroomServerStatus, List<GroomServerAction>> actionMap) {
      List<GroomServerAction> list = actionMap.get(groomStatus);
      if (!actionMap.containsKey(groomStatus)) {
        list = new ArrayList<GroomServerAction>();
        actionMap.put(groomStatus, list);
      }
      list.add(new RecoverTaskAction(task, superstep));

    }

    private void restartTask(TaskInProgress tip, long superstep,
        Map<String, GroomServerStatus> groomStatuses,
        Map<GroomServerStatus, List<GroomServerAction>> actionMap) {
      GroomServerStatus serverStatus = tip.getGroomServerStatus();
      Task task = tip.constructTask(serverStatus);
      populateAction(task, superstep, serverStatus, actionMap);

    }

    private void restartJob(long superstep,
        Map<String, GroomServerStatus> groomStatuses,
        Map<TaskID, TaskInProgress> recoveryMap, TaskInProgress[] allTasks,
        Map<GroomServerStatus, Integer> taskCountInGroomMap,
        Map<GroomServerStatus, List<GroomServerAction>> actionMap)
        throws IOException {
      String path = conf.get(""bsp.checkpoint.prefix_path"", ""/checkpoint/"");

      if (superstep >= 0) {
        FileSystem fileSystem = FileSystem.get(conf);
        for (TaskInProgress allTask : allTasks) {
          String[] hosts = null;
          if (recoveryMap.containsKey(allTask.getTaskId())) {

            // Update task count in map.
            // TODO: This should be a responsibility of GroomServerStatus
            Integer count = taskCountInGroomMap.get(allTask
                .getGroomServerStatus());
            if (count != null) {
              count = count.intValue() - 1;
              taskCountInGroomMap.put(allTask.getGroomServerStatus(), count);
            }

            StringBuffer ckptPath = new StringBuffer(path);
            ckptPath.append(this.jobId.toString());
            ckptPath.append(""/"").append(superstep).append(""/"")
                .append(allTask.getTaskId().getId());
            Path checkpointPath = new Path(ckptPath.toString());
            if (fileSystem.exists(checkpointPath)) {
              FileStatus fileStatus = fileSystem.getFileStatus(checkpointPath);
              BlockLocation[] blocks = fileSystem.getFileBlockLocations(
                  fileStatus, 0, fileStatus.getLen());
              hosts = blocks[0].getHosts();
            } else {
              hosts = new String[groomStatuses.keySet().size()];
              groomStatuses.keySet().toArray(hosts);
            }
            GroomServerStatus serverStatus = this.allocationStrategy
                .getGroomToAllocate(groomStatuses, hosts, taskCountInGroomMap,
                    new BSPResource[0], allTask);
            Task task = allTask.constructTask(serverStatus);
            populateAction(task, superstep, serverStatus, actionMap);

          } else {
            restartTask(allTask, superstep, groomStatuses, actionMap);
          }
        }
      } else {
        // Start the task from the beginning.
        for (TaskInProgress allTask : allTasks) {
          if (recoveryMap.containsKey(allTask.getTaskId())) {
            this.allocationStrategy.getGroomToAllocate(groomStatuses,
                this.allocationStrategy.selectGrooms(groomStatuses,
                    taskCountInGroomMap, new BSPResource[0], allTask),
                taskCountInGroomMap, new BSPResource[0], allTask);
          } else {
            restartTask(allTask, superstep, groomStatuses, actionMap);
          }
        }
      }
    }

  }// end of CheckpointMasterService

  @Override
  public FaultTolerantPeerService<M> constructPeerFaultTolerance(BSPJob job,
      @SuppressWarnings(""rawtypes"") BSPPeer bspPeer, PeerSyncClient syncClient,
      InetSocketAddress peerAddress, TaskAttemptID taskAttemptId,
      long superstep, Configuration conf, MessageManager<M> messenger)
      throws Exception {
    CheckpointPeerService<M> service = new CheckpointPeerService<M>();
    service.initialize(job, bspPeer, syncClient, peerAddress, taskAttemptId,
        superstep, conf, messenger);
    return service;
  }

  @Override
  public FaultTolerantMasterService constructMasterFaultTolerance(
      BSPJobID jobId, int maxTaskAttempts, TaskInProgress[] tasks,
      Configuration conf, MasterSyncClient masterClient,
      TaskAllocationStrategy allocationStrategy) throws Exception {
    CheckpointMasterService service = new CheckpointMasterService();
    service.initialize(jobId, maxTaskAttempts, tasks, conf, masterClient,
        allocationStrategy);
    return service;
  }

  /**
   * Initializes the peer fault tolerance by checkpointing service. For
   * recovery, on peer initialization, it reads all the checkpointed messages to
   * recover the state of the peer. During normal working, it checkpoints all
   * the messages it received in the previous superstep. It also stores the
   * superstep progress in the global synchronization area.
   * 
   */
  public static class CheckpointPeerService<M extends Writable> implements
      FaultTolerantPeerService<M>, MessageEventListener<M> {

    private BSPJob job;
    @SuppressWarnings(""rawtypes"")
    private BSPPeer peer;
    private PeerSyncClient syncClient;
    private long superstep;
    private Configuration conf;
    private MessageManager<M> messenger;
    private FileSystem fs;
    private int checkPointInterval;
    volatile private long lastCheckPointStep;
    volatile private boolean checkpointState;
    volatile private FSDataOutputStream checkpointStream;
    volatile private long checkpointMessageCount;

    public void initialize(BSPJob job,
        @SuppressWarnings(""rawtypes"") BSPPeer bspPeer,
        PeerSyncClient syncClient, InetSocketAddress peerAddress,
        TaskAttemptID taskAttemptId, long superstep, Configuration conf,
        MessageManager<M> messenger) throws IOException {

      this.job = job;
      this.peer = bspPeer;
      this.syncClient = syncClient;
      this.superstep = superstep;
      this.conf = conf;
      this.messenger = messenger;
      this.fs = FileSystem.get(conf);
      this.checkPointInterval = conf.getInt(Constants.CHECKPOINT_INTERVAL,
          Constants.DEFAULT_CHECKPOINT_INTERVAL);
      this.checkPointInterval = conf.getInt(Constants.CHECKPOINT_INTERVAL,
          Constants.DEFAULT_CHECKPOINT_INTERVAL);

      this.checkpointState = conf.getBoolean(Constants.CHECKPOINT_ENABLED,
          false);

      if (superstep > 0) {
        this.lastCheckPointStep = this.superstep;
      } else {
        this.lastCheckPointStep = 1;
      }
      this.checkpointMessageCount = 0L;
    }

    private String checkpointPath(long step) {
      String backup = conf.get(""bsp.checkpoint.prefix_path"", ""checkpoint/"");
      String ckptPath = backup + job.getJobID().toString() + ""/"" + (step) + ""/""
          + peer.getPeerIndex();
      if (LOG.isDebugEnabled())
        LOG.debug(""Received Messages are to be saved to "" + ckptPath);
      return ckptPath;
    }

    @Override
    public TaskStatus.State onPeerInitialized(TaskStatus.State state)
        throws Exception {
      if (this.superstep >= 0 && state.equals(TaskStatus.State.RECOVERING)) {
        ArrayWritable progressArr = new ArrayWritable(LongWritable.class);
        boolean result = this.syncClient.getInformation(
            this.syncClient.constructKey(job.getJobID(), ""checkpoint"",
                String.valueOf(peer.getPeerIndex())), progressArr);

        if (!result) {
          throw new IOException(""No data found to restore peer state."");
        }

        Writable[] progressInfo = progressArr.get();
        long superstepProgress = ((LongWritable) progressInfo[0]).get();
        long numMessages = ((LongWritable) progressInfo[1]).get();

        if (LOG.isDebugEnabled()) {
          LOG.debug(""Got sstep ="" + superstepProgress + "" numMessages = ""
              + numMessages + "" this.superstep = "" + this.superstep);
        }

        if (numMessages > 0) {
          Path path = new Path(checkpointPath(superstepProgress));
          FSDataInputStream in = this.fs.open(path);
          BSPMessageBundle<M> bundle = new BSPMessageBundle<M>();

          try {
            for (int i = 0; i < numMessages; ++i) {
              String className = in.readUTF();
              if (className.equals(BSPMessageBundle.class.getCanonicalName())) {
                BSPMessageBundle<M> tmp = new BSPMessageBundle<M>();
                tmp.readFields(in);
                messenger.loopBackBundle(tmp);
              } else {
                @SuppressWarnings(""unchecked"")
                M message = (M) ReflectionUtils.newInstance(
                    Class.forName(className), conf);
                message.readFields(in);
                bundle.addMessage(message);
              }
            }

            if (bundle.size() > 0) {
              messenger.loopBackBundle(bundle);
            }
          } catch (EOFException e) {
            LOG.error(""Error recovering from checkpointing"", e);
            throw new IOException(e);
          } finally {
            this.fs.close();
          }
        }
      }
      this.messenger.registerListener(this);
      return TaskStatus.State.RUNNING;

    }

    public final boolean isReadyToCheckpoint() {

      checkPointInterval = conf.getInt(Constants.CHECKPOINT_INTERVAL, 1);
      LOG.info(new StringBuffer(1000).append(""Enabled = "")
          .append(conf.getBoolean(Constants.CHECKPOINT_ENABLED, false))
          .append("" checkPointInterval = "").append(checkPointInterval)
          .append("" lastCheckPointStep = "").append(lastCheckPointStep)
          .append("" getSuperstepCount() = "").append(peer.getSuperstepCount())
          .toString());
      if (LOG.isDebugEnabled())
        LOG.debug(new StringBuffer(1000).append(""Enabled = "")
            .append(conf.getBoolean(Constants.CHECKPOINT_ENABLED, false))
            .append("" checkPointInterval = "").append(checkPointInterval)
            .append("" lastCheckPointStep = "").append(lastCheckPointStep)
            .append("" getSuperstepCount() = "").append(peer.getSuperstepCount())
            .toString());

      return (conf.getBoolean(Constants.CHECKPOINT_ENABLED, false)
          && (checkPointInterval != 0) && (((int) ((peer.getSuperstepCount() + 1) - lastCheckPointStep)) >= checkPointInterval));

    }

    @Override
    public void beforeBarrier() throws Exception {
    }

    @Override
    public void duringBarrier() throws Exception {
    }

    @Override
    public void afterBarrier() throws Exception {

      synchronized (this) {
        if (checkpointState) {

          if (checkpointStream != null) {
            this.checkpointStream.close();
            this.checkpointStream = null;
          }

          lastCheckPointStep = peer.getSuperstepCount();

          ArrayWritable writableArray = new ArrayWritable(LongWritable.class);
          Writable[] writeArr = new Writable[2];
          writeArr[0] = new LongWritable(lastCheckPointStep);
          writeArr[1] = new LongWritable(checkpointMessageCount);
          writableArray.set(writeArr);

          if (LOG.isDebugEnabled()) {
            LOG.debug(""Storing lastCheckPointStep = "" + lastCheckPointStep
                + "" checkpointMessageCount = "" + checkpointMessageCount
                + "" for peer = "" + String.valueOf(peer.getPeerIndex()));
          }

          this.syncClient.storeInformation(this.syncClient.constructKey(
              this.job.getJobID(), ""checkpoint"",
              String.valueOf(peer.getPeerIndex())), writableArray, true, null);
        }
        checkpointState = isReadyToCheckpoint();
        checkpointMessageCount = 0;
      }

      LOG.info(""checkpointNext = "" + checkpointState
          + "" checkpointMessageCount = "" + checkpointMessageCount);
    }

    @Override
    public void onInitialized() {

    }

    @Override
    public void onMessageSent(String peerName, M message) {
    }

    @Override
    public void onMessageReceived(M message) {
      String checkpointedPath = null;

      if (message == null) {
        LOG.error(""Message M is found to be null"");
      }

      synchronized (this) {
        if (checkpointState) {
          if (this.checkpointStream == null) {
            checkpointedPath = checkpointPath(peer.getSuperstepCount() + 1);
            try {
              LOG.info(""Creating path "" + checkpointedPath);
              if (LOG.isDebugEnabled()) {
                LOG.debug(""Creating path "" + checkpointedPath);
              }
              checkpointStream = this.fs.create(new Path(checkpointedPath));
            } catch (IOException ioe) {
              LOG.error(""Fail checkpointing messages to "" + checkpointedPath,
                  ioe);
              throw new RuntimeException(""Failed opening HDFS file ""
                  + checkpointedPath, ioe);
            }
          }
          
          try {
            ++checkpointMessageCount;
            checkpointStream.writeUTF(message.getClass().getCanonicalName());
            message.write(checkpointStream);
          } catch (IOException ioe) {
            LOG.error(""Fail checkpointing messages to "" + checkpointedPath, ioe);
            throw new RuntimeException(""Failed writing to HDFS file ""
                + checkpointedPath, ioe);
          }

          if (LOG.isDebugEnabled()) {
            LOG.debug(""message count = "" + checkpointMessageCount);
          }
        }
      }

    }

    @Override
    public void onClose() {

    }

    @Override
    public void onBundleReceived(BSPMessageBundle<M> bundle) {
      String checkpointedPath = null;

      if (bundle == null) {
        LOG.error(""bundle is found to be null"");
      }

      synchronized (this) {
        if (checkpointState) {
          if (this.checkpointStream == null) {
            checkpointedPath = checkpointPath(peer.getSuperstepCount() + 1);
            try {
              LOG.info(""Creating path "" + checkpointedPath);
              if (LOG.isDebugEnabled()) {
                LOG.debug(""Creating path "" + checkpointedPath);
              }
              checkpointStream = this.fs.create(new Path(checkpointedPath));
            } catch (IOException ioe) {
              LOG.error(""Fail checkpointing messages to "" + checkpointedPath,
                  ioe);
              throw new RuntimeException(""Failed opening HDFS file ""
                  + checkpointedPath, ioe);
            }
          }

          try {
            ++checkpointMessageCount;
            checkpointStream.writeUTF(bundle.getClass().getCanonicalName());
            bundle.write(checkpointStream);
          } catch (IOException ioe) {
            LOG.error(""Fail checkpointing messages to "" + checkpointedPath, ioe);
            throw new RuntimeException(""Failed writing to HDFS file ""
                + checkpointedPath, ioe);
          }

          if (LOG.isDebugEnabled()) {
            LOG.debug(""message count = "" + checkpointMessageCount);
          }
        }
      }
    }

  }

}
",blob
1446,"    public static class Build {

        /**
         * Project version.
         */
        private String version = """";

        public String getVersion() {
            return version;
        }

        public void setVersion(final String version) {
            this.version = version;
        }

    }
",data class
1438,,blob
522,"public class GroomServerStatus implements Writable {
  public static final Log LOG = LogFactory.getLog(GroomServerStatus.class);

  static {
    WritableFactories.setFactory(GroomServerStatus.class,
        new WritableFactory() {
          @Override
          public Writable newInstance() {
            return new GroomServerStatus();
          }
        });
  }

  String groomName;
  String rpcServer;
  String hostName;
  int failures;
  List<TaskStatus> taskReports;

  volatile long lastSeen;
  private int maxTasks;

  public GroomServerStatus() {
    // taskReports = new ArrayList<TaskStatus>();
    taskReports = new CopyOnWriteArrayList<TaskStatus>();
  }

  public GroomServerStatus(String groomName, List<TaskStatus> taskReports,
      int failures, int maxTasks) {
    this(groomName, taskReports, failures, maxTasks, """", """");
  }

  public GroomServerStatus(String groomName, List<TaskStatus> taskReports,
      int failures, int maxTasks, String rpc, String hostName) {
    this.groomName = groomName;
    this.taskReports = new ArrayList<TaskStatus>(taskReports);
    this.failures = failures;
    this.maxTasks = maxTasks;
    this.rpcServer = rpc;
    this.hostName = hostName;
  }

  public String getGroomName() {
    return groomName;
  }

  public String getGroomHostName() {
    return hostName;
  }

  public String getRpcServer() {
    return rpcServer;
  }

  /**
   * Get the current tasks at the GroomServer. Tasks are tracked by a
   * {@link TaskStatus} object.
   * 
   * @return a list of {@link TaskStatus} representing the current tasks at the
   *         GroomServer.
   */
  public List<TaskStatus> getTaskReports() {
    return taskReports;
  }

  public int getFailures() {
    return failures;
  }

  public long getLastSeen() {
    return lastSeen;
  }

  public void setLastSeen(long lastSeen) {
    this.lastSeen = lastSeen;
  }

  public int getMaxTasks() {
    return maxTasks;
  }

  /**
   * Return the current BSP Task count
   */
  public int countTasks() {
    int taskCount = 0;
    for (TaskStatus ts : taskReports) {
      TaskStatus.State state = ts.getRunState();
      if (state == TaskStatus.State.RUNNING
          || state == TaskStatus.State.UNASSIGNED) {
        taskCount++;
      }
    }

    return taskCount;
  }

  /**
   * For BSPMaster to distinguish between different GroomServers, because
   * BSPMaster stores using GroomServerStatus as key.
   */
  @Override
  public int hashCode() {
    int result = 17;
    result = 37 * result + groomName.hashCode();
    result = 37 * result + rpcServer.hashCode();
    result = 37 * result + hostName.hashCode();
    /*
     * result = 37*result + (int)failures; result = 37*result +
     * taskReports.hashCode(); result = 37*result +
     * (int)(lastSeen^(lastSeen>>>32)); result = 37*result + (int)maxTasks;
     */
    return result;
  }

  @Override
  public boolean equals(Object o) {
    if (o == this)
      return true;
    if (null == o)
      return false;
    if (getClass() != o.getClass())
      return false;

    GroomServerStatus s = (GroomServerStatus) o;
    if (!s.groomName.equals(groomName))
      return false;
    if (!s.rpcServer.equals(rpcServer))
      return false;
    /*
     * if(s.failures != failures) return false; if(null == s.taskReports){
     * if(null != s.taskReports) return false; }else
     * if(!s.taskReports.equals(taskReports)){ return false; } if(s.lastSeen !=
     * lastSeen) return false; if(s.maxTasks != maxTasks) return false;
     */
    return true;
  }

  /*
   * (non-Javadoc)
   * @see org.apache.hadoop.io.Writable#readFields(java.io.DataInput)
   */
  @Override
  public void readFields(DataInput in) throws IOException {
    this.groomName = Text.readString(in);
    this.rpcServer = Text.readString(in);
    this.hostName = Text.readString(in);

    this.failures = in.readInt();
    this.maxTasks = in.readInt();
    taskReports.clear();
    int numTasks = in.readInt();

    TaskStatus status;
    for (int i = 0; i < numTasks; i++) {
      status = new TaskStatus();
      status.readFields(in);
      taskReports.add(status);
    }
  }

  /*
   * (non-Javadoc)
   * @see org.apache.hadoop.io.Writable#write(java.io.DataOutput)
   */
  @Override
  public void write(DataOutput out) throws IOException {
    Text.writeString(out, groomName);
    Text.writeString(out, rpcServer);
    Text.writeString(out, hostName);

    out.writeInt(failures);
    out.writeInt(maxTasks);
    out.writeInt(taskReports.size());
    for (TaskStatus taskStatus : taskReports) {
      taskStatus.write(out);
    }
  }

  public Iterator<TaskStatus> taskReports() {
    return taskReports.iterator();
  }
}
",data class
958,"public class NetAgent extends Agent {
    //---------------------navigational members-----------------------------------

    // All these request objects point to the same physical request object.
    ConnectionRequestInterface connectionRequest_;
    StatementRequestInterface statementRequest_;
    ResultSetRequestInterface resultSetRequest_;

    // All these reply objects point to the same physical reply object.
    ConnectionReply connectionReply_;
    private ConnectionReply packageReply_;
    StatementReply statementReply_;
    ResultSetReply resultSetReply_;

    //---------------------navigational cheat-links-------------------------------
    // Cheat-links are for convenience only, and are not part of the conceptual model.
    // Warning:
    //   Cheat-links should only be defined for invariant state data.
    //   That is, the state data is set by the constructor and never changes.

    // Alias for (NetConnection) super.connection
    NetConnection netConnection_;

    // Alias for (Request) super.*Request, all in one
    // In the case of the NET implementation, these all point to the same physical request object.
    private Request request_;
    NetConnectionRequest netConnectionRequest_;
    private NetPackageRequest netPackageRequest_;
    private NetStatementRequest netStatementRequest_;
    private NetResultSetRequest netResultSetRequest_;

    // Alias for (Reply) super.*Reply, all in one.
    // In the case of the NET implementation, these all point to the same physical reply object.
    private Reply reply_;
    NetConnectionReply netConnectionReply_;
    private NetPackageReply netPackageReply_;
    private NetStatementReply netStatementReply_;
    private NetResultSetReply netResultSetReply_;

    //-----------------------------state------------------------------------------

    Socket socket_;
    private InputStream rawSocketInputStream_;
    private OutputStream rawSocketOutputStream_;

    String server_;
    int port_;
    private int clientSSLMode_;

    private EbcdicCcsidManager ebcdicCcsidManager_;
    private Utf8CcsidManager utf8CcsidManager_;
    private CcsidManager currentCcsidManager_;
    
    // TODO: Remove target? Keep just one CcsidManager?
    //public CcsidManager targetCcsidManager_;
    Typdef typdef_;
    Typdef targetTypdef_;
    Typdef originalTargetTypdef_; // added to support typdef overrides

    private int svrcod_;

    int orignalTargetSqlam_ = NetConfiguration.MGRLVL_7;
    int targetSqlam_ = orignalTargetSqlam_;

    SqlException exceptionOpeningSocket_ = null;
    SqlException exceptionConvertingRdbnam = null;
    
    /**
     * Flag which indicates that a writeChain has been started and data sent to
     * the server.
     * If true, starting a new write chain will throw a DisconnectException. 
     * It is cleared when the write chain is ended.
     */
    private boolean writeChainIsDirty_ = false;
    //---------------------constructors/finalizer---------------------------------

    // Only used for testing
    public NetAgent(NetConnection netConnection,
                    LogWriter logWriter) throws SqlException {
        super(netConnection, logWriter);
        this.netConnection_ = netConnection;
    }

    NetAgent(NetConnection netConnection,
             LogWriter netLogWriter,
             int loginTimeout,
             String server,
             int port,
             int clientSSLMode) throws SqlException {
        super(netConnection, netLogWriter);

        server_ = server;
        port_ = port;
        netConnection_ = netConnection;
        clientSSLMode_ = clientSSLMode;

        if (server_ == null) {
            throw new DisconnectException(this, 
                new ClientMessageId(SQLState.CONNECT_REQUIRED_PROPERTY_NOT_SET),
                ""serverName"");
        }

        try {
            socket_ = (Socket)AccessController.doPrivileged(
                new OpenSocketAction(server, port, clientSSLMode_));
        } catch (PrivilegedActionException e) {
            throw new DisconnectException(this,
                new ClientMessageId(SQLState.CONNECT_UNABLE_TO_CONNECT_TO_SERVER),
                e.getException(),
                e.getException().getClass().getName(), server, port,
                e.getException().getMessage());
        }

        // Set TCP/IP Socket Properties
        try {
            if (exceptionOpeningSocket_ == null) {
                socket_.setTcpNoDelay(true); // disables nagles algorithm
                socket_.setKeepAlive(true); // PROTOCOL Manual: TCP/IP connection allocation rule #2
                socket_.setSoTimeout(loginTimeout * 1000);
            }
        } catch (SocketException e) {
            try {
                socket_.close();
            } catch (IOException doNothing) {
            }
            exceptionOpeningSocket_ = new DisconnectException(this,
                new ClientMessageId(SQLState.CONNECT_SOCKET_EXCEPTION),
                e, e.getMessage());
        }

        try {
            if (exceptionOpeningSocket_ == null) {
                rawSocketOutputStream_ = socket_.getOutputStream();
                rawSocketInputStream_ = socket_.getInputStream();
            }
        } catch (IOException e) {
            try {
                socket_.close();
            } catch (IOException doNothing) {
            }
            exceptionOpeningSocket_ = new DisconnectException(this, 
                new ClientMessageId(SQLState.CONNECT_UNABLE_TO_OPEN_SOCKET_STREAM),
                e, e.getMessage());
        }

        ebcdicCcsidManager_ = new EbcdicCcsidManager();
        utf8CcsidManager_ = new Utf8CcsidManager();
        
        currentCcsidManager_ = ebcdicCcsidManager_;

        if (netConnection_.isXAConnection()) {
            NetXAConnectionReply netXAConnectionReply_ = new NetXAConnectionReply(this, netConnection_.commBufferSize_);
            netResultSetReply_ = (NetResultSetReply) netXAConnectionReply_;
            netStatementReply_ = (NetStatementReply) netResultSetReply_;
            netPackageReply_ = (NetPackageReply) netStatementReply_;
            netConnectionReply_ = (NetConnectionReply) netPackageReply_;
            reply_ = (Reply) netConnectionReply_;

            resultSetReply_ = new ResultSetReply(this,
                    netResultSetReply_,
                    netStatementReply_,
                    netConnectionReply_);
            statementReply_ = (StatementReply) resultSetReply_;
            packageReply_ = (ConnectionReply) statementReply_;
            connectionReply_ = (ConnectionReply) packageReply_;
            NetXAConnectionRequest netXAConnectionRequest_ = new NetXAConnectionRequest(this, netConnection_.commBufferSize_);
            netResultSetRequest_ = (NetResultSetRequest) netXAConnectionRequest_;
            netStatementRequest_ = (NetStatementRequest) netResultSetRequest_;
            netPackageRequest_ = (NetPackageRequest) netStatementRequest_;
            netConnectionRequest_ = (NetConnectionRequest) netPackageRequest_;
            request_ = (Request) netConnectionRequest_;

            resultSetRequest_ = (ResultSetRequestInterface) netResultSetRequest_;
            statementRequest_ = (StatementRequestInterface) netStatementRequest_;
            connectionRequest_ = (ConnectionRequestInterface) netConnectionRequest_;
        } else {
            netResultSetReply_ = new NetResultSetReply(this, netConnection_.commBufferSize_);
            netStatementReply_ = (NetStatementReply) netResultSetReply_;
            netPackageReply_ = (NetPackageReply) netStatementReply_;
            netConnectionReply_ = (NetConnectionReply) netPackageReply_;
            reply_ = (Reply) netConnectionReply_;

            resultSetReply_ = new ResultSetReply(this,
                    netResultSetReply_,
                    netStatementReply_,
                    netConnectionReply_);
            statementReply_ = (StatementReply) resultSetReply_;
            packageReply_ = (ConnectionReply) statementReply_;
            connectionReply_ = (ConnectionReply) packageReply_;
            netResultSetRequest_ = new NetResultSetRequest(this, netConnection_.commBufferSize_);
            netStatementRequest_ = (NetStatementRequest) netResultSetRequest_;
            netPackageRequest_ = (NetPackageRequest) netStatementRequest_;
            netConnectionRequest_ = (NetConnectionRequest) netPackageRequest_;
            request_ = (Request) netConnectionRequest_;

            resultSetRequest_ = (ResultSetRequestInterface) netResultSetRequest_;
            statementRequest_ = (StatementRequestInterface) netStatementRequest_;
            connectionRequest_ = (ConnectionRequestInterface) netConnectionRequest_;
        }
    }

    protected void resetAgent_(LogWriter netLogWriter,
                               //CcsidManager sourceCcsidManager,
                               //CcsidManager targetCcsidManager,
                               int loginTimeout,
                               String server,
                               int port) throws SqlException {
        
        exceptionConvertingRdbnam = null;
        // most properties will remain unchanged on connect reset.
        targetTypdef_ = originalTargetTypdef_;
        svrcod_ = 0;

        // Set TCP/IP Socket Properties
        try {
            socket_.setSoTimeout(loginTimeout * 1000);
        } catch (SocketException e) {
            try {
                socket_.close();
            } catch (IOException doNothing) {
            }
            throw new SqlException(logWriter_, 
                new ClientMessageId(SQLState.SOCKET_EXCEPTION),
                e, e.getMessage());
        }
    }


    void setSvrcod(int svrcod) {
        if (svrcod > svrcod_) {
            svrcod_ = svrcod;
        }
    }

    void clearSvrcod() {
        svrcod_ = CodePoint.SVRCOD_INFO;
    }

    private int getSvrcod() {
        return svrcod_;
    }

    public void flush_() throws DisconnectException {
        sendRequest();
        reply_.initialize();
    }

    // Close socket and its streams.
    public void close_() throws SqlException {
        // can we just close the socket here, do we need to close streams individually
        SqlException accumulatedExceptions = null;
        if (rawSocketInputStream_ != null) {
            try {
                rawSocketInputStream_.close();
            } catch (IOException e) {
                // note when {6} = 0 it indicates the socket was closed.
                // this should be ok since we are going to go an close the socket
                // immediately following this call.
                // changing {4} to e.getMessage() may require pub changes
                accumulatedExceptions = new SqlException(logWriter_,
                    new ClientMessageId(SQLState.COMMUNICATION_ERROR),
                    e, e.getMessage());
            } finally {
                rawSocketInputStream_ = null;
            }
        }

        if (rawSocketOutputStream_ != null) {
            try {
                rawSocketOutputStream_.close();
            } catch (IOException e) {
                // note when {6} = 0 it indicates the socket was closed.
                // this should be ok since we are going to go an close the socket
                // immediately following this call.
                // changing {4} to e.getMessage() may require pub changes
                SqlException latestException = new SqlException(logWriter_,
                    new ClientMessageId(SQLState.COMMUNICATION_ERROR),
                    e, e.getMessage());
                accumulatedExceptions = Utils.accumulateSQLException(latestException, accumulatedExceptions);
            } finally {
                rawSocketOutputStream_ = null;
            }
        }

        if (socket_ != null) {
            try {
                socket_.close();
            } catch (IOException e) {
                // again {6} = 0, indicates the socket was closed.
                // maybe set {4} to e.getMessage().
                // do this for now and but may need to modify or
                // add this to the message pubs.
                SqlException latestException = new SqlException(logWriter_,
                    new ClientMessageId(SQLState.COMMUNICATION_ERROR),
                        e, e.getMessage());
                accumulatedExceptions = Utils.accumulateSQLException(latestException, accumulatedExceptions);
            } finally {
                socket_ = null;
            }
        }

        if (accumulatedExceptions != null) {
            throw accumulatedExceptions;
        }
    }

    /**
     * Specifies the maximum blocking time that should be used when sending
     * and receiving messages. The timeout is implemented by using the the 
     * underlying socket implementation's timeout support. 
     * 
     * Note that the support for timeout on sockets is dependent on the OS 
     * implementation. For the same reason we ignore any exceptions thrown
     * by the call to the socket layer.
     * 
     * @param timeout The timeout value in seconds. A value of 0 corresponds to 
     * infinite timeout.
     */
    protected void setTimeout(int timeout) {
        try {
            // Sets a timeout on the socket
            socket_.setSoTimeout(timeout * 1000); // convert to milliseconds
        } catch (SocketException se) {
            // Silently ignore any exceptions from the socket layer
            if (SanityManager.DEBUG) {
                System.out.println(""NetAgent.setTimeout: ignoring exception: "" + 
                                   se);
            }
        }
    }

    /**
     * Returns the current timeout value that is set on the socket.
     * 
     * Note that the support for timeout on sockets is dependent on the OS 
     * implementation. For the same reason we ignore any exceptions thrown
     * by the call to the socket layer.
     * 
     * @return The timeout value in seconds. A value of 0 corresponds to
     * that no timeout is specified on the socket.
     */
    protected int getTimeout() {
        int timeout = 0; // 0 is default timeout for sockets

        // Read the timeout currently set on the socket
        try {
            timeout = socket_.getSoTimeout();
        } catch (SocketException se) {
            // Silently ignore any exceptions from the socket layer
            if (SanityManager.DEBUG) {
                System.out.println(""NetAgent.getTimeout: ignoring exception: "" + 
                                   se);
            }
        }

        // Convert from milliseconds to seconds (note that this truncates
        // the results towards zero but that should not be a problem).
        timeout = timeout / 1000;
        return timeout;
    }

    private void sendRequest() throws DisconnectException {
        try {
            request_.flush(rawSocketOutputStream_);
        } catch (IOException e) {
            throwCommunicationsFailure(e);
        }
    }

    public InputStream getInputStream() {
        return rawSocketInputStream_;
    }

    public CcsidManager getCurrentCcsidManager() {
        return currentCcsidManager_;
    }
    
    public OutputStream getOutputStream() {
        return rawSocketOutputStream_;
    }

    void setInputStream(InputStream inputStream) {
        rawSocketInputStream_ = inputStream;
    }

    void setOutputStream(OutputStream outputStream) {
        rawSocketOutputStream_ = outputStream;
    }

    void throwCommunicationsFailure(Throwable cause)
        throws DisconnectException {
        //DisconnectException
        //accumulateReadExceptionAndDisconnect
        // note when {6} = 0 it indicates the socket was closed.
        // need to still validate any token values against message publications.
        accumulateChainBreakingReadExceptionAndThrow(
            new DisconnectException(this,
                new ClientMessageId(SQLState.COMMUNICATION_ERROR),
                cause, cause.getMessage()));
    }
        
    // ----------------------- call-down methods ---------------------------------

    protected void markChainBreakingException_() {
        setSvrcod(CodePoint.SVRCOD_ERROR);
    }

    public void checkForChainBreakingException_() throws SqlException {
        int svrcod = getSvrcod();
        clearSvrcod();
        if (svrcod > CodePoint.SVRCOD_WARNING) // Not for SQL warning, if svrcod > WARNING, then its a chain breaker
        {
            super.checkForExceptions(); // throws the accumulated exceptions, we'll always have at least one.
        }
    }

    private void writeDeferredResetConnection() throws SqlException {
        if (!netConnection_.resetConnectionAtFirstSql_) {
            return;
        }
        try {
            netConnection_.writeDeferredReset();
        } catch (SqlException sqle) {
            DisconnectException de = new DisconnectException(this, 
                new ClientMessageId(SQLState.CONNECTION_FAILED_ON_DEFERRED_RESET));
            de.setNextException(sqle);
            throw de;
        }
    }
    /**
     * Marks the agent's write chain as dirty. A write chain is dirty when data
     * from it has been sent to the server. A dirty write chain cannot be reset 
     * and reused for another request until the remaining data has been sent to
     * the server and the write chain properly ended. 
     * 
     * Resetting a dirty chain will cause the new request to be appended to the 
     * unfinished request already at the server, which will likely lead to 
     * cryptic syntax errors.
     */
    void markWriteChainAsDirty() {    
        writeChainIsDirty_ = true;
    }
    
    private void verifyWriteChainIsClean() throws DisconnectException {
        if (writeChainIsDirty_) { 
            throw new DisconnectException(this, 
                new ClientMessageId(SQLState.NET_WRITE_CHAIN_IS_DIRTY));
        }
    }
    public void beginWriteChainOutsideUOW() throws SqlException {
        verifyWriteChainIsClean();
        request_.initialize();
        writeDeferredResetConnection();
    }

    public void beginWriteChain(ClientStatement statement) throws SqlException {
        verifyWriteChainIsClean();
        request_.initialize();
        writeDeferredResetConnection();
        super.beginWriteChain(statement);
    }

    protected void endWriteChain() {}
    
    private void readDeferredResetConnection() throws SqlException {
        if (!netConnection_.resetConnectionAtFirstSql_) {
            return;
        }
        try {
            netConnection_.readDeferredReset();
            checkForExceptions();
        } catch (SqlException sqle) {
            DisconnectException de = new DisconnectException(this, 
                new ClientMessageId(SQLState.CONNECTION_FAILED_ON_DEFERRED_RESET));
            de.setNextException(sqle);
            throw de;
        }
    }

    protected void beginReadChain(ClientStatement statement)
            throws SqlException {
        // Clear here as endWriteChain may not always be called
        writeChainIsDirty_ = false;
        readDeferredResetConnection();
        super.beginReadChain(statement);
    }

    protected void beginReadChainOutsideUOW() throws SqlException {
        // Clear here as endWriteChain may not always be called
        writeChainIsDirty_ = false;
        readDeferredResetConnection();
        super.beginReadChainOutsideUOW();
    }

    /**
     * Switches the current CCSID manager to UTF-8
     */
    void switchToUtf8CcsidMgr() {
        currentCcsidManager_ = utf8CcsidManager_;
    }
    
    /**
     * Switches the current CCSID manager to EBCDIC
     */
    void switchToEbcdicMgr() {
        currentCcsidManager_ = ebcdicCcsidManager_;
    }
}
",blob
1386,"    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:com.alibaba.otter.canal.protocol.RowChange)
        RowChangeOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return CanalEntry.internal_static_com_alibaba_otter_canal_protocol_RowChange_descriptor;
      }

      protected FieldAccessorTable
          internalGetFieldAccessorTable() {
        return CanalEntry.internal_static_com_alibaba_otter_canal_protocol_RowChange_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                RowChange.class, Builder.class);
      }

      // Construct using com.alibaba.otter.canal.protocol.CanalEntry.RowChange.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders) {
          getRowDatasFieldBuilder();
          getPropsFieldBuilder();
        }
      }
      private static Builder create() {
        return new Builder();
      }

      public Builder clear() {
        super.clear();
        tableId_ = 0L;
        bitField0_ = (bitField0_ & ~0x00000001);
        eventType_ = EventType.UPDATE;
        bitField0_ = (bitField0_ & ~0x00000002);
        isDdl_ = false;
        bitField0_ = (bitField0_ & ~0x00000004);
        sql_ = """";
        bitField0_ = (bitField0_ & ~0x00000008);
        if (rowDatasBuilder_ == null) {
          rowDatas_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
        } else {
          rowDatasBuilder_.clear();
        }
        if (propsBuilder_ == null) {
          props_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
        } else {
          propsBuilder_.clear();
        }
        ddlSchemaName_ = """";
        bitField0_ = (bitField0_ & ~0x00000040);
        return this;
      }

      public Builder clone() {
        return create().mergeFrom(buildPartial());
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return CanalEntry.internal_static_com_alibaba_otter_canal_protocol_RowChange_descriptor;
      }

      public RowChange getDefaultInstanceForType() {
        return RowChange.getDefaultInstance();
      }

      public RowChange build() {
        RowChange result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public RowChange buildPartial() {
        RowChange result = new RowChange(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.tableId_ = tableId_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.eventType_ = eventType_;
        if (((from_bitField0_ & 0x00000004) == 0x00000004)) {
          to_bitField0_ |= 0x00000004;
        }
        result.isDdl_ = isDdl_;
        if (((from_bitField0_ & 0x00000008) == 0x00000008)) {
          to_bitField0_ |= 0x00000008;
        }
        result.sql_ = sql_;
        if (rowDatasBuilder_ == null) {
          if (((bitField0_ & 0x00000010) == 0x00000010)) {
            rowDatas_ = java.util.Collections.unmodifiableList(rowDatas_);
            bitField0_ = (bitField0_ & ~0x00000010);
          }
          result.rowDatas_ = rowDatas_;
        } else {
          result.rowDatas_ = rowDatasBuilder_.build();
        }
        if (propsBuilder_ == null) {
          if (((bitField0_ & 0x00000020) == 0x00000020)) {
            props_ = java.util.Collections.unmodifiableList(props_);
            bitField0_ = (bitField0_ & ~0x00000020);
          }
          result.props_ = props_;
        } else {
          result.props_ = propsBuilder_.build();
        }
        if (((from_bitField0_ & 0x00000040) == 0x00000040)) {
          to_bitField0_ |= 0x00000010;
        }
        result.ddlSchemaName_ = ddlSchemaName_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof RowChange) {
          return mergeFrom((RowChange)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(RowChange other) {
        if (other == RowChange.getDefaultInstance()) return this;
        if (other.hasTableId()) {
          setTableId(other.getTableId());
        }
        if (other.hasEventType()) {
          setEventType(other.getEventType());
        }
        if (other.hasIsDdl()) {
          setIsDdl(other.getIsDdl());
        }
        if (other.hasSql()) {
          bitField0_ |= 0x00000008;
          sql_ = other.sql_;
          onChanged();
        }
        if (rowDatasBuilder_ == null) {
          if (!other.rowDatas_.isEmpty()) {
            if (rowDatas_.isEmpty()) {
              rowDatas_ = other.rowDatas_;
              bitField0_ = (bitField0_ & ~0x00000010);
            } else {
              ensureRowDatasIsMutable();
              rowDatas_.addAll(other.rowDatas_);
            }
            onChanged();
          }
        } else {
          if (!other.rowDatas_.isEmpty()) {
            if (rowDatasBuilder_.isEmpty()) {
              rowDatasBuilder_.dispose();
              rowDatasBuilder_ = null;
              rowDatas_ = other.rowDatas_;
              bitField0_ = (bitField0_ & ~0x00000010);
              rowDatasBuilder_ =
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getRowDatasFieldBuilder() : null;
            } else {
              rowDatasBuilder_.addAllMessages(other.rowDatas_);
            }
          }
        }
        if (propsBuilder_ == null) {
          if (!other.props_.isEmpty()) {
            if (props_.isEmpty()) {
              props_ = other.props_;
              bitField0_ = (bitField0_ & ~0x00000020);
            } else {
              ensurePropsIsMutable();
              props_.addAll(other.props_);
            }
            onChanged();
          }
        } else {
          if (!other.props_.isEmpty()) {
            if (propsBuilder_.isEmpty()) {
              propsBuilder_.dispose();
              propsBuilder_ = null;
              props_ = other.props_;
              bitField0_ = (bitField0_ & ~0x00000020);
              propsBuilder_ =
                com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ?
                   getPropsFieldBuilder() : null;
            } else {
              propsBuilder_.addAllMessages(other.props_);
            }
          }
        }
        if (other.hasDdlSchemaName()) {
          bitField0_ |= 0x00000040;
          ddlSchemaName_ = other.ddlSchemaName_;
          onChanged();
        }
        this.mergeUnknownFields(other.getUnknownFields());
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        RowChange parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (RowChange) e.getUnfinishedMessage();
          throw e;
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private long tableId_ ;
      /**
       * <code>optional int64 tableId = 1;</code>
       *
       * <pre>
       **tableId,由数据库产生*
       * </pre>
       */
      public boolean hasTableId() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }
      /**
       * <code>optional int64 tableId = 1;</code>
       *
       * <pre>
       **tableId,由数据库产生*
       * </pre>
       */
      public long getTableId() {
        return tableId_;
      }
      /**
       * <code>optional int64 tableId = 1;</code>
       *
       * <pre>
       **tableId,由数据库产生*
       * </pre>
       */
      public Builder setTableId(long value) {
        bitField0_ |= 0x00000001;
        tableId_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional int64 tableId = 1;</code>
       *
       * <pre>
       **tableId,由数据库产生*
       * </pre>
       */
      public Builder clearTableId() {
        bitField0_ = (bitField0_ & ~0x00000001);
        tableId_ = 0L;
        onChanged();
        return this;
      }

      private EventType eventType_ = EventType.UPDATE;
      /**
       * <code>optional .com.alibaba.otter.canal.protocol.EventType eventType = 2 [default = UPDATE];</code>
       *
       * <pre>
       **数据变更类型*
       * </pre>
       */
      public boolean hasEventType() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }
      /**
       * <code>optional .com.alibaba.otter.canal.protocol.EventType eventType = 2 [default = UPDATE];</code>
       *
       * <pre>
       **数据变更类型*
       * </pre>
       */
      public EventType getEventType() {
        return eventType_;
      }
      /**
       * <code>optional .com.alibaba.otter.canal.protocol.EventType eventType = 2 [default = UPDATE];</code>
       *
       * <pre>
       **数据变更类型*
       * </pre>
       */
      public Builder setEventType(EventType value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        eventType_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional .com.alibaba.otter.canal.protocol.EventType eventType = 2 [default = UPDATE];</code>
       *
       * <pre>
       **数据变更类型*
       * </pre>
       */
      public Builder clearEventType() {
        bitField0_ = (bitField0_ & ~0x00000002);
        eventType_ = EventType.UPDATE;
        onChanged();
        return this;
      }

      private boolean isDdl_ ;
      /**
       * <code>optional bool isDdl = 10 [default = false];</code>
       *
       * <pre>
       ** 标识是否是ddl语句  *
       * </pre>
       */
      public boolean hasIsDdl() {
        return ((bitField0_ & 0x00000004) == 0x00000004);
      }
      /**
       * <code>optional bool isDdl = 10 [default = false];</code>
       *
       * <pre>
       ** 标识是否是ddl语句  *
       * </pre>
       */
      public boolean getIsDdl() {
        return isDdl_;
      }
      /**
       * <code>optional bool isDdl = 10 [default = false];</code>
       *
       * <pre>
       ** 标识是否是ddl语句  *
       * </pre>
       */
      public Builder setIsDdl(boolean value) {
        bitField0_ |= 0x00000004;
        isDdl_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional bool isDdl = 10 [default = false];</code>
       *
       * <pre>
       ** 标识是否是ddl语句  *
       * </pre>
       */
      public Builder clearIsDdl() {
        bitField0_ = (bitField0_ & ~0x00000004);
        isDdl_ = false;
        onChanged();
        return this;
      }

      private Object sql_ = """";
      /**
       * <code>optional string sql = 11;</code>
       *
       * <pre>
       ** ddl/query的sql语句  *
       * </pre>
       */
      public boolean hasSql() {
        return ((bitField0_ & 0x00000008) == 0x00000008);
      }
      /**
       * <code>optional string sql = 11;</code>
       *
       * <pre>
       ** ddl/query的sql语句  *
       * </pre>
       */
      public String getSql() {
        Object ref = sql_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            sql_ = s;
          }
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <code>optional string sql = 11;</code>
       *
       * <pre>
       ** ddl/query的sql语句  *
       * </pre>
       */
      public com.google.protobuf.ByteString
          getSqlBytes() {
        Object ref = sql_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          sql_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string sql = 11;</code>
       *
       * <pre>
       ** ddl/query的sql语句  *
       * </pre>
       */
      public Builder setSql(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        sql_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string sql = 11;</code>
       *
       * <pre>
       ** ddl/query的sql语句  *
       * </pre>
       */
      public Builder clearSql() {
        bitField0_ = (bitField0_ & ~0x00000008);
        sql_ = getDefaultInstance().getSql();
        onChanged();
        return this;
      }
      /**
       * <code>optional string sql = 11;</code>
       *
       * <pre>
       ** ddl/query的sql语句  *
       * </pre>
       */
      public Builder setSqlBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000008;
        sql_ = value;
        onChanged();
        return this;
      }

      private java.util.List<RowData> rowDatas_ =
        java.util.Collections.emptyList();
      private void ensureRowDatasIsMutable() {
        if (!((bitField0_ & 0x00000010) == 0x00000010)) {
          rowDatas_ = new java.util.ArrayList<RowData>(rowDatas_);
          bitField0_ |= 0x00000010;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          RowData, RowData.Builder, RowDataOrBuilder> rowDatasBuilder_;

      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;</code>
       *
       * <pre>
       ** 一次数据库变更可能存在多行  *
       * </pre>
       */
      public java.util.List<RowData> getRowDatasList() {
        if (rowDatasBuilder_ == null) {
          return java.util.Collections.unmodifiableList(rowDatas_);
        } else {
          return rowDatasBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;</code>
       *
       * <pre>
       ** 一次数据库变更可能存在多行  *
       * </pre>
       */
      public int getRowDatasCount() {
        if (rowDatasBuilder_ == null) {
          return rowDatas_.size();
        } else {
          return rowDatasBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;</code>
       *
       * <pre>
       ** 一次数据库变更可能存在多行  *
       * </pre>
       */
      public RowData getRowDatas(int index) {
        if (rowDatasBuilder_ == null) {
          return rowDatas_.get(index);
        } else {
          return rowDatasBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;</code>
       *
       * <pre>
       ** 一次数据库变更可能存在多行  *
       * </pre>
       */
      public Builder setRowDatas(
          int index, RowData value) {
        if (rowDatasBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRowDatasIsMutable();
          rowDatas_.set(index, value);
          onChanged();
        } else {
          rowDatasBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;</code>
       *
       * <pre>
       ** 一次数据库变更可能存在多行  *
       * </pre>
       */
      public Builder setRowDatas(
          int index, RowData.Builder builderForValue) {
        if (rowDatasBuilder_ == null) {
          ensureRowDatasIsMutable();
          rowDatas_.set(index, builderForValue.build());
          onChanged();
        } else {
          rowDatasBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;</code>
       *
       * <pre>
       ** 一次数据库变更可能存在多行  *
       * </pre>
       */
      public Builder addRowDatas(RowData value) {
        if (rowDatasBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRowDatasIsMutable();
          rowDatas_.add(value);
          onChanged();
        } else {
          rowDatasBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;</code>
       *
       * <pre>
       ** 一次数据库变更可能存在多行  *
       * </pre>
       */
      public Builder addRowDatas(
          int index, RowData value) {
        if (rowDatasBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRowDatasIsMutable();
          rowDatas_.add(index, value);
          onChanged();
        } else {
          rowDatasBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;</code>
       *
       * <pre>
       ** 一次数据库变更可能存在多行  *
       * </pre>
       */
      public Builder addRowDatas(
          RowData.Builder builderForValue) {
        if (rowDatasBuilder_ == null) {
          ensureRowDatasIsMutable();
          rowDatas_.add(builderForValue.build());
          onChanged();
        } else {
          rowDatasBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;</code>
       *
       * <pre>
       ** 一次数据库变更可能存在多行  *
       * </pre>
       */
      public Builder addRowDatas(
          int index, RowData.Builder builderForValue) {
        if (rowDatasBuilder_ == null) {
          ensureRowDatasIsMutable();
          rowDatas_.add(index, builderForValue.build());
          onChanged();
        } else {
          rowDatasBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;</code>
       *
       * <pre>
       ** 一次数据库变更可能存在多行  *
       * </pre>
       */
      public Builder addAllRowDatas(
          Iterable<? extends RowData> values) {
        if (rowDatasBuilder_ == null) {
          ensureRowDatasIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, rowDatas_);
          onChanged();
        } else {
          rowDatasBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;</code>
       *
       * <pre>
       ** 一次数据库变更可能存在多行  *
       * </pre>
       */
      public Builder clearRowDatas() {
        if (rowDatasBuilder_ == null) {
          rowDatas_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000010);
          onChanged();
        } else {
          rowDatasBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;</code>
       *
       * <pre>
       ** 一次数据库变更可能存在多行  *
       * </pre>
       */
      public Builder removeRowDatas(int index) {
        if (rowDatasBuilder_ == null) {
          ensureRowDatasIsMutable();
          rowDatas_.remove(index);
          onChanged();
        } else {
          rowDatasBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;</code>
       *
       * <pre>
       ** 一次数据库变更可能存在多行  *
       * </pre>
       */
      public RowData.Builder getRowDatasBuilder(
          int index) {
        return getRowDatasFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;</code>
       *
       * <pre>
       ** 一次数据库变更可能存在多行  *
       * </pre>
       */
      public RowDataOrBuilder getRowDatasOrBuilder(
          int index) {
        if (rowDatasBuilder_ == null) {
          return rowDatas_.get(index);  } else {
          return rowDatasBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;</code>
       *
       * <pre>
       ** 一次数据库变更可能存在多行  *
       * </pre>
       */
      public java.util.List<? extends RowDataOrBuilder>
           getRowDatasOrBuilderList() {
        if (rowDatasBuilder_ != null) {
          return rowDatasBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(rowDatas_);
        }
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;</code>
       *
       * <pre>
       ** 一次数据库变更可能存在多行  *
       * </pre>
       */
      public RowData.Builder addRowDatasBuilder() {
        return getRowDatasFieldBuilder().addBuilder(
            RowData.getDefaultInstance());
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;</code>
       *
       * <pre>
       ** 一次数据库变更可能存在多行  *
       * </pre>
       */
      public RowData.Builder addRowDatasBuilder(
          int index) {
        return getRowDatasFieldBuilder().addBuilder(
            index, RowData.getDefaultInstance());
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.RowData rowDatas = 12;</code>
       *
       * <pre>
       ** 一次数据库变更可能存在多行  *
       * </pre>
       */
      public java.util.List<RowData.Builder>
           getRowDatasBuilderList() {
        return getRowDatasFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          RowData, RowData.Builder, RowDataOrBuilder>
          getRowDatasFieldBuilder() {
        if (rowDatasBuilder_ == null) {
          rowDatasBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              RowData, RowData.Builder, RowDataOrBuilder>(
                  rowDatas_,
                  ((bitField0_ & 0x00000010) == 0x00000010),
                  getParentForChildren(),
                  isClean());
          rowDatas_ = null;
        }
        return rowDatasBuilder_;
      }

      private java.util.List<Pair> props_ =
        java.util.Collections.emptyList();
      private void ensurePropsIsMutable() {
        if (!((bitField0_ & 0x00000020) == 0x00000020)) {
          props_ = new java.util.ArrayList<Pair>(props_);
          bitField0_ |= 0x00000020;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilder<
          Pair, Pair.Builder, PairOrBuilder> propsBuilder_;

      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.Pair props = 13;</code>
       *
       * <pre>
       **预留扩展*
       * </pre>
       */
      public java.util.List<Pair> getPropsList() {
        if (propsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(props_);
        } else {
          return propsBuilder_.getMessageList();
        }
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.Pair props = 13;</code>
       *
       * <pre>
       **预留扩展*
       * </pre>
       */
      public int getPropsCount() {
        if (propsBuilder_ == null) {
          return props_.size();
        } else {
          return propsBuilder_.getCount();
        }
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.Pair props = 13;</code>
       *
       * <pre>
       **预留扩展*
       * </pre>
       */
      public Pair getProps(int index) {
        if (propsBuilder_ == null) {
          return props_.get(index);
        } else {
          return propsBuilder_.getMessage(index);
        }
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.Pair props = 13;</code>
       *
       * <pre>
       **预留扩展*
       * </pre>
       */
      public Builder setProps(
          int index, Pair value) {
        if (propsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePropsIsMutable();
          props_.set(index, value);
          onChanged();
        } else {
          propsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.Pair props = 13;</code>
       *
       * <pre>
       **预留扩展*
       * </pre>
       */
      public Builder setProps(
          int index, Pair.Builder builderForValue) {
        if (propsBuilder_ == null) {
          ensurePropsIsMutable();
          props_.set(index, builderForValue.build());
          onChanged();
        } else {
          propsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.Pair props = 13;</code>
       *
       * <pre>
       **预留扩展*
       * </pre>
       */
      public Builder addProps(Pair value) {
        if (propsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePropsIsMutable();
          props_.add(value);
          onChanged();
        } else {
          propsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.Pair props = 13;</code>
       *
       * <pre>
       **预留扩展*
       * </pre>
       */
      public Builder addProps(
          int index, Pair value) {
        if (propsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensurePropsIsMutable();
          props_.add(index, value);
          onChanged();
        } else {
          propsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.Pair props = 13;</code>
       *
       * <pre>
       **预留扩展*
       * </pre>
       */
      public Builder addProps(
          Pair.Builder builderForValue) {
        if (propsBuilder_ == null) {
          ensurePropsIsMutable();
          props_.add(builderForValue.build());
          onChanged();
        } else {
          propsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.Pair props = 13;</code>
       *
       * <pre>
       **预留扩展*
       * </pre>
       */
      public Builder addProps(
          int index, Pair.Builder builderForValue) {
        if (propsBuilder_ == null) {
          ensurePropsIsMutable();
          props_.add(index, builderForValue.build());
          onChanged();
        } else {
          propsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.Pair props = 13;</code>
       *
       * <pre>
       **预留扩展*
       * </pre>
       */
      public Builder addAllProps(
          Iterable<? extends Pair> values) {
        if (propsBuilder_ == null) {
          ensurePropsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, props_);
          onChanged();
        } else {
          propsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.Pair props = 13;</code>
       *
       * <pre>
       **预留扩展*
       * </pre>
       */
      public Builder clearProps() {
        if (propsBuilder_ == null) {
          props_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000020);
          onChanged();
        } else {
          propsBuilder_.clear();
        }
        return this;
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.Pair props = 13;</code>
       *
       * <pre>
       **预留扩展*
       * </pre>
       */
      public Builder removeProps(int index) {
        if (propsBuilder_ == null) {
          ensurePropsIsMutable();
          props_.remove(index);
          onChanged();
        } else {
          propsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.Pair props = 13;</code>
       *
       * <pre>
       **预留扩展*
       * </pre>
       */
      public Pair.Builder getPropsBuilder(
          int index) {
        return getPropsFieldBuilder().getBuilder(index);
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.Pair props = 13;</code>
       *
       * <pre>
       **预留扩展*
       * </pre>
       */
      public PairOrBuilder getPropsOrBuilder(
          int index) {
        if (propsBuilder_ == null) {
          return props_.get(index);  } else {
          return propsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.Pair props = 13;</code>
       *
       * <pre>
       **预留扩展*
       * </pre>
       */
      public java.util.List<? extends PairOrBuilder>
           getPropsOrBuilderList() {
        if (propsBuilder_ != null) {
          return propsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(props_);
        }
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.Pair props = 13;</code>
       *
       * <pre>
       **预留扩展*
       * </pre>
       */
      public Pair.Builder addPropsBuilder() {
        return getPropsFieldBuilder().addBuilder(
            Pair.getDefaultInstance());
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.Pair props = 13;</code>
       *
       * <pre>
       **预留扩展*
       * </pre>
       */
      public Pair.Builder addPropsBuilder(
          int index) {
        return getPropsFieldBuilder().addBuilder(
            index, Pair.getDefaultInstance());
      }
      /**
       * <code>repeated .com.alibaba.otter.canal.protocol.Pair props = 13;</code>
       *
       * <pre>
       **预留扩展*
       * </pre>
       */
      public java.util.List<Pair.Builder>
           getPropsBuilderList() {
        return getPropsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilder<
          Pair, Pair.Builder, PairOrBuilder>
          getPropsFieldBuilder() {
        if (propsBuilder_ == null) {
          propsBuilder_ = new com.google.protobuf.RepeatedFieldBuilder<
              Pair, Pair.Builder, PairOrBuilder>(
                  props_,
                  ((bitField0_ & 0x00000020) == 0x00000020),
                  getParentForChildren(),
                  isClean());
          props_ = null;
        }
        return propsBuilder_;
      }

      private Object ddlSchemaName_ = """";
      /**
       * <code>optional string ddlSchemaName = 14;</code>
       *
       * <pre>
       ** ddl/query的schemaName，会存在跨库ddl，需要保留执行ddl的当前schemaName  *
       * </pre>
       */
      public boolean hasDdlSchemaName() {
        return ((bitField0_ & 0x00000040) == 0x00000040);
      }
      /**
       * <code>optional string ddlSchemaName = 14;</code>
       *
       * <pre>
       ** ddl/query的schemaName，会存在跨库ddl，需要保留执行ddl的当前schemaName  *
       * </pre>
       */
      public String getDdlSchemaName() {
        Object ref = ddlSchemaName_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            ddlSchemaName_ = s;
          }
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <code>optional string ddlSchemaName = 14;</code>
       *
       * <pre>
       ** ddl/query的schemaName，会存在跨库ddl，需要保留执行ddl的当前schemaName  *
       * </pre>
       */
      public com.google.protobuf.ByteString
          getDdlSchemaNameBytes() {
        Object ref = ddlSchemaName_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          ddlSchemaName_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>optional string ddlSchemaName = 14;</code>
       *
       * <pre>
       ** ddl/query的schemaName，会存在跨库ddl，需要保留执行ddl的当前schemaName  *
       * </pre>
       */
      public Builder setDdlSchemaName(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000040;
        ddlSchemaName_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>optional string ddlSchemaName = 14;</code>
       *
       * <pre>
       ** ddl/query的schemaName，会存在跨库ddl，需要保留执行ddl的当前schemaName  *
       * </pre>
       */
      public Builder clearDdlSchemaName() {
        bitField0_ = (bitField0_ & ~0x00000040);
        ddlSchemaName_ = getDefaultInstance().getDdlSchemaName();
        onChanged();
        return this;
      }
      /**
       * <code>optional string ddlSchemaName = 14;</code>
       *
       * <pre>
       ** ddl/query的schemaName，会存在跨库ddl，需要保留执行ddl的当前schemaName  *
       * </pre>
       */
      public Builder setDdlSchemaNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  bitField0_ |= 0x00000040;
        ddlSchemaName_ = value;
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:com.alibaba.otter.canal.protocol.RowChange)
    }
",data class
143,"  private void parseQuotedValue(byte prev) throws IOException {
    final byte newLine = this.newLine;
    final byte delimiter = this.delimiter;
    final TextOutput output = this.output;
    final TextInput input = this.input;
    final byte quote = this.quote;

    ch = input.nextCharNoNewLineCheck();

    while (!(prev == quote && (ch == delimiter || ch == newLine || isWhite(ch)))) {
      if (ch != quote) {
        if (prev == quote) { // unescaped quote detected
          if (parseUnescapedQuotes) {
            output.append(quote);
            output.append(ch);
            parseQuotedValue(ch);
            break;
          } else {
            throw new TextParsingException(
                context,
                ""Unescaped quote character '""
                    + quote
                    + ""' inside quoted value of CSV field. To allow unescaped quotes, set 'parseUnescapedQuotes' to 'true' in the CSV parser settings. Cannot parse CSV input."");
          }
        }
        output.append(ch);
        prev = ch;
      } else if (prev == quoteEscape) {
        output.append(quote);
        prev = NULL_BYTE;
      } else {
        prev = ch;
      }
      ch = input.nextCharNoNewLineCheck();
    }

    // Handles whitespaces after quoted value:
    // Whitespaces are ignored (i.e., ch <= ' ') if they are not used as delimiters (i.e., ch != ' ')
    // For example, in tab-separated files (TSV files), '\t' is used as delimiter and should not be ignored
    // Content after whitespaces may be parsed if 'parseUnescapedQuotes' is enabled.
    if (ch != newLine && ch <= ' ' && ch != delimiter) {
      final DrillBuf workBuf = this.workBuf;
      workBuf.resetWriterIndex();
      do {
        // saves whitespaces after value
        workBuf.writeByte(ch);
        ch = input.nextChar();
        // found a new line, go to next record.
        if (ch == newLine) {
          return;
        }
      } while (ch <= ' ' && ch != delimiter);

      // there's more stuff after the quoted value, not only empty spaces.
      if (!(ch == delimiter || ch == newLine) && parseUnescapedQuotes) {

        output.append(quote);
        for(int i =0; i < workBuf.writerIndex(); i++){
          output.append(workBuf.getByte(i));
        }
        // the next character is not the escape character, put it there
        if (ch != quoteEscape) {
          output.append(ch);
        }
        // sets this character as the previous character (may be escaping)
        // calls recursively to keep parsing potentially quoted content
        parseQuotedValue(ch);
      }
    }

    if (!(ch == delimiter || ch == newLine)) {
      throw new TextParsingException(context, ""Unexpected character '"" + ch
          + ""' following quoted value of CSV field. Expecting '"" + delimiter + ""'. Cannot parse CSV input."");
    }
  }
",long method
1012,"public final class OgnlHelper {

    private static final Pattern INDEX_PATTERN = Pattern.compile(""^(.*)\\[(.*)\\]$"");

    private OgnlHelper() {
    }

    /**
     * Tests whether or not the given String is a Camel OGNL expression.
     * <p/>
     * An expression is considered an OGNL expression when it contains either one of the following chars: . or [
     *
     * @param expression  the String
     * @return <tt>true</tt> if a Camel OGNL expression, otherwise <tt>false</tt>. 
     */
    public static boolean isValidOgnlExpression(String expression) {
        if (ObjectHelper.isEmpty(expression)) {
            return false;
        }

        // the brackets should come in a pair
        int bracketBegin = StringHelper.countChar(expression, '[');
        int bracketEnd = StringHelper.countChar(expression, ']');
        if (bracketBegin > 0 && bracketEnd > 0) {
            return bracketBegin == bracketEnd;
        }

        return expression.contains(""."");
    }

    public static boolean isInvalidValidOgnlExpression(String expression) {
        if (ObjectHelper.isEmpty(expression)) {
            return false;
        }

        if (!expression.contains(""."") && !expression.contains(""["") && !expression.contains(""]"")) {
            return false;
        }

        // the brackets should come in pair
        int bracketBegin = StringHelper.countChar(expression, '[');
        int bracketEnd = StringHelper.countChar(expression, ']');
        if (bracketBegin > 0 || bracketEnd > 0) {
            return bracketBegin != bracketEnd;
        }
        
        // check for double dots
        if (expression.contains("".."")) {
            return true;
        }

        return false;
    }

    /**
     * Validates whether the method name is using valid java identifiers in the name
     * Will throw {@link IllegalArgumentException} if the method name is invalid.
     */
    public static void validateMethodName(String method) {
        if (ObjectHelper.isEmpty(method)) {
            return;
        }
        for (int i = 0; i < method.length(); i++) {
            char ch = method.charAt(i);
            if (i == 0 && '.' == ch) {
                // its a dot before a method name
                continue;
            }
            if (ch == '(' || ch == '[' || ch == '.' || ch == '?') {
                // break when method name ends and sub method or arguments begin
                break;
            }
            if (i == 0 && !Character.isJavaIdentifierStart(ch)) {
                throw new IllegalArgumentException(""Method name must start with a valid java identifier at position: 0 in method: "" + method);
            } else if (!Character.isJavaIdentifierPart(ch)) {
                throw new IllegalArgumentException(""Method name must be valid java identifier at position: "" + i + "" in method: "" + method);
            }
        }
    }

    /**
     * Tests whether or not the given Camel OGNL expression is using the null safe operator or not.
     *
     * @param ognlExpression the Camel OGNL expression
     * @return <tt>true</tt> if the null safe operator is used, otherwise <tt>false</tt>.
     */
    public static boolean isNullSafeOperator(String ognlExpression) {
        if (ObjectHelper.isEmpty(ognlExpression)) {
            return false;
        }

        return ognlExpression.startsWith(""?"");
    }

    /**
     * Removes any leading operators from the Camel OGNL expression.
     * <p/>
     * Will remove any leading of the following chars: ? or .
     *
     * @param ognlExpression  the Camel OGNL expression
     * @return the Camel OGNL expression without any leading operators.
     */
    public static String removeLeadingOperators(String ognlExpression) {
        if (ObjectHelper.isEmpty(ognlExpression)) {
            return ognlExpression;
        }

        if (ognlExpression.startsWith(""?"")) {
            ognlExpression = ognlExpression.substring(1);
        }
        if (ognlExpression.startsWith(""."")) {
            ognlExpression = ognlExpression.substring(1);
        }

        return ognlExpression;
    }

    /**
     * Removes any trailing operators from the Camel OGNL expression.
     *
     * @param ognlExpression  the Camel OGNL expression
     * @return the Camel OGNL expression without any trailing operators.
     */
    public static String removeTrailingOperators(String ognlExpression) {
        if (ObjectHelper.isEmpty(ognlExpression)) {
            return ognlExpression;
        }

        if (ognlExpression.contains(""["")) {
            return StringHelper.before(ognlExpression, ""["");
        }
        return ognlExpression;
    }

    public static String removeOperators(String ognlExpression) {
        return removeLeadingOperators(removeTrailingOperators(ognlExpression));
    }

    public static KeyValueHolder<String, String> isOgnlIndex(String ognlExpression) {
        Matcher matcher = INDEX_PATTERN.matcher(ognlExpression);
        if (matcher.matches()) {

            // to avoid empty strings as we want key/value to be null in such cases
            String key = matcher.group(1);
            if (ObjectHelper.isEmpty(key)) {
                key = null;
            }

            // to avoid empty strings as we want key/value to be null in such cases
            String value = matcher.group(2);
            if (ObjectHelper.isEmpty(value)) {
                value = null;
            }

            return new KeyValueHolder<>(key, value);
        }

        return null;
    }

    /**
     * Regular expression with repeating groups is a pain to get right
     * and then nobody understands the reg exp afterwards.
     * So we use a bit ugly/low-level Java code to split the OGNL into methods.
     *
     * @param ognl the ognl expression
     * @return a list of methods, will return an empty list, if ognl expression has no methods
     * @throws IllegalArgumentException if the last method has a missing ending parenthesis
     */
    public static List<String> splitOgnl(String ognl) {
        List<String> methods = new ArrayList<>();

        // return an empty list if ognl is empty
        if (ObjectHelper.isEmpty(ognl)) {
            return methods;
        }

        StringBuilder sb = new StringBuilder();

        int j = 0; // j is used as counter per method
        boolean squareBracket = false; // special to keep track if we are inside a square bracket block, eg: [foo]
        boolean parenthesisBracket = false; // special to keep track if we are inside a parenthesis block, eg: bar(${body}, ${header.foo})
        for (int i = 0; i < ognl.length(); i++) {
            char ch = ognl.charAt(i);
            // special for starting a new method
            if (j == 0 || (j == 1 && ognl.charAt(i - 1) == '?')
                    || (ch != '.' && ch != '?' && ch != ']')) {
                sb.append(ch);
                // special if we are doing square bracket
                if (ch == '[' && !parenthesisBracket) {
                    squareBracket = true;
                } else if (ch == '(') {
                    parenthesisBracket = true;
                } else if (ch == ')') {
                    parenthesisBracket = false;
                }
                j++; // advance
            } else {
                if (ch == '.' && !squareBracket && !parenthesisBracket) {
                    // only treat dot as a method separator if not inside a square bracket block
                    // as dots can be used in key names when accessing maps

                    // a dit denotes end of this method and a new method is to be invoked
                    String s = sb.toString();

                    // reset sb
                    sb.setLength(0);

                    // pass over ? to the new method
                    if (s.endsWith(""?"")) {
                        sb.append(""?"");
                        s = s.substring(0, s.length() - 1);
                    }

                    // add the method
                    methods.add(s);

                    // reset j to begin a new method
                    j = 0;
                } else if (ch == ']' && !parenthesisBracket) {
                    // append ending ] to method name
                    sb.append(ch);
                    String s = sb.toString();

                    // reset sb
                    sb.setLength(0);

                    // add the method
                    methods.add(s);

                    // reset j to begin a new method
                    j = 0;

                    // no more square bracket
                    squareBracket = false;
                }

                // and don't lose the char if its not an ] end marker (as we already added that)
                if (ch != ']' || parenthesisBracket) {
                    sb.append(ch);
                }

                // only advance if already begun on the new method
                if (j > 0) {
                    j++;
                }
            }
        }

        // add remainder in buffer when reached end of data
        if (sb.length() > 0) {
            methods.add(sb.toString());
        }

        String last = methods.isEmpty() ? null : methods.get(methods.size() - 1);
        if (parenthesisBracket && last != null) {
            // there is an unclosed parenthesis bracket on the last method, so it should end with a parenthesis
            if (last.contains(""("") && !last.endsWith("")"")) {
                throw new IllegalArgumentException(""Method should end with parenthesis, was "" + last);
            }
        }

        return methods;
    }

}
",blob
432,"    @Override
    public void updateExperiment(String airavataExperimentId, ExperimentModel experiment) throws RegistryServiceException, TException {
        try {
            experimentCatalog = RegistryFactory.getDefaultExpCatalog();
            if (!experimentCatalog.isExist(ExperimentCatalogModelType.EXPERIMENT, airavataExperimentId)) {
                logger.error(airavataExperimentId, ""Update request failed, Experiment {} doesn't exist."", airavataExperimentId);
                throw new RegistryServiceException(""Requested experiment id "" + airavataExperimentId + "" does not exist in the system.."");
            }

            ExperimentStatus experimentStatus = getExperimentStatusInternal(airavataExperimentId);
            if (experimentStatus != null){
                ExperimentState experimentState = experimentStatus.getState();
                switch (experimentState){
                    case CREATED: case VALIDATED:
                        if(experiment.getUserConfigurationData() != null && experiment.getUserConfigurationData()
                                .getComputationalResourceScheduling() != null){
                            String compResourceId = experiment.getUserConfigurationData()
                                    .getComputationalResourceScheduling().getResourceHostId();
                            ComputeResourceDescription computeResourceDescription = appCatalog.getComputeResource()
                                    .getComputeResource(compResourceId);
                            if(!computeResourceDescription.isEnabled()){
                                logger.error(""Compute Resource is not enabled by the Admin!"");
                                AiravataSystemException exception = new AiravataSystemException();
                                exception.setAiravataErrorType(AiravataErrorType.INTERNAL_ERROR);
                                exception.setMessage(""Compute Resource is not enabled by the Admin!"");
                                throw exception;
                            }
                        }
                        experimentCatalog.update(ExperimentCatalogModelType.EXPERIMENT, experiment, airavataExperimentId);
                        logger.debug(airavataExperimentId, ""Successfully updated experiment {} "", experiment.getExperimentName());
                        break;
                    default:
                        logger.error(airavataExperimentId, ""Error while updating experiment. Update experiment is only valid for experiments "" +
                                ""with status CREATED, VALIDATED, CANCELLED, FAILED and UNKNOWN. Make sure the given "" +
                                ""experiment is in one of above statuses... "");
                        AiravataSystemException exception = new AiravataSystemException();
                        exception.setAiravataErrorType(AiravataErrorType.INTERNAL_ERROR);
                        exception.setMessage(""Error while updating experiment. Update experiment is only valid for experiments "" +
                                ""with status CREATED, VALIDATED, CANCELLED, FAILED and UNKNOWN. Make sure the given "" +
                                ""experiment is in one of above statuses... "");
                        throw exception;
                }
            }
        } catch (RegistryException e) {
            logger.error(airavataExperimentId, ""Error while updating experiment"", e);
            RegistryServiceException exception = new RegistryServiceException();
            exception.setMessage(""Error while updating experiment. More info : "" + e.getMessage());
            throw exception;
        } catch (AppCatalogException e) {
            logger.error(airavataExperimentId, ""Error while updating experiment"", e);
            RegistryServiceException exception = new RegistryServiceException();
            exception.setMessage(""Error while updating experiment. More info : "" + e.getMessage());
            throw exception;
        }
    }
",feature envy
502,"@JsonSerialize(include = JsonSerialize.Inclusion.NON_NULL)
@JsonIgnoreProperties(ignoreUnknown = true)
public class SchedulerInfo {
    private String type;
    private double capacity;
    private double usedCapacity;
    private double maxCapacity;
    private String queueName;
    private Queues queues;

    public Queues getQueues() {
        return queues;
    }

    public void setQueues(Queues queues) {
        this.queues = queues;
    }


    public double getUsedCapacity() {
        return usedCapacity;
    }

    public void setUsedCapacity(double usedCapacity) {
        this.usedCapacity = usedCapacity;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public double getCapacity() {
        return capacity;
    }

    public void setCapacity(double capacity) {
        this.capacity = capacity;
    }

    public double getMaxCapacity() {
        return maxCapacity;
    }

    public void setMaxCapacity(double maxCapacity) {
        this.maxCapacity = maxCapacity;
    }

    public String getQueueName() {
        return queueName;
    }

    public void setQueueName(String queueName) {
        this.queueName = queueName;
    }

}
",data class
1332,"  private void validateArrayStep(String arrStep)
    throws QueryException
  {
    boolean wildAllowed  = true;    // * is allowed initially
    boolean digitAllowed = true;    // Digit is allowed as next char
    boolean commaAllowed = false;   // Comma is allowed as next char

    boolean afterDigit    = false;  // Last non-space was a digit
    boolean toAllowed     = false;  // Any space after digit allows ""to""
    boolean afterTo       = false;  // After ""to"" expecting range end
    boolean toInProgress  = false;  // Prior char was 't' in ""to""
    boolean spaceRequired = false;  // A whitespace is required (after ""to"")
    boolean digitRequired = false;  // Digit required after comma or ""to""

    for (int i = 1; i < arrStep.length() - 1; ++i)
    {
      char currentChar = arrStep.charAt(i);

      if (currentChar == '*')
      {
        if (!wildAllowed)
          throwArrayException(arrStep);

        wildAllowed  = false;  // We've seen the only allowed wildcard
        digitAllowed = false;  // Only whitespace is allowed afterward
      }
      else if (currentChar == ',')
      {
        if (!commaAllowed)
          throwArrayException(arrStep);

        commaAllowed  = false;
        toAllowed     = false;
        afterDigit    = false;
        afterTo       = false;
        digitRequired = true;  // Next non-space must be a digit
      }
      else if (""0123456789"".indexOf(currentChar) >= 0)
      {
        if (!digitAllowed)
          throwArrayException(arrStep);

        wildAllowed   = false; // Wildcard no longer allowed
        commaAllowed  = true;
        afterDigit    = true;
        digitRequired = false;
      }
      else if ("" \t\n\r"".indexOf(currentChar) >= 0)
      {
        // Whitespace not allowed when parsing ""to""
        if (toInProgress)
          throwArrayException(arrStep);

        if (afterDigit)
        {
          // Last non-space was a digit - next non-space is ""to"" or comma
          digitAllowed = false;
          toAllowed    = !afterTo;
          commaAllowed = true;
        }
        else if (spaceRequired)
        {
          // This is the whitespace required after ""to""
          digitAllowed  = true;
          spaceRequired = false;
          digitRequired = true;  // At least one digit must follow
        }
      }
      else if (currentChar == 't')
      {
        if (!toAllowed)
          throwArrayException(arrStep);

        toInProgress = true;  // Next char must be the 'o' in ""to""
        commaAllowed = false;
        afterDigit   = false;
      }
      else if (currentChar == 'o')
      {
        if (!toInProgress)
          throwArrayException(arrStep);

        toInProgress  = false;
        toAllowed     = false;
        afterTo       = true;
        spaceRequired = true;  // ""to"" must be followed by whitespace
      }
      else
      {
        // Invalid character
        throwArrayException(arrStep);
      }
    }

    // Empty array or only whitespace found
    if (wildAllowed)
      throwArrayException(arrStep);

    // Incomplete ""to"" or comma sequence at end of subscript
    if (toInProgress || spaceRequired || digitRequired)
      throwArrayException(arrStep);
  }
",long method
4,"public class SparkVersion {
  private static final Logger logger = LoggerFactory.getLogger(SparkVersion.class);

  public static final SparkVersion SPARK_1_6_0 = SparkVersion.fromVersionString(""1.6.0"");

  public static final SparkVersion SPARK_2_0_0 = SparkVersion.fromVersionString(""2.0.0"");
  public static final SparkVersion SPARK_2_3_0 = SparkVersion.fromVersionString(""2.3.0"");
  public static final SparkVersion SPARK_2_3_1 = SparkVersion.fromVersionString(""2.3.1"");
  public static final SparkVersion SPARK_2_4_0 = SparkVersion.fromVersionString(""2.4.0"");
  public static final SparkVersion SPARK_3_0_0 = SparkVersion.fromVersionString(""3.0.0"");

  public static final SparkVersion MIN_SUPPORTED_VERSION =  SPARK_1_6_0;
  public static final SparkVersion UNSUPPORTED_FUTURE_VERSION = SPARK_3_0_0;

  private int version;
  private int majorVersion;
  private int minorVersion;
  private int patchVersion;
  private String versionString;

  SparkVersion(String versionString) {
    this.versionString = versionString;

    try {
      int pos = versionString.indexOf('-');

      String numberPart = versionString;
      if (pos > 0) {
        numberPart = versionString.substring(0, pos);
      }

      String versions[] = numberPart.split(""\\."");
      this.majorVersion = Integer.parseInt(versions[0]);
      this.minorVersion = Integer.parseInt(versions[1]);
      this.patchVersion = Integer.parseInt(versions[2]);
      // version is always 5 digits. (e.g. 2.0.0 -> 20000, 1.6.2 -> 10602)
      version = Integer.parseInt(String.format(""%d%02d%02d"", majorVersion, minorVersion, patchVersion));
    } catch (Exception e) {
      logger.error(""Can not recognize Spark version "" + versionString +
          "". Assume it's a future release"", e);

      // assume it is future release
      version = 99999;
    }
  }

  public int toNumber() {
    return version;
  }

  public String toString() {
    return versionString;
  }

  public boolean isUnsupportedVersion() {
    return olderThan(MIN_SUPPORTED_VERSION) || newerThanEquals(UNSUPPORTED_FUTURE_VERSION);
  }

  public static SparkVersion fromVersionString(String versionString) {
    return new SparkVersion(versionString);
  }

  public boolean isSpark2() {
    return this.newerThanEquals(SPARK_2_0_0);
  }

  public boolean isSecretSocketSupported() {
    return this.newerThanEquals(SparkVersion.SPARK_2_4_0) ||
            this.newerThanEqualsPatchVersion(SPARK_2_3_1) ||
            this.newerThanEqualsPatchVersion(SparkVersion.fromVersionString(""2.2.2"")) ||
            this.newerThanEqualsPatchVersion(SparkVersion.fromVersionString(""2.1.3""));
  }

  public boolean equals(Object versionToCompare) {
    return version == ((SparkVersion) versionToCompare).version;
  }

  public boolean newerThan(SparkVersion versionToCompare) {
    return version > versionToCompare.version;
  }

  public boolean newerThanEquals(SparkVersion versionToCompare) {
    return version >= versionToCompare.version;
  }

  public boolean newerThanEqualsPatchVersion(SparkVersion versionToCompare) {
    return majorVersion == versionToCompare.majorVersion &&
            minorVersion == versionToCompare.minorVersion &&
            patchVersion >= versionToCompare.patchVersion;
  }

  public boolean olderThan(SparkVersion versionToCompare) {
    return version < versionToCompare.version;
  }

  public boolean olderThanEquals(SparkVersion versionToCompare) {
    return version <= versionToCompare.version;
  }
}
",data class
1379,"public class AssemblerConfig {

	// Private Member Variables ------------------------------------------------

	/** The portlet app descriptor, which is usually WEB-INF/portlet.xml. */
    private File portletDescriptor;

    /** The webapp descriptor to assemble, which is usually WEB-INF/web.xml. */
    private File webappDescriptor;

    /** The assemble destination, which points to the assembled WAR file. */
    private File destination;

    /** The class of the servlet that will handle portlet requests */
    private String dispatchServletClass;

    /** The source archive to assemble */
    private File source;
    
    /** Assembler sink buffer size.  Defaults to 4096 bytes. */
    private int assemblerSinkBuflen = 1024 * 4; // 4kb

    // Public Methods ----------------------------------------------------------

    public File getPortletDescriptor() {
        return portletDescriptor;
    }

    public void setPortletDescriptor(File portletDescriptor) {
        this.portletDescriptor = portletDescriptor;
    }

    public File getWebappDescriptor() {
        return webappDescriptor;
    }

    public void setWebappDescriptor(File webappDescriptor) {
        this.webappDescriptor = webappDescriptor;
    }

    public File getDestination() {
        return destination;
    }

    public void setDestination(File destination) {
        this.destination = destination;
    }

    public String getDispatchServletClass() {
        return dispatchServletClass;
    }

    public void setDispatchServletClass(String dispatchServletClass) {
        this.dispatchServletClass = dispatchServletClass;
    }

    /**
     * @deprecated use <code>setSource(File)</code> instead.
     */
    public void setWarSource(File source) {
        this.source = source;
    }
    
    public void setSource(File source) {
        this.source = source;
    }
    
    /**
     * @deprecated use <code>getSource()</code> instead.
     */
    public File getWarSource() {
        return source;
    }
    
    public File getSource() {
        return source;
    }
    
    public int getAssemblerSinkBuflen() {
        return assemblerSinkBuflen;
    }
    
    public void setAssemblerSinkBuflen(int buflen) {
        this.assemblerSinkBuflen = buflen;
    }
}
",data class
43,"@Generated(""com.amazonaws:aws-java-sdk-code-generator"")
public class ListKeysResult extends com.ibm.cloud.objectstorage.AmazonWebServiceResult<com.ibm.cloud.objectstorage.ResponseMetadata> implements Serializable, Cloneable {

    /**
     * <p>
     * A list of keys.
     * </p>
     */
    private com.ibm.cloud.objectstorage.internal.SdkInternalList<KeyListEntry> keys;
    /**
     * <p>
     * When <code>Truncated</code> is true, this element is present and contains the value to use for the
     * <code>Marker</code> parameter in a subsequent request.
     * </p>
     */
    private String nextMarker;
    /**
     * <p>
     * A flag that indicates whether there are more items in the list. When this value is true, the list in this
     * response is truncated. To retrieve more items, pass the value of the <code>NextMarker</code> element in this
     * response to the <code>Marker</code> parameter in a subsequent request.
     * </p>
     */
    private Boolean truncated;

    /**
     * <p>
     * A list of keys.
     * </p>
     * 
     * @return A list of keys.
     */

    public java.util.List<KeyListEntry> getKeys() {
        if (keys == null) {
            keys = new com.ibm.cloud.objectstorage.internal.SdkInternalList<KeyListEntry>();
        }
        return keys;
    }

    /**
     * <p>
     * A list of keys.
     * </p>
     * 
     * @param keys
     *        A list of keys.
     */

    public void setKeys(java.util.Collection<KeyListEntry> keys) {
        if (keys == null) {
            this.keys = null;
            return;
        }

        this.keys = new com.ibm.cloud.objectstorage.internal.SdkInternalList<KeyListEntry>(keys);
    }

    /**
     * <p>
     * A list of keys.
     * </p>
     * <p>
     * <b>NOTE:</b> This method appends the values to the existing list (if any). Use
     * {@link #setKeys(java.util.Collection)} or {@link #withKeys(java.util.Collection)} if you want to override the
     * existing values.
     * </p>
     * 
     * @param keys
     *        A list of keys.
     * @return Returns a reference to this object so that method calls can be chained together.
     */

    public ListKeysResult withKeys(KeyListEntry... keys) {
        if (this.keys == null) {
            setKeys(new com.ibm.cloud.objectstorage.internal.SdkInternalList<KeyListEntry>(keys.length));
        }
        for (KeyListEntry ele : keys) {
            this.keys.add(ele);
        }
        return this;
    }

    /**
     * <p>
     * A list of keys.
     * </p>
     * 
     * @param keys
     *        A list of keys.
     * @return Returns a reference to this object so that method calls can be chained together.
     */

    public ListKeysResult withKeys(java.util.Collection<KeyListEntry> keys) {
        setKeys(keys);
        return this;
    }

    /**
     * <p>
     * When <code>Truncated</code> is true, this element is present and contains the value to use for the
     * <code>Marker</code> parameter in a subsequent request.
     * </p>
     * 
     * @param nextMarker
     *        When <code>Truncated</code> is true, this element is present and contains the value to use for the
     *        <code>Marker</code> parameter in a subsequent request.
     */

    public void setNextMarker(String nextMarker) {
        this.nextMarker = nextMarker;
    }

    /**
     * <p>
     * When <code>Truncated</code> is true, this element is present and contains the value to use for the
     * <code>Marker</code> parameter in a subsequent request.
     * </p>
     * 
     * @return When <code>Truncated</code> is true, this element is present and contains the value to use for the
     *         <code>Marker</code> parameter in a subsequent request.
     */

    public String getNextMarker() {
        return this.nextMarker;
    }

    /**
     * <p>
     * When <code>Truncated</code> is true, this element is present and contains the value to use for the
     * <code>Marker</code> parameter in a subsequent request.
     * </p>
     * 
     * @param nextMarker
     *        When <code>Truncated</code> is true, this element is present and contains the value to use for the
     *        <code>Marker</code> parameter in a subsequent request.
     * @return Returns a reference to this object so that method calls can be chained together.
     */

    public ListKeysResult withNextMarker(String nextMarker) {
        setNextMarker(nextMarker);
        return this;
    }

    /**
     * <p>
     * A flag that indicates whether there are more items in the list. When this value is true, the list in this
     * response is truncated. To retrieve more items, pass the value of the <code>NextMarker</code> element in this
     * response to the <code>Marker</code> parameter in a subsequent request.
     * </p>
     * 
     * @param truncated
     *        A flag that indicates whether there are more items in the list. When this value is true, the list in this
     *        response is truncated. To retrieve more items, pass the value of the <code>NextMarker</code> element in
     *        this response to the <code>Marker</code> parameter in a subsequent request.
     */

    public void setTruncated(Boolean truncated) {
        this.truncated = truncated;
    }

    /**
     * <p>
     * A flag that indicates whether there are more items in the list. When this value is true, the list in this
     * response is truncated. To retrieve more items, pass the value of the <code>NextMarker</code> element in this
     * response to the <code>Marker</code> parameter in a subsequent request.
     * </p>
     * 
     * @return A flag that indicates whether there are more items in the list. When this value is true, the list in this
     *         response is truncated. To retrieve more items, pass the value of the <code>NextMarker</code> element in
     *         this response to the <code>Marker</code> parameter in a subsequent request.
     */

    public Boolean getTruncated() {
        return this.truncated;
    }

    /**
     * <p>
     * A flag that indicates whether there are more items in the list. When this value is true, the list in this
     * response is truncated. To retrieve more items, pass the value of the <code>NextMarker</code> element in this
     * response to the <code>Marker</code> parameter in a subsequent request.
     * </p>
     * 
     * @param truncated
     *        A flag that indicates whether there are more items in the list. When this value is true, the list in this
     *        response is truncated. To retrieve more items, pass the value of the <code>NextMarker</code> element in
     *        this response to the <code>Marker</code> parameter in a subsequent request.
     * @return Returns a reference to this object so that method calls can be chained together.
     */

    public ListKeysResult withTruncated(Boolean truncated) {
        setTruncated(truncated);
        return this;
    }

    /**
     * <p>
     * A flag that indicates whether there are more items in the list. When this value is true, the list in this
     * response is truncated. To retrieve more items, pass the value of the <code>NextMarker</code> element in this
     * response to the <code>Marker</code> parameter in a subsequent request.
     * </p>
     * 
     * @return A flag that indicates whether there are more items in the list. When this value is true, the list in this
     *         response is truncated. To retrieve more items, pass the value of the <code>NextMarker</code> element in
     *         this response to the <code>Marker</code> parameter in a subsequent request.
     */

    public Boolean isTruncated() {
        return this.truncated;
    }

    /**
     * Returns a string representation of this object; useful for testing and debugging.
     *
     * @return A string representation of this object.
     *
     * @see java.lang.Object#toString()
     */
    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(""{"");
        if (getKeys() != null)
            sb.append(""Keys: "").append(getKeys()).append("","");
        if (getNextMarker() != null)
            sb.append(""NextMarker: "").append(getNextMarker()).append("","");
        if (getTruncated() != null)
            sb.append(""Truncated: "").append(getTruncated());
        sb.append(""}"");
        return sb.toString();
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;

        if (obj instanceof ListKeysResult == false)
            return false;
        ListKeysResult other = (ListKeysResult) obj;
        if (other.getKeys() == null ^ this.getKeys() == null)
            return false;
        if (other.getKeys() != null && other.getKeys().equals(this.getKeys()) == false)
            return false;
        if (other.getNextMarker() == null ^ this.getNextMarker() == null)
            return false;
        if (other.getNextMarker() != null && other.getNextMarker().equals(this.getNextMarker()) == false)
            return false;
        if (other.getTruncated() == null ^ this.getTruncated() == null)
            return false;
        if (other.getTruncated() != null && other.getTruncated().equals(this.getTruncated()) == false)
            return false;
        return true;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int hashCode = 1;

        hashCode = prime * hashCode + ((getKeys() == null) ? 0 : getKeys().hashCode());
        hashCode = prime * hashCode + ((getNextMarker() == null) ? 0 : getNextMarker().hashCode());
        hashCode = prime * hashCode + ((getTruncated() == null) ? 0 : getTruncated().hashCode());
        return hashCode;
    }

    @Override
    public ListKeysResult clone() {
        try {
            return (ListKeysResult) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new IllegalStateException(""Got a CloneNotSupportedException from Object.clone() "" + ""even though we're Cloneable!"", e);
        }
    }

}
",data class
1445,"    @Override
    public java.util.concurrent.Future<GenerateAutonomousDatabaseWalletResponse>
            generateAutonomousDatabaseWallet(
                    final GenerateAutonomousDatabaseWalletRequest request,
                    final com.oracle.bmc.responses.AsyncHandler<
                                    GenerateAutonomousDatabaseWalletRequest,
                                    GenerateAutonomousDatabaseWalletResponse>
                            handler) {
        LOG.trace(""Called async generateAutonomousDatabaseWallet"");
        final GenerateAutonomousDatabaseWalletRequest interceptedRequest =
                GenerateAutonomousDatabaseWalletConverter.interceptRequest(request);
        final com.oracle.bmc.http.internal.WrappedInvocationBuilder ib =
                GenerateAutonomousDatabaseWalletConverter.fromRequest(client, interceptedRequest);
        final com.google.common.base.Function<
                        javax.ws.rs.core.Response, GenerateAutonomousDatabaseWalletResponse>
                transformer = GenerateAutonomousDatabaseWalletConverter.fromResponse();

        com.oracle.bmc.responses.AsyncHandler<
                        GenerateAutonomousDatabaseWalletRequest,
                        GenerateAutonomousDatabaseWalletResponse>
                handlerToUse = handler;
        if (handler != null
                && this.authenticationDetailsProvider
                        instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            handlerToUse =
                    new com.oracle.bmc.util.internal.RefreshAuthTokenWrappingAsyncHandler<
                            GenerateAutonomousDatabaseWalletRequest,
                            GenerateAutonomousDatabaseWalletResponse>(
                            (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                                    this.authenticationDetailsProvider,
                            handler) {
                        @Override
                        public void retryCall() {
                            final com.oracle.bmc.util.internal.Consumer<javax.ws.rs.core.Response>
                                    onSuccess =
                                            new com.oracle.bmc.http.internal.SuccessConsumer<>(
                                                    this, transformer, interceptedRequest);
                            final com.oracle.bmc.util.internal.Consumer<Throwable> onError =
                                    new com.oracle.bmc.http.internal.ErrorConsumer<>(
                                            this, interceptedRequest);
                            client.post(
                                    ib,
                                    interceptedRequest.getGenerateAutonomousDatabaseWalletDetails(),
                                    interceptedRequest,
                                    onSuccess,
                                    onError);
                        }
                    };
        }

        final com.oracle.bmc.util.internal.Consumer<javax.ws.rs.core.Response> onSuccess =
                (handler == null)
                        ? null
                        : new com.oracle.bmc.http.internal.SuccessConsumer<>(
                                handlerToUse, transformer, interceptedRequest);
        final com.oracle.bmc.util.internal.Consumer<Throwable> onError =
                (handler == null)
                        ? null
                        : new com.oracle.bmc.http.internal.ErrorConsumer<>(
                                handlerToUse, interceptedRequest);

        java.util.concurrent.Future<javax.ws.rs.core.Response> responseFuture =
                client.post(
                        ib,
                        interceptedRequest.getGenerateAutonomousDatabaseWalletDetails(),
                        interceptedRequest,
                        onSuccess,
                        onError);

        if (this.authenticationDetailsProvider
                instanceof com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider) {
            return new com.oracle.bmc.util.internal.RefreshAuthTokenTransformingFuture<
                    javax.ws.rs.core.Response, GenerateAutonomousDatabaseWalletResponse>(
                    responseFuture,
                    transformer,
                    (com.oracle.bmc.auth.RefreshableOnNotAuthenticatedProvider)
                            this.authenticationDetailsProvider,
                    new com.google.common.base.Supplier<
                            java.util.concurrent.Future<javax.ws.rs.core.Response>>() {
                        @Override
                        public java.util.concurrent.Future<javax.ws.rs.core.Response> get() {
                            return client.post(
                                    ib,
                                    interceptedRequest.getGenerateAutonomousDatabaseWalletDetails(),
                                    interceptedRequest,
                                    onSuccess,
                                    onError);
                        }
                    });
        } else {
            return new com.oracle.bmc.util.internal.TransformingFuture<>(
                    responseFuture, transformer);
        }
    }
",long method
708,"public class EventAdapterGenerator
{
  public static AdapterClassLoader ldr = new AdapterClassLoader();
  static Class  EVENTLISTENER          = null;
  static String CLASSPACKAGE           = ""org/apache/bsf/util/event/adapters/"";
  static String WRITEDIRECTORY         = null;

  // starting 8 bytes of all Java Class files
  static byte   CLASSHEADER[];
  // constant pool items found in all event adapters
  static short  BASECPCOUNT; // number of cp items + 1 ( cp item # 0 reserved for JVM )
  static byte   BASECP[];    //
  // some bytes in the middle of the class file (see below)
  static byte   FIXEDCLASSBYTES[];
  // the initialization method, noargs constructor
  static byte   INITMETHOD[];

  private static BSF_Log logger=null;

  /* The static initializer */
  static
  {
    // logger = LogFactory.getLog((org.apache.bsf.util.event.generator.EventAdapterGenerator.class).getName());
        logger = BSF_LogFactory.getLog((org.apache.bsf.util.event.generator.EventAdapterGenerator.class).getName());

    String USERCLASSPACKAGE = System.getProperty(""DynamicEventClassPackage"",
                                                 """");

    if (!USERCLASSPACKAGE.equals(""""))
    {
      CLASSPACKAGE = USERCLASSPACKAGE;
    }

    if(CLASSPACKAGE.length() > 0 )
    {
      CLASSPACKAGE = CLASSPACKAGE.replace('\\','/');
      if(!CLASSPACKAGE.endsWith(""/""))
      { CLASSPACKAGE = CLASSPACKAGE+""/""; }
    }
    WRITEDIRECTORY = System.getProperty(""DynamicEventClassWriteDirectory"",CLASSPACKAGE);
    if(WRITEDIRECTORY.length() > 0 )
    {
      WRITEDIRECTORY = WRITEDIRECTORY.replace('\\','/');
      if(!WRITEDIRECTORY.endsWith(""/""))
      { WRITEDIRECTORY = WRITEDIRECTORY+""/""; }
    }
    try
    // { EVENTLISTENER = Class.forName(""java.util.EventListener""); }
    {
            // EVENTLISTENER = Thread.currentThread().getContextClassLoader().loadClass (""java.util.EventListener""); // rgf, 2006-01-05

            // rgf, 20070917: first try context class loader, then BSFManager's defining class loader
            EVENTLISTENER=null;
            ClassLoader tccl=Thread.currentThread().getContextClassLoader();

            if (tccl!=null)
            {
                try {
                     EVENTLISTENER = tccl.loadClass (""java.util.EventListener"");
                }
                catch(ClassNotFoundException ex01)
                {}
            }

            if (EVENTLISTENER==null)    // did not work, try to load it via the definedClassLoader
            {
                EVENTLISTENER = BSFManager.getDefinedClassLoader().loadClass (""java.util.EventListener"");
            }

        }
    catch(ClassNotFoundException ex)
    {
            System.err.println(ex.getMessage());
            ex.printStackTrace();
        }


    // start of the Java Class File
    CLASSHEADER = ByteUtility.addBytes(CLASSHEADER,(byte)0xCA);  // magic
    CLASSHEADER = ByteUtility.addBytes(CLASSHEADER,(byte)0xFE);  // magic
    CLASSHEADER = ByteUtility.addBytes(CLASSHEADER,(byte)0xBA);  // magic
    CLASSHEADER = ByteUtility.addBytes(CLASSHEADER,(byte)0xBE);  // magic
    CLASSHEADER = ByteUtility.addBytes(CLASSHEADER,(short)3);    // minor version
    CLASSHEADER = ByteUtility.addBytes(CLASSHEADER,(short)45);   // major version

    // Start the constant pool for base items in all event adapter classes
    BASECPCOUNT = 17; // number of cp items + 1 ( cp item # 0 reserved for JVM )

    // cp item 01
    BASECP = Bytecode.addUtf8(BASECP,""()V"");

    // cp item 02
    BASECP = Bytecode.addUtf8(BASECP,""<init>"");

    // cp item 03
    BASECP = Bytecode.addUtf8(BASECP,""Code"");

    // cp item 04
    BASECP = Bytecode.addUtf8(BASECP,""eventProcessor"");

    // cp item 05
    BASECP = Bytecode.addUtf8(BASECP,""java/lang/Object"");

    // cp item 06
    BASECP = Bytecode.addUtf8(BASECP,""org/apache/bsf/util/event/EventAdapterImpl"");

    // cp item 07
    BASECP = Bytecode.addUtf8(BASECP,""org/apache/bsf/util/event/EventProcessor"");

    // cp item 08
    BASECP = Bytecode.addUtf8(BASECP,""(Ljava/lang/String;[Ljava/lang/Object;)V"");

    // cp item 09
    BASECP = Bytecode.addUtf8(BASECP,""Lorg/apache/bsf/util/event/EventProcessor;"");

    // cp item 10
    BASECP = Bytecode.addClass(BASECP,(short)5); // Class ""java/lang/Object""

    // cp item 11
    BASECP = Bytecode.addClass(BASECP,(short)6); // Class ""org/apache/bsf/util/event/EventAdapterImpl""

    // cp item 12
    BASECP = Bytecode.addClass(BASECP,(short)7); // Class ""org/apache/bsf/util/event/EventProcessor""

    // cp item 13
    BASECP = Bytecode.addNameAndType(BASECP,(short)2,(short)1); // ""<init>"" ""()V""

    // cp item 14
    BASECP = Bytecode.addNameAndType(BASECP,(short)4,(short)9); // ""eventProcessor"" ""Lorg/apache/bsf/util/event/EventProcessor;""

    // cp item 15
    BASECP = Bytecode.addFieldRef(BASECP,(short)11,(short)14);

    // cp item 16
    BASECP = Bytecode.addMethodRef(BASECP,(short)11,(short)13);

    // fixed bytes in middle of class file
    FIXEDCLASSBYTES = ByteUtility.addBytes(FIXEDCLASSBYTES,(short)0x21); // access_flags        (fixed)
    FIXEDCLASSBYTES = ByteUtility.addBytes(FIXEDCLASSBYTES,(short)20);   // this_class          (fixed)
    FIXEDCLASSBYTES = ByteUtility.addBytes(FIXEDCLASSBYTES,(short)11);   // super_class         (fixed)
    FIXEDCLASSBYTES = ByteUtility.addBytes(FIXEDCLASSBYTES,(short)1);    // interface_count     (fixed)
    FIXEDCLASSBYTES = ByteUtility.addBytes(FIXEDCLASSBYTES,(short)19);   // interfaces          (fixed)
    FIXEDCLASSBYTES = ByteUtility.addBytes(FIXEDCLASSBYTES,(short)0);    // field_count         (fixed)

    // initialization method, constructor
    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)1);              // access_flags
    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)2);              // name_index ""<init>""
    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)1);              // descriptor_index ""()V""
    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)1);              // attribute_count
    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)3);              // attribute_name_index ""Code""
    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(long)17);              // attribute_length
    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)1);              // max_stack
    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)1);              // max_locals
    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(long)5);               // code_length
    //code
    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(byte)0x2A);            // aload_0
    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(byte)0xB7);            // invokespecial
    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)16);             // method_ref index
    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(byte)0xB1);            // return
    // exception table
    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)0);              // exception_table_length
    INITMETHOD = ByteUtility.addBytes(INITMETHOD,(short)0);              // attributes_count

  }

  /* methods that take an EventListener Class Type to create an EventAdapterClass */
  public static Class makeEventAdapterClass(Class listenerType,boolean writeClassFile)
  {
      logger.debug(""EventAdapterGenerator"");

        if( EVENTLISTENER.isAssignableFrom(listenerType) )
    {
      boolean exceptionable    = false;
      boolean nonExceptionable = false;
      byte    constantPool[]   = null;
      short   cpBaseIndex;
      short   cpCount          = 0;
      short   cpExceptionBaseIndex;
      short   exceptionableCount;
      short   nonExceptionableCount;

      /* Derive Names */
      String listenerTypeName      = listenerType.getName();
          logger.debug(""ListenerTypeName: ""+listenerTypeName);
      String adapterClassName      =
        CLASSPACKAGE+
        (listenerTypeName.endsWith(""Listener"")
         ? listenerTypeName.substring(0, listenerTypeName.length() - 8)
         : listenerTypeName).replace('.', '_') +
        ""Adapter"";
      String finalAdapterClassName = adapterClassName;
      Class  cached                = null;
      int    suffixIndex           = 0;

      do
      {
        if (null != (cached = ldr.getLoadedClass(finalAdapterClassName)))
        {
                    logger.debug(""cached:  ""+cached);
          try
          {
            if (!listenerType.isAssignableFrom(cached))
              finalAdapterClassName = adapterClassName + ""_"" + suffixIndex++;
            else
              return cached;
          }
          catch(VerifyError ex)
          {
                      System.err.println(ex.getMessage());
                      ex.printStackTrace();
                      return cached;
          }
        }
      }
      while (cached != null);

      String eventListenerName = listenerTypeName.replace('.', '/');

      /* method stuff */
      java.lang.reflect.Method lms[] = listenerType.getMethods();

      /* ****************************************************************************************** */
      // Listener interface
      // Class name
      cpCount += 4;

      // cp item 17
      constantPool = Bytecode.addUtf8(constantPool,eventListenerName);

      // cp item 18
      constantPool = Bytecode.addUtf8(constantPool,finalAdapterClassName);

      // cp item 19
      constantPool = Bytecode.addClass(constantPool,(short)17);

      // cp item 20
      constantPool = Bytecode.addClass(constantPool,(short)18);

      // do we have nonExceptionalble event, exceptionable or both
      for (int i = 0 ; i < lms.length ; ++i)
      {
        Class exceptionTypes[] = lms[i].getExceptionTypes();
        if( 0 < exceptionTypes.length)
        { exceptionable = true; }
        else
        { nonExceptionable = true; }
      }/* End for*/

      /* ****************************************************************************************** */
      // optional inclusion of nonexceptional events affects exceptional events indices

      nonExceptionableCount = 0;
      if(nonExceptionable)
      {
        nonExceptionableCount = 3;
        cpCount += nonExceptionableCount;

        // cp item 21
        constantPool = Bytecode.addUtf8(constantPool,""processEvent"");

        // cp item 22
        constantPool = Bytecode.addNameAndType(constantPool,(short)21,(short)8);


        // cp item 23
        constantPool = Bytecode.addInterfaceMethodRef(constantPool,(short)12,(short)22);
      }

      /* ****************************************************************************************** */
      // optional inclusion of exceptional events affects CP Items which follow for specific methods

      exceptionableCount = 0;
      if(exceptionable)
      {
        int classIndex = BASECPCOUNT + cpCount + 1;
        int nameIndex  = BASECPCOUNT + cpCount + 0;
        int natIndex   = BASECPCOUNT + cpCount + 3;

        exceptionableCount = 5;
        cpCount += exceptionableCount;

        // cp item 24 or 21
        constantPool = Bytecode.addUtf8(constantPool,""processExceptionableEvent"");

        // cp item 25 or 22
        constantPool = Bytecode.addUtf8(constantPool,""java/lang/Exception"");

        // cp item 26 or 23
        constantPool = Bytecode.addClass(constantPool,(short)classIndex);

        // cp item 27 or 24
        constantPool = Bytecode.addNameAndType(constantPool,(short)nameIndex,(short)8);

        // cp item 28 or 25
        constantPool = Bytecode.addInterfaceMethodRef(constantPool,(short)12,(short)natIndex);

      }

      // base index for method cp references
      cpBaseIndex = (short)(BASECPCOUNT + cpCount);
          logger.debug(""cpBaseIndex: "" + cpBaseIndex);

      for (int i = 0 ; i < lms.length ; ++i)
      {
        String eventMethodName = lms[i].getName();
        String eventName = lms[i].getParameterTypes()[0].getName().replace('.','/');
        cpCount += 3;
        // cp items for event methods
        constantPool = Bytecode.addUtf8(constantPool,eventMethodName);
        constantPool = Bytecode.addUtf8(constantPool,(""(L"" + eventName + "";)V""));
        constantPool = Bytecode.addString(constantPool,(short)(BASECPCOUNT+cpCount-3));
      }/* End for*/

      boolean propertyChangeFlag[] = new boolean[lms.length];
      int cpIndexPCE = 0;
      for (int i = 0 ; i < lms.length ; ++i)
      {
        String eventName = lms[i].getParameterTypes()[0].getName().replace('.','/');
        // cp items for PropertyChangeEvent special handling
        if(eventName.equalsIgnoreCase(""java/beans/PropertyChangeEvent""))
        {
          propertyChangeFlag[i] = true;
          if( 0 == cpIndexPCE )
          {
            constantPool = Bytecode.addUtf8(constantPool,eventName);
            constantPool = Bytecode.addUtf8(constantPool,""getPropertyName"");
            constantPool = Bytecode.addUtf8(constantPool,""()Ljava/lang/String;"");
            constantPool = Bytecode.addClass(constantPool,(short)(BASECPCOUNT + cpCount));
            constantPool = Bytecode.addNameAndType(constantPool,
                                                   (short)(BASECPCOUNT + cpCount + 1),
                                                   (short)(BASECPCOUNT + cpCount + 2));
            constantPool = Bytecode.addMethodRef(constantPool,
                                                 (short)(BASECPCOUNT + cpCount + 3),
                                                 (short)(BASECPCOUNT + cpCount + 4));
            cpCount += 6;
            cpIndexPCE = BASECPCOUNT + cpCount - 1;

          }
        }
        else
        { propertyChangeFlag[i] = false; }
      }/* End for*/

      cpExceptionBaseIndex = (short)(BASECPCOUNT + cpCount);
          logger.debug(""cpExceptionBaseIndex: "" + cpExceptionBaseIndex);

      int excpIndex[][] = new int[lms.length][];
      for (int i = 0 ; i < lms.length ; ++i)
      {
        Class exceptionTypes[] = lms[i].getExceptionTypes();
        excpIndex[i] = new int[exceptionTypes.length];
        for ( int j = 0 ; j < exceptionTypes.length ; j++)
        {
          constantPool = Bytecode.addUtf8(constantPool,exceptionTypes[j].getName().replace('.', '/'));
          constantPool = Bytecode.addClass(constantPool,(short)(BASECPCOUNT+cpCount));
          excpIndex[i][j] = BASECPCOUNT + cpCount + 1;
          cpCount += 2;
        }
      }/* End for*/
      /* end constant pool */

      /* ************************************************************************************************ */
      // put the Class byte array together

      /* start */
      byte newClass[] = CLASSHEADER;                                   // magic, version      (fixed)
      short count = (short)(BASECPCOUNT + cpCount);
      newClass = ByteUtility.addBytes(newClass,count);                 // constant_pool_count (variable)
      newClass = ByteUtility.addBytes(newClass,BASECP);                // constant_pool       (fixed)
      newClass = ByteUtility.addBytes(newClass,constantPool);          // constant_pool       (variable)
      newClass = ByteUtility.addBytes(newClass,FIXEDCLASSBYTES);       // see FIXEDCLASSBYTES (fixed)
      newClass = ByteUtility.addBytes(newClass,(short)(lms.length+1)); // method_count        (variable)
      newClass = ByteUtility.addBytes(newClass,INITMETHOD);            // constructor <init>  (fixed)
      // methods

      /* ****************************************************************************************** */
      /* loop over listener methods from listenerType */
      for (int i = 0 ; i < lms.length ; ++i)
      {
        newClass = ByteUtility.addBytes(newClass,(short)1);                   // access_flags             (fixed)
        newClass = ByteUtility.addBytes(newClass,(short)(cpBaseIndex+3*i+0)); // name_index               (variable)
        newClass = ByteUtility.addBytes(newClass,(short)(cpBaseIndex+3*i+1)); // descriptor_index         (variable)
        newClass = ByteUtility.addBytes(newClass,(short)1);                   // attribute_count          (fixed)
        newClass = ByteUtility.addBytes(newClass,(short)3);                   // attribute_name_index code(fixed)

        // Code Attribute Length
        int length = 32;
        if( 0 < excpIndex[i].length )
        { length += 5 + 8 * ( 1 + excpIndex[i].length ); }
        if(propertyChangeFlag[i])
        { length += 2; }
        newClass = ByteUtility.addBytes(newClass,(long)length);               // attribute_length         (variable)

        // start code attribute
        newClass = ByteUtility.addBytes(newClass,(short)6);                   // max_stack                (fixed)
        newClass = ByteUtility.addBytes(newClass,(short)3);                   // max_locals               (fixed)

        // Code Length
        length = 20;
        if(exceptionable && 0 < excpIndex[i].length)
        { length += 5; }
        if(propertyChangeFlag[i])
        { length += 2; }
        newClass = ByteUtility.addBytes(newClass,(long)length);               // code_length              (variable)

        // start code
        newClass = ByteUtility.addBytes(newClass,(byte)0x2A);                 // aload_0                  (fixed)
        newClass = ByteUtility.addBytes(newClass,(byte)0xB4);                 // getfield                 (fixed)
        newClass = ByteUtility.addBytes(newClass,(short)15);                  // index                    (fixed)


        if(propertyChangeFlag[i])
        { // the propertyName is passed as the first parameter
          newClass = ByteUtility.addBytes(newClass,(byte)0x2B);               // aload_1                  (fixed)
          newClass = ByteUtility.addBytes(newClass,(byte)0xB6);               // invokevirtual            (fixed)
          newClass = ByteUtility.addBytes(newClass,(short)cpIndexPCE);        // methodref                (variable)
        }
        else
        { // the eventMethodName is passed as the first parameter
          // Target for method invocation.
          newClass = ByteUtility.addBytes(newClass,(byte)0x12);                 // ldc                    (fixed)
          newClass = ByteUtility.addBytes(newClass,(byte)(cpBaseIndex+3*i+2));  // index (byte)           (variable)
        }

        newClass = ByteUtility.addBytes(newClass,(byte)0x04);                 // iconst_1                 (fixed)
        newClass = ByteUtility.addBytes(newClass,(byte)0xBD);                 // anewarray                (fixed)
        newClass = ByteUtility.addBytes(newClass,(short)10);                  // Class java/lang/Object   (fixed)
        newClass = ByteUtility.addBytes(newClass,(byte)0x59);                 // dup                      (fixed)
        newClass = ByteUtility.addBytes(newClass,(byte)0x03);                 // iconst_0                 (fixed)
        newClass = ByteUtility.addBytes(newClass,(byte)0x2B);                 // aload_1                  (fixed)
        newClass = ByteUtility.addBytes(newClass,(byte)0x53);                 // aastore                  (fixed)
        newClass = ByteUtility.addBytes(newClass,(byte)0xB9);                 // invokeinterface          (fixed)

        // index to processEvent or processExceptionableEvent method
        length = 23; // actually an index into cp
        if(exceptionable && nonExceptionable)
        { // interface method index
          if( 0 < lms[i].getExceptionTypes().length )
          { length += 5; }
        }
        else if(exceptionable)
        { length += 2; }
        newClass = ByteUtility.addBytes(newClass,(short)length);              // index (process??????...) (variable)

        newClass = ByteUtility.addBytes(newClass,(byte)0x03);                 // iconst_0                 (fixed)
        newClass = ByteUtility.addBytes(newClass,(byte)0x00);                 // noop                     (fixed)
        newClass = ByteUtility.addBytes(newClass,(byte)0xB1);                 // return                   (fixed)

        if(exceptionable && 0 < excpIndex[i].length)
        { // exception code
          newClass = ByteUtility.addBytes(newClass,(byte)0x4D);               // astore_2                 (fixed)
          newClass = ByteUtility.addBytes(newClass,(byte)0x2C);               // aload_2                  (fixed)
          newClass = ByteUtility.addBytes(newClass,(byte)0xBF);               // athrow                   (fixed)
          newClass = ByteUtility.addBytes(newClass,(byte)0x57);               // pop                      (fixed)
          newClass = ByteUtility.addBytes(newClass,(byte)0xB1);               // return                   (fixed)
        // end code

          // exception table
          length = excpIndex[i].length;
          newClass = ByteUtility.addBytes(newClass,(short)(1+length));        // exception_table_length   (variable)
          for( int j = 0 ; j < length ; j++ )
          { // catch exception types and rethrow
            newClass = ByteUtility.addBytes(newClass,(short)0);               // start_pc                 (fixed)
            if(propertyChangeFlag[i])
            {
              newClass = ByteUtility.addBytes(newClass,(short)21);            // end_pc                   (fixed)
              newClass = ByteUtility.addBytes(newClass,(short)22);            // handler_pc               (fixed)
            }
            else
            {
              newClass = ByteUtility.addBytes(newClass,(short)19);            // end_pc                   (fixed)
              newClass = ByteUtility.addBytes(newClass,(short)20);            // handler_pc               (fixed)
            }
            newClass = ByteUtility.addBytes(newClass,(short)excpIndex[i][j]); // catch_type               (variable)
          }
          // catch ""exception"" and trap it
          newClass = ByteUtility.addBytes(newClass,(short)0);                 // start_pc                 (fixed)
          if(propertyChangeFlag[i])
          {
            newClass = ByteUtility.addBytes(newClass,(short)21);              // end_pc                   (fixed)
            newClass = ByteUtility.addBytes(newClass,(short)25);              // handler_pc               (fixed)
          }
          else
          {
            newClass = ByteUtility.addBytes(newClass,(short)19);              // end_pc                   (fixed)
            newClass = ByteUtility.addBytes(newClass,(short)23);              // handler_pc               (fixed)
          }
          if(nonExceptionable)
          { newClass = ByteUtility.addBytes(newClass,(short)26); }            // catch_type               (fixed)
          else                                                                                            // or
          { newClass = ByteUtility.addBytes(newClass,(short)23); }            // catch_type               (fixed)
        }
        else
        { newClass = ByteUtility.addBytes(newClass,(short)0); }               // exception_table_length   (fixed)
        // attributes on the code attribute (none)
        newClass = ByteUtility.addBytes(newClass,(short)0);                   // attribute_count          (fixed)
        // end code attribute


      }/* End for*/
      // Class Attributes (none for this)
      newClass = ByteUtility.addBytes(newClass,(short)0);                     // attribute_count          (fixed)
      /* done */

          logger.debug(""adapterName: "" + finalAdapterClassName);
          logger.debug(""cpCount: "" + count + "" = "" + BASECPCOUNT + "" + "" +  cpCount);
          logger.debug(""methodCount: "" + (lms.length+1));
      // output to disk class file
      /* ****************************************************************************************** */

      // now create the class and load it
      // return the Class.

      if (writeClassFile)
      {
        try
        {
                    // removed ""WRITEDIRECTORY+"", as this path is already part of 'finalAdapterClassName'
          FileOutputStream fos =  new FileOutputStream(finalAdapterClassName+"".class"");
          fos.write(newClass);
          fos.close();
        }
        catch(IOException ex)
        {
                    System.err.println(ex.getMessage());
                    ex.printStackTrace();
                }

        try
        {
          Class ret = ldr.loadClass(finalAdapterClassName);
          logger.debug(""EventAdapterGenerator: "" +
                             ret.getName() +
                             "" dynamically generated"");
          return ret;
        }
        catch (ClassNotFoundException ex)
        {
                    System.err.println(ex.getMessage());
                    ex.printStackTrace();
                }
      }

      try
      {
        Class ret = ldr.defineClass(finalAdapterClassName,newClass);
        logger.debug(""EventAdapterGenerator: "" +
                                       ret.getName() +
                                       "" dynamically generated"");
        return ret;
      }

      catch(Throwable ex)           // rgf, 2012-01-15
      {
        System.err.println(ex.getMessage());
        ex.printStackTrace();
      }
    }
    return null;
  }
}
",blob
913,"public class DataBinder implements PropertyEditorRegistry, TypeConverter {

	/** Default object name used for binding: ""target"". */
	public static final String DEFAULT_OBJECT_NAME = ""target"";

	/** Default limit for array and collection growing: 256. */
	public static final int DEFAULT_AUTO_GROW_COLLECTION_LIMIT = 256;


	/**
	 * We'll create a lot of DataBinder instances: Let's use a static logger.
	 */
	protected static final Log logger = LogFactory.getLog(DataBinder.class);

	@Nullable
	private final Object target;

	private final String objectName;

	@Nullable
	private AbstractPropertyBindingResult bindingResult;

	@Nullable
	private SimpleTypeConverter typeConverter;

	private boolean ignoreUnknownFields = true;

	private boolean ignoreInvalidFields = false;

	private boolean autoGrowNestedPaths = true;

	private int autoGrowCollectionLimit = DEFAULT_AUTO_GROW_COLLECTION_LIMIT;

	@Nullable
	private String[] allowedFields;

	@Nullable
	private String[] disallowedFields;

	@Nullable
	private String[] requiredFields;

	@Nullable
	private ConversionService conversionService;

	@Nullable
	private MessageCodesResolver messageCodesResolver;

	private BindingErrorProcessor bindingErrorProcessor = new DefaultBindingErrorProcessor();

	private final List<Validator> validators = new ArrayList<>();


	/**
	 * Create a new DataBinder instance, with default object name.
	 * @param target the target object to bind onto (or {@code null}
	 * if the binder is just used to convert a plain parameter value)
	 * @see #DEFAULT_OBJECT_NAME
	 */
	public DataBinder(@Nullable Object target) {
		this(target, DEFAULT_OBJECT_NAME);
	}

	/**
	 * Create a new DataBinder instance.
	 * @param target the target object to bind onto (or {@code null}
	 * if the binder is just used to convert a plain parameter value)
	 * @param objectName the name of the target object
	 */
	public DataBinder(@Nullable Object target, String objectName) {
		this.target = ObjectUtils.unwrapOptional(target);
		this.objectName = objectName;
	}


	/**
	 * Return the wrapped target object.
	 */
	@Nullable
	public Object getTarget() {
		return this.target;
	}

	/**
	 * Return the name of the bound object.
	 */
	public String getObjectName() {
		return this.objectName;
	}

	/**
	 * Set whether this binder should attempt to ""auto-grow"" a nested path that contains a null value.
	 * <p>If ""true"", a null path location will be populated with a default object value and traversed
	 * instead of resulting in an exception. This flag also enables auto-growth of collection elements
	 * when accessing an out-of-bounds index.
	 * <p>Default is ""true"" on a standard DataBinder. Note that since Spring 4.1 this feature is supported
	 * for bean property access (DataBinder's default mode) and field access.
	 * @see #initBeanPropertyAccess()
	 * @see org.springframework.beans.BeanWrapper#setAutoGrowNestedPaths
	 */
	public void setAutoGrowNestedPaths(boolean autoGrowNestedPaths) {
		Assert.state(this.bindingResult == null,
				""DataBinder is already initialized - call setAutoGrowNestedPaths before other configuration methods"");
		this.autoGrowNestedPaths = autoGrowNestedPaths;
	}

	/**
	 * Return whether ""auto-growing"" of nested paths has been activated.
	 */
	public boolean isAutoGrowNestedPaths() {
		return this.autoGrowNestedPaths;
	}

	/**
	 * Specify the limit for array and collection auto-growing.
	 * <p>Default is 256, preventing OutOfMemoryErrors in case of large indexes.
	 * Raise this limit if your auto-growing needs are unusually high.
	 * @see #initBeanPropertyAccess()
	 * @see org.springframework.beans.BeanWrapper#setAutoGrowCollectionLimit
	 */
	public void setAutoGrowCollectionLimit(int autoGrowCollectionLimit) {
		Assert.state(this.bindingResult == null,
				""DataBinder is already initialized - call setAutoGrowCollectionLimit before other configuration methods"");
		this.autoGrowCollectionLimit = autoGrowCollectionLimit;
	}

	/**
	 * Return the current limit for array and collection auto-growing.
	 */
	public int getAutoGrowCollectionLimit() {
		return this.autoGrowCollectionLimit;
	}

	/**
	 * Initialize standard JavaBean property access for this DataBinder.
	 * <p>This is the default; an explicit call just leads to eager initialization.
	 * @see #initDirectFieldAccess()
	 * @see #createBeanPropertyBindingResult()
	 */
	public void initBeanPropertyAccess() {
		Assert.state(this.bindingResult == null,
				""DataBinder is already initialized - call initBeanPropertyAccess before other configuration methods"");
		this.bindingResult = createBeanPropertyBindingResult();
	}

	/**
	 * Create the {@link AbstractPropertyBindingResult} instance using standard
	 * JavaBean property access.
	 * @since 4.2.1
	 */
	protected AbstractPropertyBindingResult createBeanPropertyBindingResult() {
		BeanPropertyBindingResult result = new BeanPropertyBindingResult(getTarget(),
				getObjectName(), isAutoGrowNestedPaths(), getAutoGrowCollectionLimit());

		if (this.conversionService != null) {
			result.initConversion(this.conversionService);
		}
		if (this.messageCodesResolver != null) {
			result.setMessageCodesResolver(this.messageCodesResolver);
		}

		return result;
	}

	/**
	 * Initialize direct field access for this DataBinder,
	 * as alternative to the default bean property access.
	 * @see #initBeanPropertyAccess()
	 * @see #createDirectFieldBindingResult()
	 */
	public void initDirectFieldAccess() {
		Assert.state(this.bindingResult == null,
				""DataBinder is already initialized - call initDirectFieldAccess before other configuration methods"");
		this.bindingResult = createDirectFieldBindingResult();
	}

	/**
	 * Create the {@link AbstractPropertyBindingResult} instance using direct
	 * field access.
	 * @since 4.2.1
	 */
	protected AbstractPropertyBindingResult createDirectFieldBindingResult() {
		DirectFieldBindingResult result = new DirectFieldBindingResult(getTarget(),
				getObjectName(), isAutoGrowNestedPaths());

		if (this.conversionService != null) {
			result.initConversion(this.conversionService);
		}
		if (this.messageCodesResolver != null) {
			result.setMessageCodesResolver(this.messageCodesResolver);
		}

		return result;
	}

	/**
	 * Return the internal BindingResult held by this DataBinder,
	 * as an AbstractPropertyBindingResult.
	 */
	protected AbstractPropertyBindingResult getInternalBindingResult() {
		if (this.bindingResult == null) {
			initBeanPropertyAccess();
		}
		return this.bindingResult;
	}

	/**
	 * Return the underlying PropertyAccessor of this binder's BindingResult.
	 */
	protected ConfigurablePropertyAccessor getPropertyAccessor() {
		return getInternalBindingResult().getPropertyAccessor();
	}

	/**
	 * Return this binder's underlying SimpleTypeConverter.
	 */
	protected SimpleTypeConverter getSimpleTypeConverter() {
		if (this.typeConverter == null) {
			this.typeConverter = new SimpleTypeConverter();
			if (this.conversionService != null) {
				this.typeConverter.setConversionService(this.conversionService);
			}
		}
		return this.typeConverter;
	}

	/**
	 * Return the underlying TypeConverter of this binder's BindingResult.
	 */
	protected PropertyEditorRegistry getPropertyEditorRegistry() {
		if (getTarget() != null) {
			return getInternalBindingResult().getPropertyAccessor();
		}
		else {
			return getSimpleTypeConverter();
		}
	}

	/**
	 * Return the underlying TypeConverter of this binder's BindingResult.
	 */
	protected TypeConverter getTypeConverter() {
		if (getTarget() != null) {
			return getInternalBindingResult().getPropertyAccessor();
		}
		else {
			return getSimpleTypeConverter();
		}
	}

	/**
	 * Return the BindingResult instance created by this DataBinder.
	 * This allows for convenient access to the binding results after
	 * a bind operation.
	 * @return the BindingResult instance, to be treated as BindingResult
	 * or as Errors instance (Errors is a super-interface of BindingResult)
	 * @see Errors
	 * @see #bind
	 */
	public BindingResult getBindingResult() {
		return getInternalBindingResult();
	}


	/**
	 * Set whether to ignore unknown fields, that is, whether to ignore bind
	 * parameters that do not have corresponding fields in the target object.
	 * <p>Default is ""true"". Turn this off to enforce that all bind parameters
	 * must have a matching field in the target object.
	 * <p>Note that this setting only applies to <i>binding</i> operations
	 * on this DataBinder, not to <i>retrieving</i> values via its
	 * {@link #getBindingResult() BindingResult}.
	 * @see #bind
	 */
	public void setIgnoreUnknownFields(boolean ignoreUnknownFields) {
		this.ignoreUnknownFields = ignoreUnknownFields;
	}

	/**
	 * Return whether to ignore unknown fields when binding.
	 */
	public boolean isIgnoreUnknownFields() {
		return this.ignoreUnknownFields;
	}

	/**
	 * Set whether to ignore invalid fields, that is, whether to ignore bind
	 * parameters that have corresponding fields in the target object which are
	 * not accessible (for example because of null values in the nested path).
	 * <p>Default is ""false"". Turn this on to ignore bind parameters for
	 * nested objects in non-existing parts of the target object graph.
	 * <p>Note that this setting only applies to <i>binding</i> operations
	 * on this DataBinder, not to <i>retrieving</i> values via its
	 * {@link #getBindingResult() BindingResult}.
	 * @see #bind
	 */
	public void setIgnoreInvalidFields(boolean ignoreInvalidFields) {
		this.ignoreInvalidFields = ignoreInvalidFields;
	}

	/**
	 * Return whether to ignore invalid fields when binding.
	 */
	public boolean isIgnoreInvalidFields() {
		return this.ignoreInvalidFields;
	}

	/**
	 * Register fields that should be allowed for binding. Default is all
	 * fields. Restrict this for example to avoid unwanted modifications
	 * by malicious users when binding HTTP request parameters.
	 * <p>Supports ""xxx*"", ""*xxx"" and ""*xxx*"" patterns. More sophisticated matching
	 * can be implemented by overriding the {@code isAllowed} method.
	 * <p>Alternatively, specify a list of <i>disallowed</i> fields.
	 * @param allowedFields array of field names
	 * @see #setDisallowedFields
	 * @see #isAllowed(String)
	 */
	public void setAllowedFields(@Nullable String... allowedFields) {
		this.allowedFields = PropertyAccessorUtils.canonicalPropertyNames(allowedFields);
	}

	/**
	 * Return the fields that should be allowed for binding.
	 * @return array of field names
	 */
	@Nullable
	public String[] getAllowedFields() {
		return this.allowedFields;
	}

	/**
	 * Register fields that should <i>not</i> be allowed for binding. Default is none.
	 * Mark fields as disallowed for example to avoid unwanted modifications
	 * by malicious users when binding HTTP request parameters.
	 * <p>Supports ""xxx*"", ""*xxx"" and ""*xxx*"" patterns. More sophisticated matching
	 * can be implemented by overriding the {@code isAllowed} method.
	 * <p>Alternatively, specify a list of <i>allowed</i> fields.
	 * @param disallowedFields array of field names
	 * @see #setAllowedFields
	 * @see #isAllowed(String)
	 */
	public void setDisallowedFields(@Nullable String... disallowedFields) {
		this.disallowedFields = PropertyAccessorUtils.canonicalPropertyNames(disallowedFields);
	}

	/**
	 * Return the fields that should <i>not</i> be allowed for binding.
	 * @return array of field names
	 */
	@Nullable
	public String[] getDisallowedFields() {
		return this.disallowedFields;
	}

	/**
	 * Register fields that are required for each binding process.
	 * <p>If one of the specified fields is not contained in the list of
	 * incoming property values, a corresponding ""missing field"" error
	 * will be created, with error code ""required"" (by the default
	 * binding error processor).
	 * @param requiredFields array of field names
	 * @see #setBindingErrorProcessor
	 * @see DefaultBindingErrorProcessor#MISSING_FIELD_ERROR_CODE
	 */
	public void setRequiredFields(@Nullable String... requiredFields) {
		this.requiredFields = PropertyAccessorUtils.canonicalPropertyNames(requiredFields);
		if (logger.isDebugEnabled()) {
			logger.debug(""DataBinder requires binding of required fields ["" +
					StringUtils.arrayToCommaDelimitedString(requiredFields) + ""]"");
		}
	}

	/**
	 * Return the fields that are required for each binding process.
	 * @return array of field names
	 */
	@Nullable
	public String[] getRequiredFields() {
		return this.requiredFields;
	}

	/**
	 * Set the strategy to use for resolving errors into message codes.
	 * Applies the given strategy to the underlying errors holder.
	 * <p>Default is a DefaultMessageCodesResolver.
	 * @see BeanPropertyBindingResult#setMessageCodesResolver
	 * @see DefaultMessageCodesResolver
	 */
	public void setMessageCodesResolver(@Nullable MessageCodesResolver messageCodesResolver) {
		Assert.state(this.messageCodesResolver == null, ""DataBinder is already initialized with MessageCodesResolver"");
		this.messageCodesResolver = messageCodesResolver;
		if (this.bindingResult != null && messageCodesResolver != null) {
			this.bindingResult.setMessageCodesResolver(messageCodesResolver);
		}
	}

	/**
	 * Set the strategy to use for processing binding errors, that is,
	 * required field errors and {@code PropertyAccessException}s.
	 * <p>Default is a DefaultBindingErrorProcessor.
	 * @see DefaultBindingErrorProcessor
	 */
	public void setBindingErrorProcessor(BindingErrorProcessor bindingErrorProcessor) {
		Assert.notNull(bindingErrorProcessor, ""BindingErrorProcessor must not be null"");
		this.bindingErrorProcessor = bindingErrorProcessor;
	}

	/**
	 * Return the strategy for processing binding errors.
	 */
	public BindingErrorProcessor getBindingErrorProcessor() {
		return this.bindingErrorProcessor;
	}

	/**
	 * Set the Validator to apply after each binding step.
	 * @see #addValidators(Validator...)
	 * @see #replaceValidators(Validator...)
	 */
	public void setValidator(@Nullable Validator validator) {
		assertValidators(validator);
		this.validators.clear();
		if (validator != null) {
			this.validators.add(validator);
		}
	}

	private void assertValidators(Validator... validators) {
		Object target = getTarget();
		for (Validator validator : validators) {
			if (validator != null && (target != null && !validator.supports(target.getClass()))) {
				throw new IllegalStateException(""Invalid target for Validator ["" + validator + ""]: "" + target);
			}
		}
	}

	/**
	 * Add Validators to apply after each binding step.
	 * @see #setValidator(Validator)
	 * @see #replaceValidators(Validator...)
	 */
	public void addValidators(Validator... validators) {
		assertValidators(validators);
		this.validators.addAll(Arrays.asList(validators));
	}

	/**
	 * Replace the Validators to apply after each binding step.
	 * @see #setValidator(Validator)
	 * @see #addValidators(Validator...)
	 */
	public void replaceValidators(Validator... validators) {
		assertValidators(validators);
		this.validators.clear();
		this.validators.addAll(Arrays.asList(validators));
	}

	/**
	 * Return the primary Validator to apply after each binding step, if any.
	 */
	@Nullable
	public Validator getValidator() {
		return (!this.validators.isEmpty() ? this.validators.get(0) : null);
	}

	/**
	 * Return the Validators to apply after data binding.
	 */
	public List<Validator> getValidators() {
		return Collections.unmodifiableList(this.validators);
	}


	//---------------------------------------------------------------------
	// Implementation of PropertyEditorRegistry/TypeConverter interface
	//---------------------------------------------------------------------

	/**
	 * Specify a Spring 3.0 ConversionService to use for converting
	 * property values, as an alternative to JavaBeans PropertyEditors.
	 */
	public void setConversionService(@Nullable ConversionService conversionService) {
		Assert.state(this.conversionService == null, ""DataBinder is already initialized with ConversionService"");
		this.conversionService = conversionService;
		if (this.bindingResult != null && conversionService != null) {
			this.bindingResult.initConversion(conversionService);
		}
	}

	/**
	 * Return the associated ConversionService, if any.
	 */
	@Nullable
	public ConversionService getConversionService() {
		return this.conversionService;
	}

	/**
	 * Add a custom formatter, applying it to all fields matching the
	 * {@link Formatter}-declared type.
	 * <p>Registers a corresponding {@link PropertyEditor} adapter underneath the covers.
	 * @param formatter the formatter to add, generically declared for a specific type
	 * @since 4.2
	 * @see #registerCustomEditor(Class, PropertyEditor)
	 */
	public void addCustomFormatter(Formatter<?> formatter) {
		FormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter);
		getPropertyEditorRegistry().registerCustomEditor(adapter.getFieldType(), adapter);
	}

	/**
	 * Add a custom formatter for the field type specified in {@link Formatter} class,
	 * applying it to the specified fields only, if any, or otherwise to all fields.
	 * <p>Registers a corresponding {@link PropertyEditor} adapter underneath the covers.
	 * @param formatter the formatter to add, generically declared for a specific type
	 * @param fields the fields to apply the formatter to, or none if to be applied to all
	 * @since 4.2
	 * @see #registerCustomEditor(Class, String, PropertyEditor)
	 */
	public void addCustomFormatter(Formatter<?> formatter, String... fields) {
		FormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter);
		Class<?> fieldType = adapter.getFieldType();
		if (ObjectUtils.isEmpty(fields)) {
			getPropertyEditorRegistry().registerCustomEditor(fieldType, adapter);
		}
		else {
			for (String field : fields) {
				getPropertyEditorRegistry().registerCustomEditor(fieldType, field, adapter);
			}
		}
	}

	/**
	 * Add a custom formatter, applying it to the specified field types only, if any,
	 * or otherwise to all fields matching the {@link Formatter}-declared type.
	 * <p>Registers a corresponding {@link PropertyEditor} adapter underneath the covers.
	 * @param formatter the formatter to add (does not need to generically declare a
	 * field type if field types are explicitly specified as parameters)
	 * @param fieldTypes the field types to apply the formatter to, or none if to be
	 * derived from the given {@link Formatter} implementation class
	 * @since 4.2
	 * @see #registerCustomEditor(Class, PropertyEditor)
	 */
	public void addCustomFormatter(Formatter<?> formatter, Class<?>... fieldTypes) {
		FormatterPropertyEditorAdapter adapter = new FormatterPropertyEditorAdapter(formatter);
		if (ObjectUtils.isEmpty(fieldTypes)) {
			getPropertyEditorRegistry().registerCustomEditor(adapter.getFieldType(), adapter);
		}
		else {
			for (Class<?> fieldType : fieldTypes) {
				getPropertyEditorRegistry().registerCustomEditor(fieldType, adapter);
			}
		}
	}

	@Override
	public void registerCustomEditor(Class<?> requiredType, PropertyEditor propertyEditor) {
		getPropertyEditorRegistry().registerCustomEditor(requiredType, propertyEditor);
	}

	@Override
	public void registerCustomEditor(@Nullable Class<?> requiredType, @Nullable String field, PropertyEditor propertyEditor) {
		getPropertyEditorRegistry().registerCustomEditor(requiredType, field, propertyEditor);
	}

	@Override
	@Nullable
	public PropertyEditor findCustomEditor(@Nullable Class<?> requiredType, @Nullable String propertyPath) {
		return getPropertyEditorRegistry().findCustomEditor(requiredType, propertyPath);
	}

	@Override
	@Nullable
	public <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType) throws TypeMismatchException {
		return getTypeConverter().convertIfNecessary(value, requiredType);
	}

	@Override
	@Nullable
	public <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,
			@Nullable MethodParameter methodParam) throws TypeMismatchException {

		return getTypeConverter().convertIfNecessary(value, requiredType, methodParam);
	}

	@Override
	@Nullable
	public <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType, @Nullable Field field)
			throws TypeMismatchException {

		return getTypeConverter().convertIfNecessary(value, requiredType, field);
	}

	@Nullable
	@Override
	public <T> T convertIfNecessary(@Nullable Object value, @Nullable Class<T> requiredType,
			@Nullable TypeDescriptor typeDescriptor) throws TypeMismatchException {

		return getTypeConverter().convertIfNecessary(value, requiredType, typeDescriptor);
	}


	/**
	 * Bind the given property values to this binder's target.
	 * <p>This call can create field errors, representing basic binding
	 * errors like a required field (code ""required""), or type mismatch
	 * between value and bean property (code ""typeMismatch"").
	 * <p>Note that the given PropertyValues should be a throwaway instance:
	 * For efficiency, it will be modified to just contain allowed fields if it
	 * implements the MutablePropertyValues interface; else, an internal mutable
	 * copy will be created for this purpose. Pass in a copy of the PropertyValues
	 * if you want your original instance to stay unmodified in any case.
	 * @param pvs property values to bind
	 * @see #doBind(org.springframework.beans.MutablePropertyValues)
	 */
	public void bind(PropertyValues pvs) {
		MutablePropertyValues mpvs = (pvs instanceof MutablePropertyValues ?
				(MutablePropertyValues) pvs : new MutablePropertyValues(pvs));
		doBind(mpvs);
	}

	/**
	 * Actual implementation of the binding process, working with the
	 * passed-in MutablePropertyValues instance.
	 * @param mpvs the property values to bind,
	 * as MutablePropertyValues instance
	 * @see #checkAllowedFields
	 * @see #checkRequiredFields
	 * @see #applyPropertyValues
	 */
	protected void doBind(MutablePropertyValues mpvs) {
		checkAllowedFields(mpvs);
		checkRequiredFields(mpvs);
		applyPropertyValues(mpvs);
	}

	/**
	 * Check the given property values against the allowed fields,
	 * removing values for fields that are not allowed.
	 * @param mpvs the property values to be bound (can be modified)
	 * @see #getAllowedFields
	 * @see #isAllowed(String)
	 */
	protected void checkAllowedFields(MutablePropertyValues mpvs) {
		PropertyValue[] pvs = mpvs.getPropertyValues();
		for (PropertyValue pv : pvs) {
			String field = PropertyAccessorUtils.canonicalPropertyName(pv.getName());
			if (!isAllowed(field)) {
				mpvs.removePropertyValue(pv);
				getBindingResult().recordSuppressedField(field);
				if (logger.isDebugEnabled()) {
					logger.debug(""Field ["" + field + ""] has been removed from PropertyValues "" +
							""and will not be bound, because it has not been found in the list of allowed fields"");
				}
			}
		}
	}

	/**
	 * Return if the given field is allowed for binding.
	 * Invoked for each passed-in property value.
	 * <p>The default implementation checks for ""xxx*"", ""*xxx"" and ""*xxx*"" matches,
	 * as well as direct equality, in the specified lists of allowed fields and
	 * disallowed fields. A field matching a disallowed pattern will not be accepted
	 * even if it also happens to match a pattern in the allowed list.
	 * <p>Can be overridden in subclasses.
	 * @param field the field to check
	 * @return if the field is allowed
	 * @see #setAllowedFields
	 * @see #setDisallowedFields
	 * @see org.springframework.util.PatternMatchUtils#simpleMatch(String, String)
	 */
	protected boolean isAllowed(String field) {
		String[] allowed = getAllowedFields();
		String[] disallowed = getDisallowedFields();
		return ((ObjectUtils.isEmpty(allowed) || PatternMatchUtils.simpleMatch(allowed, field)) &&
				(ObjectUtils.isEmpty(disallowed) || !PatternMatchUtils.simpleMatch(disallowed, field)));
	}

	/**
	 * Check the given property values against the required fields,
	 * generating missing field errors where appropriate.
	 * @param mpvs the property values to be bound (can be modified)
	 * @see #getRequiredFields
	 * @see #getBindingErrorProcessor
	 * @see BindingErrorProcessor#processMissingFieldError
	 */
	protected void checkRequiredFields(MutablePropertyValues mpvs) {
		String[] requiredFields = getRequiredFields();
		if (!ObjectUtils.isEmpty(requiredFields)) {
			Map<String, PropertyValue> propertyValues = new HashMap<>();
			PropertyValue[] pvs = mpvs.getPropertyValues();
			for (PropertyValue pv : pvs) {
				String canonicalName = PropertyAccessorUtils.canonicalPropertyName(pv.getName());
				propertyValues.put(canonicalName, pv);
			}
			for (String field : requiredFields) {
				PropertyValue pv = propertyValues.get(field);
				boolean empty = (pv == null || pv.getValue() == null);
				if (!empty) {
					if (pv.getValue() instanceof String) {
						empty = !StringUtils.hasText((String) pv.getValue());
					}
					else if (pv.getValue() instanceof String[]) {
						String[] values = (String[]) pv.getValue();
						empty = (values.length == 0 || !StringUtils.hasText(values[0]));
					}
				}
				if (empty) {
					// Use bind error processor to create FieldError.
					getBindingErrorProcessor().processMissingFieldError(field, getInternalBindingResult());
					// Remove property from property values to bind:
					// It has already caused a field error with a rejected value.
					if (pv != null) {
						mpvs.removePropertyValue(pv);
						propertyValues.remove(field);
					}
				}
			}
		}
	}

	/**
	 * Apply given property values to the target object.
	 * <p>Default implementation applies all of the supplied property
	 * values as bean property values. By default, unknown fields will
	 * be ignored.
	 * @param mpvs the property values to be bound (can be modified)
	 * @see #getTarget
	 * @see #getPropertyAccessor
	 * @see #isIgnoreUnknownFields
	 * @see #getBindingErrorProcessor
	 * @see BindingErrorProcessor#processPropertyAccessException
	 */
	protected void applyPropertyValues(MutablePropertyValues mpvs) {
		try {
			// Bind request parameters onto target object.
			getPropertyAccessor().setPropertyValues(mpvs, isIgnoreUnknownFields(), isIgnoreInvalidFields());
		}
		catch (PropertyBatchUpdateException ex) {
			// Use bind error processor to create FieldErrors.
			for (PropertyAccessException pae : ex.getPropertyAccessExceptions()) {
				getBindingErrorProcessor().processPropertyAccessException(pae, getInternalBindingResult());
			}
		}
	}


	/**
	 * Invoke the specified Validators, if any.
	 * @see #setValidator(Validator)
	 * @see #getBindingResult()
	 */
	public void validate() {
		Object target = getTarget();
		Assert.state(target != null, ""No target to validate"");
		BindingResult bindingResult = getBindingResult();
		// Call each validator with the same binding result
		for (Validator validator : getValidators()) {
			validator.validate(target, bindingResult);
		}
	}

	/**
	 * Invoke the specified Validators, if any, with the given validation hints.
	 * <p>Note: Validation hints may get ignored by the actual target Validator.
	 * @param validationHints one or more hint objects to be passed to a {@link SmartValidator}
	 * @since 3.1
	 * @see #setValidator(Validator)
	 * @see SmartValidator#validate(Object, Errors, Object...)
	 */
	public void validate(Object... validationHints) {
		Object target = getTarget();
		Assert.state(target != null, ""No target to validate"");
		BindingResult bindingResult = getBindingResult();
		// Call each validator with the same binding result
		for (Validator validator : getValidators()) {
			if (!ObjectUtils.isEmpty(validationHints) && validator instanceof SmartValidator) {
				((SmartValidator) validator).validate(target, bindingResult, validationHints);
			}
			else if (validator != null) {
				validator.validate(target, bindingResult);
			}
		}
	}

	/**
	 * Close this DataBinder, which may result in throwing
	 * a BindException if it encountered any errors.
	 * @return the model Map, containing target object and Errors instance
	 * @throws BindException if there were any errors in the bind operation
	 * @see BindingResult#getModel()
	 */
	public Map<?, ?> close() throws BindException {
		if (getBindingResult().hasErrors()) {
			throw new BindException(getBindingResult());
		}
		return getBindingResult().getModel();
	}

}
",blob
747,"public class UnifyBasicTypeVariableTypeRule extends LambdaTypeSystemRule {

	protected Variable<org.eclipse.xsemantics.example.lambda.lambda.TypeVariable> var_v1 = new Variable<org.eclipse.xsemantics.example.lambda.lambda.TypeVariable>(
			createEClassifierType(basicPackage.getTypeVariable()));

	protected Variable<org.eclipse.xsemantics.example.lambda.lambda.BasicType> var_b = new Variable<org.eclipse.xsemantics.example.lambda.lambda.BasicType>(
			createEClassifierType(basicPackage.getBasicType()));

	protected Variable<org.eclipse.xsemantics.example.lambda.lambda.Type> var_t1 = new Variable<org.eclipse.xsemantics.example.lambda.lambda.Type>(
			createEClassifierType(basicPackage.getType()));

	protected TypingJudgmentEnvironment env_G = new TypingJudgmentEnvironment();

	public UnifyBasicTypeVariableTypeRule() {
		this(""UnifyBasicTypeVariable"", ""|-"", ""=="");
	}

	public UnifyBasicTypeVariableTypeRule(String ruleName,
			String typeJudgmentSymbol, String typeStatementRelation) {
		super(ruleName, typeJudgmentSymbol, typeStatementRelation);
	}

	@Override
	public Variable<org.eclipse.xsemantics.example.lambda.lambda.BasicType> getLeft() {
		return var_b;
	}

	@Override
	public Variable<org.eclipse.xsemantics.example.lambda.lambda.Type> getRight() {
		return var_t1;
	}

	@Override
	public TypingJudgmentEnvironment getEnvironment() {
		return env_G;
	}

	@Override
	public void setEnvironment(TypingJudgmentEnvironment environment) {
		if (environment != null)
			env_G = environment;
	}

	@Override
	public RuntimeRule newInstance() {
		return new UnifyBasicTypeVariableTypeRule(""UnifyBasicTypeVariable"",
				""|-"", ""=="");
	}

	@Override
	public void applyImpl() throws RuleFailedException {

		var_v1 = new Variable<org.eclipse.xsemantics.example.lambda.lambda.TypeVariable>(
				createEClassifierType(basicPackage.getTypeVariable()), castto(
						var_t1.getValue(),
						org.eclipse.xsemantics.example.lambda.lambda.TypeVariable.class));

		applyMappingRule(env_G, var_v1, var_b);

		// final check for variable initialization

	}

}
",data class
224,"        @Override
        public void addOptionValues(List<OptionValue> optionValues, Map<String, Object> context, Delegator delegator) {
            // first expand any conditions that need expanding based on the current context
            EntityCondition findCondition = null;
            if (UtilValidate.isNotEmpty(this.constraintList)) {
                List<EntityCondition> expandedConditionList = new LinkedList<>();
                for (EntityFinderUtil.Condition condition : constraintList) {
                    ModelEntity modelEntity = delegator.getModelEntity(this.entityName);
                    if (modelEntity == null) {
                        throw new IllegalArgumentException(""Error in entity-options: could not find entity ["" + this.entityName
                                + ""]"");
                    }
                    EntityCondition createdCondition = condition.createCondition(context, modelEntity,
                            delegator.getModelFieldTypeReader(modelEntity));
                    if (createdCondition != null) {
                        expandedConditionList.add(createdCondition);
                    }
                }
                findCondition = EntityCondition.makeCondition(expandedConditionList);
            }

            try {
                Locale locale = UtilMisc.ensureLocale(context.get(""locale""));
                ModelEntity modelEntity = delegator.getModelEntity(this.entityName);
                Boolean localizedOrderBy = UtilValidate.isNotEmpty(this.orderByList)
                        && ModelUtil.isPotentialLocalizedFields(modelEntity, this.orderByList);

                List<GenericValue> values = null;
                if (!localizedOrderBy) {
                    values = delegator.findList(this.entityName, findCondition, null, this.orderByList, null, this.cache);
                } else {
                    //if entity has localized label
                    values = delegator.findList(this.entityName, findCondition, null, null, null, this.cache);
                    values = EntityUtil.localizedOrderBy(values, this.orderByList, locale);
                }

                // filter-by-date if requested
                if (""true"".equals(this.filterByDate)) {
                    values = EntityUtil.filterByDate(values, true);
                } else if (!""false"".equals(this.filterByDate)) {
                    // not explicitly true or false, check to see if has fromDate and thruDate, if so do the filter
                    if (modelEntity != null && modelEntity.isField(""fromDate"") && modelEntity.isField(""thruDate"")) {
                        values = EntityUtil.filterByDate(values, true);
                    }
                }

                for (GenericValue value : values) {
                    // add key and description with string expansion, ie expanding ${} stuff, passing locale explicitly to expand value string because it won't be found in the Entity
                    MapStack<String> localContext = MapStack.create(context);
                    // Rendering code might try to modify the GenericEntity instance,
                    // so we make a copy of it.
                    Map<String, Object> genericEntityClone = UtilGenerics.cast(value.clone());
                    localContext.push(genericEntityClone);

                    // expand with the new localContext, which is locale aware
                    String optionDesc = this.description.expandString(localContext, locale);

                    Object keyFieldObject = value.get(this.getKeyFieldName());
                    if (keyFieldObject == null) {
                        throw new IllegalArgumentException(
                                ""The entity-options identifier (from key-name attribute, or default to the field name) [""
                                        + this.getKeyFieldName() + ""], may not be a valid key field name for the entity [""
                                        + this.entityName + ""]."");
                    }
                    String keyFieldValue = keyFieldObject.toString();
                    optionValues.add(new OptionValue(keyFieldValue, optionDesc));
                }
            } catch (GenericEntityException e) {
                Debug.logError(e, ""Error getting entity options in form"", module);
            }
        }
",feature envy
109,"public class BrocadeVcsApi {
    private static final Logger s_logger = Logger.getLogger(BrocadeVcsApi.class);

    private final String _host;
    private final String _adminuser;
    private final String _adminpass;

    protected DefaultHttpClient _client;

    protected HttpRequestBase createMethod(String type, String uri) throws BrocadeVcsApiException {
        String url;
        try {
            url = new URL(Constants.PROTOCOL, _host, Constants.PORT, uri).toString();
        } catch (final MalformedURLException e) {
            s_logger.error(""Unable to build Brocade Switch API URL"", e);
            throw new BrocadeVcsApiException(""Unable to build Brocade Switch API URL"", e);
        }

        if (""post"".equalsIgnoreCase(type)) {
            return new HttpPost(url);
        } else if (""get"".equalsIgnoreCase(type)) {
            return new HttpGet(url);
        } else if (""delete"".equalsIgnoreCase(type)) {
            return new HttpDelete(url);
        } else if (""patch"".equalsIgnoreCase(type)) {
            return new HttpPatch(url);
        } else {
            throw new BrocadeVcsApiException(""Requesting unknown method type"");
        }
    }

    public BrocadeVcsApi(String address, String username, String password) {
        _host = address;
        _adminuser = username;
        _adminpass = password;
        _client = new DefaultHttpClient();
        _client.getCredentialsProvider().setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(_adminuser, _adminpass));

    }

    /*
     * Get Operational Status
     */
    public Output getSwitchStatus() throws BrocadeVcsApiException {
        return executeRetreiveStatus(Constants.STATUS_URI);

    }

    /*
     * Creates a new virtual network.
     */
    public boolean createNetwork(int vlanId, long networkId) throws BrocadeVcsApiException {

        if (createInterfaceVlan(vlanId)) {

            final PortProfile portProfile = createPortProfile(vlanId, networkId);

            if (portProfile != null) {
                return activatePortProfile(portProfile);
            }
        }
        return false;
    }

    /*
     * Activates a port-profile.
     */
    private boolean activatePortProfile(PortProfile portProfile) throws BrocadeVcsApiException {
        final PortProfileGlobal portProfileGlobal = new PortProfileGlobal();
        portProfile.setVlanProfile(null);
        final Activate activate = new Activate();
        portProfile.setActivate(activate);
        portProfileGlobal.setPortProfile(portProfile);

        //activate port-profile
        return executeUpdateObject(portProfileGlobal, Constants.URI);
    }

    /*
     *  Creates AMPP port-profile.
     */
    private PortProfile createPortProfile(int vlanId, long networkId) throws BrocadeVcsApiException {

        final PortProfile portProfile = new PortProfile();
        portProfile.setName(Constants.PORT_PROFILE_NAME_PREFIX + networkId);
        if (executeCreateObject(portProfile, Constants.URI)) {
            if (createVlanSubProfile(vlanId, portProfile)) {
                return portProfile;
            }
        }
        return null;
    }

    /*
     * Create vlan sub-profile for port-profile
     */
    private boolean createVlanSubProfile(int vlanId, PortProfile portProfile) throws BrocadeVcsApiException {
        final VlanProfile vlanProfile = new VlanProfile();
        portProfile.setVlanProfile(vlanProfile);
        if (executeUpdateObject(portProfile, Constants.URI)) {
            return configureVlanSubProfile(vlanId, portProfile);
        }
        return false;
    }

    /*
     * Configures vlan sub-profile for port-profile.
     * - configure L2 mode for vlan sub-profile
     * - configure trunk mode for vlan sub-profile
     * - configure allowed VLANs for vlan sub-profile
     */
    private boolean configureVlanSubProfile(int vlanId, PortProfile portProfile) throws BrocadeVcsApiException {
        final SwitchportBasic switchPortBasic = new SwitchportBasic();
        final Basic basic = new Basic();
        switchPortBasic.setBasic(basic);
        portProfile.getVlanProfile().setSwitchportBasic(switchPortBasic);
        // configure L2 mode for vlan sub-profile
        if (executeUpdateObject(portProfile, Constants.URI)) {
            VlanProfile vlanProfile = new VlanProfile();
            Switchport switchPort = new Switchport();
            final Mode mode = new Mode();
            mode.setVlanMode(""trunk"");
            switchPort.setMode(mode);
            vlanProfile.setSwitchport(switchPort);
            portProfile.setVlanProfile(vlanProfile);

            // configure trunk mode for vlan sub-profile
            if (executeUpdateObject(portProfile, Constants.URI)) {
                vlanProfile = new VlanProfile();
                switchPort = new Switchport();
                final Trunk trunk = new Trunk();
                final Allowed allowed = new Allowed();
                final Allowed.Vlan allowedVlan = new Allowed.Vlan();
                allowedVlan.setAdd(vlanId);
                allowed.setVlan(allowedVlan);
                trunk.setAllowed(allowed);
                switchPort.setTrunk(trunk);
                vlanProfile.setSwitchport(switchPort);
                portProfile.setVlanProfile(vlanProfile);

                //configure allowed VLANs for vlan sub-profile
                return executeUpdateObject(portProfile, Constants.URI);
            }
        }

        return false;

    }

    /*
     * Creates a vlan interface.
     */
    private boolean createInterfaceVlan(int vlanId) throws BrocadeVcsApiException {
        final InterfaceVlan interfaceVlan = new InterfaceVlan();
        final Interface interfaceObj = new Interface();
        final Vlan vlan = new Vlan();
        vlan.setName(vlanId);
        interfaceObj.setVlan(vlan);
        interfaceVlan.setInterface(interfaceObj);

        return executeUpdateObject(interfaceVlan, Constants.URI);

    }

    /*
     * Associates a MAC address to virtual network.
     */
    public boolean associateMacToNetwork(long networkId, String macAddress) throws BrocadeVcsApiException {

        final PortProfileGlobal portProfileGlobal = new PortProfileGlobal();
        final PortProfile portProfile = new PortProfile();
        portProfile.setName(Constants.PORT_PROFILE_NAME_PREFIX + networkId);
        final Static staticObj = new Static();
        staticObj.setMacAddress(macAddress);
        portProfile.setStatic(staticObj);
        portProfileGlobal.setPortProfile(portProfile);

        //associates a mac address to a port-profile
        return executeUpdateObject(portProfileGlobal, Constants.URI);
    }

    /*
     * Disassociates a MAC address from virtual network.
     */
    public boolean disassociateMacFromNetwork(long networkId, String macAddress) throws BrocadeVcsApiException {

        final PortProfileGlobal portProfileGlobal = new PortProfileGlobal();
        final PortProfile portProfile = new PortProfile();
        portProfile.setName(Constants.PORT_PROFILE_NAME_PREFIX + networkId);
        final Static staticObj = new Static();
        staticObj.setOperation(""delete"");
        staticObj.setMacAddress(macAddress);
        portProfile.setStatic(staticObj);
        portProfileGlobal.setPortProfile(portProfile);

        //associates a mac address to a port-profile
        return executeUpdateObject(portProfileGlobal, Constants.URI);
    }

    /*
     * Deletes a new virtual network.
     */
    public boolean deleteNetwork(int vlanId, long networkId) throws BrocadeVcsApiException {

        if (deactivatePortProfile(networkId)) {

            if (deletePortProfile(networkId)) {
                return deleteInterfaceVlan(vlanId);
            }
        }
        return false;
    }

    /*
     * Deletes a vlan interface.
     */
    private boolean deleteInterfaceVlan(int vlanId) throws BrocadeVcsApiException {
        final InterfaceVlan interfaceVlan = new InterfaceVlan();
        final Interface interfaceObj = new Interface();
        final Vlan vlan = new Vlan();
        vlan.setOperation(""delete"");
        vlan.setName(vlanId);
        interfaceObj.setVlan(vlan);
        interfaceVlan.setInterface(interfaceObj);

        return executeUpdateObject(interfaceVlan, Constants.URI);

    }

    /*
     * Deactivates a port-profile.
     */
    private boolean deactivatePortProfile(long networkId) throws BrocadeVcsApiException {
        final PortProfileGlobal portProfileGlobal = new PortProfileGlobal();
        final PortProfile portProfile = new PortProfile();
        portProfile.setName(Constants.PORT_PROFILE_NAME_PREFIX + networkId);
        final Activate activate = new Activate();
        activate.setOperation(""delete"");
        portProfile.setActivate(activate);
        portProfileGlobal.setPortProfile(portProfile);

        //activate port-profile
        return executeUpdateObject(portProfileGlobal, Constants.URI);
    }

    /*
     *  Deletes AMPP port-profile.
     */
    private boolean deletePortProfile(long networkId) throws BrocadeVcsApiException {

        final PortProfile portProfile = new PortProfile();
        portProfile.setName(Constants.PORT_PROFILE_NAME_PREFIX + networkId);
        portProfile.setOperation(""delete"");
        //deletes port-profile
        return executeUpdateObject(portProfile, Constants.URI);
    }

    protected <T> boolean executeUpdateObject(T newObject, String uri) throws BrocadeVcsApiException {

        final boolean result = true;

        if (_host == null || _host.isEmpty() || _adminuser == null || _adminuser.isEmpty() || _adminpass == null || _adminpass.isEmpty()) {
            throw new BrocadeVcsApiException(""Hostname/credentials are null or empty"");
        }

        final HttpPatch pm = (HttpPatch)createMethod(""patch"", uri);
        pm.setHeader(""Accept"", ""application/vnd.configuration.resource+xml"");

        pm.setEntity(new StringEntity(convertToString(newObject), ContentType.APPLICATION_XML));

        final HttpResponse response = executeMethod(pm);

        if (response.getStatusLine().getStatusCode() != HttpStatus.SC_NO_CONTENT) {

            String errorMessage;
            try {
                errorMessage = responseToErrorMessage(response);
            } catch (final IOException e) {
                s_logger.error(""Failed to update object : "" + e.getMessage());
                throw new BrocadeVcsApiException(""Failed to update object : "" + e.getMessage());
            }

            pm.releaseConnection();
            s_logger.error(""Failed to update object : "" + errorMessage);
            throw new BrocadeVcsApiException(""Failed to update object : "" + errorMessage);
        }

        pm.releaseConnection();

        return result;
    }

    protected <T> String convertToString(T object) throws BrocadeVcsApiException {

        final StringWriter stringWriter = new StringWriter();

        try {
            final JAXBContext context = JAXBContext.newInstance(object.getClass());
            final Marshaller marshaller = context.createMarshaller();

            marshaller.marshal(object, stringWriter);

        } catch (final JAXBException e) {
            s_logger.error(""Failed to convert object to string : "" + e.getMessage());
            throw new BrocadeVcsApiException(""Failed to convert object to string : "" + e.getMessage());
        }

        final String str = stringWriter.toString();
        s_logger.info(str);

        return str;

    }

    protected Output convertToXML(String object) throws BrocadeVcsApiException {

        Output output = null;
        try {
            final JAXBContext context = JAXBContext.newInstance(Output.class);

            final StringReader reader = new StringReader(object);

            final Unmarshaller unmarshaller = context.createUnmarshaller();
            final Object result = unmarshaller.unmarshal(reader);

            if (result instanceof Output) {
                output = (Output)result;
                s_logger.info(output);
            }

        } catch (final JAXBException e) {
            s_logger.error(""Failed to convert string to object : "" + e.getMessage());
            throw new BrocadeVcsApiException(""Failed to convert string to object : "" + e.getMessage());
        }

        return output;

    }

    protected <T> boolean executeCreateObject(T newObject, String uri) throws BrocadeVcsApiException {
        if (_host == null || _host.isEmpty() || _adminuser == null || _adminuser.isEmpty() || _adminpass == null || _adminpass.isEmpty()) {
            throw new BrocadeVcsApiException(""Hostname/credentials are null or empty"");
        }

        final boolean result = true;
        final HttpPost pm = (HttpPost)createMethod(""post"", uri);
        pm.setHeader(""Accept"", ""application/vnd.configuration.resource+xml"");
        pm.setEntity(new StringEntity(convertToString(newObject), ContentType.APPLICATION_XML));

        final HttpResponse response = executeMethod(pm);

        if (response.getStatusLine().getStatusCode() != HttpStatus.SC_CREATED) {

            String errorMessage;
            try {
                errorMessage = responseToErrorMessage(response);
            } catch (final IOException e) {
                s_logger.error(""Failed to create object : "" + e.getMessage());
                throw new BrocadeVcsApiException(""Failed to create object : "" + e.getMessage());
            }

            pm.releaseConnection();
            s_logger.error(""Failed to create object : "" + errorMessage);
            throw new BrocadeVcsApiException(""Failed to create object : "" + errorMessage);
        }

        pm.releaseConnection();

        return result;
    }

    protected Output executeRetreiveStatus(String uri) throws BrocadeVcsApiException {
        if (_host == null || _host.isEmpty() || _adminuser == null || _adminuser.isEmpty() || _adminpass == null || _adminpass.isEmpty()) {
            throw new BrocadeVcsApiException(""Hostname/credentials are null or empty"");
        }

        String readLine = null;
        StringBuffer sb = null;

        final HttpPost pm = (HttpPost)createMethod(""post"", uri);
        pm.setHeader(""Accept"", ""application/vnd.operational-state.resource+xml"");
        pm.setEntity(new StringEntity(""<show-vcs></show-vcs>"", ContentType.APPLICATION_XML));

        final HttpResponse response = executeMethod(pm);

        if (response.getStatusLine().getStatusCode() != HttpStatus.SC_OK) {

            String errorMessage;
            try {
                errorMessage = responseToErrorMessage(response);
            } catch (final IOException e) {
                s_logger.error(""Failed to retreive status : "" + e.getMessage());
                throw new BrocadeVcsApiException(""Failed to retreive status : "" + e.getMessage());
            }

            pm.releaseConnection();
            s_logger.error(""Failed to retreive status : "" + errorMessage);
            throw new BrocadeVcsApiException(""Failed to retreive status : "" + errorMessage);
        }

        try (BufferedReader br = new BufferedReader(new InputStreamReader(response.getEntity().getContent(), Charset.forName(""UTF-8"")))) {
            sb = new StringBuffer();

            while ((readLine = br.readLine()) != null) {
                s_logger.debug(readLine);
                sb.append(readLine);

            }
        } catch (final Exception e) {
            s_logger.error(""Failed to retreive status : "" + e.getMessage());
            throw new BrocadeVcsApiException(""Failed to retreive status : "" + e.getMessage());
        }

        pm.releaseConnection();

        return convertToXML(sb.toString());
    }

    protected void executeDeleteObject(String uri) throws BrocadeVcsApiException {
        if (_host == null || _host.isEmpty() || _adminuser == null || _adminuser.isEmpty() || _adminpass == null || _adminpass.isEmpty()) {
            throw new BrocadeVcsApiException(""Hostname/credentials are null or empty"");
        }

        final HttpDelete dm = (HttpDelete)createMethod(""delete"", uri);
        dm.setHeader(""Accept"", ""application/vnd.configuration.resource+xml"");

        final HttpResponse response = executeMethod(dm);

        if (response.getStatusLine().getStatusCode() != HttpStatus.SC_NO_CONTENT) {

            String errorMessage;
            try {
                errorMessage = responseToErrorMessage(response);
            } catch (final IOException e) {
                s_logger.error(""Failed to delete object : "" + e.getMessage());
                throw new BrocadeVcsApiException(""Failed to delete object : "" + e.getMessage());
            }

            dm.releaseConnection();
            s_logger.error(""Failed to delete object : "" + errorMessage);
            throw new BrocadeVcsApiException(""Failed to delete object : "" + errorMessage);
        }
        dm.releaseConnection();
    }

    protected HttpResponse executeMethod(HttpRequestBase method) throws BrocadeVcsApiException {
        HttpResponse response = null;
        try {
            response = _client.execute(method);
            if (response.getStatusLine().getStatusCode() == HttpStatus.SC_UNAUTHORIZED) {
                method.releaseConnection();
                response = _client.execute(method);
            }
        } catch (final IOException e) {
            s_logger.error(""IOException caught while trying to connect to the Brocade Switch"", e);
            method.releaseConnection();
            throw new BrocadeVcsApiException(""API call to Brocade Switch Failed"", e);
        }

        return response;
    }

    private String responseToErrorMessage(HttpResponse response) throws IOException {

        if (""text/html"".equals(response.getEntity().getContentType().getValue())) {

            try (BufferedReader rd = new BufferedReader(new InputStreamReader(response.getEntity().getContent(), Charset.forName(""UTF-8"")))) {

                final StringBuffer result = new StringBuffer();
                String line = """";
                while ((line = rd.readLine()) != null) {
                    result.append(line);
                }
                return result.toString();
            }
        }
        return null;
    }

}
",blob
1411,"    public void validateDepositDetailForUpdate(final JsonElement element, final FromJsonHelper fromApiJsonHelper,
            final DataValidatorBuilder baseDataValidator) {
        if (fromApiJsonHelper.parameterExists(nameParamName, element)) {
            final String name = fromApiJsonHelper.extractStringNamed(nameParamName, element);
            baseDataValidator.reset().parameter(nameParamName).value(name).notBlank().notExceedingLengthOf(100);
        }

        if (fromApiJsonHelper.parameterExists(shortNameParamName, element)) {
            final String shortName = fromApiJsonHelper.extractStringNamed(shortNameParamName, element);
            baseDataValidator.reset().parameter(shortNameParamName).value(shortName).notBlank().notExceedingLengthOf(4);
        }

        if (fromApiJsonHelper.parameterExists(descriptionParamName, element)) {
            final String description = fromApiJsonHelper.extractStringNamed(descriptionParamName, element);
            baseDataValidator.reset().parameter(descriptionParamName).value(description).notBlank().notExceedingLengthOf(500);
        }

        if (fromApiJsonHelper.parameterExists(currencyCodeParamName, element)) {
            final String currencyCode = fromApiJsonHelper.extractStringNamed(currencyCodeParamName, element);
            baseDataValidator.reset().parameter(currencyCodeParamName).value(currencyCode).notBlank();
        }

        if (fromApiJsonHelper.parameterExists(digitsAfterDecimalParamName, element)) {
            final Integer digitsAfterDecimal = fromApiJsonHelper.extractIntegerSansLocaleNamed(digitsAfterDecimalParamName, element);
            baseDataValidator.reset().parameter(digitsAfterDecimalParamName).value(digitsAfterDecimal).notNull().inMinMaxRange(0, 6);
        }

        if (fromApiJsonHelper.parameterExists(inMultiplesOfParamName, element)) {
            final Integer inMultiplesOf = fromApiJsonHelper.extractIntegerNamed(inMultiplesOfParamName, element, Locale.getDefault());
            baseDataValidator.reset().parameter(inMultiplesOfParamName).value(inMultiplesOf).ignoreIfNull().integerZeroOrGreater();
        }

        if (fromApiJsonHelper.parameterExists(nominalAnnualInterestRateParamName, element)) {
            final BigDecimal interestRate = fromApiJsonHelper.extractBigDecimalWithLocaleNamed(nominalAnnualInterestRateParamName, element);
            baseDataValidator.reset().parameter(nominalAnnualInterestRateParamName).value(interestRate).notNull().zeroOrPositiveAmount();
        }

        if (fromApiJsonHelper.parameterExists(interestCompoundingPeriodTypeParamName, element)) {
            final Integer interestCompoundingPeriodType = fromApiJsonHelper.extractIntegerSansLocaleNamed(
                    interestCompoundingPeriodTypeParamName, element);
            baseDataValidator.reset().parameter(interestCompoundingPeriodTypeParamName).value(interestCompoundingPeriodType).notNull()
                    .isOneOfTheseValues(SavingsCompoundingInterestPeriodType.integerValues());
        }

        if (fromApiJsonHelper.parameterExists(interestCalculationTypeParamName, element)) {
            final Integer interestCalculationType = fromApiJsonHelper.extractIntegerSansLocaleNamed(interestCalculationTypeParamName,
                    element);
            baseDataValidator.reset().parameter(interestCalculationTypeParamName).value(interestCalculationType).notNull()
                    .inMinMaxRange(1, 2);
        }

        if (fromApiJsonHelper.parameterExists(interestCalculationDaysInYearTypeParamName, element)) {
            final Integer interestCalculationDaysInYearType = fromApiJsonHelper.extractIntegerSansLocaleNamed(
                    interestCalculationDaysInYearTypeParamName, element);
            baseDataValidator.reset().parameter(interestCalculationDaysInYearTypeParamName).value(interestCalculationDaysInYearType)
                    .notNull().isOneOfTheseValues(360, 365);
        }

        if (fromApiJsonHelper.parameterExists(minRequiredOpeningBalanceParamName, element)) {
            final BigDecimal minOpeningBalance = fromApiJsonHelper.extractBigDecimalWithLocaleNamed(minRequiredOpeningBalanceParamName,
                    element);
            baseDataValidator.reset().parameter(minRequiredOpeningBalanceParamName).value(minOpeningBalance).ignoreIfNull()
                    .zeroOrPositiveAmount();
        }

        if (fromApiJsonHelper.parameterExists(lockinPeriodFrequencyParamName, element)) {
            final Integer lockinPeriodFrequency = fromApiJsonHelper.extractIntegerWithLocaleNamed(lockinPeriodFrequencyParamName, element);
            baseDataValidator.reset().parameter(lockinPeriodFrequencyParamName).value(lockinPeriodFrequency).ignoreIfNull()
                    .integerZeroOrGreater();
        }

        if (fromApiJsonHelper.parameterExists(lockinPeriodFrequencyTypeParamName, element)) {
            final Integer lockinPeriodFrequencyType = fromApiJsonHelper.extractIntegerSansLocaleNamed(lockinPeriodFrequencyTypeParamName,
                    element);
            baseDataValidator.reset().parameter(lockinPeriodFrequencyTypeParamName).value(lockinPeriodFrequencyType).inMinMaxRange(0, 3);
        }

        if (fromApiJsonHelper.parameterExists(withdrawalFeeForTransfersParamName, element)) {
            final Boolean isWithdrawalFeeApplicableForTransfers = fromApiJsonHelper.extractBooleanNamed(withdrawalFeeForTransfersParamName,
                    element);
            baseDataValidator.reset().parameter(withdrawalFeeForTransfersParamName).value(isWithdrawalFeeApplicableForTransfers)
                    .ignoreIfNull().validateForBooleanValue();
        }

        if (fromApiJsonHelper.parameterExists(feeAmountParamName, element)) {
            final BigDecimal annualFeeAmount = fromApiJsonHelper.extractBigDecimalWithLocaleNamed(feeAmountParamName, element);
            baseDataValidator.reset().parameter(feeAmountParamName).value(annualFeeAmount).ignoreIfNull().zeroOrPositiveAmount();
        }

        if (fromApiJsonHelper.parameterExists(feeOnMonthDayParamName, element)) {
            final MonthDay monthDayOfAnnualFee = fromApiJsonHelper.extractMonthDayNamed(feeOnMonthDayParamName, element);
            baseDataValidator.reset().parameter(feeOnMonthDayParamName).value(monthDayOfAnnualFee).ignoreIfNull();
        }

        if (this.fromApiJsonHelper.parameterExists(minBalanceForInterestCalculationParamName, element)) {
            final BigDecimal minBalanceForInterestCalculation = this.fromApiJsonHelper.extractBigDecimalWithLocaleNamed(
                    minBalanceForInterestCalculationParamName, element);
            baseDataValidator.reset().parameter(minBalanceForInterestCalculationParamName).value(minBalanceForInterestCalculation)
                    .ignoreIfNull().zeroOrPositiveAmount();
        }

        final Long savingsControlAccountId = fromApiJsonHelper.extractLongNamed(
                SAVINGS_PRODUCT_ACCOUNTING_PARAMS.SAVINGS_CONTROL.getValue(), element);
        baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.SAVINGS_CONTROL.getValue()).value(savingsControlAccountId)
                .ignoreIfNull().integerGreaterThanZero();

        final Long savingsReferenceAccountId = fromApiJsonHelper.extractLongNamed(
                SAVINGS_PRODUCT_ACCOUNTING_PARAMS.SAVINGS_REFERENCE.getValue(), element);
        baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.SAVINGS_REFERENCE.getValue())
                .value(savingsReferenceAccountId).ignoreIfNull().integerGreaterThanZero();

        final Long transfersInSuspenseAccountId = fromApiJsonHelper.extractLongNamed(
                SAVINGS_PRODUCT_ACCOUNTING_PARAMS.TRANSFERS_SUSPENSE.getValue(), element);
        baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.TRANSFERS_SUSPENSE.getValue())
                .value(transfersInSuspenseAccountId).ignoreIfNull().integerGreaterThanZero();

        final Long interestOnSavingsAccountId = fromApiJsonHelper.extractLongNamed(
                SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INTEREST_ON_SAVINGS.getValue(), element);
        baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INTEREST_ON_SAVINGS.getValue())
                .value(interestOnSavingsAccountId).ignoreIfNull().integerGreaterThanZero();

        final Long incomeFromFeeId = fromApiJsonHelper.extractLongNamed(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INCOME_FROM_FEES.getValue(),
                element);
        baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INCOME_FROM_FEES.getValue()).value(incomeFromFeeId)
                .ignoreIfNull().integerGreaterThanZero();

        final Long incomeFromPenaltyId = fromApiJsonHelper.extractLongNamed(
                SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INCOME_FROM_PENALTIES.getValue(), element);
        baseDataValidator.reset().parameter(SAVINGS_PRODUCT_ACCOUNTING_PARAMS.INCOME_FROM_PENALTIES.getValue()).value(incomeFromPenaltyId)
                .ignoreIfNull().integerGreaterThanZero();

        validatePaymentChannelFundSourceMappings(fromApiJsonHelper, baseDataValidator, element);
        validateChargeToIncomeAccountMappings(fromApiJsonHelper, baseDataValidator, element);
        validateTaxWithHoldingParams(baseDataValidator, element, false);
    }
",feature envy
562,"public class TupleImpl extends IndifferentAccessMap implements Seqable, Indexed, IMeta, Tuple {
    private List<Object> values;
    private int taskId;
    private String streamId;
    private GeneralTopologyContext context;
    private MessageId id;
    private IPersistentMap _meta = null;
    Long _processSampleStartTime = null;
    Long _executeSampleStartTime = null;
    long _outAckVal = 0;

    public TupleImpl() {
    }

    public TupleImpl(GeneralTopologyContext context, List<Object> values, int taskId, String streamId, MessageId id) {
        this.values = values;
        this.taskId = taskId;
        this.streamId = streamId;
        this.id = id;
        this.context = context;

        /*
        String componentId = context.getComponentId(taskId);
        Fields schema = context.getComponentOutputFields(componentId, streamId);
        if (values.size() != schema.size()) {
            throw new IllegalArgumentException(""Tuple created with wrong number of fields. "" + ""Expected "" + schema.size() + "" fields but got "" + values.size()
                    + "" fields"");
        }*/
    }

    public TupleImpl(GeneralTopologyContext context, List<Object> values, int taskId, String streamId) {
        this(context, values, taskId, streamId, MessageId.makeUnanchored());
    }

    public void setProcessSampleStartTime(long ms) {
        _processSampleStartTime = ms;
    }

    public Long getProcessSampleStartTime() {
        return _processSampleStartTime;
    }

    public void setExecuteSampleStartTime(long ms) {
        _executeSampleStartTime = ms;
    }

    public Long getExecuteSampleStartTime() {
        return _executeSampleStartTime;
    }

    public void updateAckVal(long val) {
        _outAckVal = _outAckVal ^ val;
    }

    public long getAckVal() {
        return _outAckVal;
    }

    public int size() {
        return values.size();
    }

    public int fieldIndex(String field) {
        return getFields().fieldIndex(field);
    }

    public boolean contains(String field) {
        return getFields().contains(field);
    }

    public Object getValue(int i) {
        return values.get(i);
    }

    public String getString(int i) {
        return (String) values.get(i);
    }

    public Integer getInteger(int i) {
        return (Integer) values.get(i);
    }

    public Long getLong(int i) {
        return (Long) values.get(i);
    }

    public Boolean getBoolean(int i) {
        return (Boolean) values.get(i);
    }

    public Short getShort(int i) {
        return (Short) values.get(i);
    }

    public Byte getByte(int i) {
        return (Byte) values.get(i);
    }

    public Double getDouble(int i) {
        return (Double) values.get(i);
    }

    public Float getFloat(int i) {
        return (Float) values.get(i);
    }

    public byte[] getBinary(int i) {
        return (byte[]) values.get(i);
    }

    public Object getValueByField(String field) {
        return values.get(fieldIndex(field));
    }

    public String getStringByField(String field) {
        return (String) values.get(fieldIndex(field));
    }

    public Integer getIntegerByField(String field) {
        return (Integer) values.get(fieldIndex(field));
    }

    public Long getLongByField(String field) {
        return (Long) values.get(fieldIndex(field));
    }

    public Boolean getBooleanByField(String field) {
        return (Boolean) values.get(fieldIndex(field));
    }

    public Short getShortByField(String field) {
        return (Short) values.get(fieldIndex(field));
    }

    public Byte getByteByField(String field) {
        return (Byte) values.get(fieldIndex(field));
    }

    public Double getDoubleByField(String field) {
        return (Double) values.get(fieldIndex(field));
    }

    public Float getFloatByField(String field) {
        return (Float) values.get(fieldIndex(field));
    }

    public byte[] getBinaryByField(String field) {
        return (byte[]) values.get(fieldIndex(field));
    }

    public List<Object> getValues() {
        return values;
    }

    public Fields getFields() {
        return context.getComponentOutputFields(getSourceComponent(), getSourceStreamId());
    }

    public List<Object> select(Fields selector) {
        return getFields().select(selector, values);
    }

    public GlobalStreamId getSourceGlobalStreamid() {
        return new GlobalStreamId(getSourceComponent(), streamId);
    }

    public String getSourceComponent() {
        return context.getComponentId(taskId);
    }

    public int getSourceTask() {
        return taskId;
    }

    public String getSourceStreamId() {
        return streamId;
    }

    public MessageId getMessageId() {
        return id;
    }

    @Override
    public String toString() {
        return ""source: "" + getSourceComponent() + "":"" + taskId + "", stream: "" + streamId + "", id: "" + id.toString() + "", "" + values.toString();
    }

    @Override
    public boolean equals(Object other) {
        return this == other;
    }

    @Override
    public int hashCode() {
        return System.identityHashCode(this);
    }

    private Keyword makeKeyword(String name) {
        return Keyword.intern(Symbol.create(name));
    }

    /* ILookup */
    @Override
    public Object valAt(Object o) {
        try {
            if (o instanceof Keyword) {
                return getValueByField(((Keyword) o).getName());
            } else if (o instanceof String) {
                return getValueByField((String) o);
            }
        } catch (IllegalArgumentException ignored) {
        }
        return null;
    }

    /* Seqable */
    public ISeq seq() {
        if (values.size() > 0) {
            return new Seq(getFields().toList(), values, 0);
        }
        return null;
    }

    static class Seq extends ASeq implements Counted {
        final List<String> fields;
        final List<Object> values;
        final int i;

        Seq(List<String> fields, List<Object> values, int i) {
            this.fields = fields;
            this.values = values;
            assert i >= 0;
            this.i = i;
        }

        public Seq(IPersistentMap meta, List<String> fields, List<Object> values, int i) {
            super(meta);
            this.fields = fields;
            this.values = values;
            assert i >= 0;
            this.i = i;
        }

        public Object first() {
            return new MapEntry(fields.get(i), values.get(i));
        }

        public ISeq next() {
            if (i + 1 < fields.size()) {
                return new Seq(fields, values, i + 1);
            }
            return null;
        }

        public int count() {
            assert fields.size() - i >= 0 : ""index out of bounds"";
            // i being the position in the fields of this seq, the remainder of the seq is the size
            return fields.size() - i;
        }

        public Obj withMeta(IPersistentMap meta) {
            return new Seq(meta, fields, values, i);
        }
    }

    /* Indexed */
    public Object nth(int i) {
        if (i < values.size()) {
            return values.get(i);
        } else {
            return null;
        }
    }

    public Object nth(int i, Object notfound) {
        Object ret = nth(i);
        if (ret == null)
            ret = notfound;
        return ret;
    }

    /* Counted */
    public int count() {
        return values.size();
    }

    /* IMeta */
    public IPersistentMap meta() {
        if (_meta == null) {
            _meta = new PersistentArrayMap(new Object[]{makeKeyword(""stream""), getSourceStreamId(),
                    makeKeyword(""component""), getSourceComponent(), makeKeyword(""task""), getSourceTask()});
        }
        return _meta;
    }

    private PersistentArrayMap toMap() {
        Object array[] = new Object[values.size() * 2];
        List<String> fields = getFields().toList();
        for (int i = 0; i < values.size(); i++) {
            array[i * 2] = fields.get(i);
            array[(i * 2) + 1] = values.get(i);
        }
        return new PersistentArrayMap(array);
    }

    public IPersistentMap getMap() {
        if (_map == null) {
            setMap(toMap());
        }
        return _map;
    }

    public void setTopologyContext(GeneralTopologyContext context) {
        this.context = context;
    }

    public GeneralTopologyContext getTopologyContext() {
        return context;
    }
}
",data class
466,"    @XmlRootElement(name = ""header"")
    @XmlAccessorType(XmlAccessType.FIELD)
    public static class Header {

        @XmlAttribute
        private String key;

        @XmlAttribute
        private String type;

        @XmlValue
        private String value;

        public String getKey() {
            return key;
        }

        public void setKey(String key) {
            this.key = key;
        }

        public String getType() {
            return type;
        }

        public void setType(String type) {
            this.type = type;
        }

        public String getValue() {
            return value;
        }

        public void setValue(String value) {
            this.value = value;
        }
    }
",data class
842,"  @Override
  public java.lang.String toString() {
    java.lang.StringBuilder sb = new java.lang.StringBuilder(""SupervisorInfo("");
    boolean first = true;

    sb.append(""time_secs:"");
    sb.append(this.time_secs);
    first = false;
    if (!first) sb.append("", "");
    sb.append(""hostname:"");
    if (this.hostname == null) {
      sb.append(""null"");
    } else {
      sb.append(this.hostname);
    }
    first = false;
    if (is_set_assignment_id()) {
      if (!first) sb.append("", "");
      sb.append(""assignment_id:"");
      if (this.assignment_id == null) {
        sb.append(""null"");
      } else {
        sb.append(this.assignment_id);
      }
      first = false;
    }
    if (is_set_used_ports()) {
      if (!first) sb.append("", "");
      sb.append(""used_ports:"");
      if (this.used_ports == null) {
        sb.append(""null"");
      } else {
        sb.append(this.used_ports);
      }
      first = false;
    }
    if (is_set_meta()) {
      if (!first) sb.append("", "");
      sb.append(""meta:"");
      if (this.meta == null) {
        sb.append(""null"");
      } else {
        sb.append(this.meta);
      }
      first = false;
    }
    if (is_set_scheduler_meta()) {
      if (!first) sb.append("", "");
      sb.append(""scheduler_meta:"");
      if (this.scheduler_meta == null) {
        sb.append(""null"");
      } else {
        sb.append(this.scheduler_meta);
      }
      first = false;
    }
    if (is_set_uptime_secs()) {
      if (!first) sb.append("", "");
      sb.append(""uptime_secs:"");
      sb.append(this.uptime_secs);
      first = false;
    }
    if (is_set_version()) {
      if (!first) sb.append("", "");
      sb.append(""version:"");
      if (this.version == null) {
        sb.append(""null"");
      } else {
        sb.append(this.version);
      }
      first = false;
    }
    if (is_set_resources_map()) {
      if (!first) sb.append("", "");
      sb.append(""resources_map:"");
      if (this.resources_map == null) {
        sb.append(""null"");
      } else {
        sb.append(this.resources_map);
      }
      first = false;
    }
    if (is_set_server_port()) {
      if (!first) sb.append("", "");
      sb.append(""server_port:"");
      sb.append(this.server_port);
      first = false;
    }
    sb.append("")"");
    return sb.toString();
  }
",long method
968,"    private LdapComparator<?> classLoadComparator( SchemaManager schemaManager, String oid, String className,
        Attribute byteCode ) throws LdapException
    {
        // Try to class load the comparator
        LdapComparator<?> comparator;
        Class<?> clazz;
        String byteCodeStr = StringConstants.EMPTY;

        if ( byteCode == null )
        {
            try
            {
                clazz = Class.forName( className );
            }
            catch ( ClassNotFoundException cnfe )
            {
                LOG.error( I18n.err( I18n.ERR_16056_CANNOT_FIND_CMP_CTOR, className ) );
                throw new LdapSchemaException( I18n.err( I18n.ERR_16057_CANNOT_FIND_CMP_CLASS, cnfe.getMessage() ) );
            }
        }
        else
        {
            classLoader.setAttribute( byteCode );
            
            try
            {
                clazz = classLoader.loadClass( className );
            }
            catch ( ClassNotFoundException cnfe )
            {
                LOG.error( I18n.err( I18n.ERR_16058_CANNOT_LOAD_CMP_CTOR, className ) );
                throw new LdapSchemaException( I18n.err( I18n.ERR_16059_CANNOT_LOAD_CMP_CLASS, cnfe.getMessage() ) );
            }

            byteCodeStr = new String( Base64.encode( byteCode.getBytes() ) );
        }

        // Create the comparator instance. Either we have a no argument constructor,
        // or we have one which takes an OID. Lets try the one with an OID argument first
        try
        {
            Constructor<?> constructor = clazz.getConstructor( new Class[]
                { String.class } );
            
            try
            {
                comparator = ( LdapComparator<?> ) constructor.newInstance( oid );
            }
            catch ( InvocationTargetException ite )
            {
                LOG.error( I18n.err( I18n.ERR_16060_CANNOT_INVOKE_CMP_CTOR, className ) );
                throw new LdapSchemaException( I18n.err( I18n.ERR_16061_CANNOT_INVOKE_CMP_CLASS, ite.getMessage() ) );
            }
            catch ( InstantiationException ie )
            {
                LOG.error( I18n.err( I18n.ERR_16062_CANNOT_INST_CMP_CTOR_CLASS, className ) );
                throw new LdapSchemaException( I18n.err( I18n.ERR_16063_CANNOT_INST_CMP_CLASS, ie.getMessage() ) );
            }
            catch ( IllegalAccessException ie )
            {
                LOG.error( I18n.err( I18n.ERR_16064_CANNOT_ACCESS_CMP_CTOR, className ) );
                throw new LdapSchemaException( I18n.err( I18n.ERR_16065_CANNOT_ACCESS_CMP_CLASS, ie.getMessage() ) );
            }
        }
        catch ( NoSuchMethodException nsme )
        {
            // Ok, let's try with the constructor without argument.
            // In this case, we will have to check that the OID is the same than
            // the one we got in the Comparator entry
            try
            {
                clazz.getConstructor();
            }
            catch ( NoSuchMethodException nsme2 )
            {
                LOG.error( I18n.err( I18n.ERR_16066_CANNOT_FIND_CMP_CTOR_METH_CLASS, className ) );
                throw new LdapSchemaException( I18n.err( I18n.ERR_16067_CANNOT_FIND_CMP_CTOR_METH, nsme2.getMessage() ) );
            }
            
            try
            { 
                comparator = ( LdapComparator<?> ) clazz.newInstance();
            }
            catch ( InstantiationException ie )
            {
                LOG.error( I18n.err( I18n.ERR_16062_CANNOT_INST_CMP_CTOR_CLASS, className ) );
                throw new LdapSchemaException( I18n.err( I18n.ERR_16063_CANNOT_INST_CMP_CLASS, ie.getMessage() ) );
            }
            catch ( IllegalAccessException iae )
            {
                LOG.error( I18n.err( I18n.ERR_16064_CANNOT_ACCESS_CMP_CTOR, className ) );
                throw new LdapSchemaException( I18n.err( I18n.ERR_16065_CANNOT_ACCESS_CMP_CLASS, iae.getMessage() ) );
            }

            if ( !comparator.getOid().equals( oid ) )
            {
                String msg = I18n.err( I18n.ERR_16021_DIFFERENT_COMPARATOR_OID, oid, comparator.getOid() );
                throw new LdapInvalidAttributeValueException( ResultCodeEnum.UNWILLING_TO_PERFORM, msg, nsme );
            }
        }

        // Update the loadable fields
        comparator.setBytecode( byteCodeStr );
        comparator.setFqcn( className );

        // Inject the SchemaManager for the comparator who needs it
        comparator.setSchemaManager( schemaManager );

        return comparator;
    }
",long method
1263,"public class TezClientUtils {

  private static Log LOG = LogFactory.getLog(TezClientUtils.class);
  private static final int UTF8_CHUNK_SIZE = 16 * 1024;

  /**
   * Setup LocalResource map for Tez jars based on provided Configuration
   * 
   * @param conf
   *          Configuration to use to access Tez jars' locations
   * @param credentials
   *          a credentials instance into which tokens for the Tez local
   *          resources will be populated
   * @return Map of LocalResources to use when launching Tez AM
   * @throws IOException
   */
  static Map<String, LocalResource> setupTezJarsLocalResources(
      TezConfiguration conf, Credentials credentials)
      throws IOException {
    Preconditions.checkNotNull(credentials, ""A non-null credentials object should be specified"");
    Map<String, LocalResource> tezJarResources = new HashMap<String, LocalResource>();

    if (conf.getBoolean(TezConfiguration.TEZ_IGNORE_LIB_URIS, false)){
      LOG.info(""Ignoring '"" + TezConfiguration.TEZ_LIB_URIS + ""' since  '"" + 
            TezConfiguration.TEZ_IGNORE_LIB_URIS + ""' is set to true"");
    } else {
      // Add tez jars to local resource
      String[] tezJarUris = conf.getStrings(TezConfiguration.TEZ_LIB_URIS);
        
      if (tezJarUris == null || tezJarUris.length == 0) {
        throw new TezUncheckedException(""Invalid configuration of tez jars""
            + "", "" + TezConfiguration.TEZ_LIB_URIS
            + "" is not defined in the configurartion"");
      }
     
      List<Path> tezJarPaths = Lists.newArrayListWithCapacity(tezJarUris.length);

      for (String tezJarUri : tezJarUris) {
        URI uri;
        try {
          uri = new URI(tezJarUri.trim());
        } catch (URISyntaxException e) {
          String message = ""Invalid URI defined in configuration for""
              + "" location of TEZ jars. providedURI="" + tezJarUri;
          LOG.error(message);
          throw new TezUncheckedException(message, e);
        }
        if (!uri.isAbsolute()) {
          String message = ""Non-absolute URI defined in configuration for""
              + "" location of TEZ jars. providedURI="" + tezJarUri;
          LOG.error(message);
          throw new TezUncheckedException(message);
        }
        Path p = new Path(uri);
        FileSystem pathfs = p.getFileSystem(conf);
        p = pathfs.makeQualified(p);
        tezJarPaths.add(p);
        RemoteIterator<LocatedFileStatus> iter = pathfs.listFiles(p, false);
        while (iter.hasNext()) {
          LocatedFileStatus fStatus = iter.next();
          String rsrcName = fStatus.getPath().getName();
          // FIXME currently not checking for duplicates due to quirks
          // in assembly generation
          if (tezJarResources.containsKey(rsrcName)) {
            String message = ""Duplicate resource found""
                + "", resourceName="" + rsrcName
                + "", existingPath="" +
                tezJarResources.get(rsrcName).getResource().toString()
                + "", newPath="" + fStatus.getPath();
            LOG.warn(message);
            // throw new TezUncheckedException(message);
          }
          tezJarResources.put(rsrcName,
              LocalResource.newInstance(
                  ConverterUtils.getYarnUrlFromPath(fStatus.getPath()),
                  LocalResourceType.FILE,
                  LocalResourceVisibility.PUBLIC,
                  fStatus.getLen(),
                  fStatus.getModificationTime()));
        }
      }
      
      if (tezJarResources.isEmpty()) {
        throw new TezUncheckedException(
            ""No files found in locations specified in ""
                + TezConfiguration.TEZ_LIB_URIS + "" . Locations: ""
                + StringUtils.join(tezJarUris, ','));
      } else {
        // Obtain credentials.
        TokenCache.obtainTokensForFileSystems(credentials,
            tezJarPaths.toArray(new Path[tezJarPaths.size()]), conf);
      }
    }
   
    return tezJarResources;
  }

  static void processTezLocalCredentialsFile(Credentials credentials, Configuration conf)
      throws IOException {
    String path = conf.get(TezJobConfig.TEZ_CREDENTIALS_PATH);
    if (path == null) {
      return;
    } else {
      TokenCache.mergeBinaryTokens(credentials, conf, path);
    }
  }

  /**
   * Verify or create the Staging area directory on the configured Filesystem
   * @param stagingArea Staging area directory path
   * @return the FileSytem for the staging area directory
   * @throws IOException
   */
  public static FileSystem ensureStagingDirExists(Configuration conf,
      Path stagingArea)
      throws IOException {
    FileSystem fs = stagingArea.getFileSystem(conf);
    String realUser;
    String currentUser;
    UserGroupInformation ugi = UserGroupInformation.getLoginUser();
    realUser = ugi.getShortUserName();
    currentUser = UserGroupInformation.getCurrentUser().getShortUserName();
    if (fs.exists(stagingArea)) {
      FileStatus fsStatus = fs.getFileStatus(stagingArea);
      String owner = fsStatus.getOwner();
      if (!(owner.equals(currentUser) || owner.equals(realUser))) {
        throw new IOException(""The ownership on the staging directory ""
            + stagingArea + "" is not as expected. "" + ""It is owned by "" + owner
            + "". The directory must "" + ""be owned by the submitter ""
            + currentUser + "" or "" + ""by "" + realUser);
      }
      if (!fsStatus.getPermission().equals(TezCommonUtils.TEZ_AM_DIR_PERMISSION)) {
        LOG.info(""Permissions on staging directory "" + stagingArea + "" are ""
            + ""incorrect: "" + fsStatus.getPermission()
            + "". Fixing permissions "" + ""to correct value ""
            + TezCommonUtils.TEZ_AM_DIR_PERMISSION);
        fs.setPermission(stagingArea, TezCommonUtils.TEZ_AM_DIR_PERMISSION);
      }
    } else {
      TezCommonUtils.mkDirForAM(fs, stagingArea);
    }
    return fs;
  }

  /**
   * Obtains tokens for the DAG based on the list of URIs setup in the DAG. The
   * fetched credentials are populated back into the DAG and can be retrieved
   * via dag.getCredentials
   * 
   * @param dag
   *          the dag for which credentials need to be setup
   * @param sessionCredentials
   *          session credentials which have already been obtained, and will be
   *          required for the DAG
   * @param conf
   * @throws IOException
   */
  @Private
  static void setupDAGCredentials(DAG dag, Credentials sessionCredentials,
      Configuration conf) throws IOException {

    Preconditions.checkNotNull(sessionCredentials);
    LogUtils.logCredentials(LOG, sessionCredentials, ""session"");

    Credentials dagCredentials = dag.getCredentials();
    if (dagCredentials == null) {
      dagCredentials = new Credentials();
      dag.setCredentials(dagCredentials);
    }
    // All session creds are required for the DAG.
    dagCredentials.mergeAll(sessionCredentials);
    
    // Add additional credentials based on any URIs that the user may have specified.
    
    // Obtain Credentials for any paths that the user may have configured.
    Collection<URI> uris = dag.getURIsForCredentials();
    if (uris != null && !uris.isEmpty()) {
      Iterator<Path> pathIter = Iterators.transform(uris.iterator(), new Function<URI, Path>() {
        @Override
        public Path apply(URI input) {
          return new Path(input);
        }
      });

      Path[] paths = Iterators.toArray(pathIter, Path.class);
      TokenCache.obtainTokensForFileSystems(dagCredentials, paths, conf);
    }

    // Obtain Credentials for the local resources configured on the DAG
    try {
      Set<Path> lrPaths = new HashSet<Path>();
      for (Vertex v: dag.getVertices()) {
        for (LocalResource lr: v.getTaskLocalFiles().values()) {
          lrPaths.add(ConverterUtils.getPathFromYarnURL(lr.getResource()));
        }
      }

      Path[] paths = lrPaths.toArray(new Path[lrPaths.size()]);
      TokenCache.obtainTokensForFileSystems(dagCredentials, paths, conf);

    } catch (URISyntaxException e) {
      throw new IOException(e);
    }
  }

  /**
   * Create an ApplicationSubmissionContext to launch a Tez AM
   * @param conf TezConfiguration
   * @param appId Application Id
   * @param dag DAG to be submitted
   * @param amName Name for the application
   * @param amConfig AM Configuration
   * @param tezJarResources Resources to be used by the AM
   * @param sessionCreds the credential object which will be populated with session specific
   * @return an ApplicationSubmissionContext to launch a Tez AM
   * @throws IOException
   * @throws YarnException
   */
  static ApplicationSubmissionContext createApplicationSubmissionContext(
      TezConfiguration conf, ApplicationId appId, DAG dag, String amName,
      AMConfiguration amConfig, Map<String, LocalResource> tezJarResources,
      Credentials sessionCreds)
          throws IOException, YarnException{

    Preconditions.checkNotNull(sessionCreds);

    FileSystem fs = TezClientUtils.ensureStagingDirExists(conf,
        TezCommonUtils.getTezBaseStagingPath(conf));
    String strAppId = appId.toString();
    Path tezSysStagingPath = TezCommonUtils.createTezSystemStagingPath(conf, strAppId);
    Path binaryConfPath = TezCommonUtils.getTezConfStagingPath(tezSysStagingPath);
    binaryConfPath = fs.makeQualified(binaryConfPath);

    // Setup resource requirements
    Resource capability = Records.newRecord(Resource.class);
    capability.setMemory(
        amConfig.getTezConfiguration().getInt(TezConfiguration.TEZ_AM_RESOURCE_MEMORY_MB,
            TezConfiguration.TEZ_AM_RESOURCE_MEMORY_MB_DEFAULT));
    capability.setVirtualCores(
        amConfig.getTezConfiguration().getInt(TezConfiguration.TEZ_AM_RESOURCE_CPU_VCORES,
            TezConfiguration.TEZ_AM_RESOURCE_CPU_VCORES_DEFAULT));
    if (LOG.isDebugEnabled()) {
      LOG.debug(""AppMaster capability = "" + capability);
    }

    // Setup required Credentials for the AM launch. DAG specific credentials
    // are handled separately.
    ByteBuffer securityTokens = null;
    // Setup security tokens
    Credentials amLaunchCredentials = new Credentials();
    if (amConfig.getCredentials() != null) {
      amLaunchCredentials.addAll(amConfig.getCredentials());
    }

    // Add Staging dir creds to the list of session credentials.
    TokenCache.obtainTokensForFileSystems(sessionCreds, new Path[] {binaryConfPath}, conf);

    // Add session specific credentials to the AM credentials.
    amLaunchCredentials.mergeAll(sessionCreds);

    DataOutputBuffer dob = new DataOutputBuffer();
    amLaunchCredentials.writeTokenStorageToStream(dob);
    securityTokens = ByteBuffer.wrap(dob.getData(), 0, dob.getLength());

    // Need to set credentials based on DAG and the URIs which have been set for the DAG.

    if (dag != null) {
      setupDAGCredentials(dag, sessionCreds, conf);
    }

    // Setup the command to run the AM
    List<String> vargs = new ArrayList<String>(8);
    vargs.add(Environment.JAVA_HOME.$() + ""/bin/java"");

    String amOpts = amConfig.getTezConfiguration().get(
        TezConfiguration.TEZ_AM_LAUNCH_CMD_OPTS,
        TezConfiguration.TEZ_AM_LAUNCH_CMD_OPTS_DEFAULT);
    amOpts = maybeAddDefaultMemoryJavaOpts(amOpts, capability,
        amConfig.getTezConfiguration().getDouble(TezConfiguration.TEZ_CONTAINER_MAX_JAVA_HEAP_FRACTION,
            TezConfiguration.TEZ_CONTAINER_MAX_JAVA_HEAP_FRACTION_DEFAULT));
    vargs.add(amOpts);

    String amLogLevel = amConfig.getTezConfiguration().get(
        TezConfiguration.TEZ_AM_LOG_LEVEL,
        TezConfiguration.TEZ_AM_LOG_LEVEL_DEFAULT);
    maybeAddDefaultLoggingJavaOpts(amLogLevel, vargs);

    // FIX sun bug mentioned in TEZ-327
    vargs.add(""-Dsun.nio.ch.bugLevel=''"");

    vargs.add(TezConfiguration.TEZ_APPLICATION_MASTER_CLASS);
    if (dag == null) {
      vargs.add(""--"" + TezConstants.TEZ_SESSION_MODE_CLI_OPTION);
    }

    vargs.add(""1>"" + ApplicationConstants.LOG_DIR_EXPANSION_VAR +
        File.separator + ApplicationConstants.STDOUT);
    vargs.add(""2>"" + ApplicationConstants.LOG_DIR_EXPANSION_VAR +
        File.separator + ApplicationConstants.STDERR);


    Vector<String> vargsFinal = new Vector<String>(8);
    // Final command
    StringBuilder mergedCommand = new StringBuilder();
    for (CharSequence str : vargs) {
      mergedCommand.append(str).append("" "");
    }
    vargsFinal.add(mergedCommand.toString());

    if (LOG.isDebugEnabled()) {
      LOG.debug(""Command to launch container for ApplicationMaster is : ""
          + mergedCommand);
    }

    Map<String, String> environment = new TreeMap<String, String>();
    TezYARNUtils.setupDefaultEnv(environment, conf, TezConfiguration.TEZ_AM_LAUNCH_ENV,
        TezConfiguration.TEZ_AM_LAUNCH_ENV_DEFAULT);
    
    // finally apply env set in the code. This could potentially be removed in
    // TEZ-692
    if (amConfig.getEnv() != null) {
      for (Map.Entry<String, String> entry : amConfig.getEnv().entrySet()) {
        TezYARNUtils.addToEnvironment(environment, entry.getKey(),
            entry.getValue(), File.pathSeparator);
      }
    }
    
    Map<String, LocalResource> localResources =
        new TreeMap<String, LocalResource>();

    // Not fetching credentials for AMLocalResources. Expect this to be provided via AMCredentials.
    if (amConfig.getLocalResources() != null) {
      localResources.putAll(amConfig.getLocalResources());
    }
    localResources.putAll(tezJarResources);

    // emit conf as PB file
    Configuration finalTezConf = createFinalTezConfForApp(conf,
      amConfig.getTezConfiguration());
    
    FSDataOutputStream amConfPBOutBinaryStream = null;
    try {
      ConfigurationProto.Builder confProtoBuilder =
          ConfigurationProto.newBuilder();
      Iterator<Entry<String, String>> iter = finalTezConf.iterator();
      while (iter.hasNext()) {
        Entry<String, String> entry = iter.next();
        PlanKeyValuePair.Builder kvp = PlanKeyValuePair.newBuilder();
        kvp.setKey(entry.getKey());
        kvp.setValue(entry.getValue());
        confProtoBuilder.addConfKeyValues(kvp);
      }
      //binary output
      amConfPBOutBinaryStream = TezCommonUtils.createFileForAM(fs, binaryConfPath);
      confProtoBuilder.build().writeTo(amConfPBOutBinaryStream);
    } finally {
      if(amConfPBOutBinaryStream != null){
        amConfPBOutBinaryStream.close();
      }
    }

    LocalResource binaryConfLRsrc =
        TezClientUtils.createLocalResource(fs,
            binaryConfPath, LocalResourceType.FILE,
            LocalResourceVisibility.APPLICATION);
    localResources.put(TezConfiguration.TEZ_PB_BINARY_CONF_NAME,
        binaryConfLRsrc);

    // Create Session Jars definition to be sent to AM as a local resource
    Path sessionJarsPath = TezCommonUtils.getTezSessionJarStagingPath(tezSysStagingPath);
    FSDataOutputStream sessionJarsPBOutStream = null;
    try {
      Map<String, LocalResource> sessionJars =
        new HashMap<String, LocalResource>(tezJarResources.size() + 1);
      sessionJars.putAll(tezJarResources);
      sessionJars.put(TezConfiguration.TEZ_PB_BINARY_CONF_NAME,
        binaryConfLRsrc);
      DAGProtos.PlanLocalResourcesProto proto =
        DagTypeConverters.convertFromLocalResources(sessionJars);
      sessionJarsPBOutStream = TezCommonUtils.createFileForAM(fs, sessionJarsPath);
      proto.writeDelimitedTo(sessionJarsPBOutStream);
      
      // Write out the initial list of resources which will be available in the AM
      DAGProtos.PlanLocalResourcesProto amResourceProto;
      if (amConfig.getLocalResources() != null && !amConfig.getLocalResources().isEmpty()) {
        amResourceProto = DagTypeConverters.convertFromLocalResources(localResources);
      } else {
        amResourceProto = DAGProtos.PlanLocalResourcesProto.getDefaultInstance(); 
      }
      amResourceProto.writeDelimitedTo(sessionJarsPBOutStream);
    } finally {
      if (sessionJarsPBOutStream != null) {
        sessionJarsPBOutStream.close();
      }
    }

    LocalResource sessionJarsPBLRsrc =
      TezClientUtils.createLocalResource(fs,
        sessionJarsPath, LocalResourceType.FILE,
        LocalResourceVisibility.APPLICATION);
    localResources.put(
      TezConfiguration.TEZ_SESSION_LOCAL_RESOURCES_PB_FILE_NAME,
      sessionJarsPBLRsrc);

    if(dag != null) {

      for (Vertex v : dag.getVertices()) {
        if (tezJarResources != null) {
          v.getTaskLocalFiles().putAll(tezJarResources);
        }
        v.getTaskLocalFiles().put(TezConfiguration.TEZ_PB_BINARY_CONF_NAME,
            binaryConfLRsrc);

        Map<String, String> taskEnv = v.getTaskEnvironment();
        TezYARNUtils.setupDefaultEnv(taskEnv, conf,
            TezConfiguration.TEZ_TASK_LAUNCH_ENV,
            TezConfiguration.TEZ_TASK_LAUNCH_ENV_DEFAULT);

        TezClientUtils.setDefaultLaunchCmdOpts(v, amConfig.getTezConfiguration());
      }

      // emit protobuf DAG file style
      Path binaryPath = TezCommonUtils.getTezBinPlanStagingPath(tezSysStagingPath);
      if (LOG.isDebugEnabled()) {
        LOG.debug(""Stage directory information for AppId :"" + appId + "" tezSysStagingPath :""
            + tezSysStagingPath + "" binaryConfPath :"" + binaryConfPath + "" sessionJarsPath :""
            + sessionJarsPath + "" binaryPlanPath :"" + binaryPath);
      }
      amConfig.getTezConfiguration().set(TezConfiguration.TEZ_AM_PLAN_REMOTE_PATH,
          binaryPath.toUri().toString());

      DAGPlan dagPB = dag.createDag(null);

      FSDataOutputStream dagPBOutBinaryStream = null;

      try {
        //binary output
        dagPBOutBinaryStream = TezCommonUtils.createFileForAM(fs, binaryPath);
        dagPB.writeTo(dagPBOutBinaryStream);
      } finally {
        if(dagPBOutBinaryStream != null){
          dagPBOutBinaryStream.close();
        }
      }

      localResources.put(TezConfiguration.TEZ_PB_PLAN_BINARY_NAME,
        TezClientUtils.createLocalResource(fs,
          binaryPath, LocalResourceType.FILE,
          LocalResourceVisibility.APPLICATION));

      if (Level.DEBUG.isGreaterOrEqual(Level.toLevel(amLogLevel))) {
        Path textPath = localizeDagPlanAsText(dagPB, fs, amConfig, strAppId, tezSysStagingPath);
        localResources.put(TezConfiguration.TEZ_PB_PLAN_TEXT_NAME,
            TezClientUtils.createLocalResource(fs,
                textPath, LocalResourceType.FILE,
                LocalResourceVisibility.APPLICATION));
      }
    }
    Map<ApplicationAccessType, String> acls
        = new HashMap<ApplicationAccessType, String>();

    // Setup ContainerLaunchContext for AM container
    ContainerLaunchContext amContainer =
        ContainerLaunchContext.newInstance(localResources, environment,
            vargsFinal, null, securityTokens, acls);

    // Set up the ApplicationSubmissionContext
    ApplicationSubmissionContext appContext = Records
        .newRecord(ApplicationSubmissionContext.class);

    appContext.setApplicationType(TezConfiguration.TEZ_APPLICATION_TYPE);
    appContext.setApplicationId(appId);
    appContext.setResource(capability);
    if (amConfig.getQueueName() != null) {
      appContext.setQueue(amConfig.getQueueName());
    }
    appContext.setApplicationName(amName);
    appContext.setCancelTokensWhenComplete(amConfig.getTezConfiguration().getBoolean(
        TezConfiguration.TEZ_AM_CANCEL_DELEGATION_TOKEN,
        TezConfiguration.TEZ_AM_CANCEL_DELEGATION_TOKEN_DEFAULT));
    appContext.setAMContainerSpec(amContainer);
    
    appContext.setMaxAppAttempts(
      finalTezConf.getInt(TezConfiguration.TEZ_AM_MAX_APP_ATTEMPTS,
        TezConfiguration.TEZ_AM_MAX_APP_ATTEMPTS_DEFAULT));

    return appContext;

  }
  
  
  static void maybeAddDefaultLoggingJavaOpts(String logLevel, List<String> vargs) {
    if (vargs != null && !vargs.isEmpty()) {
      for (String arg : vargs) {
        if (arg.contains(TezConfiguration.TEZ_ROOT_LOGGER_NAME)) {
          return ;
        }
      }
    }
    TezClientUtils.addLog4jSystemProperties(logLevel, vargs);
  }
  
  static String maybeAddDefaultLoggingJavaOpts(String logLevel, String javaOpts) {
    List<String> vargs = new ArrayList<String>(5);
    if (javaOpts != null) {
      vargs.add(javaOpts);
    } else {
      vargs.add("""");
    }
    maybeAddDefaultLoggingJavaOpts(logLevel, vargs);
    if (vargs.size() == 1) {
      return vargs.get(0);
    }
    return StringUtils.join(vargs, "" "").trim();
  }
  
  static void setDefaultLaunchCmdOpts(Vertex v, TezConfiguration conf) {
    String vOpts = v.getTaskLaunchCmdOpts();
    String vConfigOpts = conf.get(TezConfiguration.TEZ_TASK_LAUNCH_CMD_OPTS,
        TezConfiguration.TEZ_TASK_LAUNCH_CMD_OPTS_DEFAULT);
    if (vConfigOpts != null && vConfigOpts.length() > 0) {
      vOpts += ("" "" + vConfigOpts);
    }
    
    vOpts = maybeAddDefaultLoggingJavaOpts(conf.get(
        TezConfiguration.TEZ_TASK_LOG_LEVEL,
        TezConfiguration.TEZ_TASK_LOG_LEVEL_DEFAULT), vOpts);
    v.setTaskLaunchCmdOpts(vOpts);
  }

  @Private
  @VisibleForTesting
  public static void addLog4jSystemProperties(String logLevel,
      List<String> vargs) {
    vargs.add(""-Dlog4j.configuration=""
        + TezConfiguration.TEZ_CONTAINER_LOG4J_PROPERTIES_FILE);
    vargs.add(""-D"" + YarnConfiguration.YARN_APP_CONTAINER_LOG_DIR + ""=""
        + ApplicationConstants.LOG_DIR_EXPANSION_VAR);
    vargs.add(""-D"" + TezConfiguration.TEZ_ROOT_LOGGER_NAME + ""="" + logLevel
        + "","" + TezConfiguration.TEZ_CONTAINER_LOGGER_NAME);
  }

  static Configuration createFinalTezConfForApp(TezConfiguration tezConf,
      TezConfiguration amConf) {
    Configuration conf = new Configuration(false);
    conf.setQuietMode(true);

    assert tezConf != null;
    assert amConf != null;

    Entry<String, String> entry;
    Iterator<Entry<String, String>> iter = tezConf.iterator();
    while (iter.hasNext()) {
      entry = iter.next();
      // Copy all tez config parameters.
      if (entry.getKey().startsWith(TezConfiguration.TEZ_PREFIX)) {
        conf.set(entry.getKey(), entry.getValue());
        if (LOG.isDebugEnabled()) {
          LOG.debug(""Adding tez dag am parameter from conf: "" + entry.getKey()
            + "", with value: "" + entry.getValue());
        }
      }
    }

    iter = amConf.iterator();
    while (iter.hasNext()) {
      entry = iter.next();
      // Copy all tez config parameters.
      if (entry.getKey().startsWith(TezConfiguration.TEZ_PREFIX)) {
        conf.set(entry.getKey(), entry.getValue());
        if (LOG.isDebugEnabled()) {
          LOG.debug(""Adding tez dag am parameter from amConf: "" + entry.getKey()
              + "", with value: "" + entry.getValue());
        }
      }
    }
    return conf;
  }

  /**
   * Helper function to create a YARN LocalResource
   * @param fs FileSystem object
   * @param p Path of resource to localize
   * @param type LocalResource Type
   * @return a YARN LocalResource for the given Path
   * @throws IOException
   */
  static LocalResource createLocalResource(FileSystem fs, Path p,
      LocalResourceType type,
      LocalResourceVisibility visibility) throws IOException {
    LocalResource rsrc = Records.newRecord(LocalResource.class);
    FileStatus rsrcStat = fs.getFileStatus(p);
    rsrc.setResource(ConverterUtils.getYarnUrlFromPath(fs.resolvePath(rsrcStat
        .getPath())));
    rsrc.setSize(rsrcStat.getLen());
    rsrc.setTimestamp(rsrcStat.getModificationTime());
    rsrc.setType(type);
    rsrc.setVisibility(visibility);
    return rsrc;
  }

  private static Path localizeDagPlanAsText(DAGPlan dagPB, FileSystem fs, AMConfiguration amConfig,
      String strAppId, Path tezSysStagingPath) throws IOException {
    Path textPath = TezCommonUtils.getTezTextPlanStagingPath(tezSysStagingPath);
    FSDataOutputStream dagPBOutTextStream = null;
    try {
      dagPBOutTextStream = TezCommonUtils.createFileForAM(fs, textPath);
      String dagPBStr = dagPB.toString();
      int dagPBStrLen = dagPBStr.length();
      if (dagPBStrLen <= UTF8_CHUNK_SIZE) {
        dagPBOutTextStream.writeUTF(dagPBStr);
      } else {
        int startIndex = 0;
        while (startIndex < dagPBStrLen) {
          int endIndex = startIndex + UTF8_CHUNK_SIZE;
          if (endIndex > dagPBStrLen) {
            endIndex = dagPBStrLen;
          }
          dagPBOutTextStream.writeUTF(dagPBStr.substring(startIndex, endIndex));
          startIndex += UTF8_CHUNK_SIZE;
        }
      }
    } finally {
      if (dagPBOutTextStream != null) {
        dagPBOutTextStream.close();
      }
    }
    return textPath;
  }

  static DAGClientAMProtocolBlockingPB getSessionAMProxy(YarnClient yarnClient,
      Configuration conf,
      ApplicationId applicationId) throws TezException, IOException {
    ApplicationReport appReport;
    try {
      appReport = yarnClient.getApplicationReport(
          applicationId);

      if(appReport == null) {
        throw new TezUncheckedException(""Could not retrieve application report""
            + "" from YARN, applicationId="" + applicationId);
      }
      YarnApplicationState appState = appReport.getYarnApplicationState();
      if(appState != YarnApplicationState.RUNNING) {
        if (appState == YarnApplicationState.FINISHED
            || appState == YarnApplicationState.KILLED
            || appState == YarnApplicationState.FAILED) {
          throw new SessionNotRunning(""Application not running""
              + "", applicationId="" + applicationId
              + "", yarnApplicationState="" + appReport.getYarnApplicationState()
              + "", finalApplicationStatus=""
              + appReport.getFinalApplicationStatus()
              + "", trackingUrl="" + appReport.getTrackingUrl());
        }
        return null;
      }
    } catch (YarnException e) {
      throw new TezException(e);
    }
    return getAMProxy(conf, appReport.getHost(),
        appReport.getRpcPort(), appReport.getClientToAMToken());
  }

  @Private
  public static DAGClientAMProtocolBlockingPB getAMProxy(final Configuration conf, String amHost,
      int amRpcPort, org.apache.hadoop.yarn.api.records.Token clientToAMToken) throws IOException {

    final InetSocketAddress serviceAddr = new InetSocketAddress(amHost, amRpcPort);
    UserGroupInformation userUgi = UserGroupInformation.createRemoteUser(UserGroupInformation
        .getCurrentUser().getUserName());
    if (clientToAMToken != null) {
      Token<ClientToAMTokenIdentifier> token = ConverterUtils.convertFromYarn(clientToAMToken,
          serviceAddr);
      userUgi.addToken(token);
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(""Connecting to Tez AM at "" + serviceAddr);
    }
    DAGClientAMProtocolBlockingPB proxy = null;
    try {
      proxy = userUgi.doAs(new PrivilegedExceptionAction<DAGClientAMProtocolBlockingPB>() {
        @Override
        public DAGClientAMProtocolBlockingPB run() throws IOException {
          RPC.setProtocolEngine(conf, DAGClientAMProtocolBlockingPB.class, ProtobufRpcEngine.class);
          return (DAGClientAMProtocolBlockingPB) RPC.getProxy(DAGClientAMProtocolBlockingPB.class,
              0, serviceAddr, conf);
        }
      });
    } catch (InterruptedException e) {
      throw new IOException(""Failed to connect to AM"", e);
    }
    return proxy;
  }

  @Private
  public static void createSessionToken(String tokenIdentifier,
      JobTokenSecretManager jobTokenSecretManager,
      Credentials credentials) {
    JobTokenIdentifier identifier = new JobTokenIdentifier(new Text(
        tokenIdentifier));
    Token<JobTokenIdentifier> sessionToken = new Token<JobTokenIdentifier>(identifier,
        jobTokenSecretManager);
    sessionToken.setService(identifier.getJobId());
    TokenCache.setSessionToken(sessionToken, credentials);
  }

  /**
   * Add computed Xmx value to java opts if both -Xms and -Xmx are not specified
   * @param javaOpts Current java opts
   * @param resource Resource capability based on which java opts will be computed
   * @param maxHeapFactor Factor to size Xmx ( valid range is 0.0 < x < 1.0)
   * @return Modified java opts with computed Xmx value
   */
  public static String maybeAddDefaultMemoryJavaOpts(String javaOpts, Resource resource,
      double maxHeapFactor) {
    if ((javaOpts != null && !javaOpts.isEmpty()
          && (javaOpts.contains(""-Xmx"") || javaOpts.contains(""-Xms"")))
        || (resource.getMemory() <= 0)) {
      return javaOpts;
    }
    if (maxHeapFactor <= 0 || maxHeapFactor >= 1) {
      return javaOpts;
    }
    int maxMemory = (int)(resource.getMemory() * maxHeapFactor);
    maxMemory = maxMemory <= 0 ? 1 : maxMemory;

    return "" -Xmx"" + maxMemory + ""m ""
        + ( javaOpts != null ? javaOpts : """");
  }

}
",blob
